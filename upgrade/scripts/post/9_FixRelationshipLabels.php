<?php
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * Fix resetting of relationship labels, caused by duplication of language file contents
 */
class SugarUpgradeFixRelationshipLabels extends UpgradeScript
{
    const REGEX_RELATIONSHIP_LANG_FILENAME = '/^[\w]+\.custom([a-z][\w]+)\.php$/';
    const REGEX_RELATIONSHIP_LABEL = '/^LBL_(\w+?)_FROM_/i';
    const REGEX_AUTOGENERATED_LABEL = '/\/\/[^\n]*?auto\W*generated/i';

    public $order = 9999;
    public $type = self::UPGRADE_CUSTOM;

    /**
     * @var string empty string for default directory, path to Sugar root with trailing slash if processing e.g. another Sugar copy
     */
    private $pathPrefix = "";

    public function run()
    {
        if (version_compare($this->from_version, '11.1.0', '>=')) {
            return;
        }
        $files = $this->findCustomModuleLanguageFilesToFix();
        foreach ($files as [$file, $module, $relation]) {
            $this->fixModuleEntryFile($file, $relation);
        }
        $this->fixIntermediateFiles();
        $this->rebuildCaches();
        $this->log("Completed fixing of relationship labels");
    }

    /**
     * @return array [...[file, module, relation]]
     */
    private function findCustomModuleLanguageFilesToFix(): array
    {
        $pattern = "{$this->pathPrefix}custom/Extension/modules/*";
        $directories = glob($pattern);

        $result = [];
        foreach ($directories as $directory) {
            if (!is_dir($directory)) {
                continue;
            }
            $module = basename($directory);

            $pattern = "{$directory}/Ext/Language/*.php";
            $files = glob($pattern);
            if (!$files) {
                continue;
            }

            $fileRegex = self::REGEX_RELATIONSHIP_LANG_FILENAME;
            foreach ($files as $file) {
                $match = [];
                if (preg_match($fileRegex, basename($file), $match)) {
                    $result[] = [$file, $module, $match[1]];
                } else {
                    $this->log("Skipping file {$file}");
                }
            }
        }
        return $result;
    }

    private function fixModuleEntryFile(string $file, string $relation): void
    {
        if (!$this->isAutoGenerated($file)) {
            $this->log("Skipping $file - custom, not autogenerated");
            return;
        }

        $mod_strings = [];
        $out_strings = [];
        $delete_strings = [];
        include $file;

        $prefix = 'LBL_' . strtoupper($relation) . '_FROM_';
        foreach ($mod_strings as $key => $label) {
            if (strpos($key, $prefix) === 0) {
                $out_strings[$key] = $label;
            } else {
                $delete_strings[$key] = $label;
            }
        }

        if ($delete_strings) {
            $this->log("Fixing $file");
            $this->upgrader->backupFile($file);

            if ($this->saveLabels($file, $out_strings)) {
                $this->log("Write successful: $file");
            } else {
                $this->log("Write failed: $file");
            }
        } else {
            $this->log("File OK, nothing to fix: $file");
        }
    }

    private function saveLabels(string $file, array $labels): bool
    {
        $write = "<?php\n// WARNING: The contents of this file are auto-generated.\n";
        foreach ($labels as $k => $v) {
            $ek = var_export($k, true);
            $write .= "\$mod_strings[$ek] = " . var_export($v, true) . ";\n";
        }

        return file_put_contents($file, $write) > 0;
    }

    private function fixIntermediateFiles(): void
    {
        $pattern = "{$this->pathPrefix}custom/Extension/modules/relationships/language/*";
        $files = glob($pattern);
        foreach ($files as $file) {
            $this->fixIntermediateFile($file);
        }
    }

    private function fixIntermediateFile(string $file): void
    {
        if (!preg_match('/^\w+\.php$/i', basename($file))) {
            return;
        }
        $module = basename($file, '.php');

        $splitLabels = ['_' => []];
        $mod_strings = [];
        include $file;
        if (empty($mod_strings)) {
            return;
        }

        $this->log("Fixing $file");
        $this->upgrader->backupFile($file);

        $regex = self::REGEX_RELATIONSHIP_LABEL;
        foreach ($mod_strings as $key => $label) {
            $match = [];
            if (preg_match($regex, $key, $match)) {
                $splitLabels[strtolower($match[1])][$key] = $label;
            } else {
                $splitLabels['_'][$key] = $label;
            }
        }

        foreach ($splitLabels as $relation => $labels) {
            $relationFile = $relation === '_'
                ? $file
                : dirname($file) . '/' . $module . '.' . $relation . '.php';
            if ($this->saveLabels($relationFile, $labels)) {
                $this->log("Write successful: $relationFile");
            } else {
                $this->log("Write failed: $relationFile");
            }
        }
    }

    private function rebuildCaches(): void
    {
        // touch *.lang.php files to make them last in orderMapping, so that custom labels have higher priority than original
        $pattern = "{$this->pathPrefix}custom/Extension/modules/*/Ext/Language/*.lang.php";
        $files = glob($pattern);
        foreach ($files as $file) {
            $this->log("Touching {$file}");
            touch($file);
        }

        $this->log("Rebuilding language cache");
        $moduleInstallerClass = SugarAutoLoader::customClass('ModuleInstaller');
        $moduleInstaller = new $moduleInstallerClass();
        $moduleInstaller->silent = true;
        $languages = SugarConfig::getInstance()->get('languages');
        $moduleInstaller->rebuild_languages($languages);
    }

    /**
     * @return bool
     */
    private function isAutoGenerated(string $file): bool
    {
        $content = file_get_contents($file);
        return (bool)preg_match(self::REGEX_AUTOGENERATED_LABEL, $content);
    }
}
