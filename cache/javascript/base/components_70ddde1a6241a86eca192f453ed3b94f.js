(function(app) {
 SUGAR.jssource = {"fields": {
"base": {
"selection": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.SelectionField
 * @alias SUGAR.App.view.fields.BaseSelectionField
 * @extends View.Fields.Base.BaseField
 */
({
	// Selection Field (base) 

    events: {
        'click input.selection': 'toggleSelect'
    },
    toggleSelect: function(evt) {
        var $el = $(evt.currentTarget).is(":checked");
        if($el) {
            this.check();
        } else {
            this.uncheck();
        }
    },
    check: function() {
        if(this.model) {
            this.context.set('selection_model', this.model);
        }
    },
    uncheck: function() {
        if(this.model) {
            this.context.unset('selection_model');
        }
    },
    bindDomChange: function() {
        //don't update the row's model & re-render, this is just a mechanism for selecting a row
    }
}) },
"repeat-dow": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Repeat Day of Week is a custom field for Meetings/Calls used to set
 * days of the week for a Weekly recurring record.
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.RepeatDowField
 * @alias SUGAR.App.view.fields.BaseRepeatDowField
 * @extends View.Fields.Base.EnumField
 */
({
	// Repeat-dow Field (base) 

    extendsFrom: 'EnumField',

    defaultOnUndefined: false, //custom default behavior defined below

    /**
     * @inheritdoc
     *
     * Set default value for this field and
     * add validation (required if `repeat_type` is weekly)
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'enum';

        this.def['default'] = this.getDefaultDayOfWeek();

        this.model.addValidationTask(
            'repeat_dow_validator_' + this.cid,
            _.bind(this._doValidateRepeatDow, this)
        );
    },

    /**
     * Get the default day of week (current day of the week)
     *
     * @return {String} Day of the week
     */
    getDefaultDayOfWeek: function() {
        var isoDayOfWeek = app.date().isoWeekday(),
            sugarDayOfWeek = (isoDayOfWeek === 7) ? 0 : isoDayOfWeek;
        return sugarDayOfWeek.toString();
    },

    /**
     * @inheritdoc
     *
     * Model day of week format is a string of numeric characters ('1'-'7')
     * Select2 needs an array of these numeric strings
     */
    format: function(value) {
        return (_.isString(value)) ? value.split('').sort() : value;
    },

    /**
     * @inheritdoc
     *
     * Select2 array of numeric strings to Model numeric string format
     */
    unformat: function(value) {
        return (_.isArray(value)) ? value.sort().join('') : value;
    },

    /**
     * Custom required validator for the `repeat_dow` field.
     *
     * This validates `repeat_dow` based on the value of `repeat_type` -
     * if Weekly repeat type, repeat day of week must be specified
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateRepeatDow: function(fields, errors, callback) {
        var repeatType = this.model.get('repeat_type'),
            repeatDow = this.model.get(this.name);

        if (repeatType === 'Weekly' && (!_.isString(repeatDow) || repeatDow.length < 1)) {
            errors[this.name] = {'required': true};
        }
        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('repeat_dow_validator_' + this.cid);
        this._super('_dispose');
    }
}) },
"collection-count": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.CollectionCountField
 * @alias SUGAR.App.view.fields.BaseCollectionCountField
 * @extends View.Fields.Base.BaseField
 */
({
	// Collection-count Field (base) 

    events: {
        'click [data-action="count"]': 'fetchCount'
    },

    /**
     * Fetches the total amount of filtered records from the collection, and
     * renders the field to show the new (or cached) total.
     */
    fetchCount: function() {
        if (_.isNull(this.collection.total)) {
            app.alert.show('fetch_count', {
                level: 'process',
                title: app.lang.get('LBL_LOADING'),
                autoClose: false
            });
        }

        this.collection.trigger('list:page-total:fetching');

        this.isLoadingCount = true;
        this.updateCount();

        var successCallback = _.bind(function(total) {
            this.isLoadingCount = false;
            var options = {
                total: total
            };
            this.updateCount(options);
        }, this);
        this.collection.fetchTotal({
            success: successCallback,
            complete: function() {
                app.alert.dismiss('fetch_count');
            }
        });
    },

    /**
     * Updates {@link #countLabel the count label} and renders this field.
     *
     * @param {number} [options] Optional hash of values to use for the `length`
     *   and `hasMore` properties. Use this if you want to customize what this
     *   field should display.
     * @param {number} [options.length] The length of values.
     * @param {number} [options.total] Total number of records.
     * @param {boolean} [options.hasMore] `true` if there are more values to be
     *   fetched or paginated, `false` if we've fetched everything.
     */
    updateCount: function(options) {
        if (!this.disposed) {
            this._setCountLabel(options);

            if (!_.isUndefined(options) && !_.isUndefined(options.total)) {
                this.collection.trigger('list:page-total:fetched', options.total);
            }
            this.render();
        }
    },

    /**
     * Returns the label for the count in the headerpane.
     *
     * If you would like to customize these, the following labels are being
     * used: `TPL_LIST_HEADER_COUNT`, `TPL_LIST_HEADER_COUNT_PARTIAL`,
     * `TPL_LIST_HEADER_COUNT_TOTAL`, and `TPL_LIST_HEADER_COUNT_TOOLTIP`.
     *
     * There are several ways the total count label is represented, depending on
     * the state of `this.collection`. If the collection contains all the
     * records, the label will display `this.collection.length`, for example:
     *
     *     (17)
     *
     * If `this.collection.total` exists and is cached, the label will display
     * in the form:
     *
     *     (20 of 50)
     *
     * Otherwise, the returned label will include the link to fetch the total:
     *
     *     (20 of <a data-action="count">21+</a>)
     *
     * @protected
     * @param {number} [options] Optional hash of values to use for the `length`
     *   and `hasMore` properties. Use this if you want to customize what this
     *   field should display.
     * @param {number} [options.length] The length of values. Defaults to
     *   `this.collection.length`.
     * @param {boolean} [options.hasMore] `true` if there are more values to be
     *   fetched or paginated, `false` if we've fetched everything. Defaults to
     *   `false`.
     * @return {string|Handlebars.SafeString} The label to use for the list view
     *   count.
     */
    _setCountLabel: function(options) {
        // Default properties.
        options = options || {};

        if (_.isUndefined(options.hasMore) && this.collection.next_offset) {
            options.hasMore = this.collection.next_offset >= 0;
        }

        const recordsNum = this.getRecordsNum(options);

        if (!recordsNum.current) {
            return this.countLabel = '';
        }

        var tplKey = 'TPL_LIST_HEADER_COUNT_TOTAL';
        var context = {
            num: recordsNum.current,
            total: this.cachedCount,
        };

        if (recordsNum.current === recordsNum.total) {
            tplKey = 'TPL_LIST_HEADER_COUNT';
        } else if (!_.isNull(this.collection.total)) {
            // Save the total on the field - this is the primary save point.
            this.cachedCount = this.collection.total;
            // Since we have a total we display it through the context.
            context.total = this.collection.total;
        } else if (this.isLoadingCount) {
            context.total =  app.lang.get('LBL_LOADING');
        } else if (!this.cachedCount) {
            // Initial load case - we did not have a total for the current collection before.
            var tooltipLabel = app.lang.get('TPL_LIST_HEADER_COUNT_TOOLTIP', this.module);
            // FIXME: When SC-3681 is ready, we will no longer have the need for
            // this link, since the total will be displayed by default.
            context.total = new Handlebars.SafeString(
                `<a href="javascript:void(0);" data-action="count" rel="tooltip" data-placement="right"
title="${tooltipLabel}" role="button" tabindex="0" aria-label="${tooltipLabel}">
                ${Handlebars.Utils.escapeExpression(
                    app.lang.get('TPL_LIST_HEADER_COUNT_PARTIAL', this.module, {num: recordsNum.total})
                )}</a>`
            );
        }

        // FIXME: When SC-3681 is ready, remove the SafeString call.
        return this.countLabel = new Handlebars.SafeString(app.lang.get(tplKey, this.module, context));
    },

    /**
     * Prepare current and total count of pages
     * @param {Object} options
     * @return {Object}
     */
    getRecordsNum: function(options) {
        const collect = this.collection;
        const limit = collect.getOption('limit') || app.config.maxQueryResult || 0;
        const length = options.length || collect.length;
        const start = ((collect.page || 1) - 1) * limit + 1;

        return {
            current: this.getRecordsNumCurrent(start, length, options),
            total: this.getRecordsNumTotal(start, length, options),
        };
    },

    /**
     * Get current numeration of records
     * @param {int} start
     * @param {int} length
     * @param {Object} options
     * @return {int}
     */
    getRecordsNumCurrent: function(start, length, options) {
        let isNumRange = options.hasMore || this.collection.page > 1;
        let layout = this.context.get('layout');

        // if it is not the list layout, check if it is using list-pagination
        if (layout !== 'records') {
            let isUsingListPagination = this.context.get('isUsingListPagination') || this.checkListPagination();
            // use range format only if list-pagination is used
            isNumRange = isNumRange && isUsingListPagination;
        }

        if (isNumRange) {
            return start + '-'  + (start + length - 1);
        } else {
            return length;
        }
    },

    /**
     * Checks if the layout is using the list-pagination component
     *
     * @return {boolean}
     */
    checkListPagination: function() {
        if (_.isEmpty(this.view) || _.isEmpty(this.view.layout)) {
            return false;
        }

        let paginationComponent = this.view.layout.getComponent('list-pagination') || {};

        return !_.isEmpty(paginationComponent);
    },

    /**
     * Get total number of records
     * @param {int} start
     * @param {int} length
     * @param {Object} options
     * @return {int}
     */
    getRecordsNumTotal: function(start, length, options) {
        const collect = this.collection;

        if (collect.total) {
            return collect.total;
        } else if (options.hasMore) {
            return start + length;
        } else {
            collect.total = start + length - 1;
            return collect.total;
        }
    },

    /**
     * @override
     *
     * Re-renders the field when the attached collection is `reset`. Also
     * handles executing a request for the total count when a `pagination` event
     * occurs on the context. We do this on `pagination` because it is a
     * user-initiated action - if we request the count on `reset` as well it
     * would decrease performance.
     */
    bindDataChange: function() {
        if (!this.collection) {
            return;
        }

        this.listenTo(this.collection, 'remove', this.updateCount);

        this.listenTo(this.collection, 'reset', function() {
            if (!this.disposed && this.cachedCount) {
                // check if collection is reset because of record creation
                let isCreate = !_.isUndefined(this.context.get('isCreate')) ? this.context.get('isCreate') : false;
                if (this.context.get('isUsingListPagination') &&
                    this.context.get('paginationAction') === 'PAGINATE' &&
                    !isCreate && !this.context.get('isLink')) {
                    return;
                }

                this.fetchCollectionTotal();
            } else {
                this.updateCount();
            }
        });

        this.listenTo(this.context, 'paginate', function() {
            if (!this.disposed) {
                this.fetchCount();
            }
        });

        this.listenTo(this.context, 'refresh:count', function(hasAmount, properties) {
            this.updateCount(properties);
        });

        this.listenTo(this.context, 'list:paginate', this.updateCount);

        this.listenTo(app.events, 'list:create:success', function() {
            this.context.set('isCreate', true);
        }, this);
    },

    fetchCollectionTotal: function() {
        var successFn = _.bind(function(total) {
            // Update the cached total on reset action.
            this.cachedCount = total;
            this.updateCount({
                total: total,
            });
            this.context.unset('isCreate');
            this.context.unset('isLink');
        }, this);
        this.collection.fetchTotal({success: successFn});
    }
}) },
"dashletaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.DashletactionField
 * @alias SUGAR.App.view.fields.BaseDashletactionField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Dashletaction Field (base) 

    events: {
        'click [data-dashletaction]': 'actionClicked'
    },
    extendsFrom: 'ButtonField',
    /**
     * Trigger the function which is in the dashlet view.
     *
     * @param {Event} evt Mouse event.
     */
    actionClicked: function(evt) {
        if (this.preventClick(evt) === false) {
            return;
        }
        var action = $(evt.currentTarget).data('dashletaction');
        this._runAction(evt, action);
    },

    /**
     * Handles rowaction's event trigger and propagate the event to the main dashlet.
     *
     * @param {Event} evt Mouse event.
     * @param {String} action Name of executing parent action.
     * @protected
     */
    _runAction: function(evt, action) {
        if (!action) {
            return;
        }
        var dashlet = this.view.layout ? _.first(this.view.layout._components) : null;
        if (dashlet && _.isFunction(dashlet[action])) {
            dashlet[action](evt, this.def.params);
        } else if (_.isFunction(this.view[action])) {
            this.view[action](evt, this.def.params);
        }
    }
}) },
"range": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RangeField
 * @alias SUGAR.App.view.fields.BaseRangeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Range Field (base) 

    /**
     * holder for the field tag, so we can get at it easily
     */
    fieldTag: '.rangeSlider',

    /**
     * Object that maps the sliderType from metadata, to the appropriate noUiSlider settings.
     * The number of handles this slider has can be set in metadata by specifying sliderType to be as follows:
     * - 'single' - a single slider, the value of the field will just be the integer value of the slide
     * - 'upper' - a single slider, visually connected to the upper range, the value of the field will be {min: <value of slide>, max: this.rangeMax}
     * - 'lower' - a single slider, visually connected to the lower range, the value of the field will be {min: this.rangeMin, max: <value of slide>}
     * - 'double' - a double slider, the value of the field will be [<value of lower slide>, <value of upper slide>]
     * - 'connected' - a double slider, visually connected together, the value of the field will be {min: <value of lower slide>, max: <value of upper slide>}
     */
    _sliderTypeSettings: {
        single: {handles: 1, connect: false},
        upper: {handles: 1, connect: 'upper'},
        lower: {handles: 1, connect: 'lower'},
        'double': {handles: 2, connect: false},
        connected: {handles: 2, connect: true}
    },

    /**
     * Renders this field.  This is where the noUiSlider gets added.
     * @param value
     * @private
     */
    _render: function(value) {
        app.view.Field.prototype._render.call(this);

        this._setupSlider(this.$el.find(this.fieldTag));
    },

    /**
     * Unformats a value for storing in a model.
     *
     * Cleans up the value to store it in a model based on the sliderType
     * @param {Mixed} value The value to unformat.
     * @return {Mixed} Unformatted value based on sliderType:
     * - single - integer value
     * - double - array of two integer values
     * - upper, lower, connected - a range as {min, max}.
     */
    unformat: function(value) {
        var sliderType = this.def.sliderType || 'single';

        switch(sliderType) {
            case 'single':
                return _.first(value);
            case 'upper':
                return {
                    min: _.first(value),
                    max: this.def.maxRange || 100
                };
            case 'lower':
                return {
                    min: this.def.minRange || 0,
                    max: _.last(value)
                };
            case 'double':
                return [
                    _.isNaN(_.first(value))?this.def.minRange || 0: _.first(value),
                    _.isNaN(_.last(value))?this.def.maxRange || 100:_.last(value)
                ];
            case 'connected':
            default:
                return {
                    min: _.isNaN(_.first(value))?this.def.minRange || 0: _.first(value),
                    max: _.isNaN(_.last(value))?this.def.maxRange || 100:_.last(value)
                };
        }
    },

    /**
     * Formats a value for display.
     *
     * Converts the field stored in the model for a slider type, into a value usable by noUiSlider widget
     * @param {Mixed} value The value to format.
     * @return {Mixed} Formatted value.
     */
    format: function(value) {
        var sliderType = this.def.sliderType || 'single';

        switch(sliderType) {
            case 'single':
                return [ value || this.def.rangeMin || 0 ];
            case 'upper':
                return [ value.min || this.def.rangeMin || 0 ];
            case 'lower':
                return [ value.max || this.def.rangeMax || 100 ];
            case 'double':
                return value;
            case 'connected':
            default:
                if(value) {
                    return [ value.min || this.def.rangeMin || 0, value.max || this.def.rangeMax || 100];
                }
        }
        return [this.def.rangeMin || 0, this.def.rangeMax || 100];
    },

    /**
     * Sets up the noUiSlider jquery widget on the given jQuery element.
     * @param jqel a jquery element, i. e. $.find(this.fieldTag)
     * @private
     */
    _setupSlider: function(jqel) {

        jqel.noUiSlider('init', {
            knobs: this._calculateHandles(),
            connect: this._setupHandleConnections(this.def.sliderType || 'single'),
            scale: this._setupSliderEndpoints(),
            start: this._setupSliderStartPositions(),
            change: this._sliderChange,
            end: this._sliderChangeComplete,
            field: this
        });

        if(!this.def.hideStyle){
            this._addStyle(jqel);
        }


        if(this.def.enabled == false || this.def.view != 'edit') {
            jqel.noUiSlider('disable');
        }
    },

    /**
     * Adds the style elements to the slider fields
     * @param jqel the jQuery wrapped element that has a noUiSlider attached to it.
     */
    _addStyle: function(jqel) {
        var start = this._setupSliderStartPositions(),
            endpoints = this._setupSliderEndpoints();
        jqel.append(function(){
            var html = "",
                segments = 11,
                w = $(this).width(),
                segmentWidth = w/(segments-1),
                acum = 0;

            for(i=0;i<segments;i++) {
                acum = (segmentWidth * i)-2;
                html += "<div class='ticks' style='left:"+acum+"px'></div>";
            }
            return html;

        })
        .find('.noUi-handle div').each(function(index){
            if(i>1) {i=0;}
            $(this).append('<div class="tooltip fade top in infoBox"><div class="tooltip-arrow"></div><div class="tooltip-inner">' + start[i] + '%'+'</div></div>');
            i++;
        });

        this.$('.noUiSliderEnds').attr('data-content-before', _.first(endpoints) + '%').attr('data-content-after', _.last(endpoints) + '%')
    },

    /**
     * Used to calculate the number of sliders for this field by the sliderType set in metadata.
     * @return {integer} The number of handles for the slider
     * @private
     */
    _calculateHandles: function() {
        var sliderType = this.def.sliderType || 'single';

        return this._sliderTypeSettings[sliderType].handles;
    },

    /**
     * Used to set up the graphical connections for the handles based on the slider type
     * @param sliderType the value from metadata.  Valid options are 'single', 'upper', 'lower', 'double', 'connected'
     * @return {string || bool} The value to pass as the 'connect' setting for the noUiSlider jquery widget
     * @private
     */
    _setupHandleConnections: function(sliderType) {
        var sliderType = this.def.sliderType || 'single';

        return this._sliderTypeSettings[sliderType].connect;
    },

    /**
     * Calculates the min and max range for the sliders.
     * @return {array} the min and max setting for the range field that will be pass as the noUiSlider scale
     * @private
     */
    _setupSliderEndpoints: function() {
        var minRange = this.def.minRange || 0,
            maxRange = this.def.maxRange || 100;

        return [minRange, maxRange];
    },

    /**
     * Used to get the starting positions for the sliders to pass to the noUiSlider widget.
     * @return {integer || array} the start values contained in the model for the field.  Falls back on minRange from
     * metadata if the model is empty/undefined, or 0 if no model value and minRange is undefined in metadata.
     * @private
     */
    _setupSliderStartPositions: function() {
        var value;

        if (this.model) {
            value = this.model.get(this.name);
        }

        if (_.isUndefined(value) || (_.isArray(value) && _.isEmpty(value))) {
            return [ this.def.minRange || 0, this.def.maxRange || 100 ];
        }

        return this.format(value);
    },

    /**
     * Gets the value for the jquery slider widget and cleans it up to be used by the view
     * @param jqel the jquery element that has the noUiSlider attached to it.
     * @return {array} for sliderType set to 'single', an array with a single value, for all others, an array of two values.
     */
    getSliderValues: function(jqel) {
        var value = jqel.noUiSlider('value');

        return this.unformat(value);
    },

    /**
     * The function that gets called whenever the sliders are in the process of getting moved/changed.
     *
     * The context of `this` is the noUiSlider from which the function was activated. The field is passed through the
     * settings and can be accessed using `this.data('settings').field` for any necessary access to the controller, model, etc...
     *
     * The model will get updated with this method if updateOn is set to 'change' or 'both' in the field metadata.
     *
     * @param type The type of change that moved the slider.  This will be 'click' when the slider is clicked to a point
     * on the range, 'move' when the slider is updated via the move method (i. e. by the linked slider delegates), or
     * 'slide' when the handle is dragged to a value.
     * @private
     */
    _sliderChange: function(type) {
        var field = this.data('api').options.field,
            values;

        if(field.def.updateOn && (field.def.updateOn == 'change' || field.def.updateOn == 'both')) {
            field.model.set(field.name, field.getSliderValues(this));
        }

        if(!field.def.hideStyle) {
            values = this.noUiSlider( 'value' );
            this.find('.noUi-lowerHandle .infoBox .tooltip-inner').text(values[0]+"%");
            this.find('.noUi-upperHandle .infoBox .tooltip-inner').text(values[1]+"%");
        }

        // disables the hook if moved by another slider, to prevent circular references
        if(type != 'move' && _.isFunction(field.sliderChangeDelegate)) {
            field.sliderChangeDelegate(field.getSliderValues(this));
        }
    },

    /**
     * The function that gets called whenever the slider change is complete.
     *
     * The context of `this` is the noUiSlider from
     * which the function was activated. The field is passed through the settings and can be accessed using
     * `this.data('settings').field` for any necessary access to the controller, model, etc...
     *
     * The model will get updated with this method if updateOn is set to 'done' or 'both' in the field metadata.
     *
     * @param type The type of change that moved the slider.  This will be 'click' when the slider is clicked to a point
     * on the range, 'move' when the slider is updated via the move method (i. e. by the linked slider delegates), or
     * 'slide' when the handle is dragged to a value.
     * @private
     */
    _sliderChangeComplete: function(type) {
        var field = this.data('api').options.field;

        if(field.def.updateOn && (field.def.updateOn == 'done' || field.def.updateOn == 'both')) {
            field.model.set(field.name, field.getSliderValues(this));
        }

        // if this is set, this hook will be called when slider is done moving.
        if(_.isFunction(field.sliderDoneDelegate)) {
            field.sliderDoneDelegate(field.getSliderValues(this));
        }
    }

}) },
"discount-select": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.DiscountSelectField
 * @alias SUGAR.App.view.fields.BaseDiscountSelectField
 * @extends View.Fields.Base.ActiondropdownField
 */
({
	// Discount-select Field (base) 

    extendsFrom: 'EnumField',

    /**
     * The class added to the select2 container.
     */
    containerCssClass: 'discount-select-dropdown',

    /**
     * The current currency object.
     */
    currentCurrency: null,

    /**
     * The current symbol to use in place of the caret dropdown icon
     */
    currentDropdownSymbol: null,

    /**
     * The key,value pairs available in the dropdown.
     */
    items: null,

    /**
     * The model property we are updating.
     */
    name: 'discount_select',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.lastDiscountSelectValue = this.model.get(this.name);

        if (this.view && this.view.layout) {
            this.view.layout.on('headerpane:adjust_fields', this.repositionDropdown, this);
        }

        // Need to call these for the times where the model is fully populated and we don't need
        // to wait for a second render to display the correct data.
        if (this.model.has('currency_id')) {
            this.fetchCurrency();
            this.loadEnumOptions();
            this.updateDropdownSymbol(this.model.get(this.name));
            this.updateDropdownText(this.currentDropdownSymbol);
        }
    },

    /**
     * Helper function for generating Select2 options for this enum
     * @param {Array} optionsKeys Set of option keys that will be loaded into Select2 widget
     * @return {Object} Select2 options, refer to Select2 documentation for what each option means
     * @override
     */
    getSelect2Options: function(optionsKeys) {
        var options = this._super('getSelect2Options', [optionsKeys]);

        // Updated options for our dropdown
        var newOptions = {
            placeholder: this.currentDropdownSymbol,
            containerCssClass: this.containerCssClass,
            dropdownCss: {width: 'auto'},
            width: '28px',
        };

        return _.extendOwn(options, newOptions);
    },

    /**
     * @override
     */
    bindDataChange: function() {
        // Handle discount_select update
        this.model.on('change:' + this.name, this.handleDiscountSelectFieldChange, this);

        // If the currency is changed in another field, updated our enum menu
        this.model.on('change:currency_id', this.handleCurrencyFieldChange, this);
    },

    /**
     * Handles updating the discount_select property and reflecting the correct currency symbol
     * in the dropdown.
     *
     * @param model The model of the row that was changed
     * @param discountSelect The new value for the discount_select field
     * @param options The on-change options returned from actions
     */
    handleDiscountSelectFieldChange: function(model, discountSelect, options) {
        if (_.property('revert')(options) === true) {
            this.updateDropdownSymbol(discountSelect);
            this.updateDropdownText(this.currentDropdownSymbol);
            return;
        }

        if (_.isEqual(this.model, model)) {
            // Need to update the model property to be a boolean. The saved value is a boolean
            // but the value from the enum field items is a string. We need to handle both so
            // for expected behaviour.
            var updatedValue = app.utils.isTruthy(discountSelect);
            model.set(this.name, updatedValue);

            this.$(this.fieldTag).select2('val', updatedValue);

            if (this.currentCurrency) {
                this.updateDropdownSymbol(updatedValue);
                this.updateDropdownText(this.currentDropdownSymbol);
            }
        }
    },

    /**
     * Handles updating the currency symbol in the dropdown and updating the enum options if
     * the currency is changed while the record is being edited.
     *
     * @param model The model of the row that has changed
     * @param currencyId The new value for our currency_id field
     * @param options The on-change options returned from actions
     */
    handleCurrencyFieldChange: function(model, currencyId, options) {
        if (_.property('revert')(options) === true) {
            this.fetchCurrency();
            this.loadEnumOptions();
            this.updateDropdownSymbol(model.get(this.name));
            this.updateDropdownText(this.currentDropdownSymbol);
            return;
        }

        if (this.currentCurrency && this.currentCurrency.id !== currencyId) {
            this.fetchCurrency();
            this.loadEnumOptions();

            if (app.utils.isTruthy(model.get(this.name)) === false) {
                this.updateDropdownSymbol(model.get(this.name));
                this.updateDropdownText(this.currentDropdownSymbol);
            }
        }
    },

    /**
     * @inheritdoc
     * @override
     */
    _render: function() {
        this._super('_render');

        // This is needed for consistently updating the dropdown symbol if the same option is
        // selected.
        var $el = this.$(this.fieldTag);
        $el.on('select2-close', _.bind(function() {
            this.updateDropdownText(this.currentDropdownSymbol);
        }, this));

        // We need this redundant update when we transition into record view from subpanel for
        // example and on initialize the model doesn't have all the data. Needed because of
        // the differences in rendering record vs subpanel views.
        if (this.model.has('currency_id')) {
            this.fetchCurrency();
            this.loadEnumOptions();
            this.updateDropdownSymbol(this.model.get(this.name));
            this.updateDropdownText(this.currentDropdownSymbol);
        }

        // On the first time rendering, update the dropdown symbol.
        this.updateDropdownText(this.currentDropdownSymbol);
    },

    /**
     * Load the options for this field and pass them to callback function.
     * @override
     */
    loadEnumOptions: function() {
        var currentCurrencyString = this.buildCurrencyString();
        var percentDiscountString = app.lang.get('LBL_DISCOUNT_PERCENT');

        var items = {
            'false': currentCurrencyString,
            'true': percentDiscountString,
        };

        this.items = items;
    },

    /**
     * Resets position of status dropdown if Select2 is active and open
     * and the position of the Select2 container is shifted, which happens
     * when other fields in the headerpane are hidden on status edit
     */
    repositionDropdown: function() {
        if (!this.$el) {
            return;
        }
        var $el = this.$(this.fieldTag).select2('container');

        if ($el.hasClass('select2-dropdown-open')) {
            this.$(this.fieldTag).data('select2').dropdown.css({'left': $el.offset().left});
        }
    },

    /**
     * @inheritdoc
     *
     * This field does not render content in list mode and as an enum when
     * in edit mode.
     *
     * @override
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        if (this.action === 'edit') {
            this.template = app.template.getField(
                'enum',
                'edit',
                this.module
            );
        }
    },

    /**
     * Fetches the required currency to be used in the dropdown.
     */
    fetchCurrency: function() {
        if (this.model.has('currency_id')) {
            this.currentCurrency = app.metadata.getCurrency(this.model.get('currency_id'));
        }
    },

    /**
     * Updates the labels for the buttons
     */
    buildCurrencyString: function() {
        var currentCurrencyLabel;

        if (this.currentCurrency) {
            if (app.lang.direction !== 'ltr') {
                currentCurrencyLabel = this.currentCurrency.name + ' ' + this.currentCurrency.symbol;
            } else {
                currentCurrencyLabel = this.currentCurrency.symbol + ' ' + this.currentCurrency.name;
            }
        }

        return currentCurrencyLabel;
    },

    /**
      * Updates the dropdown button icon.
      */
    updateDropdownSymbol: function(value) {
        if (app.utils.isTruthy(value)) {
            this.currentDropdownSymbol = '%';
        } else {
            this.currentDropdownSymbol = this.currentCurrency.symbol;
        }
    },

    /**
     * Helper function for set the text of the dropdown button.
     * Note: We can't use the el.select2('val', value) because that will actually update the value
     * in our dropdown, which was want true/false.
     */
    updateDropdownText: function(value) {
        var elementQueryString = '.' + this.containerCssClass + ' > .select2-choice > .select2-chosen';
        var $dropdownButton = this.$(elementQueryString);
        $dropdownButton.text(value);
    },

    /**
     * @inheritDoc
     * @private
     */
    _dispose: function() {
        this._super('_dispose');
    },
}) },
"change-my-password": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Widget for changing a password.
 *
 * It does not require old password confirmation.
 *
 * @class View.Fields.Base.ChangeMyPasswordField
 * @alias SUGAR.App.view.fields.BaseChangeMyPasswordField
 * @extends View.Fields.Base.ChangePasswordField
 */
({
	// Change-my-password Field (base) 

    extendsFrom: 'ChangePasswordField',

    /**
     * @inheritdoc
     */
    fieldTag: 'input',

    /**
     * @override
     * @param options
     */
    initialize: function(options) {
        this._super("initialize", [options]);
        /**
         * Manually adds the validation error label to errorName2Keys
         * @type {string}
         */
        app.error.errorName2Keys['current_password'] = 'ERR_PASSWORD_MISMATCH';
        app.error.errorName2Keys['new_password'] = 'ERR_ENTER_NEW_PASSWORD';

        this.__extendModel();
    },


    /**
     * Extends the model (note that the model is already extended by ChangePasswordField)
     * - adds a validation task _doValidateCurrentPassword : handle the current password validation
     * - revertAttributes : to unset temporary attributes _current_password
     */
    __extendModel: function() {

        // _hasChangePasswordModifs is a flag to make sure model methods are overriden only once
        if (this.model && !this.model._hasChangeMyPasswordModifs) {
            // Make a copy of the model
            var _proto = _.clone(this.model);

            // This is the flag to make sure we do override methods only once
            this.model._hasChangeMyPasswordModifs = true;

            /**
             * Validates current password against server
             *
             * @param {Object} fields Hash of field definitions to validate.
             * @param {Object} errors Error validation errors
             * @param {Function} callback Async.js waterfall callback
             * @private
             */
            this.model._doValidateCurrentPassword = function(fields, errors, callback) {
                var showPasswordAlert = false;
                // Find the change my password field
                var field = _.find(fields, function(field) {
                    return field.type === 'change-my-password';
                });

                // change-my-password field was not changed, so
                // don't attempt to validate password
                if (!field) {
                    callback(null, fields, errors);
                    return;
                }

                var fieldName = field.name;
                //Get the current password
                var current = this.get(fieldName + '_current_password');
                var password = this.get(fieldName + '_new_password');
                var confirmation = this.get(fieldName + '_confirm_password');

                if (_.isEmpty(current) && _.isEmpty(password) && _.isEmpty(confirmation)) {
                    callback(null, fields, errors);
                    return;
                }
                //current is non-empty but we haven't put new/confirm passwords
                if (!_.isEmpty(current)) {
                    if (_.isEmpty(password) || _.isEmpty(confirmation) || password !== confirmation) {
                        errors[fieldName] = errors[fieldName] || {};
                        errors[fieldName].new_password = true;
                        callback(null, fields, errors);
                        return;
                    } else {
                        var data = app.utils.validatePassword(password);
                        if (!data.isValid) {
                            var errMsg = app.lang.get('LBL_PASSWORD_ENFORCE_TITLE');
                            errors[fieldName] = errors[fieldName] || {};
                            errors[fieldName].new_password = true;
                            app.alert.dismiss('passwords_invalid');
                            if (data.error) {
                                errMsg += '<br><br>' + data.error;
                            }
                            showPasswordAlert = true;
                            app.alert.show('passwords_invalid', {
                                level: 'error',
                                messages: errMsg,
                            });
                            callback(null, fields, errors);
                            app.alert.dismiss('invalid-data');
                            return;
                        }
                    }
                }
                //Validate current password
                var alertOptions = {
                    title: app.lang.get("LBL_VALIDATING"),
                    level: "process"
                };
                app.alert.show('validation', alertOptions);

                app.api.verifyPassword(current, {
                    success: function(data) {
                        if(!data || !data.valid) {
                            errors[fieldName] = errors[fieldName] || {};
                            errors[fieldName].current_password = true;
                        }
                    },
                    error: function(error) {
                        errors[fieldName] = errors[fieldName] || {};
                        errors[fieldName].current_password = true;
                    },
                    /**
                     * After check is done, close alert and trigger the completion of the validation to the editor
                     */
                    complete: function() {
                        app.alert.dismiss('validation');
                        callback(null, fields, errors);
                        if (showPasswordAlert) {
                            app.alert.dismiss('invalid-data');
                        }
                    }
                });
            };
            this.model.addValidationTask('current_password_' + this.cid, _.bind(this.model._doValidateCurrentPassword, this.model));

            this.model.revertAttributes = function(options) {
                // Find any change password field
                var attrs = _.clone(this.attributes);
                _.each(attrs, function(value, attr) {
                    if (attr.match('_current_password')) {
                        this.unset(attr);
                    }
                }, this);
                // Call the old method
                _proto.revertAttributes.call(this, options);
            };
        }
    },

    /**
     * @override
     * @param {Boolean} value
     * @return {string} value
     */
    format: function(value) {
        if (this.action === 'edit') {
            this.currentPassword = this.model.get(this.name + '_current_password');
            value = '';
        } else if (value === true) {
            value = 'value_setvalue_set';
        }
        return value;
    },

    /**
     * @override
     */
    decorateError: function (errors) {
        var ftag = this.fieldTag;
        if (errors['current_password']) {
            this.fieldTag = 'input[name=current_password]';
            app.view.Field.prototype.decorateError.call(this, {current_password: true});
        }
        errors = _.omit(errors, 'current_password');
        if (!_.isEmpty(errors)) {
            this.fieldTag = 'input[name!=current_password]';
            app.view.Field.prototype.decorateError.call(this, errors);
        }
        this.fieldTag = ftag;
    },

    /**
     * @override
     */
    clearErrorDecoration: function () {
        var self = this,
            ftag = this.fieldTag || '',
            $ftag = this.$(ftag);
        // Remove previous exclamation then add back.
        this.$('.add-on').remove();

        //Not all inputs are necessarily wrapped so check each individually
        $ftag.each(function(index, el) {
            var isWrapped = self.$(el).parent().hasClass('input-append');
            if (isWrapped) {
                self.$(el).unwrap();
            }
        });
        this.$el.removeClass(ftag);
        this.$el.removeClass("error");
        this.$el.closest('.record-cell').removeClass("error");
    },

    /**
     * @override
     */
    bindDomChange: function() {
        this.$('input[name=current_password], input[name=new_password], input[name=confirm_password]').on('change.' + this.cid, _.bind(this._setPasswordAttribute, this));
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        this.$('input[name=current_password]').off('change.' + this.cid);
        this._super('unbindDom');
    },

    /**
     * Remove validation on the model.
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('current_password_' + this.cid);
        this._super('_dispose');
    }

}) },
"hint-news-panel-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.HintNewsPanelFilterField
 * @alias SUGAR.App.view.fields.BaseHintNewsPanelFilterFieldField
 * @extends View.Fields.Base.EnumField
 */
({
	// Hint-news-panel-filter Field (base) 

    extendsFrom: 'EnumField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.defaultOption = options.viewDefs.default;
        this._super('initialize', [options]);
    },

    /**
     * @override
     * Custom options for the dropdown. By default the search input will filter and search
     * the available options fed into the dropdown. The createSearchChoice method will allow us
     * to add options to the dropdown dynamically instead of the classic filtering.
     */
    getSelect2Options: function() {
        var select2Options = {};
        select2Options.width = '100%';
        select2Options.dropdownCssClass = this.def.dropdown_class ? this.def.dropdown_class : '';
        if (this.def.container_class) {
            select2Options.containerCssClass = this.def.container_class;
        } else if (this.def.isMultiSelect) {
            select2Options.containerCssClass = 'select2-choices-pills-close';
        } else {
            select2Options.containerCssClass = '';
        }

        select2Options.minimumResultsForSearch = 1;

        select2Options.initSelection = _.bind(this._initSelection, this);
        select2Options.query = _.bind(this._query, this);

        select2Options.createSearchChoice = function(term) {
            return {
                id: term, text: term
            };
        };
        select2Options.createSearchChoicePosition = 'top';

        return select2Options;
    },

    /**
     * Looks through the available options from the dropdown and returns the option if found.
     * If the option is not found an empty object will be returned.
     * Note that aside the initial options fed to the dropdown
     * we need to take into account the option created dynamically by the filter input.
     *
     * @param {string} filter The id of an existing dropdown option.
     * @return {Object} Represents an option from the dropdown; the object has a single property.
     * The property's value is the displayed text and the key is the real value/the id.
     */
    getMatchingOption: function(filter) {
        var items = _.isString(this.items) ? app.lang.getAppListStrings(this.items) : this.items;
        this.items = this._filterOptions(items);
        var filteredItems = this._filterOptions(items);
        var extendedFilteredItems = _.extend({}, filteredItems, this.searchTerm || {});
        return _.pick(extendedFilteredItems, filter);
    },

    /**
     * @inheritdoc
     * This is a simplified version of the original, additionally allows us
     * to set a default value and a placeholder text.
     */
    _initSelection: function($ele, callback) {
        var filter = $ele.val() || this.defaultOption;
        var matchingOption = this.getMatchingOption(filter);

        callback({
            id: _.keys(matchingOption)[0] || 'placeholder',
            text: _.values(matchingOption)[0] || app.lang.get('LBL_SEARCH_SELECT')
        });
    },

    /**
     * When typing into the dropdown's input we would like to be able to create a new option
     * based on the input text and be able to select it. This method will save the search term
     * into a component variable so we could later confirm that we would like to select the dynamic option.
     *
     * @param {Object} The option being selected.
     */
    setSearchTerm: function(selection) {
        this.searchTerm = {};
        this.searchTerm[selection.choice.id] = selection.choice.text;
    },

    /**
     * Sets an option manually for the filter dropdown. If the option is not existing
     * we handle it as a search term input, an option created dynamically. Null is taken as
     * the default filter.
     *
     * @param {string} filter The id of an existing dropdown option or just a custom string to be set.
     */
    setFilter: function(filter) {
        if (filter === null) {
            filter = 'All';
        }
        if (!this.items[filter]) {
            this.setSearchTerm({choice: {id: filter, text: filter}});
        }
        this.dropdown.select2('val', filter);
    },

    /**
     * We trigger an event that could be caught by other parts of the application.
     * If the new value is 'All' we consider it as a null filter.
     *
     * @param {Object} event The change event object.
     */
    exportFilter: function(event) {
        var category = event.added.id === 'All' ? null : event.added.id;
        app.events.trigger('hint-news-panel:filter', category);
    },

    /**
     * Bind events
     */
    bindEvents: function() {
        this.dropdown = this.$(this.fieldTag);
        this.dropdown.on('change', this.exportFilter);
        app.events.on('hint-news-panel-filter:set', this.setFilter, this);
        this.dropdown.on('select2-selecting', _.bind(this.setSearchTerm, this));
    },

    /**
     * @inheritdoc
     * We bind the events to the select2 dropdown only after it has been initialized.
     */
    _render: function() {
        this._super('_render');
        this.bindEvents();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        app.events.off('hint-news-panel-filter:set');
        this.dropdown.off('change', this.exportFilter);
        this.dropdown.off('select2-selecting', _.bind(this.setSearchTerm, this));
        this._super('_dispose');
    }
}) },
"htmleditable_tinymce": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Htmleditable_tinymceField
 * @alias SUGAR.App.view.fields.BaseHtmleditable_tinymceField
 * @extends View.Fields.Base.BaseField
 */
({
	// Htmleditable_tinymce Field (base) 

    plugins: ['Tinymce'],

    fieldSelector: '.htmleditable', //iframe or textarea selector
    _htmleditor: null, // TinyMCE html editor
    _isDirty: false,
    // When the model already has the value being set, there is no need to trigger the "SetContent" event, which calls
    // our callback to save the content to the model. But we don't want to short-circuit events in TinyMCE's workflow,
    // so the following flag can be toggled to false to indicate that we don't need to save the content to the model
    // inside of the callback.
    _saveOnSetContent: true,

    /**
     * Disable field pill decoration on tinyMCE fields.
     *
     * Click-to-edit is disabled for this field due to our click listeners not
     * working as intended within the tinyMCE iFrame. Blocking field pills makes
     * the behavior consistent whether the field has contents or not.
     */
    disableDecoration: true,

    /**
     * Current version of tinyMCE editor. This is appended to script requests made
     * by tinyMCE and the tinyMCE jquery plugin to ensure we don't load from the
     * browser cache after a library upgrade.
     */
    tinyMCEVersion: '4.9.11',

    /**
     * Render an editor for edit view or an iframe for others
     *
     * @private
     */
    _render: function() {
        this.destroyTinyMCEEditor();

        this._super('_render');

        this._getHtmlEditableField().attr('data-name', this.name);

        // Hide the field for now. Once the field loads its contents completely, we will show it. This helps to prevent
        // a momentary white background/flash in the iframe before it finishes loading in dark mode
        this.hide();

        if (this._isEditView()) {
            this._renderEdit(this.def.tinyConfig || null);
        } else {
            this._renderView();
        }
    },

    /**
     * Populate the editor or textarea with the value from the model
     */
    bindDataChange: function() {
        this.model.on('change:' + this.name, function(model, value) {
            if (this._isEditView()) {
                this._saveOnSetContent = false; // the model already has the value being set, so don't set it again
                this.setEditorContent(value);
            } else {
                this.setViewContent(value);
            }
        }, this);
        // handle embedded images when saved
        this.model.on('validation:success', this.handleImageSave, this);
    },

    /**
     * Prepare content to show
     *
     * @param {string} value Sanitize HTML before addition to view
     * @private
     */
    sanitizeContent: function(value) {
        return DOMPurify.sanitize(value, {
            ADD_TAGS: ['iframe'],
            ADD_ATTR: ['frameborder'],
        });
    },

    /**
     * Determines if the iframe is loaded and has a body element
     *
     * @param {Object} editable A reference to a field jQuery object
     * @protected
     */
    _iframeHasBody: function(editable) {
        return editable.contents().length > 0 && editable.contents().find('body').length > 0;
    },

    /**
     * Sets the content displayed in the non-editor view
     *
     * @param {String} value Sanitized HTML to be placed in view
     * @param {string} styleSrc relative path to iframe_sugar.css
     */
    setViewContent: function(value, styleSrc = 'styleguide/assets/css/iframe-sugar.css') {
        var editable = this._getHtmlEditableField();
        var styleExists = false;
        var css = [];
        css.push(styleSrc);

        if (!editable) {
            return;
        }

        // Prepare content to show
        var sanitizedValue = this.sanitizeContent(value);

        if (this._iframeHasBody(editable)) {
            // Only add the stylesheet that is sugar-specific while making sure not to add any duplicates
            editable.contents().find('link[rel="stylesheet"]').each(function() {
                if ($(this).attr('href') === styleSrc) {
                    styleExists = true;
                }
            });

            if (!styleExists) {
                _.each(document.styleSheets, function(style) {
                    if (style.href) {
                        css.push(style.href);
                    }
                });

                _.each(css, function(href) {
                    editable.contents().find('head').append($('<link/>', {
                        rel: 'stylesheet',
                        href: href,
                        type: 'text/css'
                    }));
                });
            }
            var frame = _.find(editable, function(item) {
                return item.tagName === 'IFRAME';
            });
            if (frame && frame.contentWindow && frame.contentWindow.document && !_.isNull(value)) {
                frame.contentDocument.body.innerHTML = value;

                // Set the styling of the view mode based on the current sugar theme
                this._setViewContentThemeStyling(frame);

                // Show the field now that we have everything loaded (prevents the field flashing white in dark mode)
                this.show();
            }
        } else {
            // If the element has no body, the iframe hasn't loaded. Wait until it loads
            editable.on('load', _.bind(function() {
                this.setViewContent(value);
            }, this));
        }
    },

    /**
     * Sets the styling of the view mode iframe based on the current Sugar light/dark theme
     *
     * @param {Object} frame the iframe jQuery object
     * @private
     */
    _setViewContentThemeStyling: function(frame) {
        try {
            // Get the style variables of the current theme
            const themeClass = app.utils.isDarkMode() ? 'sugar-dark-theme' : 'sugar-light-theme';
            const themeElement = _.first(document.getElementsByClassName(themeClass));
            const styles = getComputedStyle(themeElement);

            // Apply the proper styles to the background and text color of the iframe
            frame.contentDocument.body.style.background = styles.getPropertyValue('--primary-content-background');
            frame.contentDocument.body.style.color = styles.getPropertyValue('--text-color');
        } catch (e) {
            frame.contentDocument.body.style.background = '#ffffff';
            frame.contentDocument.body.style.color = '#000000';
        }
    },

    /**
     * Render editor for edit view
     *
     * @param {Array} value TinyMCE config settings
     * @private
     */
    _renderEdit: function(options) {
        var self = this;
        this.initTinyMCEEditor(options);
        this._getHtmlEditableField().on('change', function(){
            self.model.set(self.name, self._getHtmlEditableField().val());
        });
    },

    /**
     * Render read-only view for other views
     *
     * @private
     */
    _renderView: function() {
        this.setViewContent(this.value);
    },

    /**
     * Is this an edit view?  If the field contains a textarea, it will assume that it's in an edit view.
     *
     * @return {Boolean}
     * @private
     */
    _isEditView: function() {
        return this.action === 'edit';
    },

    /**
     * Returns a default TinyMCE init configuration for the htmleditable widget.
     * This function can be overridden to provide a custom TinyMCE configuration.
     *
     * See [TinyMCE Configuration Documentation](http://www.tinymce.com/wiki.php/Configuration)for details.
     *
     * @return {Object} TinyMCE configuration to use with this widget
     */
    getTinyMCEConfig: function(){
        return {
            // Location of TinyMCE script
            script_url: 'include/javascript/tinymce4/tinymce.min.js?v=' + this.tinyMCEVersion,
            // Force loading of current version of tinyMCE plugin
            cache_suffix: '?v=' + this.tinyMCEVersion,

            // General options
            theme: 'modern',
            skin: app.utils.isDarkMode() ? 'sugar-dark' : 'sugar',
            plugins: 'code,help,textcolor,insertdatetime,table,paste,charmap,' +
                'image,link,anchor,directionality,searchreplace,hr,lists',
            browser_spellcheck: true,

            // User Interface options
            width: '100%',
            height: '100%',
            menubar: false,
            statusbar: false,
            resize: false,
            toolbar: 'code | bold italic underline strikethrough | alignleft aligncenter alignright ' +
                'alignjustify | forecolor backcolor |  styleselect formatselect fontselect ' +
                'fontsizeselect | cut copy paste pastetext | search searchreplace | bullist numlist | ' +
                'outdent indent | ltr rtl | undo redo | link unlink anchor image | subscript ' +
                'superscript | charmap | table | hr removeformat | insertdatetime',
            // Sets the text of the Target element of the link plugin. To disable
            // this completely, set target_list: false
            target_list: [
                {
                    text: app.lang.getAppString('LBL_TINYMCE_TARGET_SAME'),
                    value: ''
                },
                {
                    text: app.lang.getAppString('LBL_TINYMCE_TARGET_NEW'),
                    value: '_blank'
                }
            ],

            // Output options
            entity_encoding: 'raw',

            // URL options
            relative_urls: false,
            convert_urls: false,

            // Insert image
            file_browser_callback: _.bind(this.tinyMCEFileBrowseCallback, this),

            // Allow image copy&paste
            paste_data_images: true,
            images_upload_handler: _.bind(this.tinyMCEImagePasteCallback, this)
        };
    },

    /**
     * Initializes the TinyMCE editor.
     *
     * @param {Object} optConfig Optional TinyMCE config to use when initializing editor.  If none provided, will load config provided from {@link getTinyMCEConfig}.
     */
    initTinyMCEEditor: function(optConfig) {
        var self = this;
        if(_.isEmpty(this._htmleditor)){
            var config = _.extend({}, this.getTinyMCEConfig(), optConfig || {});
            var __superSetup__ = config.setup;
            // Preserve custom setup if it exists, add setup function needed for widget to work properly
            config.setup = function(editor){
                if(_.isFunction(__superSetup__)){
                    __superSetup__.call(this, editor);
                }
                self._htmleditor = editor;
                self._htmleditor.on('init', function(event) {
                    self.setEditorContent(self.getFormattedValue());
                    $(event.target.getWin()).blur(function(e){ // Editor window lost focus, update model immediately
                        self._saveEditor(true);
                    });

                    // Show the field now that we have everything loaded (prevents a white flash in dark mode)
                    self.show();
                });
                self._htmleditor.on('deactivate', function(ed){
                    self._saveEditor();
                });
                self._htmleditor.on('change', function(ed, l) {
                    // Changes have been made, mark widget as dirty so we don't lose them
                    self._isDirty = true;
                });
                self._htmleditor.on('paste', function() {
                    // Some content has been pasted, mark widget as dirty so we don't lose pasted content.
                    self._isDirty = true;
                });
                self.addCustomButtons(editor);
            };
            config.oninit = function(inst) {
                self.context.trigger('tinymce:oninit', inst);
            };

            this._getHtmlEditableField().tinymce(config);
        }
    },

    /**
     * Add custom buttons.
     * @param {Object} editor TinyMCE editor
     */
    addCustomButtons: function(editor) {},

    /**
     * Destroy TinyMCE Editor instance
     */
    destroyTinyMCEEditor: function() {
        // Clean up existing TinyMCE editor
        if(!_.isNull(this._htmleditor)){
            try {
                // A known issue with Firefox and TinyMCE produces a NS_ERROR_UNEXPECTED Exception
                this._saveEditor(true);
                this._htmleditor.remove();
                this._htmleditor.destroy();
            } catch (e) {
            }
            this._htmleditor = null;
        }
    },

    /**
     * Save the TinyMCE editor's contents to the model
     * @private
     */
    _saveEditor: function(force){
        var save = force | this._isDirty;
        if(save){
            this.model.set(this.name, this.getEditorContent(), {silent: true});
            this._isDirty = false;
        }
    },

    /**
     * Finds textarea or iframe element in the field template
     *
     * @return {HTMLElement} element from field template
     * @private
     */
    _getHtmlEditableField: function() {
        return this.$el.find(this.fieldSelector);
    },

    /**
     * Sets TinyMCE editor content
     *
     * @param {String} value HTML content to place into HTML editor body
     */
    setEditorContent: function(value) {
        if(_.isEmpty(value)){
            value = "";
        }
        if (this._isEditView() && this._htmleditor && this._htmleditor.dom) {
            this._htmleditor.setContent(value);
        }
        // setup embedded images
        this.handleEmbeddedImages(value);
    },

    /**
     * Retrieves the  TinyMCE editor content
     *
     * @return {String} content from the editor
     */
    getEditorContent: function() {
        return this._htmleditor.getContent({format: 'raw'});
    },

    /**
     * Get the content height of the field's iframe.
     *
     * @private
     * @return {number} Returns 0 if the iframe isn't found.
     */
    _getContentHeight: function() {
        var editable = this._getHtmlEditableField();

        if (this._iframeHasBody(editable)) {
            return editable.contents().find('body')[0].offsetHeight;
        }

        return 0;
    },

    /**
     * Destroy TinyMCE Editor on dispose
     *
     * @private
     */
    _dispose: function() {
        this.destroyTinyMCEEditor();
        app.view.Field.prototype._dispose.call(this);
    }

}) },
"shareaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Share row action.
 *
 * This allows an user to share a record that is currently mapped with this
 * field context.
 *
 * @class View.Fields.Base.ShareactionField
 * @alias SUGAR.App.view.fields.BaseShareactionField
 * @extends View.Fields.Base.EmailactionField
 */
({
	// Shareaction Field (base) 

    extendsFrom: 'EmailactionField',

    /**
     * Share template for subject.
     *
     * See {@link #_initShareTemplates}.
     */
    shareTplSubject: null,

    /**
     * Share template for body.
     *
     * See {@link #_initShareTemplates}.
     */
    shareTplBody: null,

    /**
     * Share template for body in HTML format.
     *
     * See {@link #_initShareTemplates}.
     */
    shareTplBodyHtml: null,

    /**
     * @inheritdoc
     *
     * Adds the share options for use when launching the email client.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'emailaction';
        this._initShareTemplates();

        // If there is a default signature in email compose, it should be
        // placed below the share content in the email body.
        this.addEmailOptions({signature_location: 'below'});
    },

    /**
     * Initializes the sharing feature templates.
     *
     * This will get the templates from either the current module (since we
     * might want to customize it per module) or from core templates.
     *
     * Please define your templates on:
     *
     * - `custom/clients/{platform}/view/share/subject.hbs`
     * - `custom/clients/{platform}/view/share/body.hbs`
     * - `custom/clients/{platform}/view/share/body-html.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/share/subject.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/share/body.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/share/body-html.hbs`
     *
     * @template
     * @protected
     */
    _initShareTemplates: function() {
        this.shareTplSubject = app.template.getView('share.subject', this.module) ||
            app.template.getView('share.subject');
        this.shareTplBody = app.template.getView('share.body', this.module) ||
            app.template.getView('share.body');
        this.shareTplBodyHtml = app.template.getView('share.body-html', this.module) ||
            app.template.getView('share.body-html');
    },

    /**
     * Returns the subject to use in the email.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model Use this model when constructing the subject.
     * @return {undefined|string}
     */
    emailOptionSubject: function(model) {
        var shareParams = this._getShareParams(model);
        var subject = this.shareTplSubject(shareParams);

        return subject;
    },

    /**
     * Returns the plain-text body to use in the email.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model Use this model when constructing the body.
     * @return {undefined|string}
     */
    emailOptionDescription: function(model) {
        var shareParams = this._getShareParams(model);
        var description = this.shareTplBody(shareParams);

        return description;
    },

    /**
     * Returns the HTML body to use in the email.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model Use this model when constructing the body.
     * @return {undefined|string}
     */
    emailOptionDescriptionHtml: function(model) {
        var shareParams = this._getShareParams(model);
        var description = this.shareTplBody(shareParams);
        var descriptionHtml = this.shareTplBodyHtml(shareParams);

        return descriptionHtml || description;
    },

    /**
     * Set subject and body settings for the EmailClientLaunch plugin to use
     *
     * @protected
     * @deprecated Use
     * View.Fields.Base.ShareactionField#emailOptionSubject,
     * View.Fields.Base.ShareactionField#emailOptionDescription, and
     * View.Fields.Base.ShareactionField#emailOptionDescriptionHtml
     * instead.
     */
    _setShareOptions: function() {
        app.logger.warn('View.Fields.Base.ShareactionField#_setShareOptions is deprecated. Use ' +
            'View.Fields.Base.ShareactionField#emailOptionSubject, ' +
            'View.Fields.Base.ShareactionField#emailOptionDescription, and ' +
            'View.Fields.Base.ShareactionField#emailOptionDescriptionHtml instead.');
    },

    /**
     * Get the params required by the templates defined on
     * {@link #_initShareTemplates}.
     *
     * Override this if your templates need more information to be sent on the
     * share email.
     *
     * @template
     * @protected
     * @param {Data.Bean} model The params come from this model's attributes.
     * EmailClientLaunch plugin should dictate the model based on the context.
     */
    _getShareParams: function(model) {
        // Falls back to the `this.model` for backward compatibility.
        model = model || this.model;

        return _.extend({}, model.attributes, {
            module: app.lang.getModuleName(model.module),
            appId: app.config.appId,
            url: window.location.href,
            name: new Handlebars.SafeString(app.utils.getRecordName(model))
        });
    },

    /**
     * Explicit share action to launch the sugar email client with share info
     * (used by bwc)
     */
    shareWithSugarEmailClient: function() {
        this.launchSugarEmailClient(this.emailOptions);
    },

    /**
     * If there is a default signature in email compose, it should be placed
     * below the share content in the email body.
     *
     * @return {Object}
     * @protected
     * @deprecated The signature location option is set during initialization.
     */
    _retrieveEmailOptionsFromLink: function() {
        app.logger.warn('View.Fields.Base.ShareactionField#_retrieveEmailOptionsFromLink is deprecated. ' +
            'The signature location option is set during initialization.');
        return {};
    },

    /**
     * Retrieve a mailto URL to launch an external mail client with share info
     * (used by bwc)
     */
    getShareMailtoUrl: function() {
        return this._buildMailToURL(this.emailOptions);
    }
}) },
"service-enddate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
* @class View.Fields.Base.ServiceEnddateField
* @alias SUGAR.App.view.fields.BaseServiceEnddateField
* @extends View.Fields.Base.DateField
*/
({
	// Service-enddate Field (base) 

    extendsFrom: 'DateField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.viewName = 'detail';
        options.def.readonly = true;
        this._super('initialize', [options]);
        this.setFieldDependencyNames(options);
    },

    /**
     * Will set on the field the field names this field is dependent on.
     * Those field names can come from metadata or if they don't, they
     * will default to some names that have a chance to appear.
     *
     * @param {Object} options A set of parameters that help creating the field
     */
    setFieldDependencyNames: function(options) {
        this.startDateFieldName = options.def.startDateFieldName ||
            'service_start_date';
        this.durationUnitFieldName = options.def.durationUnitFieldName ||
            'service_duration_unit';
        this.durationValueFieldName = options.def.durationValueFieldName ||
            'service_duration_value';
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.model.on('change:' + this.startDateFieldName, this.calculateEndDate, this);
        this.model.on('change:' + this.durationUnitFieldName, this.calculateEndDate, this);
        this.model.on('change:' + this.durationValueFieldName, this.calculateEndDate, this);
    },

    /**
     * Based on what duration unit is set, there are different methods for
     * the sake of manipulating dates. In here one set of methods will be
     * returned (a getter and a setter).
     *
     * @return {Object} A set of two methods for reading and setting the date.
     */
    getMethodNames: function() {
        var unit = this.model.get(this.durationUnitFieldName);
        var nameParts = {
            year: 'FullYear',
            month: 'Month',
            day: 'Date'
        };
        return {
            get: 'get' + nameParts[unit],
            set: 'set' + nameParts[unit]
        };
    },

    /**
     * This method is repsonsible for checking if an enddate can be calculated.
     * In order to calculate an end date all fields the date is dependent on
     * have to have a value set.
     *
     * @return {boolean} True if the end date can be calculated.
     */
    canCalculateEndDate: function() {
        return !!(this.model.get(this.startDateFieldName) &&
            this.model.get(this.durationValueFieldName) &&
            this.model.get(this.durationUnitFieldName));
    },

    /**
     * If possible it will calculate the end date based on a start date and
     * duration. The date is being converted to a regular date format for
     * easier manipulation and after the calculation takes part, the new
     * value will converted to the correct format. A render is being triggered
     * in order to display the new value as soon as possible.
     */
    calculateEndDate: function() {
        // Don't attempt to recalculate the end date for coterm line items. No
        // matter what the user enters for start date for those, we don't want
        // to change this.
        if (!_.isEmpty(this.model.get('add_on_to_id'))) {
            return;
        }
        if (this.canCalculateEndDate()) {
            // Begin with the end date equal to zero hour on the specified start
            // date, correcting any offset added by the javascript Date object
            var endDate = new Date(this.model.get(this.startDateFieldName));
            var offsetInMs = endDate.getTimezoneOffset() * 60000;
            endDate.setTime(endDate.getTime() + offsetInMs);

            // Add the specified duration to the date, then subtract one day
            // as service runs through one day prior
            var methods = this.getMethodNames();
            var newDate = endDate[methods.get]() + this.model.get(this.durationValueFieldName);
            endDate[methods.set](newDate);
            endDate.setDate(endDate.getDate() - 1);

            var formattedEndDate = this.unformat(app.date(endDate));
            this.model.set(this.name, formattedEndDate);
        } else {
            this.model.set(this.name, '');
        }
    }
}) },
"base": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This is the base field and all of other fields extend from it.
 *
 * @class View.Fields.Base.BaseField
 * @alias SUGAR.App.view.fields.BaseBaseField
 * @extends View.Field
 */
({
	// Base Field (base) 

    plugins: ['MetadataEventDriven'],

    /**
     * Should we initialize the default field value?
     */
    shouldInitDefaultValue: false,

    /**
     * @inheritdoc
     *
     * Some plugins use events which prevents {@link View.Field#delegateEvents}
     * to fallback to metadata defined events.
     * This will make sure we merge metadata events with the ones provided by
     * the plugins.
     *
     * The Base Field will always clear any tooltips after `render`.
     */
    initialize: function(options) {

        this.events = _.extend({}, this.events, options.def.events);

        this._super('initialize', arguments);

        /**
         * Property to add or not the `ellipsis_inline` class when rendering the
         * field in the `list` template. `true` to add the class, `false`
         * otherwise.
         *
         * Defaults to `true`.
         *
         * @property {boolean}
         */
        this.ellipsis = _.isUndefined(this.def.ellipsis) || this.def.ellipsis;

        if (app.tooltip) {
            this.on('render', app.tooltip.clear);
        }

        if (this.shouldInitDefaultValue) {
            this._initDefaultValue();
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var action = 'view';
        if (this.def.link && this.def.route) {
            action = this.def.route.action;
        }
        if (this.def.link && app.acl.hasAccessToModel(action, this.model)) {
            this.href = this.buildHref();
        }
        app.view.Field.prototype._render.call(this);
    },

    /**
     * Takes care of building href for when there's a def.link and also if is
     * bwc enabled.
     *
     * Deprecated functionality:
     * If `this.def.bwcLink` is set to `true` on metadata, we force the href
     * to be in BWC.
     *
     * TODO remove this from the base field
     */
    buildHref: function() {
        var defRoute = this.def.route ? this.def.route : {},
            module = this.model.module || this.context.get('module');
        // FIXME remove this.def.bwcLink functionality (not yet removed due to Portal need for Documents)
        return '#' + app.router.buildRoute(module, this.model.get('id'), defRoute.action, this.def.bwcLink);
    },

    /**
     * @inheritdoc
     *
     * Trim whitespace from value if it is a String.
     */
    unformat: function(value) {
        return _.isString(value) ? value.trim() : value;
    },

    /**
     * Set the default field value from metadata for a new model
     *  [
     *      ...
     *      'default' => '...',
     *      ...
     *  ]
     *
     * This function makes 2 assumptions:
     *      1. the default key is named 'default'
     *      2. the default value requires no parsing
     *
     * @private
     */
    _initDefaultValue: function() {
        if (!this.model.isNew() || this.model.get(this.name) || !this.def.default) {
            return;
        }

        if (_.isFunction(this.model.setDefault)) {
            this.model.setDefault(this.name, this.def.default);
        }
    }
}) },
"boxplot": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.BoxplotField
 * @alias SUGAR.App.view.fields.BaseBoxplotField
 * @extends View.Fields.Base.BaseField
 */
({
	// Boxplot Field (base) 

    overallWorstCase: 0.0,

    overallBestCase: 0.0,

    overallCaseDifference: 0.0,

    worstCase: 0.0,

    bestCase: 0.0,

    likely: 0.0,

    likelyRound: 0,

    boxStart: 0.0,

    boxEnd: 0.0,

    boxWidth: 0.0,

    likelyPercent: 0.0,

    caretPos: 0.0,

    amountPos: 0.0,

    likelyMarginFromWorstCase: 0.0,

    initialize: function(options) {
        this._super('initialize', [options]);
        this._caseComparator();
    },

    bindDataChange: function() {
        this.collection.on('change', function() {
            this.collection.overallBestCase = null;
            this.collection.overallWorstCase = null;
            this._caseComparator();
        }, this);
    },

    /**
     * @inheritdoc
     *
     * calculates the width of the box-plot and the worst_case and the best_case end whiskers,
     * by calculating the worst_case and best_case value for a collection.
     * It also calculates the median line for the likely value position to be placed in the box plot.
     * @return {Object} this
     */
    _render: function() {
        this._boxPlotCalculator(this.overallBestCase, this.overallWorstCase);
        return this._super('_render');
    },

    /**
     * _caseComparator() accepts modelArray for the collection
     * and gets the overall worst_case value.
     * @param {Array} it accepts array of models of the collection
     * @return {Object} value minimum worst_case, maximum best_case
     * @private
     */
    _caseComparator: function() {
        if (this.collection && (!this.collection.overallBestCase || !this.collection.overallWorstCase)) {
            var min = Number.MAX_VALUE;
            var max = 0;
            var userDecPrecision = +app.user.getPreference('decimal_precision');
            var modelArray = this.collection.models;
            modelArray.forEach(function(model) {
                var worstCase = model.get('worst_case');
                var bestCase = model.get('best_case');
                if (max < parseFloat(bestCase)) {
                    max = parseFloat(bestCase);
                }
                if (min > parseFloat(worstCase)) {
                    min = parseFloat(worstCase);
                }
            });
            this.overallBestCase = max.toFixed(userDecPrecision);
            this.overallWorstCase = min.toFixed(userDecPrecision);
            this.collection.overallWorstCase = this.overallWorstCase;
            this.collection.overallBestCase = this.overallBestCase;
        } else {
            this.overallBestCase = this.collection.overallBestCase;
            this.overallWorstCase = this.collection.overallWorstCase;
        }
    },

    /**
     * _boxPlotCalculator() accepts best_Case and worst_case values relative to the entire collection
     * and calculates the box plot accordingly for the positive amounts.
     * @param {number} bestCase, worstCase
     * @private
     */
    _boxPlotCalculator: function(bestCase, worstCase) {
        var userDecPrecision = +app.user.getPreference('decimal_precision');

        this.overallCaseDifference = parseFloat((bestCase - worstCase).toFixed(userDecPrecision));

        this.worstCase = parseFloat(this.model.get('worst_case')).toFixed(userDecPrecision);
        this.likely =  parseFloat(this.model.get('amount')).toFixed(userDecPrecision);
        this.likelyRound = Math.round(this.likely);
        var likelyAmount = app.currency.formatAmountLocale(this.likely);
        this.likelyRound = likelyAmount.substring(0, likelyAmount.length - (userDecPrecision + 1));
        this.bestCase = parseFloat(this.model.get('best_case')).toFixed(userDecPrecision);

        this.likelyMarginFromWorstCase = this.likely - worstCase;

        this.likelyPercent = this.overallCaseDifference !== 0 ?
          parseFloat((this.likelyMarginFromWorstCase / this.overallCaseDifference).toFixed(userDecPrecision)) * 100 : 0;
        this.likelyPercent = this.likelyPercent === 100 ? this.likelyPercent - 1 : this.likelyPercent;
        this.caretPos =  this.likelyPercent - 2.7;
        this.amountPos = this.likelyPercent - (this.likelyRound.length + 3);
        this.amountPos = (this.amountPos <= 0) ? 0 : this.amountPos;

        this.boxStart = this.overallCaseDifference !== 0 ?
            ((this.worstCase - worstCase) / this.overallCaseDifference).toFixed(userDecPrecision) * 100 : 0;
        this.boxEnd = ((this.bestCase - worstCase) / this.overallCaseDifference).toFixed(userDecPrecision) * 100;
        this.boxEnd = this.overallCaseDifference !== 0 ?
            ((this.bestCase - worstCase) / this.overallCaseDifference).toFixed(userDecPrecision) * 100 : 0;
        this.boxWidth = parseFloat((this.boxEnd - this.boxStart).toFixed(userDecPrecision));
        this.boxWidth = (this.boxStart + this.boxWidth) === 100 ? parseFloat(this.boxWidth - 1) : this.boxWidth;
        this.boxWidth = isNaN(this.boxWidth) ? 99 : this.boxWidth;

        this.likely = app.currency.formatAmountLocale(this.likely);
        this.bestCase = app.currency.formatAmountLocale(this.bestCase);
        this.worstCase = app.currency.formatAmountLocale(this.worstCase);
    },
}) },
"mass-email-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This field uses the `EmailClientLaunch` plugin to launch the appropriate
 * email client.
 *
 * Recipients to pre-populate are pulled from the mass_collection.
 * For external email client: Changes to the mass_collection will rebuild the mailto: link
 * For internal email client: Recipients are gathered from the mass_collection on click.
 * In order for the recipients to be prepopulated, this field requires the models in the
 * mass_collection contain the email field - if not, recipients will simply be blank (no error).
 *
 * @class View.Fields.Base.MassEmailButtonField
 * @alias SUGAR.App.view.fields.BaseMassEmailButtonField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Mass-email-button Field (base) 

    extendsFrom: 'ButtonField',

    /**
     * @inheritdoc
     *
     * Add the `EmailClientLaunch` plugin and force use of `ButtonField`
     * templates.
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['EmailClientLaunch']);
        this._super('initialize', [options]);
    },

    /**
     * Set up `add`, `remove` and `reset` listeners on the `mass_collection` so
     * we can render this button appropriately whenever the mass collection changes.
     */
    bindDataChange: function() {
        var massCollection = this.context.get('mass_collection');
        massCollection.on('add remove reset', this.render, this);
        this._super('bindDataChange');
    },

    /**
     * Clean up listener on mass_collection updates
     */
    unbindData: function() {
        var massCollection = this.context.get('mass_collection');
        if (massCollection) {
            massCollection.off(null, null, this);
        }
        this._super('unbindData');
    },

    /**
     * Map mass collection models to the appropriate format
     * required to prepopulate the to on email compose
     *
     * @return {Object} options to prepopulate on the email compose
     * @private
     */
    _retrieveEmailOptionsFromLink: function() {
        var massCollection = this.context.get('mass_collection'),
            to = _.map(massCollection.models, function(model) {
                return {bean: model};
            }, this);
        return {
            to: to
        };
    }
}) },
"url": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.UrlField
 * @alias SUGAR.App.view.fields.BaseUrlField
 * @extends View.Fields.Base.BaseField
 */
({
	// Url Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super("initialize", arguments);
        //Generated URL's should not be editable
        if (app.utils.isTruthy(this.def.gen)) {
            this.def.readonly = true;
        }
    },

    format:function(value){
        if (value) {
            if (!value.match(/^([a-zA-Z]+):/)) {
                value = 'http://' + value;
            }
            let whiteList = app.config.allowedLinkSchemes;
            this.def.isClickable = true;
            if (!whiteList.filter(function(scheme) {
                return value.toLowerCase().indexOf(scheme + ':') === 0;
            }).length) {
                this.def.isClickable = false;
            }
        }
        return value;
    },
    unformat:function(value){
        value = (value!='' && value!='http://') ? value.trim() : "";
        return value;
    },
    _render: function() {
        this.def.link_target = _.isUndefined(this.def.link_target) ? '_blank' : this.def.link_target;
        app.view.Field.prototype._render.call(this);
    }
}) },
"fieldset": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * A fieldset is a field that contains one or more child fields.
 * The hbs template sets the placeholders of child fields but the creation of
 * child fields reside in the controller.
 *
 * Accessibility is checked against each child field as well as the fieldset.
 * We do not hide the fieldset in the event that the fieldset is accessible and
 * all child fields are not.
 *
 * Supported properties:
 *
 * - {Array} fields List of fields that are part of the fieldset.
 * - {boolean} show_child_labels Set to `true` to show labels on child fields in
 * the record view.
 * - {boolean} inline Set to `true` to render the fieldset inline.
 * - {boolean} equal_spacing When in inline mode, setting `true` will make the
 * fields inside fieldsets to have equal spacing, rather than being left aligned.
 *
 * Example usage:
 *
 *      array(
 *          'name' => 'date_entered_by',
 *          'type' => 'fieldset',
 *          'label' => 'LBL_DATE_ENTERED',
 *          'fields' => array(
 *              array(
 *                  'name' => 'date_entered',
 *              ),
 *              array(
 *                  'type' => 'label',
 *                  'default_value' => 'LBL_BY',
 *              ),
 *              array(
 *                  'name' => 'created_by_name',
 *              ),
 *          )
 *      )
 *
 * @class View.Fields.Base.FieldsetField
 * @alias SUGAR.App.view.fields.BaseFieldsetField
 * @extends View.Fields.Base.BaseField
 */
({
	// Fieldset Field (base) 

    /**
     * Initializes the fieldset field component.
     *
     * Initializes the fields property.
     *
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * Children fields that are created as part of this field.
         *
         * @property {Array}
         */
        this.fields = [];

        var inlineTag = this.def.inline ? '-inline' : '';
        this.def.css_class = (this.def.css_class ? this.def.css_class + ' fieldset' :
            'fieldset') + inlineTag;

        if (this.def.equal_spacing && this.def.inline) {
            this.def.css_class += ' fieldset-equal';
        }
    },

    /**
     * @inheritdoc
     *
     * Looks for the fallback template as specified by the view. Returns the
     * `detail` template if it's not found.
     * FIXME: SC-3363 This should be the default behavior in `field.js`.
     */
    _getFallbackTemplate: function(viewName) {
        if (_.contains(this.fallbackActions, viewName)) {
            return viewName;
        }
        if (app.template.get('f.' + this.type + '.' + this.view.fallbackFieldTemplate)) {
            return this.view.fallbackFieldTemplate;
        }
        return 'detail';
    },

    /**
     * @inheritdoc
     *
     * Loads the `record-detail` template if the view is `record`.
     * FIXME: This is a quick hack and will be fixed by SC-3364.
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        if ((this.view.name === 'record' ||
            this.view.name === 'create' ||
            this.view.name === 'dashablerecord' ||
            this.view.name === 'create-nodupecheck' ||
            this.view.name === 'create-no-cancel-button' ||
            this.view.name === 'pmse-case') &&
            this.type === 'fieldset' &&
            !_.contains(this.fallbackActions, this.action)
        ) {
            this.template = app.template.getField('fieldset', 'record-detail', this.model.module);
        }
    },

    /**
     * @inheritdoc
     *
     * If current fieldset is not readonly, it always falls back to false
     * (nodata unsupportable).
     * If current fieldset is readonly and all dependant fields contains empty
     * data set, then it falls back to true.
     *
     * @return {Boolean} true if this fieldset is readonly and all the data
     * fields are empty.
     */
    showNoData: function() {

        if (!this.def.readonly) {
            return false;
        }

        return !_.some(this.fields, function(field) {
            return field.name && field.model.has(field.name);
        });
    },

    /**
     * Will check for license access and if all the fields are restricted by license,
     * it will mark every field as hidden, but one.
     * @param {Array} fields A list of fields part of the given fieldset.
     */
    markLicensedFieldToHide: function(fields) {
        var nrOfFieldsWithoutLicense = _.reduce(fields, function(nr, field) {
            var hasAccess = app.acl.hasAccessToModel('license', this.model, field.name);
            return hasAccess ? nr : nr + 1;
        }, 0, this);

        if (fields.length === nrOfFieldsWithoutLicense) {
            _.each(fields, function(field, i) {
                if (i > 0) {
                    field.licensed = true;
                }
            });
        }
    },

    /**
     * @inheritdoc
     *
     * We set the result from `field.getPlaceholder()` into a property named
     * `placeholder` for each of the child fields. These placeholders help us
     * render the child fields when placed in the hbs file.
     */
    _render: function() {
        var fields = this._getChildFields();
        _.each(fields, function(field) {
            field.placeholder = field.getPlaceholder();
        }, this);

        this.focusIndex = 0;

        this.markLicensedFieldToHide(fields);

        this._super('_render');

        this._renderFields(fields);

        return this;
    },

    /**
     * Renders the children fields in their respective placeholders.
     *
     * @param {Array} fields The children fields.
     * @protected
     */
    _renderFields: function(fields) {
        // In terms of performance it is better to search the DOM once for
        // all the fieldset fields, than to search the DOM for each field.
        // That's why we cache the DOM elements in the `fieldElems` hash and pass
        // them to {@link Backbone.View#setElement}.
        var fieldElems = {};

        this.$('span[sfuuid]').each(function() {
            var $this = $(this);
            var sfId = $this.attr('sfuuid');
            fieldElems[sfId] = $this;
        });

        _.each(fields, function(field) {
            field.setElement(fieldElems[field.sfId]);
            field.render();
        }, this);
    },

    /**
     * Gets the child field definitions that are defined in the metadata.
     *
     * @return {Object} Metadata of the child fields.
     * @protected
     */
    _getChildFieldsMeta: function() {
        return app.utils.deepCopy(this.def.fields);
    },

    /**
     * Creates the children fields that are specified in the definitions.
     *
     * @return {Array} Children fields that are created.
     * @protected
     */
    _getChildFields: function() {
        if (!_.isEmpty(this.fields)) {
            return this.fields;
        }

        var metaFields = this._getChildFieldsMeta();
        if (metaFields) {
            _.each(metaFields, function(fieldDef) {
                var field = app.view.createField({
                    def: fieldDef,
                    view: this.view,
                    nested: true,
                    viewName: this.options.viewName,
                    model: this.model,
                    module: fieldDef.module
                });
                this.fields.push(field);
                field.parent = this;
            }, this);
        }
        return this.fields;
    },

    /**
     * @inheritdoc
     */
    clearErrorDecoration: function() {
        _.each(this.fields, function(field) {
            field.clearErrorDecoration();
        });

        this._super('clearErrorDecoration');
    },

    /**
     * The tab handler.
     *
     * Focus on the next child field. Skips disabled fields.
     *
     * @return {boolean} `true` if this method should be called upon the next tab.
     */
    focus: function() {
        // this should be zero but lets make sure
        if (this.focusIndex < 0 || !this.focusIndex) {
            this.focusIndex = 0;
        }

        if (this.focusIndex >= this.fields.length) {
            // done focusing our inputs return false
            this.focusIndex = -1;
            return false;
        } else {
            // this field is disabled skip ahead
            if (this.fields[this.focusIndex] && this.fields[this.focusIndex].isDisabled()) {
                this.focusIndex++;
                return this.focus();
            }
            // if the next field returns true its not done focusing so don't
            // increment to the next field
            if (_.isFunction(this.fields[this.focusIndex].focus) && this.fields[this.focusIndex].focus()) {
            } else {
                var field = this.fields[this.focusIndex];
                var $el = field.$(field.fieldTag + ':first');
                $el.focus().val($el.val());
                this.focusIndex++;
            }
            return true;
        }
    },

    /**
     * Fieldsets need to reset the action of its individual fields as well
     *
     * @protected
     * @override
     */
    _resetAction: function() {
        this._super('_resetAction');
        _.each(this.fields, function(field) {
            field._resetAction();
        });
    },

    /**
     * @inheritdoc
     */
    setDisabled: function(disable) {
        disable = _.isUndefined(disable) ? true : disable;
        this._super('setDisabled', [disable]);
        _.each(this.fields, function(field) {
            field.setDisabled(disable);
        }, this);
    },

    /**
     * @inheritdoc
     */
    setViewName: function(view) {
        this._super('setViewName', [view]);
        _.each(this.fields, function(field) {
            field.setViewName(view);
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Set action name of child fields of this field set.
     * Reset current focus index to the first item when it switches to different mode.
     */
    setMode: function(name) {
        this.focusIndex = 0;

        //Set the mode on child fields without rendering
        _.each(this.fields, function(field) {
            var oldAction = field._previousAction || field.action;
            field._removeViewClass(oldAction);
            if (field.isDisabled()) {
                field._previousAction = name;
            } else {
                field.action = name;
            }
        });

        //The _super 'setMode' would render all child fields.
        this._super('setMode', [name]);
    },

    /**
     * Fieldsets need to check its fields to see if they are all empty
     *
     * @override
     */
    isFieldEmpty: function() {
        return _.every(this._getChildFields(), function(field) {
            return field.isFieldEmpty();
        });
    },

    /**
     * @inheritdoc
     *
     * We need this empty so it won't affect the nested fields that have the
     * same `fieldTag` of this fieldset due the usage of `find()` method.
     */
    bindDomChange: function() {
    },

    /**
     * @inheritdoc
     *
     * Keep empty because you cannot set a value of a type `fieldset`.
     */
    bindDataChange: function() {
        var removeNoData = _.debounce(function() {
            if (this.disposed) {
                return;
            }

            if (this.action === 'nodata') {
                this.setMode('detail');
            }
        }, 100);

        _.each(this._getChildFields(), function(field) {
            this.model.on('change:' + field.name, removeNoData, this);
        }, this);
    },

    /**
     * @inheritdoc
     *
     * We need this empty so it won't affect the nested fields that have the
     * same `fieldTag` of this fieldset due the usage of `find()` method.
     */
    unbindDom: function() {
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        //fields inside fieldset need to be disposed before the fielset itself is disposed.
        _.each(this.fields, function(field) {
            field.parent = null;
            field.dispose();
        });
        this.fields = null;
        app.view.Field.prototype._dispose.call(this);
    }
}) },
"escalate-action": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EscalateActionField
 * @alias SUGAR.App.view.fields.BaseEscalateActionField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Escalate-action Field (base) 

    extendsFrom: 'RowactionField',

    plugins: ['LinkedModel'],

    /**
     * Flag that determines whether this action is present on a dashlet view
     */
    onDashlet: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._setUpEscalationEvents();

        // Determine if this is rendered on a dashlet or not
        this.onDashlet = this.view && this.view.name === 'dashlet-toolbar';
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (!this.isEscalatable(this.module, this.def.acl_action)) {
            this.hide();
        } else {
            this._super('_render');
        }
    },

    /**
     * Determines if the specified module is escalatable
     * 1. Module is marked escalatable
     * 2. Escalation subpanel is visible
     *
     * @return {boolean}
     */
    isModuleEscalatable: function(module) {
        var moduleDef = app.metadata.getModule(module);
        var hiddenSubpanels = app.metadata.getHiddenSubpanels();
        if (moduleDef && !_.contains(hiddenSubpanels, 'escalations')) {
            return moduleDef.isEscalatable;
        }
        // Default to false
        return false;
    },

    /**
     * Determines generic is escalatable
     * 1. User has access to Escalations module
     * 2. Module is escalatable
     *
     * @param module
     * @param aclAction
     * @return {boolean}
     */
    isEscalatable: function(module, aclAction = 'create') {
        var hasAccess = app.acl.hasAccess(aclAction, 'Escalations');
        return hasAccess && this.isModuleEscalatable(module);
    },

    /**
     * @inheritdoc
     */
    _loadTemplate: function() {
        this.type = 'rowaction';
        this._super('_loadTemplate');
        this.type = 'escalate-action';
    },

    /**
     * Handle click event for Escalate button
     */
    escalateClicked: function() {
        this._escalateModule();
    },

    /**
     * Trigger the creation of a related Escalation record
     * @private
     */
    _escalateModule: function() {
        // From LinkedModel with hardcoded Escalations module argument and escalations link argument
        this.createRelatedRecord('Escalations', 'escalations');
    },

    /**
     * Set up the escalation event handlers if the module is escalation enabled
     * @private
     */
    _setUpEscalationEvents: function() {
        this.context.on('button:escalate_button:click', this.escalateClicked, this);

        // This allows us to mimic the same behavior as when a user adds a subpanel relationship record
        this.on('linked-model:create', function() {
            // Used to grab the escalation subpanel context if it exists
            var escalationContext;

            // If this action button is not on a dashlet and is instead rendered on the record view
            if (!this.onDashlet) {
                // Grab the escalation subpanel context so that we can update the subpanel at the same time
                escalationContext = this._getEscalationSubpanelContext(this.context);
            }

            // If the module doesnt have a subpanel relationship defined, dont do anything
            // This probably shouldnt be hit since the button wont show when escalation subpanel is hidden, but
            // it protects against a custom module being built that didnt add escalation as a subpanel
            if (!_.isUndefined(escalationContext)) {
                escalationContext.set('skipFetch', false);
                escalationContext.reloadData();
            }
        }, this);
    },

    /**
     * Retrieve the escalation subpanel context from a view context
     * @param context the view context containing the subpanels
     * @private
     */
    _getEscalationSubpanelContext: function(context) {
        return _.find(context.children, function(child) {
            return child.get('module') === 'Escalations';
        });
    },

    /**
     * @inheritdoc
     */
    isAllowedDropdownButton: function() {
        return this.isEscalatable(this.module, this.def.acl_action);
    }
}) },
"editablelistbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EditablelistbuttonField
 * @alias SUGAR.App.view.fields.BaseEditablelistbuttonField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Editablelistbutton Field (base) 

    events: {
        'click [name=inline-save]' : 'saveClicked',
        'click [name=inline-cancel]' : 'cancelClicked'
    },
    extendsFrom: 'ButtonField',
    initialize: function(options) {
        this._super("initialize", [options]);
        if(this.name === 'inline-save') {
            this.model.off("change", null, this);
            this.model.on("change", function() {
                this.changed = true;
            }, this);
        }
    },
    _loadTemplate: function() {
        app.view.Field.prototype._loadTemplate.call(this);
        if(this.view.action === 'list' && _.indexOf(['edit', 'disabled'], this.action) >= 0 ) {
            this.template = app.template.getField('button', 'edit', this.module, 'edit');
        } else {
            this.template = app.template.empty;
        }
    },
    /**
     * Called whenever validation completes on the model being edited
     * @param {boolean} isValid TRUE if model is valid
     * @private
     */
    _validationComplete : function(isValid){
        if (!isValid) {
            this.setDisabled(false);
            return;
        }
        if (!this.changed) {
            this.cancelEdit();
            return;
        }

        this._save();
    },

    /**
     * Called when the model is successfully saved
     *
     * @param {Data.Bean} model The updated model
     * @private
     */
    _onSaveSuccess: function(model) {
        this.changed = false;
        this.view.toggleRow(model.id, false);
    },

    _save: function() {
        var self = this,
            options = {
                success: _.bind(this._onSaveSuccess, this),
                error: function(model, error) {
                    if (error.status === 409) {
                        app.utils.resolve409Conflict(error, self.model, function(model, isDatabaseData) {
                            if (model) {
                                if (isDatabaseData) {
                                    successCallback(model);
                                } else {
                                    self._save();
                                }
                            }
                        });
                    }
                },
                complete: function() {
                    // remove this model from the list if it has been unlinked
                    if (self.model.get('_unlinked')) {
                        self.collection.remove(self.model, { silent: true });
                        self.collection.trigger('reset');
                        self.view.render();
                    } else {
                        self.setDisabled(false);
                    }
                },
                lastModified: self.model.get('date_modified'),
                //Show alerts for this request
                showAlerts: {
                    'process': true,
                    'success': {
                        messages: app.lang.get('LBL_RECORD_SAVED', self.module)
                    }
                },
                relate: this.model.link ? true : false
            };

        options = _.extend({}, options, this.getCustomSaveOptions(options));

        this.model.save({}, options);
    },

    getCustomSaveOptions: function(options) {
        return {};
    },

    /**
     * Initiates validation on the model with fields that the user has edit
     * access to.
     */
    saveModel: function() {
        this.setDisabled(true);

        var fieldsToValidate = this.view.getFields(this.module, this.model);
        var erasedFields = this.model.get('_erased_fields');
        fieldsToValidate = _.pick(fieldsToValidate, function(fieldInfo, fieldName) {
            return app.acl.hasAccessToModel('edit', this.model, fieldName) &&
                (!_.contains(erasedFields, fieldName) || this.model.get(fieldName) || fieldInfo.id_name);
        }, this);
        this.model.doValidate(fieldsToValidate, _.bind(this._validationComplete, this));
    },

    cancelEdit: function() {
        if (this.isDisabled()) {
            this.setDisabled(false);
        }
        this.changed = false;
        this.model.revertAttributes();
        this.view.clearValidationErrors();
        this.view.toggleRow(this.model.id, false);

        // trigger a cancel event across the parent context so listening components
        // know the changes made in this row are being reverted
        if(this.context.parent) {
            this.context.parent.trigger('editablelist:cancel', this.model);
        }
    },
    saveClicked: function(evt) {
        if (!$(evt.currentTarget).hasClass('disabled')) {
            this.saveModel();
        }
    },
    cancelClicked: function(evt) {
        this.cancelEdit();
    }
}) },
"related-contact": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * RelatedContactField is needed because BaseField specifically gets values from specific keys
 * on the model, and for the HistorySummaryView list, we need to set values on the model
 * that are different from what BaseField uses so it doesn't conflict with the other values
 * on BaseField's model
 *
 * @class View.Fields.Base.RelatedContactField
 * @alias SUGAR.App.view.fields.BaseRelatedContactField
 * @extends View.Fields.Base.BaseField
 */
({
	// Related-contact Field (base) 

    events: {
        'click a': 'onLinkClicked'
    },

    /**
     * Holds the href for the field link
     */
    linkRoute: '',

    /**
     * @inheritdoc
     * @override
     *
     * Overriding since the parent buildHref would use 'id' not 'contact_id'
     * to create the href link
     */
    buildHref: function() {
        var defRoute = this.def.route ? this.def.route : {},
            module = this.model.module || this.context.get('module'),
            id = this.model.get('contact_id');
        this.linkRoute = '#' + app.router.buildRoute(module, id, defRoute.action);
        return this.linkRoute;
    },

    /**
     * Intercepts the clicked link, if the user clicked on the Contact
     * that the user was already viewing, refresh the page, because otherwise
     * the url will not change
     *
     * @param {jQuery.Event} evt The click event from the link
     */
    onLinkClicked: function(evt) {
        var currentRoute = '#' + Backbone.history.getFragment();
        if (currentRoute === this.linkRoute) {
            app.router.refresh();
        }
    }
}) },
"relative-date": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Display relative time for 'date' field.
 *
 * @class View.Fields.Base.RelativeDateField
 * @alias SUGAR.App.view.fields.BaseRelativeDateField
 * @extends View.Fields.Base.BaseField
 */
({
	// Relative-date Field (base) 

    /**
     * @inheritdoc
     *
     * Set a date to end of the day to display relative time correctly, especially when today is the date.
     * Eg, 2019-11-15 will be converted to 2019-11-15T23:59:59. This should be used for 'date' only fields.
     */
    format: function(value) {
        if (value) {
            value = app.date(value).endOf('day').format();
        }
        return value;
    }
}) },
"invitation-actions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.InvitationActionsField
 * @alias SUGAR.App.view.fields.BaseInvitationActionsField
 * @extends View.Fields.Base.BaseField
 */
({
	// Invitation-actions Field (base) 

    events: {
        'click [data-action]': 'toggleStatus'
    },

    /**
     * Toggle invitation acceptance status.
     *
     * This will fire the save automatically to the server since it is a toggle
     * button and won't make sense to do save from the view (same as favorite).
     *
     * @param {Event} evt The click event that triggered the change.
     */
    toggleStatus: function(evt) {
        var attr = {};

        attr[this.name] = $(evt.currentTarget).data('action');

        this.model.save(attr, {relate: true});
    }
}) },
"sentiment": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.SentimentField
 * @alias SUGAR.App.view.fields.BaseSentimentField
 * @extends View.Fields.Base.BaseField
 */
({
	// Sentiment Field (base) 

    extendsFrom: 'BaseField',

    /**
     * sentiment label
     */
    sentimentLabel: '',

    /**
     * sentiment icon
     */
    sentimentIcon: '',

    /**
     * @inheritdoc
     * @private
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');
        // use detail view template
        this.template = app.template.getField('sentiment', 'detail', this.model.module);
    },

    /**
     * Map sentiment score to Positive, Neutral and Negative
     */
    mapSentiment: function() {
        var val = this.model.get(this.name);
        if (val !== null && val !== undefined && !isNaN(val)) {
            var path = 'styleguide/assets/img/sentiment/';
            if (val > 1.3) {
                this.sentimentIcon = path + 'Positive.svg';
                this.sentimentLabel = 'LBL_SENTIMENT_POSITIVE';
            } else if (val < -1.3) {
                this.sentimentIcon = path + 'Negative.svg';
                this.sentimentLabel = 'LBL_SENTIMENT_NEGATIVE';
            } else {
                this.sentimentIcon = path + 'Neutral.svg';
                this.sentimentLabel = 'LBL_SENTIMENT_NEUTRAL';
            }
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this.mapSentiment();
        this._super('_render');
    }
}) },
"rowactions-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RowactionsCreateField
 * @alias SUGAR.App.view.fields.BaseRowactionsCreateField
 * @extends View.Fields.Base.RowactionsField
 */
({
	// Rowactions-create Field (base) 

    extendsFrom: 'FieldsetField',

    /**
     * @inheritdoc
     *
     * Overriding FieldsetField's method to use def.buttons not def.fields
     *
     * @override
     */
    _getChildFieldsMeta: function() {
        return app.utils.deepCopy(this.def.buttons);
    }
}) },
"phone": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.PhoneField
 * @alias SUGAR.App.view.fields.BasePhoneField
 * @extends View.Fields.Base.BaseField
 */
({
	// Phone Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * Listen for CCP phone number clicks
     */
    events: {
        'click .ccp-outgoing': '_dialNumber',
    },

    /**
     * Is a CCP agent logged in? Defaults to false.
     */
    ccpEnabled: false,

    /**
     * @override
     * @param options
     */
    initialize: function (options) {
        var serverInfo = app.metadata.getServerInfo();

        this.dialoutEnabled = serverInfo.system_skypeout_on ? true : false;
        this.ccpEnabled = window.connect && window.connect.core.initialized;

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        app.events.on('ccp:initiated', this._enableCCP, this);
        app.events.on('ccp:terminated', this._disableCCP, this);
    },

    /**
     * Attempt to dial phone number via CCP. Warn user if calling fails.
     * @param {Object} event - JQuery click event
     * @private
     */
    _dialNumber: function(event) {
        if (!(window.connect && connect.core.initialized)) {
            app.alert.show('ccp-not-initiated', {
                level: 'error',
                messages: app.lang.get('LBL_CCP_NOT_INITIATED')
            });
            return;
        }

        if (this._activeChatSession()) {
            app.alert.show('dialout-not-allowed', {
                level: 'warning',
                messages: app.lang.get('LBL_CCP_DIALOUT_NOT_ALLOWED')
            });
            return;
        }

        try {
            var phoneNumber = event.target.text;
            var agent = new connect.Agent();
            var arn = agent.getRoutingProfile().defaultOutboundQueue.queueARN;
            var endpoint = connect.Endpoint.byPhoneNumber(phoneNumber);
            agent.connect(endpoint, {
                queueARN: arn, success: _.bind(this._callSuccess, this), failure: this._callFailure
            });
        } catch (e) {
            // this occurs if there's an error in calling the library functions.
            // Error in the call itself is handled in the failure callback.
            app.logger.error(e);
            app.alert.show('ccp-call-error', {
                level: 'error',
                messages: app.lang.get('LBL_CCP_LIBRARY_CALLOUT_ERROR')
            });
        }
    },

    /**
     * Determine if there's an active chat session in the CCP.
     * @private
     */
    _activeChatSession: function() {
        var agent = new connect.Agent();
        var currentContacts = agent.getContacts();
        return _.reduce(currentContacts, function(memo, contact) {
            return memo || contact.getType() === connect.MediaType.CHAT;
        }, false);
    },

    /**
     * Callback for successful outgoing call
     * Set the phone number on the omnichannel.
     * @private
     */
    _callSuccess: function() {
        if (app.omniConsole) {
            app.omniConsole.context.set('lastDialedRecord', this.model);
        }
    },

    /**
     * Callback for call failure. Example includes bad phone number, failure in
     * CCP dialer, etc.
     *
     * @param {Object} err - API Error
     * @private
     */
    _callFailure: function(err) {
        app.alert.show('ccp-call-error', {
            level: 'error',
            messages: app.lang.get('LBL_CCP_DIALING_ERROR')
        });
        app.logger.error(err);
    },

    /**
     * Convert phone number to link
     * @private
     */
    _enableCCP: function() {
        this.ccpEnabled = true;
        this.render();
    },

    /**
     * Convert phone number to text
     * @private
     */
    _disableCCP: function() {
        this.ccpEnabled = false;
        this.render();
    },

    /**
     * Remove event listeners on dispose
     * @private
     */
    _dispose: function() {
        this._super('_dispose');
        app.events.off('ccp:initiated', null, this);
        app.events.off('ccp:terminated', null, this);
    },

}) },
"fullname": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FullnameField
 * @alias SUGAR.App.view.fields.BaseFullnameField
 * @extends View.Fields.Base.FieldsetField
 */
({
	// Fullname Field (base) 

    extendsFrom: 'FieldsetField',

    plugins: ['FocusDrawer'],

    /**
     * Mapping name field name to format initial
     *
     * @property {Object}
     */
    formatMap: {
        'f': 'first_name',
        'l': 'last_name',
        's': 'salutation'
    },

    /**
     * @inheritdoc
     * Sort the dependant fields by the user locale format order.
     */
    initialize: function(options) {
        var formatPlaceholder = app.user.getPreference('default_locale_name_format') || '';
        this._super('initialize', [options]);
        if (!this.module) {
            app.logger.error('Fullname field requires a module');
            this.dispose();
            return;
        }

        var meta = app.metadata.getModule(this.module);
        this.formatMap = meta.formatMap || this.formatMap;

        this.def.fields = _.reduce(formatPlaceholder.split(''), function(fields, letter) {
            // only letters a-z may be significant in the format,
            // everything else is translated verbatim
            if (letter >= 'a' && letter <= 'z' && this.formatMap[letter]) {
                var fieldMeta = meta.fields[this.formatMap[letter]];
                if (fieldMeta) {
                    // clone because we'd rewrite it later and we don't want to mess with actual metadata
                    fields.push(_.clone(fieldMeta));
                }
            }
            return fields;
        }, [], this);
        this.def.fields = app.metadata._patchFields(this.module, meta, this.def.fields);

        if (this.def && this.def.link && app.acl.hasAccessToModel('view', this.model)) {
            var action = this.def.route && this.def.route.action ? this.def.route.action : '';
            //If `this.template` resolves to `base/list.hbs`, that template expects an
            //initialized `this.href`. That's normally handled by the `base.js` controller,
            //but, in this case, since `fullname.js` is controller, we must handle here.
            this.href = '#' + app.router.buildRoute(this.module || this.context,
                this.model.id, action, this.def.bwcLink);
        }
    },

    /**
     * @inheritdoc
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        var template = app.template.getField(
            this.type,
            this.view.name + '-' + this.tplName,
            this.model.module);
        //SP-1719: The view-combined template should also follow the view's custom template.
        if (!template && this.view.meta && this.view.meta.template) {
            template = app.template.getField(
                this.type,
                this.view.meta.template + '-' + this.tplName,
                this.model.module);
        }
        this.template = template || this.template;
    },

    /**
     * @inheritdoc
     * Format name parts to current user locale.
     */
    format: function() {
        return app.utils.getRecordName(this.model);
    },

    /**
     * @override
     */
    _isErasedField: function() {
        if (!this.model) {
            return false;
        }

        return app.utils.isNameErased(this.model);
    },

    /**
     * @override
     * Note that the parent bindDataChange (from FieldsetField) is an empty function
     */
    bindDataChange: function() {
        if (this.model) {
            // As detail templates don't contain Sidecar Fields,
            // we need to rerender this field in order to visualize the changes
            this.model.on("change:" + this.name, function() {
                if (this.action !== 'edit') {
                    this.render();
                }
            }, this);
            // When a child field changes, we need to update the full_name value
            _.each(this.def.fields, function(field) {
                this.model.on("change:" + field.name, this.updateValue, this);
            }, this);
        }
    },

    /**
     * Update the value of this parent field when a child changes
     */
    updateValue: function() {
        this.model.set(this.name, this.format());
    },

    /**
     * Called by record view to set max width of inner record-cell div
     * to prevent long names from overflowing the outer record-cell container
     */
    setMaxWidth: function(width) {
        this.$('.record-cell').children().css({'max-width': width});
    },

    /**
     * Return the width of padding on inner record-cell
     */
    getCellPadding: function() {
        var padding = 0,
            $cell = this.$('.record-cell');

        if (!_.isEmpty($cell)) {
            padding = parseInt($cell.css('padding-left'), 10) + parseInt($cell.css('padding-right'), 10);
        }

        return padding;
    },

    _render: function() {
        // FIXME: This will be cleaned up by SC-3478.
        if (this.view.name === 'preview') {
            this.def.link = _.isUndefined(this.def.link) ? true : this.def.link;
        }
        this._super('_render');

        // set max width if this field is in headerpane
        if (this.$el.parents('.headerpane').length > 0 && _.isFunction(this.view.adjustHeaderpaneFields)) {
            // When edit field template is used on a detail record view, that means an error occurs
            // on this field while saving; we need to update fullname field to use edit styling
            if (this.view.action === 'detail' && this.tplName === 'edit') {
                var recordCell = this.$el.closest('.record-cell');
                if (recordCell) {
                    recordCell.addClass('edit');
                }
            }
            this.view.adjustHeaderpaneFields();
        }
    },

    /**
     * Used by the FocusDrawer plugin to get the ID of the record this field
     * links to
     *
     * @return {string} the ID of the related record
     */
    getFocusContextModelId: function() {
        return this.model && this.model.get('id') ? this.model.get('id') : '';
    },

    /**
     * Used by the FocusDrawer plugin to get the name of the module this
     * field links to
     *
     * @return {string} the name of the related module
     */
    getFocusContextModule: function() {
        return this.model && this.model.get('_module') ? this.model.get('_module') : '';
    }
}) },
"button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ButtonField
 * @alias SUGAR.App.view.fields.BaseButtonField
 * @extends View.Fields.Base.BaseField
 */
({
	// Button Field (base) 

    tagName: "span",
    fieldTag: "a",

    plugins: ['MetadataEventDriven'],

    initialize: function(options) {
        var self = this;
        this.tabIndex = options.def.tabindex || 0;

        this.events = _.extend({}, {
            'click *' : 'preventClick'
        }, this.events, options.def.events);

        this._super('initialize', [options]);

        // take advantage of this hook to do the acl check
        // we use this wrapper because our spec
        // requires us to set the button.isHidden = true
        // if we don't render it.
        this.before('render', function() {
            if (self.hasAccess() && !self.isOnForbiddenLayout()) {
                this._show();
                return true;
            }
            else {
                this.hide();
                return false;
            }
        });
    },
    _render:function() {
        this.fullRoute = _.isString(this.def.route) ? this.def.route : null;
        this.ariaLabel = null;
        if (!this.label || this.label.trim() === '') {
            if (this.def.tooltip) {
                this.ariaLabel = app.lang.get(this.def.tooltip, this.module);
            } else {
                this.ariaLabel = _.isString(this.def.icon) ? this.def.icon.replace(/^fa-(.*)/, '$1').replace(/-o(-)|-o$/, ' outline$1').replace('-', ' ') : null;
            }
        }

        this.href = 'javascript:void(0);';
        if (this.fullRoute) {
            this.href = '#' + this.fullRoute;
        } else if (this.def.route) {
            var module = this.module || this.model.module ||
                ((this.context && this.context.get('module')) ? this.context.get('module') : null);
            var id = this.id || this.id;
            var action = this.def.route.action;
            this.href = app.router.buildRoute(module, id, action);
        }

        this.track = this.name ? 'click:' + this.name : 'click:' + this.label;

        app.view.Field.prototype._render.call(this);
    },

    getFieldElement: function() {
        return this.$(this.fieldTag);
    },

    /**
     * Enable or disable this button.
     * @param {boolean} [disable=true] If true, disable. If false, enable.
     * @inheritdoc
     */
    setDisabled: function(disable) {
        disable = _.isUndefined(disable) ? true : disable;
        this.def.css_class = this.def.css_class || '';
        var css_class = this.def.css_class.split(' ');
        if (disable) {
            css_class.push('disabled');
        } else {
            css_class = _.without(css_class, 'disabled');
        }
        this.tabIndex = disable ? -1 : 0;
        this.def.css_class = _.unique(_.compact(css_class)).join(' ');
        app.view.Field.prototype.setDisabled.call(this, disable);
    },

    /**
     * Prevents the `click` event from propagating further if the button is
     * in a disabled state.
     *
     * @param {Event} evt The `click` event.
     * @return {boolean} Returns `false` if the button is disabled.
     */
    preventClick: function(evt) {
        // FIXME: isDisabled should not check against `this.action`, and should
        // should eliminate the need here to check for the `disabled` class.
        // Should be fixed with SC-3418.
        if (this.isDisabled() || (!this.disposed && this.$(this.fieldTag).hasClass('disabled'))) {
            evt.preventDefault();
            evt.stopImmediatePropagation();
            return false;
        }
    },

    /**
     * Handles the jquery showing and event throwing
     * of the button. does no access checks.
     * @protected
     */
    _show: function() {
        if (this.isHidden !== false) {
            if (!this.triggerBefore("show")) {
                return false;
            }

            this.getFieldElement().removeClass("hide").show();
            this.isHidden = false;
            this.trigger('show');
        }
    },

    /**
     * Show this button if permissible, otherwise mark it as hidden.
     */
    show: function() {
        if(this.hasAccess()) {
            this._show();
        } else {
            this.isHidden = true;
        }
    },

    /**
     * Hide this button.
     *
     * @return {boolean} `false` if hiding was prevented by a before-event.
     *   `undefined` otherwise.
     */
    hide: function() {
        if (this.isHidden !== true) {
            if (!this.triggerBefore("hide")) {
                return false;
            }

            this.getFieldElement().addClass("hide").hide();
            this.isHidden = true;
            this.trigger('hide');
        }
    },

    /**
     * Track using the flag that is set on the hide and show from above.
     *
     * It should check the visibility by isHidden instead of DOM visibility testing
     * since actiondropdown renders its dropdown lazy
     *
     * @return {boolean}
     */
    isVisible: function() {
        return !this.isHidden;
    },

    /**
     * @inheritdoc
     *
     * No data changes to bind.
     */
    bindDomChange: function () {
    },
    /**
     * @inheritdoc
     *
     * No need to bind DOM changes to a model.
     */
    bindDataChange: function () {
    },
    /**
     * Determine if ACLs or other properties (for example, "allow_bwc") allow for the button to show
     * @return {Boolean} true if allow access, false otherwise
     */
    hasAccess: function() {
        // buttons use the acl_action and acl_module properties in metadata to denote their action for acls
        var acl_module = this.def.acl_module,
            acl_action = this.def.acl_action;

        // Need to test BWC status
        if (_.isBoolean(this.def.allow_bwc) && !this.def.allow_bwc) {
            app.logger.warn('The "allow_bwc" property has been deprecated since 7.9, and will be removed in 7.10.');

            var isBwc = app.metadata.getModule(acl_module || this.module).isBwcEnabled;
            if (isBwc) {
                // Action not allowed for BWC module
                return false;
            }
        }

        // Finally check ACLs
        if (!acl_module) {
            return app.acl.hasAccessToModel(acl_action, this.model, this);
        } else {
            return app.acl.hasAccess(acl_action, acl_module);
        }
    },

    /**
     * Check if this button is on a layout.
     *
     * @param {Object} layout the layout def
     * @return {boolean} `true` if this button is on the layout. `false` otherwise.
     * @private
     */
    _isOnLayout: function(layout) {
        var comp = this.closestComponent(layout.name);
        return comp && (layout.name !== 'dashboard' ||
             // for dashboard, either dashboard id or type should match
             // dashboard id is used by service console. type is used by new consoles
             (!_.isUndefined(layout.id) && comp.model.get('id') === layout.id) ||
             (!_.isUndefined(layout.type) && comp.model.get('metadata').type === layout.type));
    },

    /**
     * Check if this button is on a forbidden layout.
     *
     * @return {boolean} `true` if this button is on a forbidden layout, or if
     *  it is a descendant of a forbidden layout. `false` otherwise.
     */
    isOnForbiddenLayout: function() {
        if (!this.def || (!this.def.disallowed_layouts && !this.def.allowed_layouts)) {
            return false;
        }

        if (this.def.disallowed_layouts) {
            // ban this button if it has any ancestor component in the list of disallowed layouts
            if (_.any(this.def.disallowed_layouts, function(layout) {
                return this._isOnLayout(layout);
            }, this)
            ) {
                return true;
            }
        }

        if (this.def.allowed_layouts) {
            // don't ban this button if it has any ancestor component in the list of allowed layouts
            if (_.any(this.def.allowed_layouts, function(layout) {
                return this._isOnLayout(layout);
            }, this)
            ) {
                return false;
            }
            // ban this button if it doesn't have any ancestor component in the list of allowed layouts
            return true;
        }

        if (this.view && this.view.name === 'dashlet-toolbar' && app.config.platform === 'portal') {
            // hide all dashlet toolbar buttons in portal
            return true;
        }

        return false;
    },

    /**
     * Function to be overridden by any button in an action dropdown field that needs to be filtered out
     * @return {boolean} default return true for all views except on a dashlet where filtering is necessry
     */
    isAllowedDropdownButton: function() {
        // If we are in a dashlet context we need to filter things by default using these rules.
        if (this.view.name === 'dashlet-toolbar') {
            return _.contains(['edit_button'], this.name) || _.contains(['divider', 'actionbutton'], this.type);
        }
        // Return true for record view, where we do not filter anything out
        return true;
    }
}) },
"timeperiod": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.SelectionField
 * @alias SUGAR.App.view.fields.BaseTimeperiodField
 * @extends View.Fields.Base.EnumField
 */
({
	// Timeperiod Field (base) 

    /**
     * Who we should extend
     */
    extendsFrom: 'EnumField',

    /**
     * The template for the tooltip
     */
    tooltipTemplate: '',

    /**
     * Mapping of ID's with the start ane end dates formatted for use when the tooltip is displayed
     */
    tpTooltipMap: {},

    /**
     * The selector we use to find the dropdown since it's appended to the body and not the current element
     */
    cssClassSelector: '',

    /**
     * Flag to use if Select2 tries to format the tooltips before timeperiod data returns from the server
     */
    updateDefaultTooltip: false,

    /**
     * Tooltip placement direction for the template
     */
    tooltipDir: 'right',

    /**
     * Tooltip key for determining which language string to use
     */
    tooltipKey: 'LBL_DROPDOWN_TOOLTIP',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var tooltipCssClasses = '',
            ttTemplate;

        if (app.lang.direction === 'rtl') {
            this.tooltipDir = 'left';
            tooltipCssClasses = 'force-ltr';
            this.tooltipKey += '_RTL';
        }

        ttTemplate = app.template.getField('timeperiod', 'tooltip-default');
        Handlebars.registerPartial('tooltipHtmlTemplate', ttTemplate({
            cssClasses: tooltipCssClasses
        }));

        var collectionParams = {
            limit: 100,
            params: {}
        };

        this._super('initialize', [options]);

        if (this.def.use_generic_timeperiods) {
            collectionParams.params.use_generic_timeperiods = true;
        }

        /**
         * Collection for fetching all the Timeperiods.
         *
         * @property {Data.BeanCollection}
         */
        this.tpCollection = app.data.createBeanCollection('TimePeriods');
        this.tpCollection.once('reset', this.formatTooltips, this);
        this.tpCollection.on('sync', this.render, this);
        this.tpCollection.fetch(collectionParams);

        // load the tooltip template
        this.tooltipTemplate = app.template.getField('timeperiod', 'tooltip', this.module);

        // if forecast is not setup, then we need to use the generic options
        var config = app.metadata.getModule('Forecasts', 'config');
        if (!config || config.is_setup === 0) {
            this.def.options = 'generic_timeperiod_options';
        }
    },

    /**
     * Utility method to take the TimePeriod collection and parse our the start and end dates to be in the user
     * date preference and store them for when the enum is actually opened
     * @param {Backbone.Collection} data
     */
    formatTooltips: function(data) {
        var usersDatePrefs = app.user.getPreference('datepref');
        data.each(function(model) {
          this.tpTooltipMap[model.id] = {
              start: app.date.format(app.date.parse(model.get('start_date')), usersDatePrefs),
              end: app.date.format(app.date.parse(model.get('end_date')), usersDatePrefs)
          };
        }, this);
        // since we don't need it any more, destroy it
        this._destroyTpCollection();

        if (this.updateDefaultTooltip) {
            this.updateDefaultTooltip = false;
            // manually update the default selected item's tooltip
            var tooltipText = app.lang.get('LBL_DROPDOWN_TOOLTIP', 'TimePeriods', this.tpTooltipMap[this.value[0]]);
            this.$('[rel="tooltip"]').attr('data-original-title', tooltipText);
        }
    },

    /**
     * Since this is specific to fetching the timeperiods and it's a dynamic endpoint
     * override the module for when it has to load the enum options
     *
     * @override
     * @return {string}
     */
    getLoadEnumOptionsModule: function() {
        return 'Forecasts';
    },

    /**
     * @inheritdoc
     */
    getSelect2Options: function(optionsKeys) {
        var options = this._super('getSelect2Options', [optionsKeys]);

        // this is to format the results
        options.formatResult = _.bind(this.formatOption, this);

        // this is to format the currently selected option
        options.formatSelection = _.bind(this.formatOption, this);

        if (_.isEmpty(options.dropdownCssClass)) {
            options.dropdownCssClass = 'select2-timeperiod-dropdown-' + this.cid;
        }

        this.cssClassSelector = options.dropdownCssClass;

        return options;
    },

    /**
     * Format Option for the results and the selected option to bind the tool tip data into the html
     * that gets output
     *
     * @param {Object} object
     * @return {string}
     */
    formatOption: function(object) {
        // check once if the tpTooltipMap has been built yet
        this.updateDefaultTooltip = _.isUndefined(this.tpTooltipMap[object.id]);
        return this.tooltipTemplate({
            tooltip: this.tpTooltipMap[object.id],
            value: object.text,
            tooltipDir: this.tooltipDir,
            tooltipKey: this.tooltipKey
        });
    },

    /**
     * Disposes the {@link #tpCollection} properly.
     *
     * @private
     */
    _destroyTpCollection: function() {
        if (this.tpCollection) {
            this.tpCollection.off(null, null, this);
            this.tpCollection = null;
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this._destroyTpCollection();
        this._super('_dispose');
    }
}) },
"int": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.IntField
 * @alias SUGAR.App.view.fields.BaseIntField
 * @extends View.Fields.Base.BaseField
 */
({
	// Int Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * Older IE doesn't support Number.MIN_SAFE_INTEGER
     * @private
     */
    _minInt: Number.MIN_SAFE_INTEGER || -9007199254740991,

    /**
     * Older IE doesn't support Number.MAX_SAFE_INTEGER
     * @private
     */
    _maxInt: Number.MAX_SAFE_INTEGER || 9007199254740991,

    /**
     * @inheritdoc
     *
     * Add custom min/max value validation.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        app.error.errorName2Keys.integer = 'ERROR_INT';

        this.model.addValidationTask(
            'min_max_int_validator_' + this.cid,
            _.bind(this._doValidateMinMaxInt, this)
        );
        this.model.addValidationTask(
            'is_pure_integer_validator_' + this.cid,
            _.bind(this._doValidateIntNumber, this)
        );
    },

    /**
     * @inheritdoc
     *
     * Unformats the integer based on userPreferences (grouping separator).
     * If we weren't able to parse the value, `undefined` is returned.
     *
     * @param {String} value the formatted value based on user preferences.
     * @return {Number|undefined} the unformatted value.
     */
    unformat: function(value) {
        value = app.utils.unformatNumberStringLocale(value, false);
        if (!this._isSafeInt(value)) {
            return value;
        }
        return parseFloat(value);
    },

    /**
     * @inheritdoc
     *
     * Formats the integer based on user preferences (grouping separator).
     * If the field definition has `disabled_num_format` as `true` the value
     * won't be formatted. Also, if the value isn't a finite integer it will
     * return `undefined`.
     *
     * @param {Number} value the integer value to format as per user
     *   preferences.
     * @return {String|undefined} the formatted value based as per user
     *   preferences.
     */
    format: function(value) {
        var numberGroupSeparator = '';
        var decimalSeparator = '';
        if (!this._isSafeInt(value)) {
            return value;
        }
        if (!this.def.disable_num_format) {
            numberGroupSeparator = app.user.getPreference('number_grouping_separator') || ',';
            decimalSeparator = app.user.getPreference('decimal_separator') || '.';
        }

        return app.utils.formatNumber(
            value, 0, 0,
            numberGroupSeparator,
            decimalSeparator,
            true
        );
    },

    /**
     * This validates int doesn't exceed min/max value defined in sugar config.
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateMinMaxInt: function(fields, errors, callback) {
        var value = this.model.get(this.name);
        var minValue = this._minInt;
        var maxValue = this._maxInt;
        if (!_.isUndefined(app.config.sugarMinInt)) {
            minValue = Math.max(minValue, app.config.sugarMinInt);
        }
        if (!_.isUndefined(app.config.sugarMaxInt)) {
            maxValue = Math.min(maxValue, app.config.sugarMaxInt);
        }
        if (value < minValue) {
            errors[this.name] = {'minValue': minValue};
        } else if (value > maxValue) {
            errors[this.name] = {'maxValue': maxValue};
        }
        callback(null, fields, errors);
    },

    /**
     * This validates int number.
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * */
    _doValidateIntNumber: function(fields, errors, callback) {
        if (this.model) {
            var value = this.model.get(this.name);
        }

        if (!this._isInteger(value)) {
            errors[this.name] = {'integer': true};
        }
        callback(null, fields, errors);
    },

    /**
     * Checks if value is pure integer.
     * @param {string|number} value
     * @return {boolean}
     * */
    _isInteger: function(value) {
        return !value || parseInt(value) === parseFloat(value);
    },

    /**
     * Checks if value is too big to format/unformat.
     *
     * @param {string|number} value
     * @return {boolean}
     * @private
     */
    _isSafeInt: function(value) {
        return (_.isFinite(value) && this._minInt <= value && value <= this._maxInt);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('min_max_int_validator_' + this.cid);
        this._super('_dispose');
    },
}) },
"relate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Relate field provides a link to a module that is set in the definition of
 * this field metadata.
 *
 * This field requires at least the follow definitions to be exist in the
 * field:
 *
 * ```
 * array(
 *     'name' => 'account_name',
 *     'rname' => 'name',
 *     'id_name' => 'account_id',
 *     'module' => 'Accounts',
 *     'link' => true,
 *     //...
 * ),
 * ```
 *
 * The field also support a `populate_list` to update other fields in the
 * current model from other fields of the selected model.
 *
 * ```
 * array(
 *     //...
 *     'populate_list' => array(
 *         'populate_list' => array(
 *         'billing_address_street' => 'primary_address_street',
 *         'billing_address_city' => 'primary_address_city',
 *         'billing_address_state' => 'primary_address_state',
 *         'billing_address_postalcode' => 'primary_address_postalcode',
 *         'billing_address_country' => 'primary_address_country',
 *         'phone_office' => 'phone_work',
 *         //...
 *
 *     ),
 * )
 * ```
 *
 * This field allows you to configure the minimum chars that trigger a search
 * when using the typeahead feature.
 *
 * ```
 * array(
 *     //...
 *     'minChars' => 3,
 * )
 * ```
 *
 * TODO: we have a mix of properties here with camelCase and underscore.
 * Needs to be addressed.
 *
 * @class View.Fields.Base.RelateField
 * @alias SUGAR.App.view.fields.BaseRelateField
 * @extends View.Fields.Base.BaseField
 */
({
	// Relate Field (base) 

    plugins: ['FocusDrawer'],

    fieldTag: 'input.select2',

    /**
     * Initializes field and binds all function calls to this
     * @param {Object} options
     */
    initialize: function(options) {
        /**
         * Boolean used for the 'allowClear' select2 option.
         *
         * @property {boolean}
         * @protected
         */
        this._allow_single_deselect = true;
        /**
         * Minimum input characters to trigger the search. Used for
         * `minimumInputLength` select2 option.
         *
         * @property {number}
         * @protected
         */
        this._minChars = options.def.minChars || 1;
        /**
         * Separator used by select2 to separate values. Used for `separator`
         * select2 option.
         *
         * @property {string}
         * @protected
         */
        this._separator = '|';
        /**
         * Maximum number of records the user can select.
         *
         * @property {number}
         * @protected
         */
        this._maxSelectedRecords = 20;

        if (_.property('link')(options.def) && !_.isBoolean(options.def.link)) {
            app.logger.warn('The `link` property passed in the viewDefs must be a boolean. Hence, `link`' +
                ' will be set to `true` by default.');
        }

        this._super('initialize', [options]);

        // A relate field displays a link by default.
        this.viewDefs = _.defaults(this.viewDefs || {}, {link: true});
        /**
         * The template used for a pill in case of multiselect field.
         *
         * @property {Function}
         * @private
         */
        this._select2formatSelectionTemplate = app.template.getField('relate', 'pill', this.module);

        var populateMetadata = this._getPopulateMetadata();

        if (_.isEmpty(populateMetadata)) {
            return;
        }
        _.each(this.def.populate_list, function(target, source) {
            if (_.isUndefined(populateMetadata.fields[source])) {
                app.logger.error('Fail to populate the related attributes: attempt to access undefined key - ' +
                    this.getSearchModule() + '::' + source);
            }
        }, this);

        this._createSearchCollection();
    },

    /**
     * Gets the proper module's metadata to use during auto populating fields
     *
     * @return {*|Object}
     * @protected
     */
    _getPopulateMetadata: function() {
        return app.metadata.getModule(this.getSearchModule());
    },

    /**
     * Creates a Filters BeanCollection to easily apply filters.
     * The user must have `list` access to the search module to create a
     * {@link Data.Base.FiltersBeanCollection}.
     *
     * @protected
     */
    _createFiltersCollection: function(options) {
        var searchModule = this.getSearchModule();

        if (!app.acl.hasAccess('list', searchModule)) {
            app.logger.debug('No "list" access to ' + searchModule + ' so skipping the creation of filter.');
            return;
        }

        if (app.metadata.getModule('Filters') && searchModule) {
            this.filters = app.data.createBeanCollection('Filters');
            this.filters.setModuleName(searchModule);
            this.filters.setFilterOptions(this.getFilterOptions());
            this.filters.load(options);
        }
    },
    /**
     * Creates a {@link Data.BeanCollection} for the search results pertaining
     * to the search module.
     *
     * @protected
     */
    _createSearchCollection: function() {
        var searchModule = this.getSearchModule();
        if (searchModule && app.metadata.getModule(searchModule)) {
            this.searchCollection = app.data.createBeanCollection(searchModule);
        } else {
            this.searchCollection = null;
        }
    },

    /**
     * Bind the additional keydown handler on select2
     * search element (affected by version 3.4.3).
     *
     * Invoked from {@link app.plugins.Editable}.
     * @param {Function} callback Callback function for keydown.
     */
    bindKeyDown: function(callback) {
        var $dropdown = this.$(this.fieldTag);
        $dropdown.on('keydown.record', {field: this}, callback);
        var plugin = $dropdown.data('select2');
        if (plugin) {
            plugin.focusser.on('keydown.record', {field: this}, callback);
            plugin.search.on('keydown.record', {field: this}, callback);
        }
    },

    /**
     * Unbind the additional keydown handler.
     *
     * Invoked from {@link app.plugins.Editable}.
     * @param {Function} callback Callback function for keydown.
     */
    unbindKeyDown: function(callback) {
        var $dropdown = this.$(this.fieldTag);
        $dropdown.off('keydown.record', callback);
        var plugin = $dropdown.data('select2');
        if (plugin) {
            plugin.search.off('keydown.record', callback);
        }
    },

    focus: function() {
        if (this.action !== 'disabled') {
            //Need to defer to ensure that all the related elements have finished
            //rendering before attempting to open the dropdown.
            _.defer(_.bind(function() {
                this.$(this.fieldTag).first().select2('open');
            }, this));
        }
    },

    /**
     * //FIXME: We shouldn't have this method. SC-4121 will address this.
     * Creates the css classes to set to the select2 plugin.
     *
     * @return {string}
     * @private
     */
    _buildCssClasses: function() {
        var cssClasses = [];
        if (this.view.name === 'recordlist') {
            cssClasses.push('select2-narrow');
        }
        if (this.type === 'parent') {
            cssClasses.push('select2-parent');
        }
        if (this.def.isMultiSelect) {
            cssClasses.push('select2-choices-pills-close same-size-pills');
        }
        return cssClasses.join(' ');
    },

    /**
     * Renders relate field
     */
    _render: function() {
        var searchModule = this.getSearchModule();
        this._updateErasedPlaceholder();

        this._super('_render');

        if (this.customDropdownRender) {
            this.customDropdownRender();
        } else {
            //FIXME remove check for tplName SC-2608
            switch (this.tplName) {
                case 'edit':
                case 'massupdate':
                    // `searchModule` can be undefined for a parent field when there
                    // is no value set (ie in create mode). In that case, we don't
                    // want to render the dropdown disabled.
                    if (!_.isUndefined(searchModule)) {
                        if (!app.acl.hasAccess('list', searchModule) ||
                            !_.contains(app.metadata.getModuleNames(), searchModule)) {
                            this._renderDisabledDropdown();
                            break;
                        }
                    }
                    if (_.isUndefined(this.filters) ||
                        (!_.isEmpty(this.filters.moduleName) && this.filters.moduleName !== searchModule)
                    ) {
                        this._createFiltersCollection({
                            success: _.bind(function() {
                                if (!this.disposed) {
                                    this._renderEditableDropdown();
                                }
                            }, this)
                        });
                    } else {
                        this._renderEditableDropdown();
                    }
                    break;
                case 'disabled':
                    this._renderDisabledDropdown();
                    break;
            }
        }
        return this;
    },

    /**
     * Renders the editable dropdown using the `select2` plugin.
     *
     * Since a filter may have to be applied on the field, we need to fetch
     * the list of filters for the current module before rendering the dropdown
     * (and enabling the searchahead feature that requires the filter
     * definition).
     *
     * @private
     */
    _renderEditableDropdown: function() {
        var self = this;
        var $dropdown = this.$(this.fieldTag);

        if ($dropdown.data('select2')) {
            return;
        }
        $dropdown.select2(this._getSelect2Options())
            .on('select2-open', _.bind(this._onSelect2Open, this))
            .off('searchmore')
            .on('searchmore', function() {
                $(this).select2('close');
                self.openSelectDrawer();
            })
            .on('change', _.bind(this._onSelect2Change, this));

        var plugin = $dropdown.data('select2');
        if (plugin && plugin.focusser) {
            plugin.focusser.on('select2-focus', _.bind(_.debounce(this.handleFocus, 0), this));
        }
    },

    /**
     * Renders the dropdown in disabled mode.
     *
     * @private
     */
    _renderDisabledDropdown: function() {
        var loadingLabel = app.lang.get('LBL_LOADING', this.module);
        var $dropdown = this.$(this.fieldTag);

        $dropdown.select2({
            width: '100%',
            initSelection: function(el, callback) {
                var $el = $(el),
                    id = $el.val(),
                    text = $el.data('rname');
                callback({id: id, text: text});
            },
            formatInputTooShort: function() {
                return '';
            },
            formatSearching: function() {
                return loadingLabel;
            },
            placeholder: this.getPlaceHolder(),
            allowClear: this._allow_single_deselect,
            minimumInputLength: this._minChars,
            query: _.bind(this.search, this)
        });
        $dropdown.select2('disable');
    },

    /**
     * Handler for when the select2 dropdown change event
     *
     * @param e
     * @private
     */
    _onSelect2Change: function(e) {
        var $el = $(e.target);
        var plugin = $el.data('select2');
        var id = e.val;

        if (_.isUndefined(id)) {
            return;
        }

        // For multiselect fields, we update the data-rname attributes
        // so it stays in sync with the id list, and allows us to use
        // 'setValue' method. The use of 'setValue' method is required
        // to re-render the field.
        if (this.def.isMultiSelect) {
            var dataRname = plugin.opts.element.data('rname');
            dataRname = dataRname ? dataRname.split(this._separator) : [];
            var ids = $el.select2('val');

            if (e.added) {
                dataRname.push(e.added.text);
            } else if (e.removed) {
                dataRname = _.without(dataRname, e.removed.text);
            } else {
                return;
            }
            var models = _.map(ids, function(id, index) {
                return {id: id, value: dataRname[index]};
            });

            this.setValue(models);
            return;
        }

        var value = (id) ? plugin.selection.find('span').text() : $el.data('rname');
        var collection = plugin.context;
        var attributes = {};
        if (collection && !_.isEmpty(id)) {
            // if we have search results use that to set new values
            var model = collection.get(id);
            attributes.id = model.id;
            attributes.value = model.get(this.getRelatedModuleField());
            _.each(model.attributes, function(value, field) {
                if (app.acl.hasAccessToModel('view', model, field)) {
                    attributes[field] = attributes[field] || model.get(field);
                }
            });
        } else if (e.currentTarget.value && value) {
            // if we have previous values keep them
            attributes.id = value;
            attributes.value = e.currentTarget.value;
        } else {
            // default to empty
            attributes.id = '';
            attributes.value = '';
        }

        this.setValue(attributes);
    },

    /**
     * Entry point for child classes to hook in and add/update to the base select2 options
     *
     * @return {{}}
     * @protected
     */
    _getSelect2Options: function() {
        return _.extend({}, {
            width: this.view.name === 'recordlist' ? 'off' : '100%',
            dropdownCssClass: _.bind(this._buildCssClasses, this),
            multiple: !!this.def.isMultiSelect,
            containerCssClass: _.bind(this._buildCssClasses, this),
            separator: this._separator,
            initSelection: _.bind(this._onInitSelect, this),
            formatInputTooShort: function() {
                return '';
            },
            formatSelection: _.bind(this._onFormatSelection, this),
            formatSearching: app.lang.get('LBL_LOADING', this.module),
            placeholder: this.getPlaceHolder(),
            allowClear: this._allow_single_deselect,
            minimumInputLength: this._minChars,
            maximumSelectionSize: 20,
            query: _.bind(this.search, this)
        });
    },

    /**
     * Callback for select2 `initSelection` property.
     *
     * @param {HTMLElement} el The select2 element that stores values.
     * @param {Function} callback select2 callback to initialize the plugin.
     * @private
     */
    _onInitSelect: function(el, callback) {
        var $el = $(el),
            id = $el.val(),
            text = $el.data('rname');

        if (!this.def.isMultiSelect) {
            return callback({id: id, text: text});
        }
        var ids = id.split(this._separator);
        text = text.split(this._separator);
        callback(_.map(ids, function(value, index) {
            return {id: value, text: text[index]};
        }));
    },

    /**
     * Callback for select2 `formatSelection` property.
     *
     * @param {Object} obj object containing the item name.
     * @return {string} A string containing template for a pill.
     *
     * @private
     */
    _onFormatSelection: function(obj) {
        var ctx = {};
        //TODO We should investigate why it's sometimes `text` and
        //sometimes `id` and make it always same if possible.
        ctx.text = obj.text || obj.id;
        return this._select2formatSelectionTemplate(ctx);
    },

    /**
     * Callback when select2 plugin opens.
     * @private
     * @param {Event} e The `click` event.
     */
    _onSelect2Open: function(e) {
        var plugin = this.$(e.currentTarget).data('select2');
        if (plugin.searchmore) {
            return;
        }
        var label = app.lang.get('LBL_SEARCH_AND_SELECT_ELLIPSIS', this.module);
        var $tpl = $('<div/>').addClass('select2-result-label').html(label);
        var onMouseDown = function() {
            plugin.opts.element.trigger($.Event('searchmore'));
            plugin.close();
        };
        var $content = $('<li class="select2-result">').append($tpl).mousedown(onMouseDown);
        plugin.searchmore = $('<ul class="select2-results">').append($content);
        plugin.dropdown.append(plugin.searchmore);
    },

    /**
     * Builds the route for the relate module's record.
     * @param {String} module The related module.
     * @param {String} id The record id to link to.
     *
     * TODO since base.js has a build href, we should try to reuse code or
     * extend this one from other "link" field
     */
    buildRoute: function(module, id) {
        if (_.isUndefined(id) || !this.viewDefs.link) {
            return;
        }

        var oldModule = module;
        // This is a workaround until bug 61478 is resolved to keep parity with 6.7
        if (module === 'Users' && this.context.get('module') !== 'Users') {
            module = 'Employees';
        }

        if (_.isEmpty(module)) {
            return;
        }

        var relatedRecord = this.model.get(this.fieldDefs.link);
        var action = this.viewDefs.route ? this.viewDefs.route.action : 'view';

        if (relatedRecord && app.acl.hasAccess(action, oldModule, {acls: relatedRecord._acl})) {
            this.href = '#' + app.router.buildRoute(module, id);
            //FIXME SC-6128 will remove this deprecated block.
        } else if (!relatedRecord) {
            this.href = this.href = '#' + app.router.buildRoute(module, id);
        } else {
            // if no access to module, remove the href
            this.href = undefined;
        }
    },

    // Derived controllers can override these if related module and id in another
    // place.
    _buildRoute: function () {
        this.buildRoute(this.getSearchModule(), this._getRelateId());
    },
    _getRelateId: function () {
        return this.model.get(this.def.id_name);
    },

    /**
     * @inheritdoc
     *
     * When there is no value set and we are in a create view, we try to check
     * if the parent context module matches this relate field. If it matches,
     * we pre-populate with that data.
     *
     * FIXME: the relate field should use this method to pre-populate the
     * values without touching the model or else we need to use silent to
     * prevent the warning of unsaved changes, consequently we can't bind
     * events like `change` to it.
     *
     * TODO: the model might not have the field that we are relating to. On
     * those corner cases, we need to fetch from the server that information.
     *
     * @return {String} This field's value. Need to change to object with all
     *   data that we need to render the field.
     */
    format: function(value) {

        var parentCtx = this.context && this.context.parent,
            setFromCtx;

        if (value) {
            /**
             * Flag to indicate that the value has been set from the context
             * once, so if later the value is unset, we don't set it again on
             * {@link #format}.
             *
             * @type {boolean}
             * @protected
             */
            this._valueSetOnce = true;
        }

        // This check sees if we should populate the field from the context.
        // Note that this is a different condition from if we should populate
        // the field from a parent model.
        //
        // Also note that readonly fields are not automatically populated from
        // the context.
        setFromCtx = value === null && !this.fieldDefs.readonly &&
            !this._valueSetOnce && parentCtx && _.isEmpty(this.context.get('model').link) &&
            this.view instanceof app.view.views.BaseCreateView &&
            parentCtx.get('module') === this.def.module &&
            this.module !== this.def.module;

        if (setFromCtx) {
            this._valueSetOnce = true;
            var model = parentCtx.get('model');
            // FIXME we need a method to prevent us from doing this
            this.def.auto_populate = true;
            // FIXME the setValue receives a model but not a backbone model...
            this.setValue(model.toJSON());
            // FIXME we need to iterate over the populated_ that is causing
            // unsaved warnings when doing the auto populate.
        }

        if (!this.def.isMultiSelect && this.action !== 'edit' && !this.context.get('create')) {
            this._buildRoute();
        }

        // If the field is on the audit log, remove the link. We need to explicitly
        // clear the href here as some fields will have an href created in the base
        // field controller.
        if (this.view.name === 'audit') {
            this.href = null;
        }

        var idList = this.model.get(this.def.id_name);
        if (_.isArray(value)) {
            this.formattedRname = value.join(this._separator);
            this.formattedIds = idList.join(this._separator);
        } else {
            this.formattedRname = value;
            this.formattedIds = idList;
        }

        return value;
    },

    /**
     * Sets the value in the field.
     *
     * @param {Object|Array} models The source models attributes.
     */
    setValue: function(models) {
        if (!models) {
            return;
        }
        var isErased = false;
        var updateRelatedFields = true,
            values = {};
        if (_.isArray(models)) {
            // Does not make sense to update related fields if we selected
            // multiple models
            updateRelatedFields = false;
        } else {
            models = [models];
        }

        values[this.def.id_name] = [];
        values[this.def.name] = [];
        if (this.fieldDefs.link) {
            values[this.fieldDefs.link] = [];
        }

        _.each(models, _.bind(function(model) {
            values[this.def.id_name].push(model.id);
            //FIXME SC-4196 will fix the fallback to `formatNameLocale` for person type models.
            values[this.def.name].push(model[this.getRelatedModuleField()] ||
                app.utils.formatNameLocale(model) || model.value);
            if (this.fieldDefs.link) {
                values[this.fieldDefs.link].push(model);
            } else {
                isErased = app.utils.isNameErased(app.data.createBean(model._module, model));
            }
        }, this));

        // If it's not a multiselect relate, we get rid of the array.
        if (!this.def.isMultiSelect) {
            values[this.def.id_name] = values[this.def.id_name][0];
            values[this.def.name] = values[this.def.name][0];
            if (this.fieldDefs.link) {
                values[this.fieldDefs.link] = values[this.fieldDefs.link][0];
            } else {
                this._nameIsErased = isErased;
            }
        }

        //In case of selecting an erased value twice, we need to force a re-render to show the erased placeolder.
        var forceUpdate = _.isEmpty(this.model.get(this.def.name)) && _.isEmpty(values[this.def.name]);

        this.model.set(values);

        if (updateRelatedFields) {
            //Force an update to the link field as well so that SugarLogic and other listeners can react
            if (this.fieldDefs.link && _.isEmpty(values[this.fieldDefs.link]) && forceUpdate) {
                this.model.trigger('change:' + this.fieldDefs.link);
            }
            this.updateRelatedFields(models[0]);
        }

        if (forceUpdate) {
            this._updateField();
        }
    },

    _updateErasedPlaceholder: function() {
        //Handle erased field placehilders
        // Show a custom placeholder if the field's content has been erased
        if (this._isErasedField()) {
            this.hasErasedPlaceholder = true;
        } else {
            this.hasErasedPlaceholder = false;
        }
    },

    /**
     * Handles update of related fields.
     *
     * @param {Object} model The source model attributes.
     */
    updateRelatedFields: function(model) {
        var newData = {},
            self = this;
        _.each(this.def.populate_list, function(target, source) {
            target = !_.isArray(target) ? [target] : target;
            _.each(target, function(targetName) {
                source = _.isNumber(source) ? targetName : source;
                if (!_.isUndefined(model[source]) && app.acl.hasAccessToModel('edit', this.model, targetName)) {
                    var before = this.model.get(targetName);
                    var after = model[source];
                    if (before !== after) {
                        newData[targetName] = model[source];
                    }
                }
            }, this);
        }, this);

        if (_.isEmpty(newData)) {
            return;
        }

        // if this.def.auto_populate is true set new data and doesn't show alert message
        if (!_.isUndefined(this.def.auto_populate) && this.def.auto_populate == true) {
            // if we have a currency_id, set it first to trigger the currency conversion before setting
            // the values to the model, this prevents double conversion from happening
            if (!_.isUndefined(newData.currency_id)) {
                this.model.set({currency_id: newData.currency_id});
                delete newData.currency_id;
            }
            this._setRelated(newData);
            return;
        }

        // load template key for confirmation message from defs or use default
        var messageTplKey = this.def.populate_confirm_label || 'TPL_OVERWRITE_POPULATED_DATA_CONFIRM',
            messageTpl = Handlebars.compile(app.lang.get(messageTplKey, this.getSearchModule())),
            fieldMessageTpl = app.template.getField(
                this.type,
                'overwrite-confirmation',
                this.model.module),
            messages = [],
            relatedModuleSingular = app.lang.getModuleName(this.def.module);

        _.each(newData, function(value, field) {
            var before = this.model.get(field),
                after = value;

            if (before !== after) {
                var def = this.model.fields[field];
                messages.push(fieldMessageTpl({
                    before: before,
                    after: after,
                    field_label: app.lang.get(def.label || def.vname || field, this.module)
                }));
            }
        }, this);

        app.alert.show('overwrite_confirmation', {
            level: 'confirmation',
            messages: messageTpl({
                values: new Handlebars.SafeString(messages.join(', ')),
                moduleSingularLower: relatedModuleSingular.toLowerCase()
            }),
            onConfirm: function() {
                // if we have a currency_id, set it first to trigger the currency conversion before setting
                // the values to the model, this prevents double conversion from happening
                if (!_.isUndefined(newData.currency_id)) {
                    self.model.set({currency_id: newData.currency_id});
                    delete newData.currency_id;
                }
                self._setRelated(newData);
            }
        });
    },

    /**
     * @override
     */
    _isErasedField: function() {
        if (!this.model) {
            return false;
        }

        var def = this.fieldDefs;
        var link = this.model.get(def.link);

        if (link) {
            var recordField = app.metadata.getField({
                module: def.module,
                name: def.rname
            });

            if (recordField && recordField.type === 'fullname') {
                return app.utils.isNameErased(app.data.createBean(def.module, link));
            } else {
                return _.contains(link._erased_fields, def.rname);
            }
        } else {
            return this._nameIsErased || this._super('_isErasedField');
        }
    },

    /**
     * Opens the selection drawer.
     *
     * Note that if the field definitions have a `filter_relate` property, it
     * will open the drawer and filter by this relate field.
     *
     *     @example a Revenue Line Item is associated to an account and to an
     *      opportunity. If I want to open a drawer to select an opportunity
     *      with an initial filter that filters opportunities by the account
     *      associated to the revenue line item, in the field definitions I can
     *      specify:
     *      ```
     *      'filter_relate' => array(
     *          'account_id' => 'account_id',
     *      ),
     *      ```
     *      The key is the field name in the Revenue Line Items record,
     *      the value is the field name in the Opportunities record.
     */
    openSelectDrawer: function() {
        var layout = 'selection-list';
        var context = {
            module: this.getSearchModule(),
            fields: this.getSearchFields(),
            filterOptions: this.getFilterOptions()
        };

        if (!!this.def.isMultiSelect) {
            layout = 'multi-selection-list';
            _.extend(context, {
                preselectedModelIds: _.clone(this.model.get(this.def.id_name)),
                maxSelectedRecords: this._maxSelectedRecords,
                isMultiSelect: true
            });
        }

        app.drawer.open({
            layout: layout,
            context: context
        }, _.bind(this.setValue, this));
    },

    /**
     * Gets the list of fields to search by in the related module.
     *
     * @return {Array} The list of fields.
     */
    getSearchFields: function() {
        return _.union(['id', this.getRelatedModuleField()], _.keys(this.def.populate_list || {}));
    },

    /**
     * Gets the related field name in the related module record.
     *
     * Falls back to `name` if not defined.
     *
     * @return {String} The field name.
     */
    getRelatedModuleField: function() {
        return this.def.rname || 'name';
    },

    /**
     * @inheritdoc
     *
     * We need this empty so it won't affect refresh the select2 plugin
     */
    bindDomChange: function () {
    },

    /**
     * Gets the correct module to search based on field/link defs.
     *
     * If both `this.def.module` and `link.module` are empty, fall back onto the
     * metadata manager to get the proper module as a last resort.
     *
     * @return {String} The module to search on.
     */
    getSearchModule: function () {
        // If we have a module property on this field, use it
        if (this.def.module) {
            return this.def.module;
        }

        // No module in the field def, so check if there is a module in the def
        // for the link field
        var link = this.fieldDefs.link && this.model.fields && this.model.fields[this.fieldDefs.link] || {};
        if (link.module) {
            return link.module;
        }

        // At this point neither the def nor link field def have a module... let
        // metadata manager try find it
        return app.data.getRelatedModule(this.model.module, this.fieldDefs.link);
    },
    getPlaceHolder: function () {
        var searchModule = this.getSearchModule(),
            searchModuleLower = searchModule.toLocaleLowerCase(),
            module = app.lang.getModuleName(searchModule, {defaultValue: searchModuleLower});

        return app.lang.get('LBL_SEARCH_SELECT_MODULE', this.module, {
            module: new Handlebars.SafeString(module)
        });
    },

    /**
     * Gets the default relate filter metadata for the module, if one exists
     * @return {null|Object}
     * @private
     */
    _getModuleDefaultFilterMetadata: function() {
        let moduleMetadata = app.metadata.getModule(this.getSearchModule());
        if (_.isEmpty(moduleMetadata) ||
            _.isEmpty(moduleMetadata.defaultRelateFilter) ||
            this.def.default_relate_filter === false
        ) {
            return null;
        }
        return moduleMetadata.defaultRelateFilter;
    },

    /**
     * Gets the default relate filter for the module, if one exists
     * @return {null|Object}
     * @private
     */
    _getModuleDefaultFilter: function() {
        if (!app.metadata.getModule('Filters') || !this.filters || !this.filters.collection) {
            return null;
        }

        let filterMetadata = this._getModuleDefaultFilterMetadata();
        if (_.isEmpty(filterMetadata)) {
            return null;
        }

        let filterBeanClass = app.data.getBeanClass('Filters').prototype;
        let filterOptions = new app.utils.FilterOptions().config(filterMetadata).format();
        let filter = this.filters.collection.get(filterOptions.initial_filter);
        let filterDef = null;

        if (filter) {
            let populate = filter.get('is_template') && filterOptions.filter_populate;
            filterDef = filterBeanClass.populateFilterDefinition(filter.get('filter_definition') || {}, populate);
        }

        return filterDef;
    },

    /**
     * Formats the filter options.
     *
     * @param {Boolean} force `true` to force retrieving the filter options
     *   whether or not it is available in memory.
     * @return {Object} The filter options.
     */
    getFilterOptions: function(force) {
        if (this._filterOptions && !force) {
            return this._filterOptions;
        }

        // If the related module has a default filter, apply that only if there is no field-specific default filter
        let moduleDefaultFilter = this._getModuleDefaultFilterMetadata();
        if (!_.isEmpty(moduleDefaultFilter) && _.isEmpty(this.def.initial_filter)) {
            this._filterOptions = new app.utils.FilterOptions().config(moduleDefaultFilter).format();
        } else {
            this._filterOptions = new app.utils.FilterOptions()
                .config(this.def)
                .setInitialFilter(this.def.initial_filter || '$relate')
                .populateRelate(this.model)
                .format();
        }

        return this._filterOptions;
    },

    /**
     * Builds the filter definition to pass to the request when doing a quick
     * search.
     *
     * It will combine the filter definition for the search term with the
     * initial filter definition. Both are optional, so this method may return
     * an empty filter definition (empty `array`).
     *
     * @param {String} searchTerm The term typed in the quick search field.
     * @return {Array} The filter definition.
     */
    buildFilterDefinition: function(searchTerm) {
        if (!app.metadata.getModule('Filters') || !this.filters) {
            return [];
        }
        var filterBeanClass = app.data.getBeanClass('Filters').prototype,
            filterOptions = this.getFilterOptions() || {},
            filter = this.filters.collection.get(filterOptions.initial_filter),
            filterDef,
            populate,
            searchTermFilter,
            searchModule;

        if (filter) {
            populate = filter.get('is_template') && filterOptions.filter_populate;
            filterDef = filterBeanClass.populateFilterDefinition(filter.get('filter_definition') || {}, populate);
            searchModule = filter.moduleName;
        }

        searchTermFilter = filterBeanClass.buildSearchTermFilter(searchModule || this.getSearchModule(), searchTerm);

        // If the related module has a default filter, apply that as well
        let moduleDefaultFilter = this._getModuleDefaultFilter();
        if (!_.isEmpty(moduleDefaultFilter)) {
            searchTermFilter = filterBeanClass.combineFilterDefinitions(moduleDefaultFilter, searchTermFilter);
        }

        return filterBeanClass.combineFilterDefinitions(filterDef, searchTermFilter);
    },

    /**
     * Searches for related field.
     * @param event
     */
    search: _.debounce(function(query) {
        var term = query.term || '',
            self = this,
            searchModule = this.getSearchModule(),
            params = {},
            limit = self.def.limit || 5,
            relatedModuleField = this.getRelatedModuleField();

        if (query.context) {
            params.offset = this.searchCollection.next_offset;
        }
        params.filter = this.buildFilterDefinition(term);

        this.searchCollection.fetch({
            //Don't show alerts for this request
            showAlerts: false,
            update: true,
            remove: _.isUndefined(params.offset),
            reset: _.isUndefined(params.offset),
            fields: this.getSearchFields(),
            context: self,
            params: params,
            limit: limit,
            success: function(data) {
                var fetch = {results: [], more: data.next_offset > 0, context: data};
                if (fetch.more) {
                    var fieldEl = self.$(self.fieldTag),
                        //For teamset widget, we should specify which index element to be filled in
                        plugin = (fieldEl.length > 1) ? $(fieldEl.get(self._currentIndex)).data("select2") : fieldEl.data("select2"),
                        height = plugin.searchmore.children("li:first").children(":first").outerHeight(),
                        //0.2 makes scroll not to touch the bottom line which avoid fetching next record set
                        maxHeight = height * (limit - .2);
                    plugin.results.css("max-height", maxHeight);
                }
                _.each(data.models, function (model, index) {
                    if (params.offset && index < params.offset) {
                        return;
                    }
                    fetch.results.push({
                        id: model.id,
                        text: model.get(relatedModuleField) + ''
                    });
                });
                if (query.callback && _.isFunction(query.callback)) {
                    query.callback(fetch);
                }
            },
            error: function() {
                if (query.callback && _.isFunction(query.callback)) {
                    query.callback({results: []});
                }
                app.logger.error("Unable to fetch the bean collection.");
            }
        });
    }, app.config.requiredElapsed || 500),

    /**
     * @inheritdoc
     * Avoid rendering process on select2 change in order to keep focus.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change', function() {
                this.getFilterOptions(true);
            }, this);

            this.model.on('change:' + this.name, this._updateField, this);
        }
    },

    _updateField: function() {
        if (this.disposed) {
            return;
        }
        var $dropdown = this.$(this.fieldTag);
        if (!_.isEmpty($dropdown.data('select2'))) {
            var value = this.model.get(this.def.name);
            value = _.isArray(value) ? value.join(this._separator) : value;
            value = value ? value.trim() : value;
            if (this._isErasedField()) {
                value = app.lang.getAppString('LBL_VALUE_ERASED');
            }

            $dropdown.data('rname', value);

            // `id` can be an array of ids if the field is a multiselect.
            var id = this.model.get(this.def.id_name);
            if (_.isEqual($dropdown.select2('val'), id)) {
                return;
            }

            $dropdown.select2('val', id);
        } else {
            this.render();
        }
    },


    unbindDom: function() {
        this.$(this.fieldTag).select2('destroy');
        app.view.Field.prototype.unbindDom.call(this);
    },

    /**
     * Set new values, first checking for any parent/child dependencies, setting
     * parent values first.
     *
     * @param {Object} attrs new values to set on model
     * @private
     */
    _setRelated: function(attrs) {
        var dependentAttrs = this._getDependentAttributes(attrs);
        attrs = _.omit(attrs, _.keys(dependentAttrs));

        this.model.set(attrs);
        if (!_.isEmpty(dependentAttrs)) {
            this._setRelated(dependentAttrs);
        }
    },

    /**
     * Gets attributes that depend on other attributes also being set.
     *
     * If a field has a visibility grid, it is a dropdown whose contents  depend
     * on another dropdown. If its parent is also in the attrs about to be set,
     * we need to ensure children are set after their parents.
     *
     * @param {Object} attrs Bean attributes
     * @return {Object} Attributes with dependencies
     * @private
     */
    _getDependentAttributes: function(attrs) {
        var fields = this.model.fields || {};
        var dependentAttrs = {};
        _.each(attrs, function(val, key) {
            var field = fields[key];
            if (field &&
                field.visibility_grid &&
                field.visibility_grid.trigger in attrs) {
                dependentAttrs[key] = val;
            }
        }, this);

        return dependentAttrs;
    },

    /**
     * Used by the FocusDrawer plugin to get the ID of the record this
     * field links to
     *
     * @return {string} the ID of the related record
     */
    getFocusContextModelId: function() {
        return this._getRelateId();
    },

    /**
     * Used by the FocusDrawer plugin to get the name of the module this
     * field links to
     *
     * @return {string} the name of the related module
     */
    getFocusContextModule: function() {
        return this.getSearchModule();
    }
}) },
"datetimecombo": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.DatetimecomboField
 * @alias SUGAR.App.view.fields.BaseDatetimecomboField
 * @extends View.Fields.Base.DateField
 */
({
	// Datetimecombo Field (base) 

    extendsFrom: 'DateField',

    /**
     * HTML tag of the secondary field.
     *
     * @property {String}
     */
    secondaryFieldTag: 'input[data-type=time]',

    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * If a time picker has been initialized on the field or not.
         *
         * @type {boolean}
         * @private
         */
        this._hasTimePicker = false;
    },

    /**
     * @inheritdoc
     *
     * Add `show-timepicker` on click listener.
     */
    _initEvents: function() {
        this._super('_initEvents');

        _.extend(this.events, {
            'click [data-action="show-timepicker"]': 'showTimePicker'
        });

        return this;
    },

    /**
     * @override
     */
    _initDefaultValue: function() {
        if (!this.model.isNew() || this.model.get(this.name) || !this.def.display_default) {
            return this;
        }

        var value = app.date.parseDisplayDefault(this.def.display_default);
        if (!value) {
            return this;
        }

        value = this.unformat(
            app.date(value).format(
                app.date.convertFormat(this.getUserDateTimeFormat())
            )
        );

        this.model.setDefault(this.name, value);

        return this;
    },

    /**
     * @inheritdoc
     */
    _initPlaceholderAttribute: function() {
        this._super('_initPlaceholderAttribute');

        var placeholder = this.getTimePlaceHolder(this.getUserTimeFormat());

        this.secondaryFieldPlaceholder = this.def.placeholder && app.lang.get(
            this.def.placeholder,
            this.module,
            {format: placeholder}
        ) || placeholder;

        return this;
    },

    /**
     * @inheritdoc
     *
     * Note, this is only for the datepicker, not the timepicker.
     */
    _getAppendToTarget: function() {
        var $currentComponent = this.$el;

        // this algorithm does not work on list view
        if (this.view && (this.view.type === 'recordlist' || this.view.type === 'subpanel-list')) {
            return this._super('_getAppendToTarget');
        }

        // First, attempt to attach to a parent element with an appropriate data-type attribute.
        // bootstrap-datepicker requires that the append-to target be relatively positioned:
        // https://stackoverflow.com/questions/27966645/bootstrap-datepicker-appearing-at-incorrect-location-in-a-modal
        while ($currentComponent.length > 0) {
            var dataType = $currentComponent && $currentComponent.attr('data-type');
            if (dataType === this.type) {
                $currentComponent.css('position', 'relative');
                return $currentComponent;
            } else {
                $currentComponent = $currentComponent ? $currentComponent.parent() : {};
            }
        }

        // fall back to parent implementation if necessary
        return this._super('_getAppendToTarget');
    },

    /**
     * Handler to show time picker on icon click.
     *
     * We trigger the focus on element instead of the jqueryfied element, to
     * trigger the focus on the input and avoid the `preventDefault()` imposed
     * in the library.
     */
    showTimePicker: function() {
        this.$(this.secondaryFieldTag)[0].focus();
    },

    /**
     * Return user time format.
     *
     * @return {string} User time format.
     */
    getUserTimeFormat: function() {
        return app.user.getPreference('timepref');
    },

    /**
     * Return user datetime format.
     *
     * @return {string} User datetime format.
     */
    getUserDateTimeFormat: function() {
        return this.getUserDateFormat() + ' ' + this.getUserTimeFormat();
    },

    /**
     * Return time place holder based on supplied format.
     *
     * @param {String} format Format.
     * @return {String} Time place holder.
     */
    getTimePlaceHolder: function(format) {
        var map = {
            'H': 'hh',
            'h': 'hh',
            'i': 'mm',
            'a': '',
            'A': ''
        };

        return format.replace(/[HhiaA]/g, function(s) {
            return map[s];
        });
    },

    /**
     * Set up the time picker.
     *
     * @protected
     */
    _setupTimePicker: function() {
        var options;
        var localeData = app.date.localeData();
        var lang = {
            am: localeData.meridiem(1, 00, true),
            pm: localeData.meridiem(13, 00, true),
            AM: localeData.meridiem(1, 00, false),
            PM: localeData.meridiem(13, 00, false)
        };

        this.def.time || (this.def.time = {});

        options = {
            timeFormat: this.getUserTimeFormat(),
            scrollDefaultNow: _.isUndefined(this.def.time.scroll_default_now) ?
                true :
                !!this.def.time.scroll_default_now,
            step: this.def.time.step || 15,
            disableTextInput: _.isUndefined(this.def.time.disable_text_input) ?
                false :
                !!this.def.time.disable_text_input,
            className: this.def.time.css_class || 'prevent-mousedown',
            appendTo: this.$el,
            lang: lang
        };

        this._enableDuration(options);

        this.$(this.secondaryFieldTag).timepicker(options);
        this._hasTimePicker = true;
    },

    /**
     * Show duration on the timepicker dropdown if enabled in view definition.
     * @param {Object} options The timepicker options (see
     *   https://github.com/jonthornton/jquery-timepicker#options).
     * @private
     */
    _enableDuration: function(options) {
        var self = this;

        if (this.def.time.duration) {
            options.maxTime = 85500; //23.75 hours, which is 11:45pm

            options.durationTime = function() {
                var dateStartString = self.model.get(self.def.time.duration.relative_to),
                    dateEndString = self.model.get(self.name),
                    startDate,
                    endDate;

                this.minTime = null;
                this.showDuration = false;

                if (!dateStartString || !dateEndString) {
                    return;
                }

                startDate = app.date(dateStartString);
                endDate = app.date(dateEndString);

                if ((startDate.year() === endDate.year()) &&
                    (startDate.month() === endDate.month()) &&
                    (startDate.day() === endDate.day())
                ) {
                    this.minTime = app.date.duration({
                        hours: startDate.hours(),
                        minutes: startDate.minutes()
                    }).asSeconds();
                    this.showDuration = true;
                }

                return this.minTime;
            };
        }
    },

    /**
     * Handle date and time picker changes.
     *
     * If model value is defined and supplied date or time is empty, an empty
     * string is returned, otherwise, empty values will fallback to current
     * date/time.
     *
     * All parameters and returned value are formatted according to user
     * preferences.
     *
     * @param {String} d Date value.
     * @param {String} t Time value.
     * @return {String} Datetime value.
     */
    handleDateTimeChanges: function(d, t) {
        if (this.model.get(this.name) && (!d || !t)) {
            return '';
        }

        var now = app.date();

        d = d || (t && now.format(app.date.convertFormat(this.getUserDateFormat())));
        t = t || (d && now.format(app.date.convertFormat(this.getUserTimeFormat())));

        return (d + ' ' + t).trim();
    },

    /**
     * Date picker doesn't trigger a `change` event whenever the date value
     * changes we need to override this method and listen to the `hide` event.
     *
     * Handles `hide` date picker event expecting to set the default time if
     * not filled yet, see {@link #handleDateTimeChanges}.
     *
     * All invalid values are cleared from fields without triggering an event
     * because `this.model.set()` could have been already empty thus not
     * triggering a new event and not calling the default code of
     * `bindDomChange()`.
     *
     * Undefined model values will not be replaced with empty string to prevent
     * unnecessary unsaved changes warnings.
     *
     * @override
     */
    handleHideDatePicker: function() {
        var $dateField = this.$(this.fieldTag),
            $timeField = this.$(this.secondaryFieldTag),
            d = $dateField.val(),
            t = $timeField.val(),
            datetime = this.unformat(this.handleDateTimeChanges(d, t));

        if (!datetime) {
            $dateField.val('');
            $timeField.val('');
        }

        if (_.isEmptyValue(datetime) && _.isUndefined(this.model.get(this.name))) {
            return;
        }

        this.model.set(this.name, datetime);
    },

    /**
     * @inheritdoc
     *
     * Bind time picker `changeTime` event expecting to set the default date if
     * not filled yet, see {@link #handleDateTimeChanges}.
     */
    bindDomChange: function() {
        this._super('bindDomChange');

        if (this._inDetailMode()) {
            return;
        }

        var $dateField = this.$(this.fieldTag),
            $timeField = this.$(this.secondaryFieldTag),
            selfView = this.view;

        $timeField.timepicker().on({
            showTimepicker: function() {
                selfView.trigger('list:scrollLock', true);
            },
            hideTimepicker: function() {
                selfView.trigger('list:scrollLock', false);
            },
            change: _.bind(function() {
                var t = $timeField.val().trim(),
                    datetime = '';

                if (t) {
                    var d = $dateField.val();
                    datetime = this.unformat(this.handleDateTimeChanges(d, t));
                    if (!datetime) {
                        $dateField.val('');
                        $timeField.val('');
                    }
                }
                this.model.set(this.name, datetime);
            }, this),
            focus: _.bind(function() {
                this.handleFocus();
            }, this)
        });
    },

    /**
     * @inheritdoc
     *
     * Add extra logic to unbind secondary field tag.
     */
    unbindDom: function() {
        this._super('unbindDom');

        if (this._inDetailMode()) {
            return;
        }

        this.$(this.secondaryFieldTag).off();
    },

    /**
     * Binds model changes on this field, taking into account both field tags.
     *
     * @override
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }

        this.model.on('change:' + this.name, function(model, value) {
            if (this.disposed) {
                return;
            }

            if (this._inDetailMode()) {
                this.render();
                return;
            }

            value = this.format(value) || {'date': '', 'time': ''};

            this.$(this.fieldTag).val(value['date']);
            if (value['date']) {
                var datePicker = this.$(this.fieldTag).data('datepicker');
                if (datePicker) {
                    datePicker.setValue(value.date);
                }
            }
            this.$(this.secondaryFieldTag).val(value['time']);
        }, this);
    },

    /**
     * Formats date value according to user preferences.
     *
     * @param {String} value Datetime value to format.
     * @return {Object/String/undefined} On edit mode the returned value is an
     *   object with two keys, `date` and `time`. On detail mode the returned
     *   value is a date, formatted according to user preferences if supplied
     *   value is a valid date, otherwise returned value is `undefined`.
     *
     * @override
     */
    format: function(value) {
        if (!value) {
            return value;
        }

        value = app.date(value);

        if (!value.isValid()) {
            return;
        }

        if (this.action === 'edit' || this.action === 'massupdate') {
            value = {
                'date': value.format(app.date.convertFormat(this.getUserDateFormat())),
                'time': value.format(app.date.convertFormat(this.getUserTimeFormat()))
            };

        } else {
            value = value.formatUser(false);
        }

        return value;
    },

    /**
     * Unformats datetime value for storing in model.
     *
     * @return {String} Unformatted value or `undefined` if value is
     *   an invalid date.
     *
     * @override
     */
    unformat: function(value) {
        if (!value) {
            return value;
        }

        value = app.date(value, app.date.convertFormat(this.getUserDateTimeFormat()), true);

        if (!value.isValid()) {
            return;
        }

        return value.formatServer();
    },

    /**
     * Override decorateError to take into account the two fields.
     *
     * @override
     */
    decorateError: function(errors) {
        var ftag = this.fieldTag || '',
            $ftag = this.$(ftag),
            errorMessages = [],
            $tooltip;

        // Add error styling
        this.$el.closest('.record-cell').addClass('error');
        this.$el.addClass('error');

        if (_.isString(errors)) {
            // A custom validation error was triggered for this field
            errorMessages.push(errors);
        } else {
            // For each error add to error help block
            _.each(errors, function(errorContext, errorName) {
                errorMessages.push(app.error.getErrorString(errorName, errorContext));
            });
        }

        $ftag.parent().addClass('error');

        $tooltip = [$(this.exclamationMarkTemplate(errorMessages)), $(this.exclamationMarkTemplate(errorMessages))];

        var self = this;

        $ftag.parent().children('input').each(function(index) {
            $(this).after($tooltip[index]);
        });
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (this._hasTimePicker) {
            this.$(this.secondaryFieldTag).timepicker('hide');
        }

        this._super('_render');

        if (this._inDetailMode()) {
            return;
        }

        this._setupTimePicker();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this._hasTimePicker) {
            this.$(this.secondaryFieldTag).timepicker('remove');
        }

        this._super('_dispose');
    }
}) },
"link-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * "Link" button used in selection list for linking existing records.
 *
 * @class View.Fields.Base.LinkButtonField
 * @alias SUGAR.App.view.fields.BaseLinkButtonField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Link-button Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.massCollection = this.context.get('mass_collection');
        if (!this.massCollection) {
            return;
        }

        this.listenTo(this.massCollection, 'add remove', function() {
            this.setDisabled(this.massCollection.length === 0);
        });

        if (this.massCollection.length === 0) {
            this.setDisabled(true);
        }
    },

    /**
     * @inheritdoc
     */
    _loadTemplate: function() {
        this.type = 'rowaction';
        this._super('_loadTemplate');
        this.type = 'link-button';
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.stopListening(this.massCollection);
        this._super('unbind');
    }
}) },
"hint-contacts-photo": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Hint-contacts-photo Field (base) 

    extendsFrom: 'AvatarField',

    plugins: ['MetadataEventDriven', 'Stage2CssLoader'],

    activeClass: 'hint-contacts-logo--record-view',

    /**
     *
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.context.on('button:save_button:click', this.fixFields, this);
        this.changedField = null;
    },

    /**
     * Fix picture field
     */
    fixFields: function() {
        if (this.changedField && this.changedField !== 'picture') {
            this.deleteImage();
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('change:picture', function() {
            if (this.action === 'edit') {
                // Should directly set the value in edit instead of re-rendering the whole field.
            } else {
                this.render();
            }
        }, this);

        this.model.on('change:hint_contact_pic', function() {
            if (this.action === 'edit' || SUGAR.App.controller.layout.type === 'records') {
                this.render();
            }
        }, this);
    },

    /**
     * Format value
     *
     * @param {string} value
     * @return {string}
     */
    format: function(value) {
        // this is picture
        var formattedValue = this.model.get('picture') ? this._super('format', [value]) : null;
        var hintUrl = this.model.get('hint_contact_pic');

        if (hintUrl && formattedValue) {
            if (this.model.previous('picture') !== value) {
                this.changedField = 'picture';
            } else if (this.model.previous('hint_contact_pic') !== hintUrl) {
                formattedValue = hintUrl;
                this.changedField = 'hint_contact_pic';
            }
        } else if (hintUrl) {
            formattedValue = hintUrl;
        }

        return formattedValue;
    },

    /**
     * Delete picture
     *
     * @param {Object} e
     */
    delete: function(e) {
        var self = this;
        var picture = 'picture';
        //If we are previewing a file and want to cancel
        if (this.preview === true) {
            self.preview = false;
            self.clearErrorDecoration();
            self.render();
            return;
        }
        // If it's a duplicate, don't delete the file
        if (this._duplicateBeanId) {
            self.model.unset(picture);
            self.model.set(picture, null);
            self.model.set('hint_contact_pic', '', {silent: true});
            self.render();
            return;
        }
        var confirmMessage = app.lang.get('LBL_IMAGE_DELETE_CONFIRM', self.module);
        if (confirm(confirmMessage)) {
            //Otherwise delete the image
            app.api.call('delete', self.buildUrl({htmlJsonFormat: false}), {}, {
                    success: function(response) {
                        if (self.disposed) {
                            return;
                        }
                        //Need to fire the change event twice so hint_contact_pic is also changed.
                        self.model.unset(picture);
                        self.model.set(picture, null);
                        self.model.set('hint_contact_pic', '', {silent: true});
                        if (response.record && response.record.date_modified) {
                            self.model.set('date_modified', response.record.date_modified);
                        }
                        self.render();
                    },
                    error: function(data) {
                        // refresh token if it has expired
                        app.error.handleHttpError(data, {});
                    }
                }
            );
        }
    },

    /**
     * @inheritdoc
     */
    _loadTemplate: function() {
        this.type = 'avatar';
        this._super('_loadTemplate');
        this.type = this.def.type;
    },

    /**
     * Delete `picture` from db
     */
    deleteImage: function(viewModel, fieldValue) {
        var self = this;
        app.api.call('delete', self.buildUrl({htmlJsonFormat: false}), {}, {
            success: function(response) {
                var isSugarEditMode = app.router._currentFragment.indexOf('/edit') !== -1;
                if (isSugarEditMode) {
                    if (typeof fieldValue === 'object') {
                        viewModel.set(fieldValue);
                    } else {
                        viewModel.set('hint_contact_pic', fieldValue);
                    }

                    //Need to fire the change event twice so model.previous(self.name) is also changed.
                    self.model.unset('picture');
                    self.model.set('picture', null);
                    if (response.record && response.record.date_modified) {
                        self.model.set('date_modified', response.record.date_modified);
                    }
                } else {
                    if (typeof fieldValue === 'object') {
                        viewModel.save(fieldValue);
                    } else {
                        viewModel.save('hint_contact_pic', fieldValue);
                    }

                    //Need to fire the change event twice so model.previous(self.name) is also changed.
                    self.model.set('picture', null);
                    self.model.save('picture', null);
                    if (response.record && response.record.date_modified) {
                        self.model.set('date_modified', response.record.date_modified);
                        self.model.save('date_modified', response.record.date_modified);
                    }
                }
                if (!self.disposed) {
                    self.render();
                }
            },
            error: function(data) {
                // refresh token if it has expired
                app.error.handleHttpError(data, {});
            }}
        );
    }
}) },
"enum": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EnumField
 * @alias SUGAR.App.view.fields.BaseEnumField
 * @extends View.Fields.Base.BaseField
 */
({
	// Enum Field (base) 

    fieldTag: 'input.select2',

    /**
     * HTML tag of the append value checkbox.
     *
     * @property {String}
     */
    appendValueTag: 'input[name=append_value]',

    /**
     * Whether this field is in the midst of fetching options for its dropdown.
     *
     * @type {Boolean}
     */
    isFetchingOptions: false,

    /**
     * The dropdown elements.
     *
     *     @example The format of the object is:
     *     ```
     *     {
     *         "key1": "value1",
     *         "key2": "value2",
     *         "key3": "value3"
     *     }
     *     ```
     *
     * @type {Object}
     */
    items: null,

    /**
     * The keys of dropdown elements and their index in the related
     * `app_list_keys` array.
     *
     *     @example The format of the object is:
     *     ```
     *     {
     *         "key1": 1,
     *         "key2": 0,
     *         "key3": 2
     *     }
     *     ```
     *
     * If no `app_list_keys` entry, or if elements in the expected order, the
     * object will be empty.
     *
     * @type {Object}
     */
    _keysOrder: null,

    /**
     * @inheritdoc
     */
    initialize: function() {
        this._super('initialize', arguments);

        //Reset the availible options based on the user's access and the model's values
        if (_.isString(this.def.options)) {
            var self = this;

            this.listenTo(this.model, "sync", function(model){
                var options = app.lang.getAppListStrings(self.def.options);
                if (options) {
                    self.items = self._filterOptions(options);
                }
            });
        }

        // Set appendValue for mass update
        if (!_.isUndefined(this.model) && !_.isUndefined(this.model.get(this.name + '_replace'))) {
            this.appendValue = this.model.get(this.name + '_replace') === '1';
        }
    },

    /**
     * @inheritdoc
     *
     * Returns the direction of the field depending on the nature of the first
     * option when the language direction is `rtl`.
     */
    direction: function() {
        if (_.isEmpty(this.items) || app.lang.direction !== 'rtl') {
            return;
        }

        var firstOption = _.values(this.items)[0];
        return app.utils.isDirectionRTL(firstOption) ? 'rtl' : 'ltr';
    },

    /**
     * Bind the additional keydown handler on select2
     * search element (affected by version 3.4.3).
     *
     * Invoked from {@link app.plugins.Editable}.
     * @param {Function} callback Callback function for keydown.
     */
    bindKeyDown: function(callback) {
        var $el = this.$(this.fieldTag);
        if ($el) {
            $el.on('keydown.record', {field: this}, callback);
            var plugin = $el.data('select2');
            if (plugin) {
                if (plugin.focusser) {
                    plugin.focusser.on('keydown.record', {field: this}, callback);
                }
                plugin.search.on('keydown.record', {field: this}, callback);
            }
        }
    },

    /**
     * Unbind the additional keydown handler.
     *
     * Invoked from {@link app.plugins.Editable}.
     * @param {Function} callback Callback function for keydown.
     */
    unbindKeyDown: function(callback) {
        if (this.$el) {
            var $el = this.$(this.fieldTag);
            if ($el) {
                $el.off('keydown.record', callback);
                var plugin = $el.data('select2');
                if (plugin) {
                    plugin.search.off('keydown.record', callback);
                }
            }
        }
    },

    /**
     * @override
     * @protected
     * @chainable
     */
    _render: function() {
        var self = this;
        if (!this.items || _.isEmpty(this.items)) {
            this.loadEnumOptions(false, function() {
                self.isFetchingOptions = false;
                //Re-render widget since we have fresh options list
                if(!this.disposed){
                    this.render();
                }
            });
            if (this.isFetchingOptions){
                // Set loading message in place of empty DIV while options are loaded via API
                this.$el.html('<div class="select2-loading">' + app.lang.get('LBL_LOADING') + '</div>');
                return this;
            }
        }
        //Use blank value label for blank values on multiselects
        if (this.def.isMultiSelect && !_.isUndefined(this.items['']) && this.items[''] === '') {
            var obj = {};
            _.each(this.items, function(value, key) {
               // Only work on key => value pairs that are not both blank
               if (key !== '' && value !== '') {
                   obj[key] = value;
               }
            }, this);
            this.items = obj;
        }
        this.items = this._filterOptions(this.items);
        var optionsKeys = _.isObject(this.items) ? _.keys(this.items) : [],
            defaultValue = this._checkForDefaultValue(this.model.get(this.name), optionsKeys);

        app.view.Field.prototype._render.call(this);
        // if displaying the noaccess template, just exit the method
        if (this.tplName == 'noaccess') {
            return this;
        }
        var select2Options = this.getSelect2Options(optionsKeys);
        var $el = this.$(this.fieldTag);
        //FIXME remove check for tplName SC-2608
        if (_.contains(['edit', 'list-edit', 'massupdate', 'login'], this.tplName)) {
            $el.select2(select2Options);
            var plugin = $el.data('select2');

            if (plugin && this.dir) {
                plugin.container.attr('dir', this.dir);
                plugin.results.attr('dir', this.dir);
            }

            if (plugin && plugin.focusser) {
                plugin.focusser.on('select2-focus', _.bind(_.debounce(this.handleFocus, 0), this));
            }
            $el.on('change', function(ev) {
                var value = ev.val;
                if (_.isUndefined(value)) {
                    return;
                }
                if (self.model) {
                    self.model.set(self.name, self.unformat(value));
                }
            });
            if (this.def.isMultiSelect && this.def.ordered) {
                $el.select2('container').find('ul.select2-choices').sortable({
                    containment: 'parent',
                    start: function() {
                        $el.select2('onSortStart');
                    },
                    update: function() {
                        $el.select2('onSortEnd');
                    }
                });
            }
        } else if (this.tplName === 'disabled') {
            $el.select2(select2Options);
            $el.select2('disable');
        }
        //Setup selected value in Select2 widget
        if (!_.isUndefined(this.value)) {
            // To make pills load properly when autoselecting a string val
            // from a list val needs to be an array
            if (!_.isArray(this.value)) {
                this.value = [this.value];
            }
            // Trigger the `change` event only if we automatically set the
            // default value.
            $el.select2('val', this.value, !!defaultValue);
        }

        if (this.tplName === 'detail') {
            $('.select2-drop').select2('close');
        }

        return this;
    },

    /**
     * Sets the model value to the default value if required
     * @private
     */
    _checkForDefaultValue: function(currentValue, optionsKeys){
        // Javascript keys function returns strings even if keys are numbers.  The parameter optionsKeys
        // is obtained by _.keys() operation on an object. Even if the object keys were numeric originally,
        // optionsKeys will be an array of strings. Hence we need to cast currentValue to a string
        // for comparison sake.
        if ((typeof currentValue !== 'undefined') && (currentValue !== null)) {
            currentValue = currentValue.toString();
        }

        var action = this.action || this.view.action;
        //After rendering the dropdown, the selected value should be the value set in the model,
        //or the default value. The default value fallbacks to the first option if no other is selected
        //or the selected value is not available in the list of items,
        //if the user has write access to the model for the field we are currently on.
        //This should be done only if available options are loaded, otherwise the value in model will be reset to
        //default even if it's in available options but they are not loaded yet
        if (!this.def.isMultiSelect
            && !_.isEmpty(this.items)
            && !(this.model.has(this.name) && optionsKeys.indexOf(currentValue) > -1)
            && app.acl.hasAccessToModel('write', this.model, this.name)
            && (action == 'edit' || action == 'create')
            && !this.def.defaultToBlank
        ) {
            var defaultValue = this._getDefaultOption(optionsKeys);
            //Forecasting uses backbone model (not bean) for custom enums so we have to check here
            if (_.isFunction(this.model.setDefault)) {
                this.model.setDefault(this.name, defaultValue);
            }
        }
    },

    /**
     * Called when focus on inline editing
     */
    focus: function () {
        //We must prevent focus for multi select otherwise when inline editing the dropdown is opened and it is
        //impossible to click on a pill `x` icon in order to remove an item
        if(this.action !== 'disabled' && !this.def.isMultiSelect) {
            this.$(this.fieldTag).select2('open');
        }
    },

    /**
     * Load the options for this field and pass them to callback function.  May be asynchronous.
     * @param {Boolean} fetch (optional) Force use of Enum API to load options.
     * @param {Function} callback (optional) Called when enum options are available.
     */
    loadEnumOptions: function(fetch, callback, error) {
        var self = this;
        var _module = this.getLoadEnumOptionsModule();
        var _itemsKey = 'cache:' + _module + ':' + this.name + ':items';

        this.items = this.def.options || this.context.get(_itemsKey);

        fetch = fetch || false;

        if (fetch || !this.items) {
            this.isFetchingOptions = true;
            var _key = 'request:' + _module + ':' + this.name;
            //if previous request is existed, ignore the duplicate request
            if (this.context.get(_key)) {
                var request = this.context.get(_key);
                request.xhr.done(_.bind(function(o) {
                    if (this.items !== o) {
                        this.items = o;
                        callback.call(this);
                    }
                }, this));
            } else {
                var request = app.api.enumOptions(_module, self.name, {
                    success: function(o) {
                        if(self.disposed) { return; }
                        if (self.items !== o) {
                            self.items = o;
                            self.context.set(_itemsKey, self.items);
                        }
                    },
                    error: function(e) {
                        if (self.disposed) {
                            return;
                        }

                        if (error) {
                            error(e);
                        }

                        // Continue to use SugarCRM's default error handler.
                        if (_.isFunction(app.api.defaultErrorHandler)) {
                            app.api.defaultErrorHandler(e);
                        }

                        self.items = {'': app.lang.get('LBL_NO_DATA', self.module)};
                    },
                    complete: function() {
                        if (!self.disposed) {
                            self.context.unset(_key);
                            callback.call(self);
                        }
                    }
                });
                this.context.set(_key, request);
            }
        } else if (_.isString(this.items)) {
            this.items = app.lang.getAppListStrings(this.items);
        }
    },

    /**
     * Allow overriding of what module is used for loading the enum options.
     *
     * @return {string} The module from which to load the enum options.
     */
    getLoadEnumOptionsModule: function() {
        return this.def.enum_module || this.module;
    },

    /**
     * Helper function for generating Select2 options for this enum
     * @param {Array} optionsKeys Set of option keys that will be loaded into Select2 widget
     * @return {Object} Select2 options, refer to Select2 documentation for what each option means
     */
    getSelect2Options: function(optionsKeys){
        var select2Options = {};
        select2Options.allowClear = _.indexOf(optionsKeys, "") >= 0;
        select2Options.transformVal = _.identity;

        /* From http://ivaynberg.github.com/select2/#documentation:
         * Initial value that is selected if no other selection is made
         */
        if(!this.def.isMultiSelect) {
            select2Options.placeholder = app.lang.get("LBL_SEARCH_SELECT");
        }

        /* From http://ivaynberg.github.com/select2/#documentation:
         * "Calculate the width of the container div to the source element"
         */
        select2Options.width = this.def.enum_width ? this.def.enum_width : '100%';

        /* Because the select2 dropdown is appended to <body>, we need to be able
         * to pass a classname to the constructor to allow for custom styling
         */
        select2Options.dropdownCssClass = this.def.dropdown_class ? this.def.dropdown_class : '';

        /* To get the Select2 multi-select pills to have our styling, we need to be able
         * to either pass a classname to the constructor to allow for custom styling
         * or set the 'select2-choices-pills-close' if the isMultiSelect option is set in def
         */
        select2Options.containerCssClass = this.def.container_class ? this.def.container_class : (this.def.isMultiSelect ? 'select2-choices-pills-close' : '');

        /* Because the select2 dropdown is calculated at render to be as wide as container
         * to make it differ the dropdownCss.width must be set (i.e.,100%,auto)
         */
        if (this.def.dropdown_width) {
            select2Options.dropdownCss = { width: this.def.dropdown_width };
        }

        /* All select2 dropdowns should only show the search bar for fields with 7 or more values,
         * this adds the ability to specify that threshold in metadata.
         */
        select2Options.minimumResultsForSearch = this.def.searchBarThreshold ? this.def.searchBarThreshold : 7;

        /* If is multi-select, set multiple option on Select2 widget.
         */
        if (this.def.isMultiSelect) {
            select2Options.multiple = true;
        }

        /* If we need to define a custom value separator
         */
        select2Options.separator = this.def.separator || ',';
        if (this.def.separator) {
            select2Options.tokenSeparators = [this.def.separator];
        }

        select2Options.initSelection = _.bind(this._initSelection, this);
        select2Options.query = _.bind(this._query, this);
        select2Options.sortResults = _.bind(this._sortResults, this);

        return select2Options;
    },

    /**
     * Set the option selection during select2 initialization.
     * Also used during drag/drop in multiselects.
     * @param {Selector} $ele Select2 element selector
     * @param {Function} callback Select2 data callback
     * @private
     */
    _initSelection: function($ele, callback){
        var data = [];
        var options = _.isString(this.items) ? app.lang.getAppListStrings(this.items) : this.items;
        options = this.items = this._filterOptions(options);
        var values = $ele.val();
        if (this.def.isMultiSelect) {
            values = values.split(this.def.separator || ',');
        }
        _.each(_.pick(options, values), function(value, key){
            data.push({id: key, text: value});
        }, this);
        if(data.length === 1){
            callback(data[0]);
        } else {
            callback(data);
        }
    },

    /**
     * Returns dropdown list options which can be used for editing
     *
     * @param {Object} Dropdown list options
     * @return {Object}
     * @private
     */
    _filterOptions: function (options) {
        var currentValue,
            syncedVal,
            newOptions = {},
            filter = app.metadata.getEditableDropdownFilter(this.def.options);

        /**
         * Flag to indicate that the options have already been filtered and do
         * not need to be sorted.
         *
         * @type {boolean}
         */
        this.isFiltered = !_.isEmpty(filter);

        if (!this.isFiltered) {
            return options;
        }

        if (!_.contains(this.view.plugins, "Editable")) {
            return options;
        }
        //Force the current value(s) into the availible options
        syncedVal = this.model.getSynced();
        currentValue = _.isUndefined(syncedVal[this.name]) ? this.model.get(this.name) : syncedVal[this.name];
        if (_.isString(currentValue)) {
            currentValue = [currentValue];
        }

        var currentIndex = {};

        // add current values to the index in case if current model is saved to the server in order to prevent data loss
        if (!this.model.isNew()) {
            _.each(currentValue, function(value) {
                currentIndex[value] = true;
            });
        }

        //Now remove the disabled options
        if (!this._keysOrder) {
            this._keysOrder = {};
        }
        _.each(filter, function(val, index) {
            var key = val[0],
                visible = val[1];
            if ((visible || key in currentIndex) && !_.isUndefined(options[key]) && options[key] !== false) {
                this._keysOrder[key] = index;
                newOptions[key] = options[key];
            }
        }, this);

        return newOptions;
    },

    /**
     * Adapted from eachOptions helper in hbt-helpers.js
     * Select2 callback used for loading the Select2 widget option list
     * @param {Object} query Select2 query object
     * @private
     */
    _query: function(query){
        var options = _.isString(this.items) ? app.lang.getAppListStrings(this.items) : this.items;
        var data = {
            results: [],
            // only show one "page" of results
            more: false
        };
        if (_.isObject(options)) {
            _.each(options, function(element, index) {
                var text = "" + element;
                //additionally filter results based on query term
                if(query.matcher(query.term, text)){
                    data.results.push({id: index, text: text});
                }
            });
        } else {
            options = null;
        }
        query.callback(data);

        // Special hack for Firefox bug http://stackoverflow.com/questions/13040897/firefox-scrollbar-resets-incorrectly
        $(this.$(this.fieldTag).data('select2').results[0]).scrollTop(1).scrollTop(0);
    },

    /**
     * Sort the dropdown items.
     *
     * - If `def.sort_alpha` is `true`, return the dropdown items sorted
     * alphabetically.
     * - If {@link Core.Language#getAppListKeys} is defined for
     * `this.def.options`, return the items in this order.
     * - Otherwise, fall back to the default behavior and just return the
     * `results`.
     *
     * This method is the implementation of the select2 `sortResults` option.
     * See {@link http://ivaynberg.github.io/select2/ official documentation}.
     *
     * @param {Array} results The list of results `{id: *, text: *}.`
     * @param {jQuery} container jQuery wrapper of the node that should contain
     *  the representation of the result.
     * @param {Object} query The query object used to request this set of
     *  results.
     * @return {Array} The list of results {id: *, text: *} sorted.
     * @private
     */
    _sortResults: function(results, container, query) {
        var sortedResults;

        if (this.def.sort_alpha) {
            sortedResults = _.sortBy(results, function(item) {
                return item.text;
            });
            return sortedResults;
        }

        // Do not sort if options have already been filtered; or if the key ordering is empty,
        // we should not change the order as the options were generated by a function.
        if (this.isFiltered && _.isEmpty(this._keysOrder)) {
            return results;
        }

        this._setupKeysOrder();
        // If the key ordering is empty, we should not change the order as the options were generated by a function.
        if (_.isEmpty(this._keysOrder)) {
            return results;
        }

        return _.sortBy(results, function(item) {
            return this._keysOrder[item.id];
        }, this);
    },

    _setupKeysOrder: function() {
        var keys;
        var orderedKeys;
        var filteredOrderedKeys;
        var visibilityGrid;

        if (!_.isEmpty(this._keysOrder)) {
            return;
        }

        visibilityGrid = this.def.visibility_grid || {};

        var hasTrigger = visibilityGrid.values && visibilityGrid.trigger && this.model.has(visibilityGrid.trigger);

        // in case we have visibility grid, build keys according to its order
        if (hasTrigger) {
            var trigger = this.model.get(visibilityGrid.trigger);
            var _gridKeysOrder = visibilityGrid.values[trigger];

            if (_gridKeysOrder) {
                this._keysOrder = _.reduce(_gridKeysOrder, function(memo, value, index) {
                    memo[value] = index;
                    return memo;
                }, {});

                return;
            }
        } else {
            keys = _.keys(this.items);
            this._keysOrder = {};

            orderedKeys = _.map(app.lang.getAppListKeys(this.def.options), function(appListKey) {
                return appListKey.toString();
            });

            filteredOrderedKeys = _.intersection(orderedKeys, keys);

            if (!_.isEqual(filteredOrderedKeys, keys)) {
                _.each(filteredOrderedKeys, function(key, index) {
                    return this._keysOrder[key] = index;
                }, this);
            }
        }
    },

    /**
     * Helper function for retrieving the default value for the selection
     * @param {Array} optionsKeys Set of option keys that will be loaded into Select2 widget
     * @return {string} The default value
     */
    _getDefaultOption: function (optionsKeys) {
        //  Return the default if it's available in the definition.
        if (this.def && (!_.isEmptyValue(this.def.default)) ) {
            return this.def.default;
        } else {
            this._setupKeysOrder();
            var invertedKeysOrder = _.invert(this._keysOrder);
            //Check if we have a keys order, and that the sets of keys match
            if (!_.isEmpty(invertedKeysOrder) && _.isEmpty(_.difference(_.keys(this._keysOrder), optionsKeys))) {
                return _.first(invertedKeysOrder);
            }
            return _.first(optionsKeys);
        }
    },

    /**
     *  Convert select2 value into model appropriate value for sync
     *
     * @param value Value from select2 widget
     * @return {String|Array} Unformatted value as String or String Array
     */
    unformat: function(value) {
        if (this.def.isMultiSelect && _.isArray(value)) {
            var possibleKeys = _.keys(this.items);
            if (!this.def.ordered) {
                // if it's not ordered, i.e. sortable, force order
                value = _.intersection(possibleKeys, value);
            } else {
                // no need to force order, just keep valid keys
                value = _.intersection(value, possibleKeys);
            }
            return value;
        }

        if (this.def.isMultiSelect && _.isNull(value)) {
            return [];  // Returning value that is null equivalent to server.  Backbone.js won't sync attributes with null values.
        } else {
            return value;
        }
    },

    /**
     * Convert server value into one appropriate for display in widget
     *
     * @param value
     * @return {Array} Value for select2 widget as String Array
     */
    format: function(value){
        if (this.def.isMultiSelect && _.isArray(value) && _.indexOf(value, '') > -1) {
            value = _.clone(value);

            // Delete empty values from the select list
            delete value[''];
        }
        if(this.def.isMultiSelect && _.isString(value)){
            return this.convertMultiSelectDefaultString(value);
        } else {
            return value;
        }
    },

    /**
     * Converts multiselect default strings into array of option keys for template
     * @param {String} defaultString string of the format "^option1^,^option2^,^option3^"
     * @return {Array} of the format ["option1","option2","option3"]
     */
    convertMultiSelectDefaultString: function(defaultString) {
        var result = defaultString.split(",");
        _.each(result, function(value, key) {
            // Remove empty values in the selection
            if (value !== '^^') {
                result[key] = value.replace(/\^/g,"");
            }
        });
        return result;
    },

    /**
     * @inheritdoc
     * Avoid rendering process on select2 change in order to keep focus.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:' + this.name, function() {
                let ele = this.$el;
                if (ele) {
                    let field = this.$(this.fieldTag);
                    if (field) {
                        if (_.isEmpty(field.data('select2'))) {
                            this.render();
                        } else {
                            field.select2('val', this.format(this.model.get(this.name)));
                        }
                    }
                }
            }, this);
        }
    },

    /**
     * Override to remove default DOM change listener, we use Select2 events instead
     * Binds append value checkbox change for massupdate.
     *
     * @override
     */
    bindDomChange: function() {
        var $el = this.$(this.appendValueTag);
        if ($el.length) {
            $el.on('change', _.bind(function() {
                this.appendValue = $el.prop('checked');
                //FIXME: Should use true booleans (SC-2828)
                this.model.set(this.name + '_replace', this.appendValue ? '1' : '0');
            }, this));
        }
    },

    /**
     * @override
     */
    unbindDom: function() {
        this.$(this.appendValueTag).off();
        this.$(this.fieldTag).select2('destroy');
        this._super('unbindDom');
    },

    /**
     * @override
     */
    unbindData: function() {
        var _key = 'request:' + this.module + ':' + this.name;
        this.context.unset(_key);
        app.view.Field.prototype.unbindData.call(this);
    },

    /**
     * Need to check not only if there is no value, but if there is a value and
     * it is an empty array.
     *
     * @override
     */
    _isErasedField: function() {
        if (!this.model) {
            return false;
        }

        var value = this.model.get(this.name);

        return (!value || _.isArray(value) && _.isEmpty(value)) &&
            _.contains(this.model.get('_erased_fields'), this.name);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.unbindKeyDown();
        var $el = this.$(this.fieldTag);
        var plugin = $el.data('select2');
        if (plugin) {
            plugin.close();
        }
        this._super('_dispose');
    }
}) },
"date": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.DateField
 * @alias SUGAR.App.view.fields.BaseDateField
 * @extends View.Fields.Base.BaseField
 */
({
	// Date Field (base) 

    /**
     * @inheritdoc
     */
    fieldTag: 'input[data-type=date]',

    /**
     * @inheritdoc
     */
    events: {
        'hide': 'handleHideDatePicker'
    },

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     */
    shouldInitDefaultValue: true,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // FIXME SC-1692: Remove this when SC-1692 gets in
        this._initPlugins();
        this._super('initialize', [options]);
        this._initEvents();
        this._initPlaceholderAttribute();

        /**
         * If a date picker has been initialized on the field or not.
         *
         * @type {boolean}
         * @private
         */
        this._hasDatePicker = false;
    },

    /**
     * Initialize plugins.
     *
     * @chainable
     * @protected
     * @template
     *
     * FIXME SC-1692: Remove this when SC-1692 gets in.
     */
    _initPlugins: function() {
        return this;
    },

    /**
     * Initialize events.
     *
     * @chainable
     * @protected
     * @template
     */
    _initEvents: function() {
        return this;
    },

    /**
     * If we're creating a new model and a valid `display_default` property was
     * supplied (e.g.: `next friday`) we'll use it as a date instead.
     *
     * @chainable
     * @inheritdoc
     * @override
     */
    _initDefaultValue: function() {
        if (!this.model.isNew() || this.model.get(this.name) || !this.def.display_default) {
            return this;
        }

        var value = app.date.parseDisplayDefault(this.def.display_default);
        if (!value) {
            return this;
        }

        value = this.unformat(
            app.date(value).format(
                app.date.convertFormat(this.getUserDateFormat())
            )
        );

        this.model.setDefault(this.name, value);

        return this;
    },

    /**
     * Initializes the field's placeholder attribute.
     *
     * Placeholder attribute can be used in different ways. Based on metadata
     * settings one can do:
     *
     *     // ...
     *     array(
     *         'name' => 'my_date_field',
     *         'type' => 'date',
     *         'placeholder' => 'TPL_MY_PLACEHOLDER',
     *         // ...
     *     )
     *     // ...
     *
     * Where `TPL_MY_PLACEHOLDER` is able to receive the `format` flag such as:
     *
     *     'TPL_MY_PLACEHOLDER' => 'Accepts the {{format}} format'
     *
     * If none supplied, user date format is used instead
     * {@link #getUserDateformat}.
     *
     * @chainable
     * @protected
     */
    _initPlaceholderAttribute: function() {
        var placeholder = app.date.toDatepickerFormat(this.getUserDateFormat());

        this.fieldPlaceholder = this.def.placeholder && app.lang.get(
            this.def.placeholder,
            this.module,
            {format: placeholder}
        ) || placeholder;

        return this;
    },

    /**
     * Return user date format.
     *
     * @return {String} User date format.
     */
    getUserDateFormat: function() {
        return app.user.getPreference('datepref');
    },

    /**
     * Set up date picker.
     *
     * We rely on the library to confirm that the date picker is only created
     * once.
     *
     * @protected
     */
    _setupDatePicker: function() {
        var $field = this.$(this.fieldTag),
            userDateFormat = this.getUserDateFormat(),
            options = {
                format: app.date.toDatepickerFormat(userDateFormat),
                languageDictionary: this._patchPickerMeta(),
                weekStart: parseInt(app.user.getPreference('first_day_of_week'), 10)
            };

        var appendToTarget = this._getAppendToTarget();
        if (appendToTarget) {
            options['appendTo'] = appendToTarget;
        }

        $field.datepicker(options);
        this._hasDatePicker = true;
    },

    /**
     * Retrieve an element to which the datepicker should be appended.
     *
     * @return {jQuery|undefined} Element to which the datepicker should be
     *   appended.
     * @protected
     */
    _getAppendToTarget: function() {
        var component = this.closestComponent('main-pane') ||
            this.closestComponent('drawer') ||
            this.closestComponent('preview-pane');

        if (component) {
            return component.$el;
        }
    },

    /**
     * Date picker doesn't trigger a `change` event whenever the date value
     * changes we need to override this method and listen to the `hide` event.
     *
     * Plus, we're using the `hide` event instead of the `changeDate` event
     * because the latter doesn't track copy/paste of dates whether from
     * keyboard or mouse and it also doesn't track field clearance through
     * keyboard, e.g.: selecting date text and press cmd+x.
     *
     * All invalid values are cleared from fields without triggering an event
     * because `this.model.set()` could have been already empty thus not
     * triggering a new event and not calling the default code of
     * `bindDomChange()`.
     *
     * Undefined model values will not be replaced with empty string to prevent
     * unnecessary unsaved changes warnings.
     */
    handleHideDatePicker: function() {
        var $field = this.$(this.fieldTag);

        // If we partially delete date from date picker and click outside the field, it will return undefined value.
        // But we need to use empty string as the only one negative value.
        var value = this.unformat($field.val()) || '';

        if (!value) {
            $field.val(value);
        }

        if (_.isEmptyValue(value) && _.isUndefined(this.model.get(this.name))) {
            return;
        }

        this.model.set(this.name, value);
    },

    /**
     * {@override}
     *
     * Parent method isn't called 'cause `handleHideDatePicker()` already takes
     * care of unformatting the value.
     */
    bindDomChange: function() {
        if (this._inDetailMode()) {
            return;
        }

        if (this.action === 'edit') {
            var $field = this.$(this.fieldTag);

            $field.on('focus', _.bind(this.handleFocus, this));

            $('.main-pane, .flex-list-view-content').on('scroll.' + this.cid, _.bind(function() {
                // make sure the dom element exists before trying to place the datepicker
                if (this._getAppendToTarget()) {
                    $field.datepicker('place');
                }
            }, this));
        }
    },

    /**
     * Determine if the field is currently in a read-only (detail) mode.
     *
     * @return {boolean}
     * @protected
     */
    _inDetailMode: function() {
        return this.action !== 'edit' && this.action !== 'massupdate';
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        this._super('unbindDom');

        if (this._inDetailMode()) {
            return;
        }

        if (this.action === 'edit') {
            $('.main-pane, .flex-list-view-content').off('scroll.' + this.cid);

            var $field = this.$(this.fieldTag),
                datePicker = $field.data('datepicker');
            if (datePicker && !datePicker.hidden) {
                // todo: when SC-2395 gets implemented change this to 'remove' not 'hide'
                $field.datepicker('hide');
            }
        }
    },

    /**
     * Patches our `dom_cal_*` metadata for use with date picker plugin since
     * they're very similar.
     *
     * @private
     */
    _patchPickerMeta: function() {
        var pickerMap = [], pickerMapKey, calMapIndex, mapLen, domCalKey,
            calProp, appListStrings, calendarPropsMap, i, filterIterator;

        appListStrings = app.metadata.getStrings('app_list_strings');

        filterIterator = function(v, k, l) {
            return v[1] !== "";
        };

        // Note that ordering here is used in following for loop
        calendarPropsMap = ['dom_cal_day_long', 'dom_cal_day_short', 'dom_cal_day_min', 'dom_cal_month_long', 'dom_cal_month_short'];

        for (calMapIndex = 0, mapLen = calendarPropsMap.length; calMapIndex < mapLen; calMapIndex++) {

            domCalKey = calendarPropsMap[calMapIndex];
            calProp  = appListStrings[domCalKey];

            // Patches the metadata to work w/datepicker; initially, "calProp" will look like:
            // {0: "", 1: "Sunday", 2: "Monday", 3: "Tuesday", 4: "Wednesday", 5: "Thursday", 6: "Friday", 7: "Saturday"}
            // But we need:
            // ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
            if (!_.isUndefined(calProp) && !_.isNull(calProp)) {
                // Reject the first 0: "" element and then map out the new language tuple
                // so it's back to an array of strings
                calProp = _.filter(calProp, filterIterator).map(function(prop) {
                    return prop[1];
                });
                //e.g. pushed the Sun in front to end (as required by datepicker)
                calProp.push(calProp);
            }
            switch (calMapIndex) {
                case 0:
                    pickerMapKey = 'day';
                    break;
                case 1:
                    pickerMapKey = 'daysShort';
                    break;
                case 2:
                    pickerMapKey = 'daysMin';
                    break;
                case 3:
                    pickerMapKey = 'months';
                    break;
                case 4:
                    pickerMapKey = 'monthsShort';
                    break;
            }
            pickerMap[pickerMapKey] = calProp;
        }
        return pickerMap;
    },

    /**
     * Formats date value according to user preferences.
     *
     * @param {String} value Date value to format.
     * @return {String/undefined} Formatted value or `undefined` if value is an
     *   invalid date.
     */
    format: function(value) {
        if (!value) {
            return value;
        }

        value = app.date(value);

        if (!value.isValid()) {
            return;
        }

        return value.formatUser(true);
    },

    /**
     * Unformats date value for storing in model.
     *
     * @return {String/undefined} Unformatted value or `undefined` if value is
     *   an invalid date.
     */
    unformat: function(value) {
        if (!value) {
            return value;
        }

        value = app.date(value, app.date.convertFormat(this.getUserDateFormat()), true);

        if (!value.isValid()) {
            return;
        }

        return value.formatServer(true);
    },


    /**
     * Removes fieldTag input[data-type=date] added in class name.
     *
     * @param {jQuery} childComponent.
     */
    _clearFieldTagClassDecoration: function(childComponent) {
        if (childComponent.hasClass(this.fieldTag)) {
            childComponent.removeClass(this.fieldTag);
        }
        if (childComponent.children().length) {
            this._clearFieldTagClassDecoration(childComponent.children());
        }
    },

    /**
     * @override
     */
    decorateError: function(errors) {
        this._super('decorateError', [errors]);
        this._clearFieldTagClassDecoration(this.$el);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (this._hasDatePicker) {
            this.$(this.fieldTag).datepicker('hide');
        }

        this._super('_render');

        if (this.tplName !== 'edit' && this.tplName !== 'massupdate') {
            this._hasDatePicker = false;
            return;
        }

        this._setupDatePicker();
    },

    /**
     * Focus on the date field.
     */
    focus: function() {
        this.$(this.fieldTag).datepicker('focusShow');
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        // FIXME: new date picker versions have support for plugin removal/destroy
        // we should do the upgrade in order to prevent memory leaks

        let field = this.$(this.fieldTag);
        if (field && field.length > 0 && this._hasDatePicker) {
            $(window).off('resize', field.data('datepicker').place);
        }

        this._super('_dispose');
    }
}) },
"filter-def": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FilterdefField
 * @alias SUGAR.App.view.fields.BaseFilterdefField
 * @extends View.Fields.Base.BaseField
 */
({
	// Filter-def Field (base) 

    /**
     * Map of fields types.
     *
     * Specifies correspondence between field types and field operator types.
     */
    fieldTypeMap: {
        'datetime': 'date',
        'datetimecombo': 'date'
    },
    /**
     * Stores the list of filter field options.
     */
    fieldList: {},

    /**
     * Modules that are marked as needing the field list API call in order to get a more full field list for filtering
     * Normally we only use the call for non-visible modules since we dont store their filterable fields in metadata.
     */
    needForcedAPICall: [
        'pmse_Inbox',
    ],

    /**
     * Array of filter definitions in readble format
     */
    readableFilterDef: [],
    /**
     * Source module for the filter definition
     */
    sourceModule: '',
    /**
     * The filter defs
     */
    filterDefs: {},
    /**
     * Operator map associated with filterable fields
     */
    filterOperatorMap: {},

    /**
     * @override
     * @protected
     * @chainable
     */
    _render: function() {
        var self = this;
        if (this.action === 'list' && !this.fieldList || _.isEmpty(this.fieldList)) {
            this.loadFieldList(false, function() {
                self.isFetchingOptions = false;

                //Re-render widget since we have fresh options list
                if (!this.disposed) {
                    this.render();
                }
            });
            if (this.isFetchingOptions) {
                // Set loading message in place of empty DIV while options are loaded via API
                this.$el.html('<div class="select2-loading">' + app.lang.get('LBL_LOADING') + '</div>');
                return this;
            }
        }
        app.view.Field.prototype._render.call(this);
    },

    /**
     * Load the options for this field and pass them to callback function.  May be asynchronous.
     * @param {boolean} fetch (optional) Force use of DataArchiver API to load FieldDefs.
     * @param {Function} callback (optional) Called when fieldList is available.
     */
    loadFieldList: function(fetch, callback, error) {
        var self = this;
        var _module = this.module;
        var _fieldsKey = 'cache:' + _module + ':fieldDefs';

        if (!_.isUndefined(app.metadata.getModule(_module)) && !this.needForcedAPICall.includes(_module)) {
            this.fieldList = app.data.getBeanClass('Filters').prototype.getFilterableFields(_module);
            if (_.isUndefined(this.fieldList.deleted)) {
                this.fieldList.deleted = app.metadata.getField({module: _module, name: 'deleted'});
            }
        } else {
            this.fieldList = undefined;
        }

        fetch = fetch || false;

        if (fetch || !this.fieldList) {
            this.isFetchingOptions = true;
            var _key = 'request:' + _module + ':fieldDefs';
            var request;
            //if previous request is existed, ignore the duplicate request
            if (this.context.get(_key)) {
                request = this.context.get(_key);
                request.xhr.done(_.bind(function(o) {
                    if (this.fieldList !== o) {
                        this.fieldList = o;
                        callback.call(this);
                    }
                }, this));
            } else {
                var url = app.api.buildURL('metadata/' + _module + '/fields', null, null, {});
                request = app.api.call('read', url, null, {
                    success: function(results) {
                        if (self.disposed) {
                            return;
                        }
                        self.fieldList = results;
                        self.context.set(_fieldsKey, self.fieldList);
                    },
                    error: function(e) {
                        if (self.disposed) {
                            return;
                        }

                        if (error) {
                            error(e);
                        }

                        // Continue to use Sugar7's default error handler.
                        if (_.isFunction(app.api.defaultErrorHandler)) {
                            app.api.defaultErrorHandler(e);
                        }
                    },
                    complete: function() {
                        if (!self.disposed) {
                            self.context.unset(_key);
                            callback.call(self);
                        }
                    }
                });
                this.context.set(_key, request);
            }
        }
    },

    /**
     * @inheritdoc
     *
     * Format the value to a string.
     * Return an empty string for undefined, null and object types.
     * Convert boolean to True or False.
     * Convert array, int and other types to a string.
     *
     * @param {string} the filter def in string format
     * @return {string} the formatted value
     */
    format: function(value) {
        this.readableFilterDef = [];
        this.sourceModule = this.module;
        this.filterDefs = JSON.parse(value);
        this.filterOperatorMap = app.metadata.getFilterOperators(this.sourceModule);

        _.each(this.filterDefs, function(def) {
            this.readableFilterDef.push(this.parseDef(def));
        }, this);

        return this.readableFilterDef.join(',\n');
    },

    /**
     * Responsible for parsing through the filterDef and creating a human readable string
     * @param def the filter definition line to be parsed
     * @return {string} the filter definition line in human readable format
     */
    parseDef: function(def) {
        // Create an object that will be referenced through the chain of private methods that need to be called
        this.readableString = {
            keyStringReadable: '',
            operatorStringReadable: '',
            valueStringReadable: '',
            toString: function() {
                return this.keyStringReadable + ' ' + this.operatorStringReadable + ' ' + this.valueStringReadable;
            }
        };

        // Call the first method in the chain
        _.each(def, function(value, key) {
            var keyValuePair = new app.utils.FilterOptions().keyValueFilterDef(key, value, this.fieldList);
            key = keyValuePair[0];
            value = keyValuePair[1];

            // Set readableString object
            this.readableString.keyStringReadable = this._getKeyString(key, value);
            this.readableString.operatorStringReadable = this._getOperatorString(key, value);
            this.readableString.valueStringReadable = this._getValueString(key, value);
        }, this);

        // Return the readable string to be displayed
        return this.readableString.toString();
    },

    /**
     * Add the key string to the readableString object
     * @param key
     * @param value
     * @private
     */
    _getKeyString: function(key, value) {
        // Get the key string in readable format
        return app.lang.get(this.fieldList[key].vname, this.sourceModule);
    },

    /**
     * Add the operator string to the readableString object
     * @param key
     * @param value
     * @private
     */
    _getOperatorString: function(key, value) {
        // Get the operator string in a readable format
        var fieldName = key;
        var fieldOperator = Object.keys(value)[0];
        var fieldType = this.fieldTypeMap[this.fieldList[fieldName].type] || this.fieldList[fieldName].type;

        var operatorStringReadable = app.lang.get(this.filterOperatorMap[fieldType][fieldOperator], 'Filters');
        return _.isUndefined(operatorStringReadable) ? '' : operatorStringReadable;
    },

    /**
     * Add the value string to the readableString object
     * @param value
     * @param fieldOperator
     * @param fieldType
     * @private
     */
    _getValueString: function(key, value) {
        // Get the value string in a readable format
        var operatorsWithNoValues = ['$empty', '$not_empty'];

        var fieldName = key;
        var fieldOperator = Object.keys(value)[0];
        var fieldType = this.fieldTypeMap[this.fieldList[fieldName].type] || this.fieldList[fieldName].type;

        var value = value[fieldOperator];

        var valueStringReadable = '';

        // Depending on the type of value, it is rendered differently
        if (_.contains(operatorsWithNoValues, fieldOperator)) {
            valueStringReadable = '';
        } else if (_.isArray(value)) {
            valueStringReadable = value.join(' or ');
        } else if (fieldType === 'bool') {
            valueStringReadable = Boolean(value).toString();
        } else if (fieldType === 'currency') {
            valueStringReadable = app.currency.formatAmount(value.amount, value.currency_id, 2);
        } else {
            valueStringReadable = value.toString();
        }

        return valueStringReadable;
    },
}) },
"radioenum": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RadioenumField
 * @alias SUGAR.App.view.fields.BaseRadioenumField
 * @extends View.Fields.Base.EnumField
 */
({
	// Radioenum Field (base) 

    // On list-edit template,
    // we want the radio buttons to be replaced by a select so each method must call the EnumField method instead.
    extendsFrom: 'EnumField',
    plugins: ["ListEditable"],
    fieldTag: "input",

    _render: function(){
        this.loadEnumOptions(false, function() {
                if (!this.disposed) {
                    this.render();
                }
            }
        );
        app.view.Field.prototype._render.call(this);
        if(this.tplName === 'list-edit') {
            this._super("_render");
        }
    },
    bindDomChange: function() {
        if (this.tplName === 'list-edit') {
            this._super("bindDomChange");
        } else {
            if (!(this.model instanceof Backbone.Model)) return;
            var self = this;
            var el = this.$el.find(this.fieldTag);
            el.on("change", function() {
                self.model.set(self.name, self.unformat(self.$(self.fieldTag+":radio:checked").val()));
            });
        }
    },
    format: function(value) {
        if (this.tplName === 'list-edit') {
            return this._super("format", [value]);
        } else {
            return app.view.Field.prototype.format.call(this, value);
        }
    },
    unformat: function(value) {
        if (this.tplName === 'list-edit') {
            return this._super("unformat", [value]);
        } else {
            return app.view.Field.prototype.unformat.call(this, value);
        }
    },
    decorateError: function(errors) {
        if (this.tplName === 'list-edit') {
            return this._super("decorateError", [errors]);
        } else {

            var errorMessages = [],
                $tooltip;

            // Add error styling
            this.$el.closest('.record-cell').addClass('error');
            this.$el.addClass('error');
            // For each error add to error help block
            _.each(errors, function(errorContext, errorName) {
                errorMessages.push(app.error.getErrorString(errorName, errorContext));
            });
            this.$(this.fieldTag).last().closest('p').append(this.exclamationMarkTemplate(errorMessages));
            $tooltip = this.$('.error-tooltip');
            if (_.isFunction($tooltip.tooltip)) {
                var tooltipOpts = { container: 'body', placement: 'top', trigger: 'click' };
                $tooltip.tooltip(tooltipOpts);
            }
        }
    },
    clearErrorDecoration: function() {
        if (this.tplName === 'list-edit') {
            return this._super("clearErrorDecoration");
        } else {
            var ftag = this.fieldTag || '';
            // Remove previous exclamation then add back.
            this.$('.add-on').remove();
            this.$el.removeClass(ftag);
            this.$el.removeClass("error");
            this.$el.closest('.record-cell').removeClass("error");
        }
    }
}) },
"float": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FloatField
 * @alias SUGAR.App.view.fields.BaseFloatField
 * @extends View.Fields.Base.BaseField
 */
({
	// Float Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     *
     * Unformats the float based on userPreferences (grouping/decimal separator).
     * If we weren't able to parse the value, the original value is returned.
     *
     * @param {String} value the formatted value based on user preferences.
     * @return {Number|String} the unformatted value, or original string if invalid.
     */
    unformat: function(value) {
        var unformattedValue = app.utils.unformatNumberStringLocale(value);

        // if we got a number back and we have a precision we should round to that precision as that is what will
        // be stored in the db, this is needed just in case SugarLogic is used on this field's value
        if (_.isFinite(unformattedValue) && this.def && this.def.precision) {
            unformattedValue = app.math.round(unformattedValue, this.def.precision, true);
        }
        // if unformat failed, return original value
        return _.isFinite(unformattedValue) ? unformattedValue : value;

    },

    /**
     * @inheritdoc
     *
     * Formats the float based on user preferences (grouping separator).
     * If the field definition has `disabled_num_format` as `true` the value
     * won't be formatted. Also, if the value isn't a finite float it will
     * return `undefined`.
     *
     * @param {Number} value the float value to format as per user preferences.
     * @return {String|undefined} the formatted value based as per user
     *   preferences.
     */
    format: function(value) {
        if (this.def.disable_num_format || _.isNull(value)|| _.isUndefined(value) || _.isNaN(value)) {
            return value;
        }

        var number_grouping_separator = app.user.getPreference('number_grouping_separator') || ',';
        var decimal_separator = app.user.getPreference('decimal_separator') || '.';

        if (_.isUndefined(this.def.precision) || !this.def.precision) {
            return app.utils.addNumberSeparators(
                value.toString(),
                number_grouping_separator,
                decimal_separator
            );
        }

        return app.utils.formatNumber(
            value,
            this.def.precision,
            this.def.precision,
            number_grouping_separator,
            decimal_separator
        );
    }
}) },
"badge-select": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.BadgeSelectField
 * @alias SUGAR.App.view.fields.BaseBadgeSelectField
 * @extends View.Fields.Base.EnumField
 */
({
	// Badge-select Field (base) 

    extendsFrom: 'EnumField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        if (this.view && this.view.layout) {
            this.view.layout.on('headerpane:adjust_fields', this.repositionDropdown, this);
        }
        /**
         * An object where its keys map to specific status and color to matching
         * CSS classes.
         */
        this.statusClasses = {
            'important': 'label-important',
            'warning': 'label-warning',
            'pending': 'label-pending',
            'success': 'label-success',
            'info': 'label-info',
            'inverse': 'label-inverse',
            'unknown': 'label-unknown',
            'log': 'label-log'
        };
    },

    /**
     * Resets position of status dropdown if Select2 is active and open
     * and the position of the Select2 container is shifted, which happens
     * when other fields in the headerpane are hidden on status edit
     */
    repositionDropdown: function() {
        var $el = this.$(this.fieldTag).select2('container');

        if ($el.hasClass('select2-dropdown-open')) {
            this.$(this.fieldTag).data('select2').dropdown.css({'left': $el.offset().left});
        }
    },

    /**
     * @inheritdoc
     *
     * This field renders as a badge when not in edit mode and as an enum when
     * in edit mode.
     *
     * @private
     */
    _loadTemplate: function() {
        if (this.action === 'edit') {
            this.type = 'enum';
        }

        this._super('_loadTemplate');
        this.type = 'badge-select';
    },

    /**
     * @inheritdoc
     *
     * Convert model value to dropdown value based on key.
     *
     * @param {Array/Object/string/number/boolean} value The value to format.
     * @return {string} the formatted value based on view name.
     */
    format: function(value) {
        this.statusClass = this.styleLabel(value);

        return value;
    },

    /**
     * Returns the appropriate CSS class on the label based on the value of the
     * status.
     *
     * It is a noop when the field is in edit mode.
     *
     * @param {string} status
     */
    styleLabel: function(status) {
        if (this.action === 'edit') {
            return;
        }
        if (this.action === 'disabled') {
            return 'label-disabled';
        }
        return this.statusClasses[status];
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.view && this.view.layout) {
            this.view.layout.off(null, null, this);
        }

        this._super('_dispose');
    }
}) },
"rowactions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RowactionsField
 * @alias SUGAR.App.view.fields.BaseRowactionsField
 * @extends View.Fields.Base.ActiondropdownField
 */
({
	// Rowactions Field (base) 

    extendsFrom: 'ActiondropdownField',

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        //FIXME: SC-3372 Actions should not be based on `this.view.action`

        // check to see if this is a create subpanel
        var isCreate = this.context.get('isCreateSubpanel') || false,
            shouldHide = (this.view.action === 'list' && this.action === 'edit');
        // if this is a create subpanel, trump other logic as rowactions needs to be shown on edit
        if (isCreate || !shouldHide) {
            this.show();
        } else {
            this.hide();
        }
    }
}) },
"friendly-time": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * FriendlyTime displays a duration in a human-readable manner.
 *
 * @class View.Fields.Base.FriendlyTimeField
 * @alias SUGAR.App.view.fields.BaseFriendlyTimeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Friendly-time Field (base) 

    _baseUnit: 'minutes',

    /**
     * Display the duration in a human-friendly manner.
     *
     * @param {number} elapsed Elapsed time.
     * @return {string} Human-readable representation of the duration.
     * @override
     */
    format: function(elapsed) {
        if (_.isUndefined(elapsed) || _.isNull(elapsed)) {
            return app.lang.get('LBL_NO_DATA');
        } else if (elapsed === 0) {
            return this._getZeroDurationString();
        }

        var duration = app.date.duration(elapsed, this._baseUnit);
        return duration.format() || this._getZeroDurationString();
    },

    /**
     * Get the "zero" duration string.
     *
     * @return {string} The way to display a duration of 0.
     * @private
     */
    _getZeroDurationString: function() {
        return '0 ' + app.lang.get('LBL_DURATION_' + this._baseUnit.toUpperCase());
    }
}) },
"deleterecurrencesbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * DeleterecurrencesbuttonField is a field for Meetings/Calls for the ability to delete all recurring events for a parent record
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.DeleterecurrencesbuttonField
 * @alias SUGAR.App.view.fields.BaseDeleterecurrencesbuttonField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Deleterecurrencesbutton Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     * @param {Object} options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * @inheritdoc
     *
     *  The field is hidden if event is not a recurring calendar event
     */
    _render: function() {
        if (_.isEmpty(this.model.get('repeat_type'))) {
            this.hide();
        } else {
            this._super('_render');
        }
    },

    /**
     * Renders the field when the status on the record changes.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:repeat_type', this.render, this);
        }
    },

    /**
     * Event handler for deleting all recurring calendar events of a series
     * @inheritdoc
     */
    rowActionSelect: function() {
        app.alert.show('delete_recurrence_confirmation', {
            title: app.lang.get('LBL_REMOVE_ALL_RECURRENCES', this.module),
            level: 'confirmation',
            messages: this.getDeleteMessages().confirmation,
            onConfirm: _.bind(this.deleteRecurrences, this)
        });
    },

    /**
     * Calls destroy on the model and makes api call to delete all recurring calendar events in a series.
     * Navigates to the list view on success.
     */
    deleteRecurrences: function() {
        this.model.destroy({
            params: {'all_recurrences': true},
            showAlerts: {
                'process': true,
                'success': {
                    messages: this.getDeleteMessages().success
                }
            },
            success: _.bind(function() {
                var route = '#' + this.module,
                    currentRoute = '#' + Backbone.history.getFragment();
                (currentRoute === route) ? app.router.refresh() : app.router.navigate(route, {trigger: true});
            }, this)
        });
    },

    /**
     * Formats the messages to display in the alerts when deleting recurrences.
     *
     * @return {Object} The list of messages.
     * @return {string} return.confirmation Confirmation message.
     * @return {string} return.success Success message.
     */
    getDeleteMessages: function() {
        var messages = {};
        var model = this.model;
        var name = app.utils.getRecordName(model);
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name.trim();

        messages.confirmation = app.lang.get('LBL_CONFIRM_REMOVE_ALL_RECURRENCES', this.module);
        messages.success = app.utils.formatString(app.lang.get('NTC_DELETE_SUCCESS'), [context]);
        return messages;
    }
}) },
"name": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.NameField
 * @alias SUGAR.App.view.fields.BaseNameField
 * @extends View.Fields.Base.BaseField
 */
({
	// Name Field (base) 

    plugins: ['FocusDrawer', 'MetadataEventDriven'],

    _render: function() {
        // FIXME: This will be cleaned up by SC-3478.
        if (['audit', 'side-drawer-headerpane'].includes(this.view.name)) {
            this.def.link = false;
        } else if (this.view.name === 'preview') {
            this.def.link = _.isUndefined(this.def.link) ? true : this.def.link;
            this.def.events = false;
        }
        this._super('_render');
    },

    /**
     * Used by the FocusDrawer plugin to get the ID of the record this field
     * links to
     *
     * @return {string} the ID of the related record
     */
    getFocusContextModelId: function() {
        return this.model && this.model.get('id') ? this.model.get('id') : '';
    },

    /**
     * Used by the FocusDrawer plugin to get the name of the module this
     * field links to
     *
     * @return {string} the name of the related module
     */
    getFocusContextModule: function() {
        return this.model && this.model.get('_module') ? this.model.get('_module') : '';
    },

    /**
     * Called by record view to set max width of inner record-cell div
     * to prevent long names from overflowing the outer record-cell container
     */
    setMaxWidth: function(width) {
        this.$el.css({'max-width': width});
    },

    /**
     * Return the width of padding on inner record-cell
     */
    getCellPadding: function() {
        let padding = 0;
        let $cell = this.$('.dropdown-toggle');

        if ($cell.length > 0) {
            padding = parseInt($cell.css('padding-left'), 10) + parseInt($cell.css('padding-right'), 10);
        }

        return padding;
    }
}) },
"sidebartoggle": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Sidebar toggle field that is used in the RHS layout toggle (show/hide).
 *
 * Some events have been deprecated in 7.2 and removed.
 * List of changes:
 *
 * - `sidebarRendered` has been removed. Now, when the field renders it calls
 *    {@link Layout.Default#isSidePaneVisible} directly to get the current
 *    state.
 *
 * - `toggleSidebar` has been removed. Triggers `sidebar:toggle` instead.
 *
 * - `toggleSidebarArrows` has been removed. Listens to `sidebar:state:changed`
 *    instead.
 *
 * - `openSidebarArrows` has been removed. Listens to `sidebar:state:changed`
 *    instead.
 *
 * - The app event `app:toggle:sidebar` has been removed. Listen to
 *   `sidebar:state:changed` instead.
 *
 * @class View.Fields.Base.SidebartoggleField
 * @alias SUGAR.App.view.fields.BaseSidebartoggleField
 * @extends View.Fields.Base.BaseField
 */
({
	// Sidebartoggle Field (base) 

    events: {
        'click': 'toggle'
    },

    /**
     * Store the current `open` or `close` state
     *
     * @type {String}
     */
    _state: 'open',

    /**
    * @inheritdoc
    */
    _render: function() {

        /**
        * Sets the appropriate aria-label value depending on current _state property
        *
        * @property {string}
        */
        this.ariaLabel = this._state === 'open' ?
            app.lang.get('LBL_DASHLET_MINIMIZE', this.module) :
            app.lang.get('LBL_DASHLET_MAXIMIZE', this.module);
        this.ariaLabel += ' ' + app.lang.get('LBL_DASHBOARD', this.module);

        /**
        * Sets the appropriate font awesome icon class name depending on current _state property
        *
        * @property {string}
        */
        this.iconClass = `sicon-arrow-${this._state === 'open' ? 'right' : 'left'}-double`;

        /**
        * Stores tooltips placement value according to the direction of
        * language being used.
        *
        * @property {string}
        */
        this.dataPlacement = app.lang.direction === 'rtl' ? 'right' : 'left';

        this._super('_render');

        return this;
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout && _.isFunction(defaultLayout.isSidePaneVisible)) {
            this.toggleState(defaultLayout.isSidePaneVisible() ? 'open' : 'close');
            this.listenTo(defaultLayout, 'sidebar:state:changed', this.toggleState);
        }

        //shortcut keys
        app.shortcuts.register({
            id: 'Sidebar:Toggle',
            keys: 't',
            component: this,
            description: 'LBL_SHORTCUT_SIDEBAR_TOGGLE',
            handler: this.toggle
        });
    },

    /**
     * Toggle the `open` or `close` class of the icon.
     *
     * @param {String} [state] The state. Possible values: `open` or `close`.
     */
    toggleState: function(state) {
        if (state !== 'open' && state !== 'close') {
            state = (this._state === 'open') ? 'close' : 'open';
        }
        this._state = state;

        $('#content').toggleClass('sidebar-visible', this._state === 'open');

        if (!this.disposed) {
            this.render();
        }
    },

    /**
     * Toggle the sidebar.
     *
     * @param {Event} event The `click` event.
     */
    toggle: function(event) {
        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            defaultLayout.trigger('sidebar:toggle');
        }
    }
}) },
"cab": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.CabField
 * @alias SUGAR.App.view.fields.BaseCabField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Cab Field (base) 

    events: {
        'click [data-cab]': 'actionClicked'
    },

    extendsFrom: 'ButtonField',

    /**
     * Handle click.
     *
     * @param {Event} evt Mouse event.
     */
    actionClicked: function(evt) {
        if (this.preventClick(evt) === false) {
            return;
        }
        var action = $(evt.currentTarget).data('cab');
        this.runAction(evt, action);
    },

    /**
     * Run action to handle click event.
     *
     * @param {Event} evt Mouse event.
     * @param {string} action Action name.
     */
    runAction: function(evt, action) {
        if (!action) {
            return;
        }
        if (_.isFunction(this[action])) {
            this[action](evt, this.def.params);
        } else if (_.isFunction(this.view[action])) {
            this.view[action](evt, this.def.params);
        }
    }
}) },
"actionmenu": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Actionmenu is an {@link View.Fields.Base.ActiondropdownField actiondropdown}
 * with a checkbox as the default action.
 *
 * Supported Properties:
 *
 * - {Boolean} disable_select_all_alert Boolean telling if we should show the
 *   'select all' and 'clear all' alerts when all checkboxes are checked.
 *   `true` to hide alerts. `false` to display them. Defaults to `false`.
 *
 * @class View.Fields.Base.ActionmenuField
 * @alias SUGAR.App.view.fields.BaseActionmenuField
 * @extends View.Fields.Base.ActiondropdownField
 */
({
	// Actionmenu Field (base) 

    extendsFrom: 'ActiondropdownField',

    /** Initializes the actionmenu field.
     *
     * Sets the property no_default_action to `true` because the checkbox will
     * always be the default action and it's handled separately.
     * See {@link View.Fields.Base.ActiondropdownField} for properties
     * documentation.
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.events = _.extend({}, this.events, {
            'click [data-check=all]': 'checkAll',
            'click [data-check=one]': 'check'
        });

        this.def.no_default_action = true;
        this.def.css_class = this.def.css_class + ' actionmenu';
        /**
         * The checkbox tag.
         *
         * @property {string}
         */
        this.fieldTag = 'input[type=checkbox]';

        /**
         * The mass collection the actionmenu field is related to.
         *
         * @property {Data.BeanCollection} massCollection
         */
        this.massCollection = this.context.get('mass_collection');

        this.def.disable_select_all_alert = !!this.def.disable_select_all_alert;

        if (this.options.viewName === 'list-header') {
            this.isCheckAllCheckbox = true;
        }

        if (this.isCheckAllCheckbox) {
            app.shortcuts.register({
                id: 'SelectAll:Checkbox',
                keys: 'mod+a',
                component: this,
                description: 'LBL_SHORTCUT_SELECT_ALL',
                handler: function() {
                    if (!this.isDisabled()) {
                        this.$('[data-check=all]:visible').click();
                    }
                }
            });
            app.shortcuts.register({
                id: 'SelectAll:Dropdown',
                keys: 'm',
                component: this,
                description: 'LBL_SHORTCUT_OPEN_MASS_ACTION',
                handler: function() {
                    var $dropdown = this.$(this.actionDropDownTag);
                    if ($dropdown.is(':visible') && !$dropdown.hasClass('disabled')) {
                        $dropdown.click();
                    }
                }
            });
        }
    },

    /**
     * Calls {@link #toggleSelect} to help pass the information to the context.
     */
    check: function() {
        var $checkbox = this.$(this.fieldTag);
        var isChecked = $checkbox.is(':checked');
        this.toggleSelect(isChecked);
    },

    /**
     * Sends an event to the context to add or remove the model from the mass
     * collection.
     *
     * @param {boolean} checked `true` to pass the model to the mass collection,
     *   `false` to remove it.
     */
    toggleSelect: function(checked) {
        var event = !!checked ? 'mass_collection:add' : 'mass_collection:remove';
        this.context.trigger(event, this.model);
    },

    /**
     * Selects or unselects all records that are in the current collection.
     *
     * @param {Event} The `click` or `keydown` event.
     */
    checkAll: function(event) {
        var $checkbox = this.$(this.fieldTag);
        if ($(event.target).hasClass('checkall') || event.type === 'keydown') {
            $checkbox.prop('checked', !$checkbox.is(':checked'));
        }
        var isChecked = $checkbox.is(':checked');
        this.toggleAll(isChecked);

        this.toggleCheckAllCheckboxTooltip($checkbox, isChecked);
    },

    /**
     * Sends an event to the context to add or remove all models from the mass
     * collection.
     *
     * @param {boolean} checked `true` to pass all models in the collection to
     *   the mass collection, `false` to remove them.
     *
     *
     * FIXME : Doing this way is slow to check all checkboxes when there
     * are more than 20. We should check checkboxes before adding records to
     * the mass collection SC-4079 will address this problem.
     */
    toggleAll: function(checked) {
        var event = checked ? 'mass_collection:add:all' : 'mass_collection:remove:all';
        this.context.trigger(event, this.model);
    },

    /**
     * Binds mass collection events to a record row checkbox.
     *
     * @private
     */
    _bindModelChangeEvents: function() {
        this.massCollection.on('add', function(model) {
            if (this.model && model.id === this.model.id) {
                this.$(this.fieldTag).prop('checked', true);
            }
        }, this);

        this.massCollection.on('remove', function(model) {
            if (this.model && model.id === this.model.id) {
                this.$(this.fieldTag).prop('checked', false);
            }
        }, this);

        this.massCollection.on('reset', function() {
            this.$(this.fieldTag).prop('checked', !!this.massCollection.get(this.model.id));
        }, this);
    },

    /**
     * Binds mass collection events to 'select-all' checkbox, the one used to check/
     * uncheck all record row checkboxes.
     *
     * @private
     */
    _bindAllModelChangeEvents: function() {
        // Checks/selects the actionmenu checkbox if the checkboxes of each
        // row are all checked.
        this.massCollection.on('all:checked', function() {
            if (this.collection.length !== 0) {
                this.$(this.fieldTag).prop('checked', true);
                this.toggleCheckAllCheckboxTooltip($(this.fieldTag), true);
            }
        }, this);

        // Unchecks/deselects the actionmenu checkbox if the checkboxes of
        // each row are NOT all checked.
        this.massCollection.on('not:all:checked', function() {
            this.$(this.fieldTag).prop('checked', false);
            this.toggleCheckAllCheckboxTooltip($(this.fieldTag), false);
        }, this);

        this.massCollection.on('add', this._onMassCollectionAddAll, this);
        this.massCollection.on('remove reset', this._onMassCollectionRemoveResetAll, this);
    },

    /**
     * Handler for the {@link Bean.Collection massCollection} `add` event.
     *
     * @private
     */
    _onMassCollectionAddAll: function() {
        this.setDropdownDisabled(false);
        if (!this.def.disable_select_all_alert) {
            this.context.trigger('toggleSelectAllAlert');
            this.setButtonsDisabled(this.dropdownFields);
        }
    },

    /**
     * Handler for the {@link Bean.Collection massCollection} `remove` and
     * `reset` events.
     *
     * @private
     */
    _onMassCollectionRemoveResetAll: function() {
        var massCollectionIds = _.pluck(this.massCollection.models, 'id');
        var viewCollectionIds = _.pluck(this.collection.models, 'id');
        if (this.massCollection.length === 0) {
            this.setDropdownDisabled(true);
            //massCollection.models could only have 'id' as an attribute,
            //so we need to compare ids instead of models directly.
        } else if (_.intersection(massCollectionIds, viewCollectionIds).length !== 0) {
            this.setDropdownDisabled(false);
            this.$(this.fieldTag).prop('checked', true);
        }
        if (!this.def.disable_select_all_alert) {
            this.context.trigger('toggleSelectAllAlert');
            this.setButtonsDisabled(this.dropdownFields);
        }
    },

    /**
     * @override
     *
     * Binds events on the collection, and updates the checkboxes
     * consequently.
     */
    bindDataChange: function() {
        if (this.isCheckAllCheckbox) {
            // Listeners on the checkAll/uncheckAll checkbox.
            this._bindAllModelChangeEvents();
            this.action_enabled = this.massCollection.length > 0;
            this.tabIndex = this.action_enabled ? 0 : -1;
        } else {
            // Listeners for each record selection.
            this._bindModelChangeEvents();
        }

        this.massCollection.on('massupdate:estimate', this.onTotalEstimate, this);
    },

    /**
     * Toggles the actionmenu buttons according to the buttons definition and
     * the number of selected records.
     *
     * @param {Object} fields List of the view's fields.
     * @param {number} massCollectionLength The number of selected records.
     */
    setButtonsDisabled: function(fields) {
        _.each(fields, function(field) {
            if (field.def.minSelection || field.def.maxSelection) {
                var min = field.def.minSelection || 0,
                    max = field.def.maxSelection || this.massCollection.length;
                if (this.massCollection.length < min || this.massCollection.length > max) {
                    field.setDisabled(true);
                } else {
                    field.setDisabled(false);
                }
            }
        }, this);
    },

    /**
     * @inheritdoc
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');
        if (this.view.action === 'list' && this.action === 'edit') {
            this.template = app.template.empty;
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (!this.isCheckAllCheckbox) {
            // If the model is in the mass collection, make sure the checkbox
            // is checked.
            if (this.massCollection.get(this.model.id)) {
                this.selected = true;
            } else {
                delete this.selected;
            }
        }

        this._super('_render');

        if (this.isCheckAllCheckbox && !this.def.disable_select_all_alert) {
            this.setButtonsDisabled(this.dropdownFields);
            this.setDropdownDisabled(this.massCollection.length === 0);
        }
    },

    /**
     * Since we don't have a default action button we don't need
     * to render anything here. See {@link View.Fields.Base.ActiondropdownField#_renderFields}.
     *
     * @override
     * @protected
     */
    _renderFields: $.noop,

    /**
     * Update the dropdown usability while the total count is estimating.
     */
    onTotalEstimate: function() {
        this.setDropdownDisabled(!this.massCollection.fetched);
    },

    /**
     * Disable the dropdown action.
     *
     * @param {Boolean} [disable] `true` to disable the dropdown action, `false`
     * to enable it.
     */
    setDropdownDisabled: function(disable) {
        this.$(this.actionDropDownTag)
            .toggleClass('disabled', disable)
            .attr('aria-haspopup', !disable)
            .attr('tabindex', disable ? -1 : 0);
    },

    /**
     * @inheritdoc
     */
    _getChildFieldsMeta: function() {
        // We only get the fields (the dropdown actions) metadata for the
        // checkAll/uncheckAll checkbox. Actionmenu fields tied to a model are
        // a simple checkbox and don't have metadata.
        if (this.model.id) {
            return;
        }
        return this._super('_getChildFieldsMeta');
    },

    /**
     * Update the tooltip on the check all checkbox depending on it's checked state
     *
     * @param $checkbox
     * @param isChecked
     */
    toggleCheckAllCheckboxTooltip: function($checkbox, isChecked) {
        if (this.def.is_list_pagination) {
            let $parent = $checkbox.parent();

            let attrName = $parent.attr('title') ? 'title' :
                $parent.attr('data-original-title') ? 'data-original-title' :
                    '';

            if (attrName) {
                $parent.attr(
                    attrName,
                    app.lang.get(isChecked ? 'LBL_LISTVIEW_DESELECT_ALL_ON_PAGE' : 'LBL_LISTVIEW_SELECT_ALL_ON_PAGE')
                );
            }
        }
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        if (this.massCollection) {
            var modelId = this.model.cid,
                cid = this.view.cid;
            this.massCollection.off(null, null, this);
            if (modelId) {
                this.massCollection.off(null, null, modelId);
            }
            if (cid) {
                this.massCollection.off(null, null, cid);
            }
        }
        this._super('unbindData');
    }
}) },
"closebutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * ClosebuttonField is a field for Meetings/Calls/Tasks that handles setting a value on a field in the model based on meta data with
 * an option to create a new record
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.ClosebuttonField
 * @alias SUGAR.App.view.fields.BaseClosebuttonField
 * @extends View.Fields.Base.RowactionField
 */


({
	// Closebutton Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * Setup click event handlers.
     * @inheritdoc
     *
     * @param {Object} options
     */
    initialize: function(options) {
        this.events = _.extend({}, this.events, options.def.events, {
            'click [name="record-close"]': 'closeClicked',
            'click [name="record-close-new"]': 'closeNewClicked'
        });

        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * Handle record close event.
     *
     * @param {Event} event The click event for the close button
     */
    closeClicked: function(event) {
        this._close(false);
    },

    /**
     * Handle record close and create new event.
     *
     * @param {Event} event The click event for the close and create new button
     */
    closeNewClicked: function(event) {
        this._close(true);
    },

    /**
     * @inheritdoc
     *
     * Button should be hidden if record displayed is already closed
     */
    _render: function() {
        if (this.model.get(this.getStatusFieldName()) === this.getClosedStatus()) {
            this.hide();
        } else {
            this._super('_render');
        }
    },

    /**
     * Retrieve the closed status value from the fields meta definition
     *
     * @return {string}
     */
    getClosedStatus: function() {
        return ((this.def && this.def.closed_status) ?
            this.def.closed_status :
            'Completed');
    },

    /**
     * Retrieve the status field name from the field meta definition.
     * Defaults to 'status'
     *
     * @return {string}
     */
    getStatusFieldName: function() {
        return ((this.def && this.def.status_field_name) ?
            this.def.status_field_name :
            'status');
    },

    /**
     * Close the record by setting the appropriate status on the record.
     *
     * @param {boolean} createNew Flag for whether to open a new drawer to create a
     *   record after close.
     * @private
     */
    _close: function(createNew) {
        var self = this;

        this.model.set(this.getStatusFieldName(), this.getClosedStatus());
        this.model.save({}, {
            success: function() {
                self.showSuccessMessage();
                if (createNew) {
                    self.openDrawerToCreateNewRecord();
                }
            },
            error: function(model, error) {
                self.showErrorMessage();
                app.logger.error('Record failed to close. ' + error);

                // we didn't save, revert!
                self.model.revertAttributes();
            }
        });
    },

    /**
     * Open a drawer to create a new record.
     */
    openDrawerToCreateNewRecord: function() {
        var self = this,
            statusField = this.getStatusFieldName(),
            module = app.metadata.getModule(this.model.module),
            prefill = app.data.createBean(this.model.module);

        prefill.copy(this.model);

        if (module.fields[statusField] && module.fields[statusField]['default']) {
            prefill.set(statusField, module.fields[statusField]['default']);
        } else {
            prefill.unset(statusField);
        }

        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                model: prefill
            }
        }, function() {
            if (self.parent) {
                self.parent.render();
            } else {
                self.render();
            }
        });
    },

    /**
     * Display a success message.
     *
     * This message includes the value the status field was set to - so we need
     * to retrieve the translated string (if there is one).
     */
    showSuccessMessage: function() {
        var statusField = this.getStatusFieldName(),
            statusFieldMetadata = app.metadata.getModule(this.module).fields[statusField],
            optionStrings,
            statusValue;

        // if this is an enum field, retrieve translated value
        if (statusFieldMetadata && statusFieldMetadata.options) {
            optionStrings = app.lang.getAppListStrings(statusFieldMetadata.options);
            statusValue = optionStrings[this.getClosedStatus()].toLocaleLowerCase();
        } else {
            // not an enum field - just display lowercase version of the value
            statusValue = this.getClosedStatus().toLocaleLowerCase();
        }

        app.alert.show('status_change_success', {
            level: 'success',
            autoClose: true,
            messages: app.lang.get('TPL_STATUS_CHANGE_SUCCESS',
                this.module,
                {
                    moduleSingular: app.lang.getModuleName(this.module),
                    status: statusValue
                }
            )
        });
    },

    /**
     * Display an error message.
     */
    showErrorMessage: function() {
        app.alert.show('close_record_error', {
            level: 'error',
            title: app.lang.get('ERR_AJAX_LOAD')
        });
    },

    /**
     * Re-render the field when the status on the record changes.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:status', this.render, this);
        }
    }
}) },
"save-and-send-invites-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * SaveAndSendInvitesButtonField field is a field for Meetings/Calls that handles setting the flag for sending emails to guests
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.SaveAndSendInvitesButtonField
 * @alias SUGAR.App.view.fields.BaseSaveAndSendInvitesButtonField
 * @extends View.Fields.Base.RowactionField
 *
 */
({
	// Save-and-send-invites-button Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     *
     * Sets the type to "rowaction" so that the templates are loaded from
     * super.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * Setting model event to allow unsetting of send_invites after validation error or data sync completed.
     * @inheritdoc
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }

        this.model.on('error:validation data:sync:complete', function() {
            this.model.unset('send_invites');
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Silently sets `send_invites` to true on the model before saving.
     */
    rowActionSelect: function(event) {
        this.model.set('send_invites', true, {silent: true});
        this._super('rowActionSelect', [event]);
    }
}) },
"hint-news-dashlet-search": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.HintNewsDashletSearchField
 * @alias SUGAR.App.view.fields.BaseHintNewsDashletSearchField
 * @extends View.Fields.Base.BaseField
 */
({
	// Hint-news-dashlet-search Field (base) 

    events: {
        'click #hint-news-dashlet-searchbtn': 'filterNews',
        'click #hint-news-dashlet-resetbtn': 'resetFilter',
        'keyup #hint-news-dashlet-searchinput': 'filterOnEnter'
    },

    /**
     * Filter news
     */
    filterNews: function() {
        app.events.trigger('hint-news-dashlet:search', this.searchInput.val());
    },

    /**
     * Filter on enter key
     *
     * @param {Object} event
     */
    filterOnEnter: function(event) {
        var key = event.which || event.keyCode;
        if (key === 13) {
            this.filterNews();
        }
        this.toggleResetButton();
    },

    /**
     * Reset filter
     */
    resetFilter: function() {
        this.searchInput.val('');
        this.toggleResetButton();
        this.filterNews();
    },

    /**
     * Toggle reset button
     */
    toggleResetButton: function() {
        if (this.searchInput.val()) {
            this.resetButton.removeClass('hide');
        } else {
            this.resetButton.addClass('hide');
        }
    },

    /**
     * Apply search term
     *
     * @param {string} term
     */
    applySearchTerm: function(term) {
        this.searchInput.val(term);
        this.toggleResetButton();
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        app.events.on('hint-news-dashlet:apply', this.applySearchTerm, this);
        this._super('_render');
        this.resetButton = this.$el.find('#hint-news-dashlet-resetbtn');
        this.searchInput = this.$el.find('#hint-news-dashlet-searchinput');
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        app.events.off('hint-news-dashlet:apply', this.applySearchTerm, this);
        this._super('_dispose');
    }
}) },
"favorite": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FavoriteField
 * @alias SUGAR.App.view.fields.BaseFavoriteField
 * @extends View.Fields.Base.BaseField
 */
({
	// Favorite Field (base) 


    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    'events': {
        'click .btn': 'toggle'
    },

    /**
     * @inheritdoc
     *
     * The favorite is always a readonly field.
     */
    initialize: function(options) {
        options.def.readonly = true;
        // We change the field name to be 'my_favorite' because that's the name in
        // the vardefs and thus in the model attributes. Since the model listens
        // to `my_favorite` for several events ('change:my_favorite',
        // 'acl:change:my_favorite', 'error:validation:my_favorite', ...), the
        // names need to be equal.
        options.def.name = 'my_favorite';

        this._super('initialize', [options]);
    },

    /**
     * Check first if the module has favoritesEnabled before rendering it.
     *
     * @private
     */
    _render: function() {
        // can't favorite something without an id
        if (!this.model.get('id')) {
            return null;
        }
        if (!app.metadata.getModule(this.model.module).favoritesEnabled) {
            app.logger.error("Trying to use favorite field on a module that doesn't support it: '" + this.model.module + "'.");
            return null;
        }

        if (this.model.isFavorite()) {
            this.iconClass = 'star-fill';
        }

        return app.view.Field.prototype._render.call(this);
    },

    /**
     * Function called for each click on the star icon (normally acts as toggle
     * function).
     *
     * If the star is checked, copy all the source fields to target ones
     * based on the mapping definition of this field. Otherwise, restore all the
     * values of the modified fields by this copy widget.
     *
     * @param {Event} evt
     *   The event (expecting click event) that triggered the checkbox status
     *   change.
     */
    toggle: function(evt) {
        var self = this;
        var star = $(evt.currentTarget);
        var starIcon = star.children().first();

        var options = {
            silent: true,
            alerts: false
        };
        //when we toggle favorite icon on list view we need to update the view to actually see the changes
        if (self.view && self.view.action === 'list') {
            options.success = function() {
                self._refreshListView();
            };
        }

        if (this.model.favorite(!this.model.isFavorite(), options) === false) {
            app.logger.error("Unable to set '" + this.model.module + "' record '" + this.model.id + "' as favorite");
            return;
        }

        let isFavorite = this.model.isFavorite();
        if (isFavorite) {
            star.addClass('active').attr('aria-pressed', true);
            starIcon.removeClass('sicon-star-outline').addClass('sicon-star-fill');
            this.model.trigger("favorite:active");
        } else {
            star.removeClass('active').attr('aria-pressed', false);
            starIcon.removeClass('sicon-star-fill').addClass('sicon-star-outline');
        }
    },

    /**
     * @inheritdoc
     *
     * @return {Boolean}
     */
    format: function() {
        return this.model.isFavorite();
    },

    /**
     * On model save success, this function gets called to refresh the list
     * view.
     *
     * {@link View.Fields.Base.FavoriteField} is using about the same method.
     *
     * @private
     */
    _refreshListView: function() {
        var filterPanelLayout = this.view;
        //Try to find the filterpanel layout
        while (filterPanelLayout && filterPanelLayout.name !== 'filterpanel') {
            filterPanelLayout = filterPanelLayout.layout;
        }
        //If filterpanel layout found and not disposed, then pick the value from the quicksearch input and
        //trigger the filtering
        if (filterPanelLayout && !filterPanelLayout.disposed && this.collection) {
            filterPanelLayout.applyLastFilter(this.collection, 'favorite');
        }
    }
}) },
"filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FilterField
 * @alias SUGAR.App.view.fields.BaseFilterField
 * @extends View.Fields.Base.BaseField
 */
 ({
	// Filter Field (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.initProperties();
        this.initListeners();
        this.setFilterId(this.getModelFilterId());

        this.model.addValidationTask(this.name + '_name_exists', _.bind(this._validateFilterName, this));
    },

    /**
     * @override
     */
    _render: function() {
        this._super('_render');

        if (this.action == 'edit') {
            this.disposeComponents();
            this.renderComponents();
        }
    },

    /**
     * @inheritdoc
     */
    format: function(value) {
        try {
            value = JSON.parse(value).filterName;
        } catch (error) {
            value = null;
        }
        return value;
    },

    /**
     * Validates filter name
     *
     * @protected
     */
    _validateFilterName: function(fields, errors, callback) {
        if (_.isNull(this.filterpanel)) {
            callback(null, fields, errors);
        }

        var context = this.filterpanel.context;
        var model = context.editingFilter;
        var filterName = '';

        if (model instanceof app.Bean) {
            // If filter name is missing, we manually built it
            if (_.isEmptyValue(model.get('name'))) {
                filterName = this.buildFilterName();
                model.set('name', filterName);
            }

            if (model.get('name') == this.filterName) {
                callback(null, fields, errors);
            } else {
                // Continue with the model validation only once the filter model has been saved
                context.listenTo(context, 'filter:add', function filterAdd() {
                    callback(null, fields, errors);
                });

                // Trigger filter save event so to make sure the new filter name is properly stored
                context.trigger('filter:create:save', filterName);
            }
        } else {
            callback(null, fields, errors);
        }
    },

    /**
     * Builds a filter name in case the record is saved without a filter name
     *
     * @return {string} Filter name
     */
    buildFilterName: function() {
        var calendarName = this.model.get('name');

        return 'Calendar: ' + calendarName;
    },

    /**
     * Initialize properties
     */
    initProperties: function() {
        /**
         * Indicates the default filter id used to initialize filter component
         *
         * @param {string}
         */
        this.filterDefaultId = 'assigned_to_me';

        /**
         * Indicates the current filter id used by the filter component. Default is `All <module_name>`
         *
         * @param {string}
         */
        this.filterId = 'all_records';

        /**
         * Indicates the default filter module used by the filter component
         *
         * @param {string}
         */
        this.filterDefaultModule = this.def.module || this.module;

        /**
         * @param {app.data.beanModel}
         */
        this.filterModel = null;

        /**
         * @param {app.data.beanCollection}
         */
        this.filterCollection = null;

        /**
         * @param {app.Context}
         */
        this.filterContext = null;

        /**
         * Indicates the 'filterpanel' layout component
         *
         * @param {app.view.Layout}
         */
        this.filterpanel = null;

        /**
         * Indicates the 'filter' child layout of the 'filterpanel' layout
         *
         * @param {app.view.Layout}
         */
        this.filter = null;

        /**
         * Indicates the name of the field to retrieve the module
         *
         * This field allows creating the filter layout for a module stored on another field of this model.
         * The parameter will keep the name of the source field
         *
         * @param {string}
         */
        this.filterModuleField = this.def.moduleField;

        /**
         * Indicates the loading state of the related module filters.
         * True if filters are still in loading from database,
         * false if they have already been loaded.
         *
         * @param {boolean}
         */
        this.filterLoadInProgress = false;

        /**
         * Indicates the filter name built based on the filter id
         *
         * @param {string}
         */
        this.filterName = null;
    },

    /**
     * Initialize listeners
     */
    initListeners: function() {
        if (_.isString(this.filterModuleField) && !_.isEmptyValue(this.filterModuleField)) {
            this.listenTo(this.model, 'change:' + this.filterModuleField, _.bind(this.onModuleChange, this));
        }

        this.listenTo(this.model, 'change:' + this.name, _.bind(this.onFieldChange, this));
    },

    /**
     * Initialize filter state
     *
     * @param {string} module
     */
    initFilterState: function(module) {
        var linkName = null;
        var filterId = this.filterDefaultId;

        if (this.filter instanceof app.view.Layout) {
            this.filter.initializeFilterState(module, linkName, filterId);
        }
    },

    /**
     * Handles changing module
     *
     * Reinitializes the filter component when module changes
     * Populates the filter component with the new filters
     * Renders the updated filter component
     *
     * @param {app.data.beanModel} model
     * @param {string} module
     */
    onModuleChange: function(model, module) {
        // Do nothing as long as the dynamic module is the same with the one the filter component is built on
        if (this.filterCollection instanceof app.BeanCollection && module == this.filterCollection.moduleName
        ) {
            return;
        }

        // In case the model is reverting its attributes, make sure we use the previous filter id
        if (model.hasChanged(this.name)) {
            this.setFilterId(this.filterId);
        } else {
            this.setFilterId();
        }

        this.initFilterState(module);
        this.initFilterCollection();
        this.loadComponents();
    },

    /**
     * Handles changing field value
     *
     * Updates the current 'filterId' with what is found on model
     *
     * @param {app.data.beanModel} model
     * @param {string} filter
     */
    onFieldChange: function(model, filter) {
        var filterId;

        try {
            filterId = JSON.parse(filter).filterId;
        } catch (e) {
            filterId = '';
        }

        this.setFilterId(filterId);
    },

    /**
     * Handles changing dropdown filter
     *
     * Sets the current 'filterId' and the filter name
     * Makes sure the model value is also updated
     *
     * @param {string} filterId
     */
    onFilterChange: function(filterId) {
        if (this.view.inlineEditMode || this.view.action == 'edit' || this.view.createMode) {
            this.setFilterId(filterId);
            this.setFilterName();
            this.setModelValue();
        }
    },

    /**
     * Sets model value
     *
     * It can only be a JSON, composed of filter id, filter name and filter definition,
     * or null, if there is no filter selected at this moment.
     */
    setModelValue: function() {
        var value = this.prepareModelValue();
        var options = {
            'silent': true
        };

        this.model.set(this.name, value, options);
    },

    /**
     * Prepares value to be set on model.
     *
     * @return {string|null} JSON if filters have been loaded and can retrieve the current filter id model
     *                       Null if filters collection is still empty (has not been loaded)
     */
    prepareModelValue: function() {
        var model = this.getFilterCollectionModelById();

        if (model instanceof app.data.beanModel) {
            return JSON.stringify({
                'filterId': this.filterId,
                'filterName': this.filterCollection._getTranslatedFilterName(model),
                'filterDef': model.get('filter_definition'),
                'filterTpl': model.get('filter_template')
            });
        }

        return null;
    },

    /**
     * Prepares metadata used to build filterpanel component.
     *
     * @return {Object}
     */
    getFilterMeta: function() {
        return {
            'model': this.initFilterModel(),
            'collection': this.initFilterCollection(),
            'context': this.initFilterContext(),
            'module': this.getFilterModule() || this.filterDefaultModule,
            'layout': this,
            'action': this.action || this.view.action,
            'name': 'filterpanel',
            'meta': {
                'components': [
                    {
                        'layout': {
                            'name': 'filter',
                            'layout': 'filter',
                            'components': [
                                {
                                    'view': 'filter-module-dropdown'
                                },
                                {
                                    'view': 'filter-filter-dropdown'
                                }
                            ]
                        }
                    },
                    {
                        'view': 'filter-rows'
                    },
                    {
                        'view': 'filter-actions'
                    }
                ],
                'filterOptions': {
                    'show_actions': true,
                    'currentFilterId': this.filterId
                }
            }
        };
    },

    /**
     * Initialize the filter model
     *
     * @return {app.data.beanModel}
     */
    initFilterModel: function() {
        var module = this.getFilterModule();

        if (!(this.filterModel instanceof app.data.beanModel) || this.filterModel.module != module) {
            this.filterModel = app.data.createBean(module);

            this.filterModel.set({
                'currentFilterId': this.filterId,
                'filter_id': this.filterId
            });
        }

        return this.filterModel;
    },

    /**
     * Initialize the filter collection
     *
     * @return {app.data.beanCollection}
     */
    initFilterCollection: function() {
        if (!(this.filterCollection instanceof app.data.beanCollection)) {
            this.filterCollection = app.data.createBeanCollection('Filters');
        }

        this.filterCollection.setModuleName(this.getFilterModule() || this.filterDefaultModule);
        this.filterCollection.setOption('limit', -1);

        return this.filterCollection;
    },

    /**
     * Initialize the filter context
     *
     * @return {app.Context}
     */
    initFilterContext: function() {
        var module = this.getFilterModule();

        if (!(this.filterContext instanceof app.Context) || this.filterContext.get('module') != module) {
            var ctxParams = {
                'module': module || this.filterDefaultModule,
                'model': this.initFilterModel(),
                'collection': this.initFilterCollection(),
                'filter_id': this.filterId,
                'currentFilterId': this.filterId,
                'layout': this.view,
                'filterOptions': {
                    // Prevent other similar components from using the same filter id (it is cached in LocalStorage)
                    'stickiness': false,
                    'show_actions': true,
                    'currentFilterId': this.filterId
                }
            };

            this.filterContext = new app.Context(ctxParams);
        }

        return this.filterContext;
    },

    /**
     * Retrieves module corresponding to the filter component.
     *
     * @return {string}
     */
    getFilterModule: function() {
        if (!app.acl.hasAccess('view', this.model.get(this.filterModuleField))) {
            return;
        }

        if (_.isString(this.filterModuleField) && !_.isEmptyValue(this.filterModuleField)) {
            return this.model.get(this.filterModuleField);
        }

        return this.filterDefaultModule;
    },

    /**
     * Retrieves filter id from the model value.
     *
     * @return {string}
     */
    getModelFilterId: function() {
        var filterId;

        if (this.model.has(this.name)) {
            var value = this.model.get(this.name);

            if (!_.isEmpty(value)) {
                try {
                    value = JSON.parse(value);
                } catch (error) {
                    value = {};
                }

                filterId = value.filterId;
            }
        }

        return filterId;
    },

    /**
     * Retrieves child filter component from main filterpanel component.
     *
     * @return {app.view.Layout}
     */
    getFilterpanelFilter: function() {
        var component = this.filterpanel.getComponent('filter');

        if (!(component instanceof app.view.Layout)) {
            component = this.filterpanel.getComponent('filterpanel');

            component = component.getComponent('filter') || component.getComponent('filter-dropdown');
        }

        return component;
    },

    /**
     * Set the filter id
     *
     * @param {string} filterId
     */
    setFilterId: function(filterId) {
        this.filterId = filterId || this.filterDefaultId;
    },

    /**
     * Set the name of the filter
     */
    setFilterName: function() {
        var model = this.getFilterCollectionModelById();

        if (model instanceof app.data.beanModel) {
            this.filterName = this.filterCollection._getTranslatedFilterName(model);
        }
    },

    /**
     * Render components
     */
    renderComponents: function() {
        if (this.filterpanel instanceof app.view.Layout) {
            this.showComponents();
        } else {
            this.loadComponents();
        }
    },

    /**
     * Build components
     */
    buildComponents: function() {
        if (this.filterpanel instanceof app.view.Layout) {
            return;
        }

        this.filterpanel = app.view.createLayout(this.getFilterMeta());

        if (_.isFunction(this.filterpanel.initComponents)) {
            this.filterpanel.initComponents();
        }

        this.filterpanel.trigger('init');
        this.filter = this.getFilterpanelFilter();

        if (this.filter instanceof app.view.Layout) {
            this.listenTo(this.filter, 'filter:change:filter', _.bind(this.onFilterChange, this));
        }
    },

    /**
     * Show components
     */
    showComponents: function() {
        var filterModule = this.getFilterModule();
        this.filterpanel.module = filterModule;
        this.filter.module = filterModule;

        this.filterModel.set('filter_id', this.filterId);
        this.filterpanel.model.set('filter_id', this.filterId);

        this.filterContext.set('filter_id', this.filterId);
        this.filterpanel.context.set('filter_id', this.filterId);

        this.filterContext.set('currentFilterId', this.filterId);
        this.filterpanel.context.set('currentFilterId', this.filterId);

        this.filter.context.set('filter_id', this.filterId);
        this.filter.context.set('currentFilterId', this.filterId);

        this.filterpanel.render();

        this.$('[data-content=wrapper]').append(this.filterpanel.el);
    },

    /**
     * Check if the components can be loaded
     *
     * @return {boolean}
     */
    canLoadComponents: function() {
        var isValidModule = true;

        if (this.def.hasOwnProperty('moduleField') &&
            (
                _.isEmptyValue(this.filterModuleField) ||
                !this.model.has(this.filterModuleField) ||
                _.isEmptyValue(this.model.get(this.filterModuleField))
            )
        ) {
            isValidModule = false;
        }

        return isValidModule && !this.filterLoadInProgress;
    },

    /**
     * Load components
     *
     * Initialize and load filter collection then build and render components
     */
    loadComponents: function() {
        if (!this.canLoadComponents()) {
            return;
        }

        this.filterLoadInProgress = true;
        this.initFilterCollection();

        var options = {
            'success': _.bind(function loadSuccess() {
                this.filterLoadInProgress = false;

                if (this.disposed) {
                    return;
                }

                var filterModel = this.getFilterCollectionModelById();

                if (filterModel instanceof app.data.beanModel) {
                    this.filterCollection.collection.defaultFilterFromMeta = this.filterId;
                }

                this.buildComponents();
                this.renderComponents();

                if (this.action == 'detail') {
                    this.render();
                }

            }, this),
            'error': _.bind(function loadError() {
                this.filterLoadInProgress = false;

                if (this.disposed) {
                    return;
                }

                this.buildComponents();
                this.renderComponents();
            }, this)
        };

        this.filterCollection.load(options);
    },

    /**
     * Retrieves the filter model from filter component's collection
     *
     * @return {app.view.beanModel|null}
     */
    getFilterCollectionModelById: function() {
        var filterModel;

        try {
            filterModel = this.filter.filters.collection.get(this.filterId);
        } catch (e) {
            filterModel = null;
        }

        return filterModel;
    },

    /**
     * Dispose filter component
     */
    disposeComponents: function() {
        if (this.filter instanceof app.view.Layout) {
            this.filter.dispose();
        }

        if (this.filterpanel instanceof app.view.Layout) {
            this.filterpanel.dispose();
        }

        this.filter = null;
        this.filterpanel = null;
        this.filterCollection = null;
        this.filterContext = null;
        this.filterModel = null;
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.off('change:' + this.name);
        this.disposeComponents();
        return this._super('_dispose');
    },

    /**
     * Fix for current implementation of FocusDrawer where 'checkFocusAvailability'
     * triggers a call to our field.getComponent
     *
     * If it doens't find the method, it throws an error and stops rendering the field
     */
    getComponent: function() {
        return;
    }
}) },
"recurrence": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Recurrence is a field for Meetings/Calls module used to set attributes
 * about a recurring record.
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.RecurrenceField
 * @alias SUGAR.App.view.fields.BaseRecurrenceField
 * @extends View.Fields.Base.FieldsetField
 */
({
	// Recurrence Field (base) 

    extendsFrom: 'FieldsetField',

    /**
     * @property {boolean} showNoData
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    /**
     * @property {int} repeatCountMin
     *
     * The minimum number of occurrences that is allowed when the repeat_count
     * field is used.
     */
    repeatCountMin: 1,

    /**
     * @property {Object} repeatEndLastValues
     *
     * Place to save off the last values of the repeat end fields so we can put
     * the values back if the user toggles back.
     */
    repeatEndLastValues: {},

    repeatTypeSpecificFields: {
        repeat_dow: ['Weekly'],
        repeat_selector: ['Monthly', 'Yearly']
    },

    /**
     * Do not let a decorator field manage this field's design
     */
    disableDecoration: true,

    /**
     * @inheritdoc
     *
     * Default the `repeat_end_type` to "Until" and update the visibility of the
     * `repeat_count` and `repeat_until` fields.
     *
     * Add validator to ensure that `repeat_count` or `repeat_until`
     * have appropriate values based on `repeat_end_type`
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.model.addValidationTask(
            'repeat_count_or_until_required_validator_' + this.cid,
            _.bind(this._doValidateRepeatCountOrUntilRequired, this)
        );
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.model.on('sync', this.setEndTypeFromEndFieldValues, this);
        this.model.on('change:repeat_type', this.repeatTypeChanged, this);
        this.model.on('change:repeat_selector', this.updateRepeatSelectorDependentFieldVisibility, this);
        this.model.on('change:repeat_end_type', this.updateRepeatEndFieldVisibility, this);
    },

    /**
     * Inherit fieldset templates
     * FIXME: Will be refactored by SC-3471.
     * @inheritdoc
     * @private
     */
    _loadTemplate: function() {
        var originalType = this.type;
        this.type = 'fieldset';
        this._super('_loadTemplate');
        this.type = originalType;
    },

    /**
     * @inheritdoc
     *
     * Prepare the recurrence fields based on the value of `repeat_type`
     */
    _render: function() {
        var repeatType = this.model.get('repeat_type');

        this._super('_render');

        switch (repeatType) {
            case 'Daily':
            case 'Weekly':
            case 'Monthly':
            case 'Yearly':
                this.showFieldBlock();
                break;
            default:
                this.hideFieldBlock();
                break;
        }

        this.prepareView();
    },

    /**
     * Show the field and its wrapper
     */
    showFieldBlock: function() {
        this.show();
        this.$el.closest('.record-cell').show();
    },

    /**
     * Hide the field and its wrapper
     */
    hideFieldBlock: function() {
        this.hide();
        this.$el.closest('.record-cell').hide();
    },

    /**
     * Set up the recurrence fields based on `repeat_type` and the action
     *
     * * `repeat_dow` - show when repeat_type is weekly, hide otherwise
     * * `repeat_end_type` - hide on detail view
     */
    prepareView: function() {
        if (this.action === 'detail') {
            this._hideField('repeat_end_type');
        }

        // If copying or view/edit - we are defaulting from end field values
        if (!this.model.isNew() || this.model.isCopy()) {
            this.setEndTypeFromEndFieldValues();
        }

        this.updateRepeatTypeDependentFieldVisibility();
        this.updateRepeatEndFieldVisibility();
        this.updateRepeatSelectorDependentFieldVisibility();
    },

    /**
     * Set field defaults when `repeat_type` changes & then re-render so the
     * hide/show logic is applied.
     *
     * When `repeat_type` is cleared (set to None), force fields to their
     * default values. Exclude repeat_end_type from defaulting since its value
     * is based on the values of repeat_count and repeat_until.
     */
    repeatTypeChanged: function() {
        var isRecurring = this._isPopulated(this.model.get('repeat_type'));
        _.each(this.fields, function(field) {
            var fieldValue = this.model.get(field.name),
                isEmpty = !this._isPopulated(fieldValue) || (fieldValue === 0);
            if ((!isRecurring || isEmpty) && field.name !== 'repeat_end_type') {
                if (field.name === 'repeat_dow' && this.model.get('date_start') !== '') {
                    if (!this.model.get('repeat_dow')) {
                        this.model.set(field.name, new Date(this.model.get('date_start')).getDay());
                    }
                } else {
                    this.model.set(field.name, field.def['default']);
                }
            }
        }, this);

        this.render();
    },

    /**
     * Update the visibility of fields dependent on the `repeat_type` field
     */
    updateRepeatTypeDependentFieldVisibility: function() {
        var repeatType = this.model.get('repeat_type');
        _.each(this.repeatTypeSpecificFields, function(showValues, fieldName) {
            if (_.contains(showValues, repeatType)) {
                this._showField(fieldName);
            } else {
                this._hideField(fieldName);
            }
        }, this);
    },

    /**
     * Update the visibility of fields dependent on the `repeat_selector` field
     */
    updateRepeatSelectorDependentFieldVisibility: function() {
        var repeatSelector = this.model.get('repeat_selector'),
            repeatSelectorVisible = this._isFieldVisible('repeat_selector');

        if (repeatSelectorVisible && repeatSelector === 'Each') {
            this._showField('repeat_days');
        } else {
            this._hideField('repeat_days');
        }

        if (repeatSelectorVisible && repeatSelector === 'On') {
            this._showField('repeat_ordinal');
            this._showField('repeat_unit');
        } else {
            this._hideField('repeat_ordinal');
            this._hideField('repeat_unit');
        }
    },

    /**
     * Set the value of repeat_end_type based on whether values are set for
     * repeat_count and repeat_until.
     */
    setEndTypeFromEndFieldValues: function() {
        var repeatUntil = this.model.get('repeat_until') || '',
            repeatCount = this.model.get('repeat_count') || '',
            repeatEndType;

        if (this._isPopulated(repeatUntil)) {
            repeatEndType = 'Until';
        } else if (this._isPopulated(repeatCount)) {
            repeatEndType = 'Occurrences';
        }

        if (repeatEndType) {
            this.model.set('repeat_end_type', repeatEndType);
        }
    },

    /**
     * Swap out Repeat Until & Repeat Occurrences fields based on the
     * value of repeat_end_type.
     */
    updateRepeatEndFieldVisibility: function() {
        var endType = this.model.get('repeat_end_type');

        //bail out if end type is not set yet
        if (!endType) {
            return;
        }

        this._toggleRepeatEndField('repeat_count', (endType === 'Occurrences'));
        this._toggleRepeatEndField('repeat_until', (endType === 'Until'));
    },

    /**
     * Hide/show the given field and either save off its value & clear (on hide)
     * or restore its previous value (on show).
     *
     * @param {string} fieldName The name of the field to hide/show
     * @param {boolean} show Whether to show (true) or hide (false)
     * @private
     */
    _toggleRepeatEndField: function(fieldName, show) {
        var value = this.model.get(fieldName),
            lastValue = this.repeatEndLastValues[fieldName];

        if (show) {
            this._showField(fieldName);
            if (!this._isPopulated(value) && this._isPopulated(lastValue)) {
                this.model.set(fieldName, lastValue);
            }
        } else {
            this._hideField(fieldName);
            this.repeatEndLastValues[fieldName] = value;
            if (this._isPopulated(value)) {
                this.model.unset(fieldName);
            }
        }
    },

    /**
     * Show the given field
     *
     * @param {string} fieldName Name of the field to show
     * @private
     */
    _showField: function(fieldName) {
        this._getFieldRecordCellByName(fieldName).show();
    },

    /**
     * Hide the given field
     *
     * @param {string} fieldName Name of the field to hide
     * @private
     */
    _hideField: function(fieldName) {
        this._getFieldRecordCellByName(fieldName).hide();
    },

    /**
     * Checks if a given field is visible
     *
     * @param {string} fieldName
     * @return {boolean} Returns true if the field is visible, false otherwise
     * @private
     */
    _isFieldVisible: function(fieldName) {
        return this._getFieldRecordCellByName(fieldName).is(':visible');
    },

    /**
     * Returns the field cell for a given field name
     *
     * @param {string} fieldName Name of the field to select
     * @return {jQuery} jQuery selected record cell
     * @private
     */
    _getFieldRecordCellByName: function(fieldName) {
        var selector = '.fieldset-field[data-name="' + fieldName + '"]';
        return this.$(selector);
    },

    /**
     * Check if a particular field is populated
     *
     * @param {string|number} value The value to check if it is populated
     * @return {boolean} Returns true if the field is populated
     * @private
     */
    _isPopulated: function(value) {
        return !_.isUndefined(value) && !_.isNull(value) && value !== '';
    },

    /**
     * Custom validator for the `repeat_count`/`repeat_until` field.
     *
     * This validates `repeat_count` is populated when `repeat_end_type` is
     * "Occurrences" and `repeat_until` is populated when `repeat_end_type` is
     * "Until".
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateRepeatCountOrUntilRequired: function(fields, errors, callback) {
        var repeatEndType = this.model.get('repeat_end_type'),
            repeatCount = this.model.get('repeat_count'),
            repeatCountIsPopulated = this._isPopulated(repeatCount),
            repeatUntilIsPopulated = this._isPopulated(this.model.get('repeat_until'));

        if (this._isPopulated(this.model.get('repeat_type'))) {
            if (repeatEndType === 'Until' && !repeatUntilIsPopulated) {
                errors.repeat_until = {required: true};
            } else if (repeatEndType === 'Occurrences') {
                if (!repeatCountIsPopulated) {
                    errors.repeat_count = {required: true};
                } else if (repeatCount < this.repeatCountMin) {
                    errors.repeat_count = {minValue: this.repeatCountMin};
                }
            }
        }

        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('repeat_count_or_until_required_validator_' + this.cid);
        this._super('_dispose');
    }
}) },
"follow": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FollowField
 * @alias SUGAR.App.view.fields.BaseFollowField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Follow Field (base) 

    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    events: {
        'click [data-event="list:follow:fire"]': 'toggleFollowing'
    },

    extendsFrom: 'RowactionField',

    initialize: function(options) {
        this._super("initialize", [options]);
        this.format();
    },
    bindDataChange: function() {
        if (this.model) {
            this.model.on("change:following", this.resetLabel, this);
        }

        // when the record is marked as favorite, it is subsequently followed by the current user (on server-side)
        // need to sync the client-side model, so an event is fired on the context from the favorite field upon success
        // set following on the model so we don't have to make a server request to get the latest value
        this.model.on("favorite:active", function() {
            this.model.set("following", true);
        }, this);
    },
    /**
     * Set current label and value since the follow button relates to the following
     *
     * @param value
     */
    format: function(value) {
        value = this.model.get("following");

        //For record view, the label should be diffent from other views
        //It also needs to have mouseover handlers for updating text
        if(this.tplName === "detail") {
            var label = value ? "LBL_FOLLOWING" : "LBL_FOLLOW";
            this.label = app.lang.get(label, this.module);
        } else {
            var label = value ? "LBL_UNFOLLOW" : "LBL_FOLLOW";
            this.label = app.lang.get(label, this.module);
        }
        return value;
    },
    /**
     * Reset label and triggers "show" handler to update parent controller dom
     */
    resetLabel: function() {
        this.render();
        //It should trigger the handler "show" to update parent controller
        //i.e. actiondropdown
        this.trigger("show");
    },
    unbindDom: function() {
        this.$("[data-hover=true]").off();
        this._super("unbindDom");
    },
    _render: function () {
        var module, mouseoverText, mouseoverClass, self = this;

        module = app.metadata.getModule(this.model.module);
        if (!module.activityStreamEnabled) {
            this.hide();
        } else {
            this._super("_render");

            if (this.tplName !== "detail") {
                return;
            }

            if (this.model.get("following")) {
                mouseoverText = app.lang.get("LBL_UNFOLLOW");
                mouseoverClass = "label-important";
            } else {
                mouseoverText = app.lang.get("LBL_FOLLOW");
                mouseoverClass = "label-success";
            }

            this.$("[data-hover=true]").on("mouseover",function () {
                $(this).text(mouseoverText).attr("class", "label").addClass(mouseoverClass);
            }).on("mouseout", function () {
                    var kls = self.model.get("following") ? "label-success" : "";
                    $(this).text(self.label).attr("class", "label").addClass(kls);
                });
        }
    },
    /**
     * Call REST API for subscribe and unsubscribe
     *
     * @param {Event} event The `click` event.
     */
    toggleFollowing: function(event) {
        var isFollowing = this.model.get("following");

        if(!_.isUndefined(isFollowing)) {
            var options = {
                alerts: false
            };
            if (this.model.follow(!isFollowing, options) === false) {
                app.logger.error('Unable to follow "' + this.model.module + '" record "' + this.model.id);
                return;
            }
        }
    }
}) },
"quickcreate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.QuickcreateField
 * @alias SUGAR.App.view.fields.BaseQuickcreateField
 * @extends View.Fields.Base.BaseField
 */
({
	// Quickcreate Field (base) 

    events: {
        'click .actionLink[data-event="true"]' : '_handleActionLink'
    },

    plugins: ['LinkedModel'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        //Listen to create view model changes to keep track of unsaved changes
        app.events.on('create:model:changed', this.createModelChanged, this);
        this.on('linked-model:create', this._prepareCtxForReload, this);
    },

    /**
     * Changes properties on the context so that its collection can be
     * re-fetched.
     *
     * FIXME: This will be removed when SC-4775 is implemented.
     *
     * @private
     */
    _prepareCtxForReload: function() {
        this.context.resetLoadFlag();
        this.context.set('skipFetch', false);
    },

    /**
     * Keeps track of if the create view's model has changed.
     * @param hasChanged
     */
    createHasChanges: false,
    createModelChanged: function(hasChanged) {
        this.createHasChanges = hasChanged;
    },
    /**
     * When menu item is clicked, warn if open drawers, reset drawers and open create
     * @param evt
     * @private
     */
    _handleActionLink: function(evt) {
        var $actionLink = $(evt.currentTarget),
            module = $actionLink.data('module'),
            moduleMeta = app.metadata.getModule(this.context.get('module'));
        this.actionLayout = $actionLink.data('layout');
        if (this.createHasChanges) {
            app.alert.show('send_confirmation', {
                level: 'confirmation',
                messages: 'LBL_WARN_UNSAVED_CHANGES',
                onConfirm: _.bind(function() {
                    app.drawer.reset(false);
                    this.createRelatedRecord(module);
                }, this)
            });
        } else {
            // TODO: SP-1568 - We don't yet deal with bwc model changed attributes so
            // this will navigate to new create page WITHOUT alert for unsaved changes
            this.createRelatedRecord(module);
        }
    },
    /**
     * Route to Create Related record UI for a BWC module.
     *
     * @param {String} module Module name.
     */
    routeToBwcCreate: function(module) {
        var context = this.getRelatedContext(module);
        if (context) {
            app.bwc.createRelatedRecord(module, this.context.get('model'), context.link);
        } else {
            var route = app.bwc.buildRoute(module, null, 'EditView');
            app.router.navigate(route, {trigger: true});
        }
    },

    /**
     * Returns context link and module name
     * if possible to create a record with context.
     *
     * @param {String} module Module name.
     * @return {Array|undefined}
     */
    getRelatedContext: function(module) {
        var meta = app.metadata.getModule(module),
            context;

        if (meta && meta.menu.quickcreate.meta.related) {
            var parentModel = this.context.get('model');

            if (parentModel.isNew()) {
                return;
            }

            context = _.find(
                meta.menu.quickcreate.meta.related,
                function(metadata) {
                    return metadata.module === parentModel.module;
                }
            );
        }

        return context;
    },

    /**
     * Open the appropriate quick create layout in a drawer
     *
     * @param {String} module Module name.
     */
    openCreateDrawer: function(module) {
        var relatedContext = this.getRelatedContext(module);
        var model = null;

        // If the Omnichannel console is open, get model pre-populated data from
        // that. Otherwise, check whether the current context's module defines
        // a link for the quick create drawer
        if (app.omniConsole && app.omniConsole.isOpen()) {
            var prepopulateData = app.omniConsole.getModelPrepopulateData(module);
            if (!_.isEmpty(prepopulateData)) {
                model = app.data.createBean(module, prepopulateData);
            }
        } else if (relatedContext) {
            model = this.createLinkModel(this.context.get('model'), relatedContext.link);
        }

        app.drawer.open({
            layout: this.actionLayout || 'create',
            context: {
                create: true,
                module: module,
                model: model
            }
        }, _.bind(function (refresh, model) {
            if (refresh) {
                // When user quick creates a model he has no access, it loads the 404 page so we need to redirect him to
                // his previous page manually
                if (model && !model.id) {
                    app.router.refresh();
                    return;
                }
                if (model && relatedContext) {
                    // Refresh the subpanel.
                    this.context.trigger('panel-top:refresh', relatedContext.link);
                    return;
                }
                //Check main context to see if it needs to be updated
                this._loadContext(app.controller.context, module);
                //Also check child contexts for updates
                if (app.controller.context.children) {
                    _.each(app.controller.context.children, function(context){
                        this._loadContext(context, module);
                    }, this);
                }

                this.context.trigger('quickcreate-drawer:closed', model);
            }
        }, this));
    },
    /**
     * Conditionally load context if it is for given module
     * @param context Context to load
     * @param module Module name to check
     * @private
     */
    _loadContext: function(context, module){
        var collection = context.get('collection');
        if (collection && collection.module === module) {
            var options = {
                //Don't show alerts for this request, background update
                showAlerts: false
            };
            context.resetLoadFlag({recursive: false});
            context.set('skipFetch', false);
            context.loadData(options);
        }
    }
}) },
"calendars": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.CalendarsField
 * @alias SUGAR.App.view.fields.BaseCalendarsField
 * @extends View.Fields.Base.BaseField
 */
 ({
	// Calendars Field (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.fieldTag = 'div';

        this.events = {
            'click span[name=removeOtherCalendar]': this._removeOtherCalendar,
            'click [name=selectAll]': this.selectCalendars
        };

        this.bkItems = [];
        this.items = [];

        this.selectAllDelayTime = 100;

        this._registerEvents();
    },

    /**
     * Remove deleted calendars stored in Local Storage
     *
     * Check for the local storage updates to make sure this field was not set with deleted calendars
     * If needed, we'll update the model
     */
    _removeCalendarsStoredButDeleted: function() {
        let calendarsUpdated = [];
        let calendarIdsInLocalStorage = _.pluck(
            app.cache.get(this.view.keyToStoreCalendarConfigurations)[this.name],
            'calendarId'
        );
        _.each(this.model.get(this.name), function(calendar) {
            if (calendarIdsInLocalStorage.indexOf(calendar.calendarId) >= 0) {
                calendarsUpdated.push(calendar);
            }
        });

        this.model.set(this.name, calendarsUpdated, {silent: true});
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        this.listenToOnce(this.context, 'updatefields', _.bind(this.render, this));

        this.listenTo(this.model, 'change:' + this.name, _.bind(this.updateCount, this));
        this.listenTo(this.model, 'change:' + this.name, _.bind(this.checkSelectAllInput, this));
    },

    /**
     * Listening to external events
     */
    _registerEvents: function() {
        this.listenTo(app.events, 'calendar:storage:changed', _.bind(this._removeCalendarsStoredButDeleted, this));
        this.listenTo(app.events, 'calendar:storage:changed', _.bind(this.updateCount, this));

        this.listenTo(this, 'calendars:selectAll', _.bind(this.selectAllCalendars, this));
    },

    /**
     * Select all calendars
     */
    selectAllCalendars: function() {
        //for low bandwidth, wait for api to finish
        if (typeof this.selectAllCalendarsTimeout !== 'undefined') {
            clearTimeout(this.selectAllCalendarsTimeout);
            this.selectAllCalendarsTimeout = null;
        }
        if (typeof this.request.status == 'undefined') {
            this.selectAllCalendarsTimeout =
            _.delay(_.bind(this.selectAllCalendars, this), this.selectAllDelayTime);
            return;
        }

        let configurations = app.utils.deepCopy(this.items) || [];

        configurations = _.map(configurations, function(config) {
            return {
                calendarId: config.calendarId,
                userId: config.userId,
                teamId: config.teamId,
                selected: true
            };
        });

        let data = {
            myCalendars: this.model.get('myCalendars') || [],
            otherCalendars: this.model.get('otherCalendars') || []
        };
        data[this.name] = configurations;

        app.cache.set(this.view.keyToStoreCalendarConfigurations, data);

        this.model.set(this.name, configurations);
        this.updateCount();

        this.context.trigger('calendars:cache:force-refresh');
    },

    /**
     * Remove Other Calendar
     *
     * @param {Event} e
     */
    _removeOtherCalendar: function(e) {
        const calendarName = $(e.currentTarget).parent()[0].innerText.bold();

        app.alert.show('message', {
            level: 'confirmation',
            messages:
                app.lang.getModString('LBL_CALENDAR_REMOVE_OTHER_CALENDAR', 'Calendar', {calendarName: calendarName}),
            autoClose: false,
            onConfirm: _.bind(function() {
                const $input = $(e.currentTarget).parent().find('input');
                const calendarId = $input.attr('calendarId');
                const userId = $input.attr('userId');
                const teamId = $input.attr('teamId');
                const newCalendars = _.filter(this.model.get(this.name), function(calendar) {
                    if (
                        calendar.calendarId === calendarId &&
                        calendar.userId === userId &&
                        calendar.teamId === teamId
                    ) {
                        return false;
                    } else {
                        return true;
                    }
                });

                const dataToSaveInLS = {
                    myCalendars: this.model.get('myCalendars') || [],
                    otherCalendars: newCalendars
                };

                app.cache.set(this.view.keyToStoreCalendarConfigurations, dataToSaveInLS);
                this.model.set(this.name, newCalendars);

                this.render();
            }, this)
        });
    },

    /**
     * Update Count in UI
     */
    updateCount: function() {
        const $field = this.$el.parent().parent();
        const data = this.model.get(this.name);

        if (Array.isArray(data) && data.length > 0) {
            let numberOfCalendarsSelected;

            if (this.name == 'otherCalendars') {
                const calendarsSelected = _.filter(data, function(calendar) {
                    return calendar.selected === true;
                });
                numberOfCalendarsSelected = calendarsSelected.length;
            } else {
                numberOfCalendarsSelected = data.length;
            }

            if (numberOfCalendarsSelected == 0) {
                $field.find('span[name=count]').html(' ');
            } else {
                $field.find('span[name=count]').html('(' + numberOfCalendarsSelected + ') ');
            }
        } else {
            $field.find('span[name=count]').html(' ');
        }
    },

    /**
     * Check the current status of Select All field
     */
    checkSelectAllInput: function() {
        const data = this.model.get(this.name);
        const items = app.utils.deepCopy(this.bkItems);

        if (_.isArray(data) && data.length > 0) {
            let numberOfCalendarsSelected;
            if (this.name === 'otherCalendars') {
                const calendarsSelected = _.filter(data, function(calendar) {
                    return calendar.selected === true;
                });
                numberOfCalendarsSelected = calendarsSelected.length;

            } else {
                numberOfCalendarsSelected = data.length;
            }

            if (numberOfCalendarsSelected === 0 || numberOfCalendarsSelected !== items.length) {
                this.checked = false;
                this.$('#' + this.name).prop('checked', false);
            } else {
                this.checked = true;
                this.$('#' + this.name).prop('checked', true);
            }
        } else {
            this.checked = false;
            this.$('#' + this.name).prop('checked', false);
        }
    },

    /**
     * @inheritdoc
     */
    render: function() {
        this._super('render');

        this.loadEnumOptions();
        this.updateCount();
        this.resizeCalendarsList();
    },

    /**
     * Resize calendars list
     */
    resizeCalendarsList: function() {
        const windowHeight = $(window).height();
        const headerHeight = $('#header .navbar').outerHeight();
        const footerHeight = $('footer').outerHeight();
        const miniCalendarHeight = 300;
        const remainingHeight = windowHeight - headerHeight - miniCalendarHeight - footerHeight;

        $('.calendarsWrapper').css('max-height', remainingHeight + 'px');
        this.checkSelectAllInput();
    },

    /**
     * Select all calendars based on input field
     *
     * @param {Event} e
     */
    selectCalendars: function(e) {
        const currentTarget = e.currentTarget.id;

        if (currentTarget === 'myCalendars') {
            const checkedMyCalendars = this.$el.find('#myCalendars').prop('checked');

            if (checkedMyCalendars) {
                this.$('input[type=checkbox]').prop('checked', true);
                this.selectAllCalendars();
            } else {
                this.$('input[type=checkbox]').prop('checked', false);
                this.uncheckAllCalendars(currentTarget);
            }
        } else {
            const checkedOtherCalendars = this.$el.find('#otherCalendars').prop('checked');

            if (checkedOtherCalendars) {
                this.$('input[type=checkbox]').prop('checked', true);
                this.selectAllCalendars();
            } else {
                this.$('input[type=checkbox]').prop('checked', false);
                this.uncheckAllCalendars(currentTarget);
            }
        }
    },

    /**
     * Clear calendar list
     *
     * @param {string} currentTarget
     */
    uncheckAllCalendars: function(currentTarget) {
        let fieldToClear = currentTarget;

        const currentCalendars = app.utils.deepCopy(this.model.get(fieldToClear));

        //useful for clear otherCalendars
        let cache = app.cache.get(this.view.keyToStoreCalendarConfigurations);
        if (fieldToClear === 'myCalendars') {
            this.model.set(fieldToClear, []);
            cache[fieldToClear] = [];
        } else {
            const updatedCalendars = _.map(currentCalendars, function(calendar) {
                calendar.selected = false;
                return calendar;
            });
            cache[fieldToClear] = updatedCalendars;
            this.model.set(fieldToClear, updatedCalendars);
        }
        app.cache.set(this.view.keyToStoreCalendarConfigurations, cache);
    },

    /**
     * @inheritdoc
     */
    loadEnumOptions: function() {
        let calendarPayload = {
            calendarType: this.def.calendar_type,
            calendarFilter: this.def.calendar_filter,
            viewSource: this.def.view_source,
            recordModule: this.view.module,
            layout: app.controller.context.get('layout')
        };

        calendarPayload.calendars = app.Calendar.utils.getConfigurationsByKey(
            this.view.keyToStoreCalendarConfigurations,
            this.name
        );

        if (this.view.name == 'calendar-scheduler-dashlet' && this.name == 'otherCalendars') {
            calendarPayload.calendars = this.model.get('otherCalendars') || [];
        }

        this.request = app.api.call('create', app.api.buildURL('Calendar/calendars'), calendarPayload, {
            success: _.bind(function(data) {
                let calendars;

                if (this.disposed) {
                    return;
                }

                //let the scheduler know all available modules
                if (this.name == 'myCalendars') {
                    let myCalendars = _.values(data.calendars);
                    let myCalendarsModulesAdded = [];
                    let myCalendarsFiltered = [];
                    _.each(myCalendars, function(myCalendar) {
                        if (myCalendarsModulesAdded.indexOf(myCalendar.module) == -1) {
                            myCalendarsFiltered.push(myCalendar);
                            myCalendarsModulesAdded.push(myCalendar.module);
                        }
                    });
                    this.context.set('myAvailableCalendars', myCalendarsFiltered);
                }

                //remove deleted calendars from local storage
                let configurationsToShow = app.Calendar.utils.getConfigurationsByKey(
                    this.view.keyToStoreCalendarConfigurations
                );

                if (this.name == 'myCalendars') {
                    let myConfigurationsToShow = configurationsToShow.myCalendars;
                    let myConfigurationsToShowVerified =
                    _.filter(myConfigurationsToShow, function(storedCalendar) {
                        let calendarStillExists = false;
                        _.each(data.calendars, function(calendarFromDb) {
                            if (calendarFromDb.calendarId === storedCalendar.calendarId &&
                                (_.isEmpty(calendarFromDb.userId) ||
                                    storedCalendar.userId === calendarFromDb.userId)
                            ) {
                                calendarStillExists = true;
                            }
                        });
                        return calendarStillExists;
                    });

                    if (configurationsToShow.myCalendars.length !== myConfigurationsToShowVerified.length) {
                        const dataToSaveInLS = {
                            myCalendars: myConfigurationsToShowVerified,
                            otherCalendars: configurationsToShow.otherCalendars || []
                        };
                        app.cache.set(this.view.keyToStoreCalendarConfigurations, dataToSaveInLS);

                        //trigger count update
                        this.model.set(this.name, myConfigurationsToShowVerified);
                    }

                    calendars = data.calendars;
                } else if (this.name == 'otherCalendars') {
                    let otherConfigurationsToShow;
                    let otherConfigurationsToShowVerified;

                    if (this.view.name == 'calendar-scheduler-dashlet') {
                        otherConfigurationsToShow = this.model.get('otherCalendars') || [];
                        otherConfigurationsToShowVerified =  this.verifyConfigurations(otherConfigurationsToShow, data);
                    } else {
                        otherConfigurationsToShow = configurationsToShow.otherCalendars;
                        otherConfigurationsToShowVerified =  this.verifyConfigurations(otherConfigurationsToShow, data);

                        if (configurationsToShow.otherCalendars.length !== otherConfigurationsToShowVerified.length) {
                            const dataToSaveInLS = {
                                myCalendars: configurationsToShow.myCalendars || [],
                                otherCalendars: otherConfigurationsToShowVerified
                            };
                            app.cache.set(this.view.keyToStoreCalendarConfigurations, dataToSaveInLS);

                            //trigger count update
                            this.model.set(this.name, otherConfigurationsToShowVerified);
                        }
                    }

                    calendars = data.calendars;
                }

                let calendarItems = [];
                _.each(calendars, function(calendar) {
                    let cal = {
                        id: calendar.calendarId,
                        name: calendar.name,
                        calendarId: calendar.calendarId,
                        selected: this.calendarIsSelected(calendar),
                        color: calendar.color,
                        user: calendar.user,
                        userId: calendar.userId,
                        userName: calendar.userName,
                        team: calendar.team,
                        teamId: calendar.teamId,
                        teamName: calendar.teamName
                    };

                    if (!_.isEmpty(calendar.userId) && _.isEmpty(calendar.teamId)) {
                        if (this.name === 'myCalendars' && this.view.name === 'calendar-scheduler-dashlet') {
                            cal.name = calendar.name;
                            cal.id = calendar.calendarId + ':user:current_user';
                        } else {
                            cal.name = calendar.userName + '\'s ' + calendar.name;
                            cal.id = calendar.calendarId + ':user:' + calendar.userId;
                        }
                    } else if (_.isEmpty(calendar.userId) && !_.isEmpty(calendar.teamId)) {
                        cal.name = calendar.teamName + '\'s ' + calendar.name;
                        cal.id = calendar.calendarId + ':team:' + calendar.teamId;
                    }

                    if (!_.isEmpty(calendar.userId)) {
                        if (typeof calendar.userColor == 'string' && !_.isEmpty(calendar.userColor)) {
                            cal.dotColor = calendar.userColor;
                        } else {
                            cal.dotColor = app.Calendar.utils.pastelColor(calendar.userId);
                        }
                    }
                    calendarItems.push(cal);
                }, this);

                this.items = calendarItems;
                this.bkItems = app.utils.deepCopy(calendarItems);

                this._render();
            }, this),
            error: function(data) {
                // refresh token if it has expired
                app.error.handleHttpError(data, {});
            }
        });
    },

    /**
     * Show calendar definition
     *
     * @param {Object} calendar
     * @return {boolean}
     */
    calendarIsSelected: function(calendar) {
        let calendarToShow;

        if (this.name == 'myCalendars') {
            calendarToShow = _.find(this.model.get(this.name), function(calendarConfig) {
                return calendarConfig.calendarId === calendar.calendarId;
            });
        } else {
            if (this.view.name == 'main-panel') {
                calendarToShow = _.find(this.model.get(this.name), _.bind(function(calendarConfig) {
                    let configurationsInStorage =
                        app.Calendar.utils.getConfigurationsByKey(this.view.keyToStoreCalendarConfigurations);
                    configurationsInStorage = configurationsInStorage.myCalendars
                        .concat(configurationsInStorage.otherCalendars);

                    let configurationInStorage = _.find(configurationsInStorage, function(configStorage) {
                        if (calendarConfig.calendarId === configStorage.calendarId &&
                            (_.isEmpty(calendarConfig.userId) || configStorage.userId === calendarConfig.userId) &&
                            (_.isEmpty(calendarConfig.teamId) || configStorage.teamId === calendarConfig.teamId)
                        ) {
                            return true;
                        }
                    });

                    if (typeof configurationInStorage != 'undefined') {
                        if (!_.isEmpty(calendarConfig.teamId)) {
                            return calendarConfig.calendarId === calendar.calendarId &&
                                calendarConfig.teamId === calendar.teamId &&
                                configurationInStorage.selected === true;

                        } else if (!_.isEmpty(calendarConfig.userId)) {
                            return calendarConfig.calendarId === calendar.calendarId &&
                                calendarConfig.userId === calendar.userId &&
                                configurationInStorage.selected === true;
                        }
                    }

                    return false;
                }, this));
            } else if (this.view.name == 'calendar-scheduler-dashlet') {
                calendarToShow = _.find(this.model.get(this.name), _.bind(function(calendarConfig) {

                    if (!_.isEmpty(calendarConfig.teamId)) {
                        return calendarConfig.calendarId === calendar.calendarId &&
                            calendarConfig.teamId === calendar.teamId &&
                            calendarConfig.selected === true;

                    } else if (!_.isEmpty(calendarConfig.userId)) {
                        return calendarConfig.calendarId === calendar.calendarId &&
                        calendarConfig.userId === calendar.userId &&
                        calendarConfig.selected === true;
                    }

                    return false;
                }, this));
            }
        }

        if (typeof calendarToShow == 'undefined') {
            return false;
        }
        return true;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        const items = app.utils.deepCopy(this.bkItems);
        this.markSelectedOptions(items);
        this.checkSelectAllInput();

        this._super('_render');
    },

    /**
     * Mark selected calendars
     *
     * @param {Array} items
     * @return {Array}
     */
    markSelectedOptions: function(items) {
        _.each(items, function(item) {
            item.selected = this.calendarIsSelected(item);
        }, this);

        return items;
    },

    /**
     * Handle input change
     *
     * @param {Event} e
     */
    handleInputChange: function(e) {
        const searchFor = e.currentTarget.value.toLowerCase();
        const items = app.utils.deepCopy(this.bkItems);

        let newItems = [];
        _.each(items, function(item) {
            if (item.name.toLowerCase().indexOf(searchFor) >= 0) {
                newItems.push(item);
            }
        }, this);

        this.items = this.markSelectedOptions(newItems);

        const $items = app.template.getField('calendars', 'items.calendars')(this);

        this.$('ul').html($items);

        this.$('input[type=checkbox]').on('change', _.bind(this.handleCheckboxChange, this));
    },

    /**
     * Handle checkbox change
     *
     * @param {Event} e
     */
    handleCheckboxChange: function(e) {
        if (e.currentTarget.id === 'myCalendars' || e.currentTarget.id === 'otherCalendars') {
            return;
        }
        const $checkbox = $(e.currentTarget).closest('li').find('input[type=checkbox]');

        const calendarId = $checkbox.attr('calendarId');
        const userId = $checkbox.attr('userId');
        const teamId = $checkbox.attr('teamId');
        const calendar = {
            calendarId: calendarId,
            userId: userId,
            teamId: teamId
        };

        this.updateCalendars(calendar, $checkbox[0].checked);
    },

    /**
     * Update model AND localStorage with calendars selected.
     * Specific actions are going to be executed in each view where the field is added
     *
     * @param {Object} calendar
     * @param {boolean} checked
     */
    updateCalendars: function(calendar, checked) {
        let dataToSaveInLS;
        let configurations;

        const calendarId = calendar.calendarId;
        const userId = calendar.userId;
        const teamId = calendar.teamId;

        const myConfigurations = this.model.get('myCalendars') || [];
        const otherConfigurations = this.model.get('otherCalendars') || [];

        let calendarsOnModel = this.model.get(this.name);

        if (Array.isArray(calendarsOnModel)) {
            calendarsOnModel = app.utils.deepCopy(calendarsOnModel);
        } else {
            calendarsOnModel = [];
        }

        if (this.name == 'myCalendars') {
            if (checked) {
                const tempConfig = {
                    calendarId: calendarId,
                    userId: userId,
                    teamId: ''
                };

                const newCalendarsList = calendarsOnModel.concat([tempConfig]);
                dataToSaveInLS = {
                    myCalendars: newCalendarsList,
                    otherCalendars: otherConfigurations
                };

                if (this.view.name != 'calendar-scheduler-dashlet') {
                    app.cache.set(this.view.keyToStoreCalendarConfigurations, dataToSaveInLS);
                }

                this.model.set(this.name, newCalendarsList);
            } else {
                configurations = _.filter(calendarsOnModel, _.bind(function(calendar) {
                    if (calendar.calendarId === calendarId) {
                        if (
                            (!_.isEmpty(calendar.userId) && calendar.userId === userId)
                        ) {
                            return false;
                        }
                    }
                    return true;
                }, this));

                dataToSaveInLS = {
                    myCalendars: configurations,
                    otherCalendars: otherConfigurations
                };

                if (this.view.name != 'calendar-scheduler-dashlet') {
                    app.cache.set(this.view.keyToStoreCalendarConfigurations, dataToSaveInLS);
                }

                this.model.set(this.name, configurations);
            }
        } else {
            if (checked) {
                configurations = _.map(calendarsOnModel, _.bind(function(calendar) {
                    if (calendar.calendarId === calendarId) {
                        if (
                            (!_.isEmpty(calendar.userId) && calendar.userId === userId) ||
                            (!_.isEmpty(calendar.teamId) && calendar.teamId === teamId)
                        ) {
                            calendar.selected = true;
                        }
                    }
                    return calendar;
                }, this));

                dataToSaveInLS = {
                    myCalendars: myConfigurations,
                    otherCalendars: configurations
                };

                if (this.view.name != 'calendar-scheduler-dashlet') {
                    app.cache.set(this.view.keyToStoreCalendarConfigurations, dataToSaveInLS);
                }

                this.model.set(this.name, configurations);
            } else {
                configurations = _.map(calendarsOnModel, _.bind(function(calendar) {
                    if (calendar.calendarId === calendarId) {
                        if (
                            (!_.isEmpty(calendar.userId) && calendar.userId === userId) ||
                            (!_.isEmpty(calendar.teamId) && calendar.teamId === teamId)
                        ) {
                            calendar.selected = false;
                        }
                    }
                    return calendar;
                }, this));

                dataToSaveInLS = {
                    myCalendars: myConfigurations,
                    otherCalendars: configurations
                };

                if (this.view.name != 'calendar-scheduler-dashlet') {
                    app.cache.set(this.view.keyToStoreCalendarConfigurations, dataToSaveInLS);
                }

                this.model.set(this.name, configurations);
            }
        }
    },

    /**
     * Verify configuration
     *
     * @param {Array} configurationToShow
     * @param {Array} data
     * @return {Array}
     */
    verifyConfigurations: function(configurationToShow, data) {
        _.filter(configurationToShow, function(storedCalendar) {
            let calendarStillExists = false;
            _.each(data.calendars, function(calendarFromDb) {
                if (calendarFromDb.calendarId === storedCalendar.calendarId &&
                    (_.isEmpty(calendarFromDb.userId) ||
                        storedCalendar.userId === calendarFromDb.userId) &&
                    (_.isEmpty(calendarFromDb.teamId) ||
                        storedCalendar.teamId === calendarFromDb.teamId)
                ) {
                    calendarStillExists = true;
                }
            });
            return calendarStillExists;
        });

        return configurationToShow;
    },

    /**
     * @inheritdoc
     */
    bindDomChange: function() {
        this.$('input').on('keyup', _.debounce(_.bind(this.handleInputChange, this), 100));

        this.$('input[type=checkbox]').on('change', _.bind(this.handleCheckboxChange, this));
    }
}) },
"hint-accounts-logo": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Hint-accounts-logo Field (base) 

    extendsFrom: 'ImageField',

    plugins: ['MetadataEventDriven', 'Stage2CssLoader'],

    events: {
        'click .image_preview': 'addDeleteImageLabel',
        'click .image_btn_label': 'deleteImage',
    },

    activeClass: 'hint-accounts-logo--record-view',

    deleteImageLabel: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        // When the delete label is active and the user clicks anywhere outside of the label, we want
        // to hide it. This event is to track that so that the label does not persist.
        window.document.addEventListener('mousedown', function(event) {
            var container = $('.image_btn_label');
            if (!container.is(event.target) && container.has(event.target).length === 0) {
                $('.image_btn_label').hide();
            }
        }, false);
    },

    /**
     * Format value
     *
     * @param {string} value
     * @return {string}
     */
    format: function(value) {
        return value;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this.model.fileField = this.name;
        this._super('_render');
        if (_.isEmpty(this.value)) {
            var template = app.template.getField(this.type, 'module-icon', this._getModuleName());
            if (template) {
                this.$('.image_field').replaceWith(template({
                    module: this._getModuleName(),
                    labelSizeClass: 'label-module-lg',
                    tooltipPlacement: app.lang.direction === 'ltr' ? 'right' : 'left'
                }));
            }
        } else {
            var layout = app.controller.layout.name;
            if (layout === 'record') {
                this.$('.image_field').addClass(this.activeClass);
            }
            //Resize widget once the image is loaded
            this.$('img').addClass('hide').on('load', $.proxy(this.resizeWidget, this));
        }
        return this;
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        var self = this;
        this.model.on('change', function() {
            self.render();
        }, this);
    },

    /**
     * Get module name for history-summary
     *
     * @return {string}
     */
    _getModuleName: function() {
        if (this.view.name === 'history-summary') {
            return this.model.get('_module');
        }
        return this.module;
    },

    /**
     * Delete hit account picture
     *
     * @param {Object} e
     */
    deleteImage: function(e) {
        if (this.model.get('hint_account_pic')) {
            this._warningAlertForLogoOverwrite();
        }
    },

    /**
     * Add delete image label
     */
    addDeleteImageLabel: function() {
        this.deleteImageLabel = true;
        this.render();
    },

    /**
     * Warning for hint account picture deletion
     */
    _warningAlertForLogoOverwrite: function() {
        var confirmMessage = app.lang.get('LBL_IMAGE_DELETE_CONFIRM', self.module);
        if (confirm(confirmMessage)) {
            this.model.save('hint_account_pic', '');
            this.deleteImageLabel = false;
            this.render();
        }
    }
}) },
"follow-up-datetime-colorcoded": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FollowUpDatetimeColorcodedField
 * @alias SUGAR.App.view.fields.FollowUpDatetimeColorcodedField
 * @extends View.Fields.Base.RelativeTimeField
 */
({
	// Follow-up-datetime-colorcoded Field (base) 

    extendsFrom: 'RelativeTimeField',

    /**
     * List of additional CSS classes to apply when showing a colored pill.
     *
     * @type string[]
     * @private
     */
    _defaultExtraClasses: ['label', 'pill'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * Map of keys of CSS class name(s)
         *
         * @type {Object}
         * @private
         */
        this._colorCodeClasses = this.def.color_code_classes || {};
    },

    /**
     * @inheritdoc
     *
     * Set color on render
     */
    _render: function() {
        this._super('_render');
        this.setColorCoding();
    },

    /**
     * Set color coding based on relative time value.
     * This is only applied when the action is list
     */
    setColorCoding: function() {
        this._clearColorCode();

        if (!this.model || this.action !== 'list') {
            return;
        }

        this._setColorCodeClass(this._getColorCodeLabel());
    },

    /**
     * Get label for the color code class base on follow up datetime value
     *
     * @return {string} label to get color code class
     * @private
     */
    _getColorCodeLabel: function() {
        var value = this.model.get(this.name);

        if (_.isEmpty(value)) {
            return '';
        }

        var followUpDate = app.date(value);
        var now = app.date();

        if (followUpDate.isBefore(now)) {
            return 'overdue';
        } else if (followUpDate.subtract(1, 'days').isBefore(now)) {
            return 'in_a_day';
        } else {
            return 'more_than_a_day';
        }
    },

    /**
     * Set the color code class to the field tag.
     *
     * @param {string} colorCodeClass Color code class name.
     * @private
     */
    _setColorCodeClass: function(colorCodeLabel) {
        if (colorCodeLabel) {
            var defaultClasses = this._defaultExtraClasses.join(' ');
            var colorCodedClass = this._colorCodeClasses[colorCodeLabel];
            if (colorCodedClass) {
                this.$el.addClass(defaultClasses + ' ' + colorCodedClass);
            } else {
                this.$el.addClass(defaultClasses);
            }
        }
    },

    /**
     * Clear color coding classes.
     * @private
     */
    _clearColorCode: function() {
        var classes = _.union(_.values(this._colorCodeClasses), this._defaultExtraClasses).join(' ');
        this.$el.removeClass(classes);
    }
}) },
"manage-subscription": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ManageSubscriptionField
 * @alias SUGAR.App.view.fields.BaseManageSubscriptionField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Manage-subscription Field (base) 

    extendsFrom: 'RowactionField',

    initialize: function (options) {
        this._super("initialize", [options]);
        this.type = 'rowaction';
    },

    /**
     * Event to navigate to the BWC Manage Subscriptions
     */
    rowActionSelect: function() {

        var route = app.bwc.buildRoute('Campaigns', this.model.id, 'Subscriptions', {
            return_module: this.module,
            return_id: this.model.id
        });
        app.router.navigate(route, {trigger: true});
    },

    /**
     * @inheritdoc
     * Check access for Campaigns Module.
     */
    hasAccess: function() {
        var access = app.acl.hasAccess('view', 'Campaigns');
        return access && this._super('hasAccess');
    }
}) },
"unlink-action": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Unlink row action used in subpanels and dashlets.
 *
 * @class View.Fields.Base.UnlinkActionField
 * @alias SUGAR.App.view.fields.BaseUnlinkActionField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Unlink-action Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     *
     * By default `list:unlinkrow:fire` event is triggered if none supplied
     * through metadata.
     */
    initialize: function(options) {
        options.def.event = options.def.event || 'list:unlinkrow:fire';
        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * @inheritdoc
     *
     * If parent module matches `Homepage` then `false` is returned.
     *
     * Plus, we cannot unlink one-to-many relationships when the relationship
     * is a required field - if that's the case `false` is returned as well.
     *
     * @return {Boolean} `true` if access is allowed, `false` otherwise.
     */
    hasAccess: function() {
        var parentModule = this.context.get('parentModule');
        if (parentModule === 'Home') {
            return false;
        }

        var link = this.context.get('link');
        if (link && app.utils.isRequiredLink(parentModule, link)) {
            return false;
        }

        return this._super('hasAccess');
    }
}) },
"dataprivacyerase": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.DataPrivacyEraseField
 * @alias SUGAR.App.view.fields.BaseDataPrivacyEraseField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Dataprivacyerase Field (base) 

    extendsFrom: 'RowactionField',

    events: {
        'click [name="dataprivacy-erase"]': 'showMarkForErasePanel'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * Check if the given module has any PII fields
     * @private
     */
    _hasPIIFields: function(baseModule) {
        return _.some(app.metadata.getModule(baseModule, 'fields'), function(field) {
            return field.pii;
        });
    },

    /**
     * @inheritdoc
     * Add ability to hide/show the erase action based on conditions
     */
    _render: function() {
        // only show erase link if all these donditions are met
        if (this.context.parent.get('module') == 'DataPrivacy' &&
            this.context.parent.get('model').get('status') == 'Open' &&
            this.context.parent.get('model').get('type') == 'Request to Erase Information' &&
            this._hasPIIFields(this.module) &&
            app.acl.hasAccess('admin', 'DataPrivacy') &&
            app.acl.hasAccess('admin', this.module)) {
            this._super('_render');
        } else {
            this.hide();
        }
    },

    bindDataChange: function() {
        this._super('bindDataChange', arguments);
        //When the parent record resaves, check if we need to show/hide
        this.listenTo(this.context.parent.get('model'), 'sync', this.render);
    },

    /**
     * Trigger event to open the Mark for Erasure drawer.
     */
    showMarkForErasePanel: function() {
        this.context.parent.trigger('mark-erasure:click', this.model);
    }
}) },
"hint-news-preferences-trigger": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.HintNewsPreferencesTriggerField
 * @alias SUGAR.App.view.fields.BaseHintNewsPreferencesTriggerField
 * @extends View.Fields.Base.BaseField
 */
({
	// Hint-news-preferences-trigger Field (base) 

    extendsFrom: 'ButtonField',

    events: {
        'click .hint-news-preferences-trigger': 'openNewsNotificationsPreferences'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.isDarkMode = app.hint.isDarkMode();
    },

    /**
     * Open News Notifications Preferences
     */
    openNewsNotificationsPreferences: function() {
        app.drawer.open({
            layout: 'stage2-news-preferences-drawer'
        });
    }
}) },
"repeat-until": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Repeat Until is a custom field for Meetings/Calls modules used to add
 * validation that ensures the date is after the end date, but only if this
 * field is editable.
 *
 * FIXME: This component will be moved out of clients/base folder as part of
 * MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.RepeatUntilField
 * @alias SUGAR.App.view.fields.BaseRepeatUntilField
 * @extends View.Fields.Base.DateField
 */
({
	// Repeat-until Field (base) 

    extendsFrom: 'DateField',

    /**
     * @inheritdoc
     *
     * Add validation that ensures the date is after the end date, but only if
     * this field is editable.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'date';

        this.model.addValidationTask(
            'repeat_until_validator_' + this.cid,
            _.bind(this._doValidateRepeatUntil, this)
        );
    },

    /**
     * Custom validator for the `repeat_until` field.
     *
     * This validates `repeat_until` to ensure the date is on or after the start date,
     * but only if this field is editable.
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateRepeatUntil: function(fields, errors, callback) {
        var isOnOrAfterStartDate,
            startDate = this.model.get('date_start'),
            repeatUntil = this.model.get(this.name),
            startDateField = this.view.getField('date_start');

        if (!_.isEmpty(repeatUntil) && (this.action === 'edit') && startDateField) {
            startDate = app.date(startDate).minutes(0).hours(0);
            isOnOrAfterStartDate = !app.date(repeatUntil).isBefore(startDate);
            if (!isOnOrAfterStartDate || !startDate.isValid()) {
                errors[this.name] = {'isAfter': startDateField.label};
            }
        }

        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('repeat_until_validator_' + this.cid);
        this._super('_dispose');
    }
}) },
"parent": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ParentField
 * @alias SUGAR.App.view.fields.BaseParentField
 * @extends View.Fields.Base.RelateField
 */
({
	// Parent Field (base) 

    extendsFrom: 'RelateField',
    fieldTag: 'input.select2[name=parent_name]',
    typeFieldTag: 'select.select2[name=parent_type]',
    plugins: ['FieldDuplicate', 'FocusDrawer'],

    /**
     * @inheritDoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //FIXME: BR-4575 will remove this.
        this.fieldDefs = _.extend(this.fieldDefs || {}, {link: 'parent'});

        /**
         * A hash of available modules in the parent type dropdown matching
         * the modules names with their label.
         *
         * @property {Object}
         * @private
         */
        this._modules = app.lang.getAppListStrings(this.def.options);

        /**
         * The hash of available modules in the parent type dropdown, filtered
         * according to list acls.
         *
         * @property {Object}
         */
        this.moduleList = {};

        this._filterModuleList(this._modules);
    },

    _isErasedField: function() {
        if (this.model && this.model.has('parent')) {
            var link = this.model.get('parent');
            if (_.isEmpty(link._erased_fields)) {
                return false;
            }
            var parentType = link.parent_type || this.model.get('parent_type');
            if (parentType) {
                return app.utils.isNameErased(app.data.createBean(parentType, link));
            }
        }

        return false;
    },

    /**
     * Calls {@link View.Fields.Base.RelateField#_render} and renders the select2
     * module dropdown.
     *
     * @inheritDoc
     */
    _render: function() {
        var self = this;
        var moduleName = this.getSearchModule();
        var module = _.pick(this._modules, moduleName);
        if (module && !app.acl.hasAccess('list', moduleName)) {
            this.noAccessModule = {key: moduleName, value: module[moduleName]};
        }

        this._super("_render");

        // Make sure that we are in list view and that a record has been specified before we render the module avatar
        if (this.view && this.view.action === 'list' && this.model.get('parent_id')) {
            this._createListViewAvatar(moduleName);
        }

        /**
         * Only allow modification of the select2 functionality under the specified templates
         */
        var allowedTpls = ['edit', 'massupdate'];
        if (_.contains(allowedTpls, this.tplName)) {
            var inList = (this.view.name === 'recordlist') ? true : false;

            this.$(this.typeFieldTag).select2({
                dropdownCssClass: inList?'select2-narrow':'',
                containerCssClass: inList?'select2-narrow':'',
                width: inList?'off':'100%',
                minimumResultsForSearch: 5
            }).on('change', function(e) {
                var module = e.val;
                if (self.noAccessModule && module !== self.noAccessModule) {
                    delete self.noAccessModule;
                }
                self.setValue({
                    id: '',
                    value: '',
                    module: module
                });
                self.$(self.fieldTag).select2('val', '');
            }).on('select2-focus', _.bind(_.debounce(this.handleFocus, 0), this));

            var domParentTypeVal = this.$(this.typeFieldTag).val();
            if(this.model.get(this.def.type_name) !== domParentTypeVal) {
                this.model.setDefault(this.def.type_name, domParentTypeVal);
                this._createSearchCollection();
            }

            if(app.acl.hasAccessToModel('edit', this.model, this.name) === false) {
                this.$(this.typeFieldTag).select2("disable");
            } else {
                this.$(this.typeFieldTag).select2("enable");
            }
        } else if(this.tplName === 'disabled'){
            this.$(this.typeFieldTag).select2('disable');
        }
        return this;
    },
    _getRelateId: function() {
         return this.model.get("parent_id");
     },
    format: function(value) {
        var module;
        this.def.module = this.getSearchModule();

        if (this.def.module) {
            module = app.lang.getModuleName(this.def.module);
        }

        var label;
        if (!_.isUndefined(module) &&
            !this.isFieldEmpty() &&
            this.tplName === 'detail') {
            label = module;
        } else {
            label = app.lang.get(this.def.label, this.module);
        }
        this.context.set('record_label', {
            field: this.name,
            label: label
        });

        var parentCtx = this.context && this.context.parent,
            setFromCtx;

        if (value) {
            this._valueSetOnce = true;
        }

        setFromCtx = !value && !this._valueSetOnce && parentCtx && _.isEmpty(this.context.get('model').link) &&
            this.view instanceof app.view.views.BaseCreateView &&
            _.contains(_.keys(app.lang.getAppListStrings(this.def.parent_type)), parentCtx.get('module')) &&
            this.module !== this.def.module;

        if (setFromCtx) {
            this._valueSetOnce = true;
            var model = parentCtx.get('model');
            // FIXME we need a method to prevent us from doing this
            // FIXME the setValue receives a model but not a backbone model...
            var attributes = model.toJSON();
            attributes.silent = true;
            this.setValue(attributes);
            value = this.model.get(this.name);

            // FIXME we need to iterate over the populated_ that isn't working now
        }

        return this._super('format', [value]);

    },

    /**
     * Filters the module list according to list acls.
     *
     * @param {Object} A hash of module names matching with their label.
     * @private
     */
    _filterModuleList: function(modules) {
        var filteredModules = _.filter(_.keys(modules), function(module) {
            return app.acl.hasAccess('list', module);
        });
        this.moduleList = _.pick(modules, filteredModules);
    },

    /**
     * @override
     */
    setValue: function(models) {
        if (!models) {
            return;
        }
        models = _.isArray(models) ? models : [models];
        _.each(models, _.bind(function(model) {

            var silent = model.silent || false,
            // FIXME we shouldn't make this assumption and this method should
            // receive a true Backbone.Model or Data.Bean
                module = model.module || model._module;


            if (app.acl.hasAccessToModel(this.action, this.model, this.name)) {
                if (module) {
                    this.model.set('parent_type', module, {silent: silent});
                    this._createSearchCollection();
                }
                // only set when we have an id on the model, as setting undefined
                // is causing issues with the warnUnsavedChanges() method
                if (!_.isUndefined(model.id)) {
                    // FIXME we shouldn't rely on model.value... and hack the full_name here until we fix it properly
                    // SC-4196 will fix this.
                    var value = model.value || model[this.def.rname || 'name'] || model['full_name'] ||
                        app.utils.formatNameLocale(model);
                    var forceUpdate = _.isEmpty(this.model.get(this.def.name)) && _.isEmpty(value);
                    this.model.set(
                        {
                            'parent_id': model.id,
                            'parent_name': value,
                            'parent': model
                        },
                        {silent: silent}
                    );
                    if (forceUpdate) {
                        this._updateField();
                    }
                }
            }
        }, this));


        // TODO we should support the auto populate of other fields like we do on normal relate.js
    },
    /**
     * Is this module available as an option to be set as parent type?
     * @param module {string}
     * @return {boolean}
     */
    isAvailableParentType: function(module) {
        var moduleFound = _.find(this.$(this.typeFieldTag).find('option'), function(dom) {
            return $(dom).val() === module;
        });
        return !!moduleFound;
    },
    getSearchModule: function() {
        return this.model.get('parent_type') || this.$(this.typeFieldTag).val();
    },
    getPlaceHolder: function() {
        return  app.lang.get('LBL_SEARCH_SELECT', this.module);
    },
    unbindDom: function() {
        this.$(this.typeFieldTag).select2('destroy');
        this._super("unbindDom");
    },

    /**
     * @inheritdoc
     * Avoid rendering process on select2 change in order to keep focus.
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        if (this.model) {
            this.model.on('change:parent_type', function() {
                var plugin = this.$(this.typeFieldTag).data('select2');
                if (_.isEmpty(plugin) || !plugin.searchmore) {
                    this.render();
                } else {
                    this.$(this.typeFieldTag).select2('val', this.model.get('parent_type'));
                }
            }, this);
        }
    },

    /**
     * Handler to refresh search collection when merging duplicates.
     *
     * Called from {@link app.plugins.FieldDuplicate#_onFieldDuplicate}
     */
    onFieldDuplicate: function() {
        if (_.isEmpty(this.searchCollection) ||
            this.searchCollection.module !== this.getSearchModule()
        ) {
            this._createSearchCollection();
        }
    },

    /**
     * Creates and renders the module specific avatar in list view
     *
     * @private
     */
    _createListViewAvatar: function(moduleName) {
        var avatarField = app.view.createField({
            def: {
                type: 'avatar',
                size: 'small',
            },
            view: this.view,
            nested: true,
            viewName: 'list',
            model: this.model,
            module: moduleName,
        });
        avatarField.render();
        this.$el.find('.parent_avatar').prepend(avatarField.$el.children());
    },

    /**
     * We do not support this field for preview edit
     * @inheritdoc
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        if (this.view.name === 'preview' && this.action !== 'erased') {
            this.template = app.template.getField('parent', 'detail', this.model.module);
        }
    }
}) },
"enum-colorcoded": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * EnumColorCodedField is an enum field that sets a background color
 * based on its value.
 * - Background colors will map to default colors based on the order of enum options
 *   from native Javascript method `Object.keys`.
 * - For example:
 *     - if `Object.keys` returns ['New', 'Duplicate', 'Pending Input', 'a_custom_option'],
 *       the color will be "dark-green, blue, dark-red, purple" respectively.
 *     - if `Object.keys` returns ['New', 'Duplicate', 'another_custom_option', 'Pending Input', 'a_custom_option']
 *       the color will be "dark-green, blue, dark-red, purple, dark-teal" respectively.
 *
 * @class View.Fields.Base.EnumColorCodedField
 * @alias SUGAR.App.view.fields.BaseEnumColorCodedField
 * @extends View.Fields.Base.EnumField
 */
({
	// Enum-colorcoded Field (base) 

    extendsFrom: 'EnumField',

    /**
     * List of additional CSS classes to apply when showing a colored pill.
     *
     * @type string[]
     * @private
     */
    _defaultExtraClasses: ['label', 'pill'],

    /**
     * List of default color codes
     *
     * @type string[]
     * @private
     */
    _defaultColorCodes: [
        'dark-green',
        'blue',
        'dark-red',
        'purple',
        'dark-teal',
        'dark-blue',
        'dark-coral',
        'dark-orange',
        'bright-blue',
        'red',
        'gray-light',
        'gray-dark'
    ],

    /**
     * @inheritdoc
     *
     * Listen for a change to this field's value and set color coding
     * appropriately.
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.model.on('change:' + this.name, this.setColorCoding, this);
    },

    /**
     * @inheritdoc
     *
     * Checks color code conditions to determine if this field should have
     * color applied to it.
     */
    _render: function() {
        this.type = 'enum'; // use enum templates
        this._super('_render');
        this.setColorCoding();
    },

    /**
     * Set color coding based on enum value.
     * This is only applied when the action is list (not inline edit on
     * list view).
     */
    setColorCoding: function() {
        this._clearColorCode();

        if (!this.model || this.action !== 'list') {
            return;
        }

        this._setColorCodeClass(this._getColorCodeClass());
    },

    /**
     * Gets color code class based on default order of enum options.
     *
     * @return {string} One of the color codes or an empty string
     *   if no color code.
     * @private
     */
    _getColorCodeClass: function() {
        var value = this.model.get(this.name);

        if (_.isEmpty(value) || !_.isObject(this.items)) {
            return '';
        }

        var codeIndex = Object.keys(this.items).indexOf(value) % this._defaultColorCodes.length;
        return this._defaultColorCodes[codeIndex] || '';
    },

    /**
     * Set the color code class to the field tag.
     *
     * @param {string} colorCodeClass Color code class name.
     * @private
     */
    _setColorCodeClass: function(colorCodeClass) {
        if (colorCodeClass) {
            this.$el.addClass(this._defaultExtraClasses.join(' ') + ' ' + colorCodeClass);
        }
    },

    /**
     * Clear color coding classes.
     * @private
     */
    _clearColorCode: function() {
        var classes = _.union(this._defaultColorCodes, this._defaultExtraClasses).join(' ');
        this.$el.removeClass(classes);
    }
}) },
"html": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.HtmlField
 * @alias SUGAR.App.view.fields.BaseHtmlField
 * @extends View.Fields.Base.BaseField
 */
({
	// Html Field (base) 

    fieldSelector: '.htmlareafield', //iframe selector

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     *
     * The html area is always a readonly field.
     * (see htmleditable for an editable html field)
     */
    initialize: function(options) {
        options.def.readonly = true;
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     *
     * Set the name of the field on the iframe as well as the contents
     *
     * @private
     */
    _render: function() {
        app.view.Field.prototype._render.call(this);

        this._getFieldElement().attr('name', this.name);
        this.setViewContent();
    },

    /**
     * Sets read only html content in the iframe
     */
    setViewContent: function(){
        var value = this.value || this.def.default_value;
        var field = this._getFieldElement();
        if(field && field.get(0) && !_.isEmpty(field.get(0).contentDocument)) {
            if(field.contents().find('body').length > 0){
                field.contents().find('body').html(value);
            }
        }
    },

    /**
     * Finds iframe element in the field template
     *
     * @return {HTMLElement} element from field template
     * @private
     */
    _getFieldElement: function() {
        return this.$el.find(this.fieldSelector);
    }

}) },
"currency": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.CurrencyField
 * @alias SUGAR.App.view.fields.BaseCurrencyField
 * @extends View.Fields.Base.BaseField
 */
({
	// Currency Field (base) 

    /**
     * list of events to listen for
     * @type {Object}
     */
    'events': {
        'click': 'updateCss'
    },
    /**
     * @type {String}
     * field value non-formatted or converted
     */
    transactionValue: '',
    /**
     * @type {Object}
     * reference to the currency dropdown field object
     */
    _currencyField: null,
    /**
     * @type {Boolean}
     * whether or not the currency dropdown is hidden from view
     */
    hideCurrencyDropdown: false,
    /**
     * @type {String}
     * last known record currency id
     */
    _lastCurrencyId: null,

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * Do we have edit access to this field?
     */
    hasEditAccess: true,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        var currencyField = this.def.currency_field || 'currency_id',
            currencyFieldValue, baseRateField, baseRateFieldValue;

        // should we ignore the user preference currency
        // currently this is only used in quotes
        var ignoreUserPrefCurrency = this.model.ignoreUserPrefCurrency || false;

        if (this.model.isNew() && (!this.model.isCopy()) && (!ignoreUserPrefCurrency)) {
            // new records are set the user's preferred currency
            currencyFieldValue = app.user.getPreference('currency_id');
            this.model.set(currencyField, currencyFieldValue);

            // set the base rate for the user's preferred currency
            baseRateField = this.def.base_rate_field || 'base_rate';
            baseRateFieldValue = app.metadata.getCurrency(currencyFieldValue).conversion_rate;
            this.model.set(baseRateField, baseRateFieldValue);

            // Modules such as `Forecasts` uses models that aren't `Data.Bean`
            if (_.isFunction(this.model.setDefault)) {
                var defaults = {};
                defaults[currencyField] = currencyFieldValue;
                defaults[baseRateField] = baseRateFieldValue;
                this.model.setDefault(defaults);
            }
        }
        this.hasEditAccess = app.acl.hasAccess('edit', this.model.module, undefined, this.name);
        // hide currency dropdown on list views
        this.hideCurrencyDropdown = this.view.action === 'list';
        // track the last currency id to convert the value on change
        this._lastCurrencyId = this.model.get(currencyField);
    },

    /**
     * @inheritdoc
     *
     * Setup transactional amount if flag is present and transaction currency
     * is not base.
     * On edit view render the currency enum field associated with this field on
     * the correct placeholder
     *
     * @return {Object} this
     * @private
     */
    _render: function() {
        if (this._currencyField) {
            this._currencyField.dispose();
            this._currencyField = null;
        }
        this._super('_render');
        if (this.hideCurrencyDropdown === false && this.tplName === 'edit') {
            this.getCurrencyField().setElement(this.$('span[sfuuid="' + this.currencySfId + '"]'));
            this.$el.find('div.select2-container').css('min-width', '8px');
            this.getCurrencyField().render();
        }
        return this;
    },

    handleValidationError: function(errors) {
        this._super('handleValidationError', [errors]);
        _.defer(function (field) {
            field.clearErrorDecoration();
            field.decorateError(errors);

        }, this);
    },

    clearErrorDecoration: function () {
        var self = this,
            ftag = this.fieldTag || '',
            $ftag = this.$(ftag);
        // Remove previous exclamation then add back.
        this.$('.add-on').remove();

        //Not all inputs are necessarily wrapped so check each individually
        $ftag.each(function(index, el) {
            var isWrapped = self.$(el).parent().hasClass('input-append');
            if (isWrapped) {
                self.$(el).unwrap();
            }
        });
        this.$el.removeClass(ftag);
        this.$el.removeClass("error");
        this.$el.closest('.record-cell').removeClass("error");
    },

    /**
     * @override
     *
     * If the incoming value is the same as the value on the model
     * then just set the currency value so it's formatted correctly
     * otherwise, set the new value on the model
     */
    bindDomChange: function() {
        if (!(this.model instanceof Backbone.Model)) {
            return;
        }

        var self = this;
        var el = this.$el.find(this.fieldTag);
        el.on('change', function() {
            // trimming the value to remove space if any
            var trimVal = el.val() ? el.val().trim() : el.val();
            var val = self.unformat(trimVal);
            if (_.isEqual(val, self.model.get(self.name))) {
                self.setCurrencyValue(val);
            } else {
                self.model.set(self.name, val);
            }
        });
    },

    /**
     * When currency changes, we need to make appropriate silent changes to the base rate.
     */
    bindDataChange: function() {
        // we do not call the parent which re-renders,
        // but instead update the value on the field directly
        this.model.on('change:' + this.name, this._valueChangeHandler, this);

        if (this.def.is_base_currency) {
            // do not add change handler to _usdollar fields
            return;
        }

        var currencyField = this.def.currency_field || 'currency_id';
        var baseRateField = this.def.base_rate_field || 'base_rate';
        // if the current_user doesn't have edit access to the field
        // don't add these listeners
        if (this.hasEditAccess && !this.hideCurrencyDropdown) {
            this.model.on('change:' + baseRateField, this.handleBaseRateFieldChange, this);
            this.model.on('change:' + currencyField, this.handleCurrencyFieldChange, this);
        }
    },

    /**
     * Listens to currency field changes. Calls the update model value method if required and saves the latest
     * currencyId
     * @protected
     */
    handleCurrencyFieldChange: function(model, currencyId, options) {
        var baseRateField = this.def.base_rate_field || 'base_rate';
        //When model is reset, it should not be called
        if (!currencyId || !this._lastCurrencyId || options.revert === true) {
            this._lastCurrencyId = currencyId;
            return;
        }

        if (_.has(model.changed, this.name)) {
            // if this field is on the view more than once, this will trigger x number of times. so if the
            // currency_id has changed and this field has already changed on the model, we should ignore it.
            return;
        }

        // update the base rate in the model, set it silently since we are already going to do a re-render
        this.model.set(baseRateField, app.metadata.getCurrency(currencyId).conversion_rate, {silent: true});

        if (!_.isUndefined(this.view.getField('base_rate'))) {
            this.view.getField('base_rate').render();
        }

        // convert the value to new currency on the model
        if (model.has(this.name)) {
            var val = model.get(this.name);
            this.updateModelWithValue(model, currencyId, val);
        }
        this._lastCurrencyId = currencyId;
    },

    /**
     * Updates the currency field value when the currency field changes.  Defers model changes and re-renders the field
     * so that the currency value changes when a 0 amount is switched between currencies.
     * @protected
     */
    updateModelWithValue: function(model, currencyId, val) {
        if (val) {
            this.model.set(
                this.name,
                app.currency.convertAmount(
                    val,
                    this._lastCurrencyId,
                    currencyId
                ),
                // we don't want to affect other bindings like sugar logic
                // when updating a value upon a currency_id change,
                // so set the model silently, then update the field value
                // directly (see next func call)
                {silent: true}
            );
        }
        // now defer changes to the end of the thread to avoid conflicts
        // with other events (from SugarLogic, etc.)
        this._deferModelChange();
    },

    /**
     * handles when the base rate changes.  Defers model changes and re-renders the field
     * so that the currency symbol changes when a 0 amount is switched between currencies.
     * @private
     */
    handleBaseRateFieldChange: function(model, currencyId, options) {
        var baseRateField = this.def.base_rate_field || 'base_rate';
        var prevBaseRate = model.previous(baseRateField);
        var baseRate = model.get(baseRateField);
        var precision;
        var newValue;
        var previousValue;

        if (!_.isUndefined(prevBaseRate)) { // it is undefined, of course, at first load
            precision = this.def && this.def.precision || 6;
            // lets actually make sure this really changed before triggering the deferModelChange method.
            // that way if base_rate is a integer we can actually make sure it didn't change
            // eg: 1 to "1.000000"
            newValue = app.math.round(baseRate, precision, true);
            previousValue = app.math.round(prevBaseRate, precision, true);
            if (!_.isEqual(newValue, previousValue)) {
                if (options && _.isUndefined(options.revert)) {
                    this._deferModelChange();
                }
            }
        }
        //rerender the currency field. This is needed if a currency field is 0, but changes currencies.  Since
        //$0 and 0 EUR are the same, it doesn't detect the switch and 0 fields can show the wrong currency symbol.
        this._render();
    },

    /**
     * Trigger the model change, but only if the current user has edit access to it.
     *
     * @private
     */
    _deferModelChange: function() {
        if (this.hasEditAccess) {
            _.defer(_.bind(function() {
                if (!this.disposed) {
                    this.model.trigger('change:' + this.name, this.model, this.model.get(this.name));
                }
            }, this));
        }
    },

    /**
     * Handler for when the value changes on the model.
     *
     * If action does not match edit, field is re-rendered, otherwise the field
     * value is updated, plus, if the currency of the given model is different
     * from the one we have, the supplied amount is also converted to the new
     * currency.
     *
     * @param {Data.Bean} model Model.
     * @param {String} value Amount.
     * @private
     */
    _valueChangeHandler: function(model, value) {
        if (this.action != 'edit') {
            this.render();
            return;
        }

        if (model.get('currency_id') !== this.model.get('currency_id')) {
            value = app.currency.convertAmount(
                value,
                model.get('currency_id'),
                this.model.get('currency_id')
            );
        }

        this.setCurrencyValue(value);
    },

    /**
     * set the currency value on the field directly
     *
     * @param {String} value
     */
    setCurrencyValue: function(value) {
        this.$('[name=' + this.name + ']').val(app.utils.formatNumberLocale(value));
    },

    /**
     * @inheritdoc
     *
     * Convert to base currency if flag is present.
     *
     * @param {Array/Object/String/Number/Boolean} value The value to format.
     * @return {String} the formatted value based on view name.
     */
    format: function(value) {
        if (_.isNull(value) || _.isUndefined(value) || _.isNaN(value)) {
            value = '';
        }

        if (this.tplName === 'edit') {
            this.currencySfId = this.getCurrencyField().sfId;
            return app.utils.formatNumberLocale(value);
        }

        var baseRate = this.model.get(this.def.base_rate_field || 'base_rate');
        var transactionalCurrencyId = this.model.get(this.def.currency_field || 'currency_id'),
            convertedCurrencyId = transactionalCurrencyId,
            origTransactionValue = value;

        // TODO review this forecasts requirement and make it work with css defined on metadata
        // force this to recalculate the transaction value if needed
        // and more importantly, clear out previous transaction value
        this.transactionValue = '';
        if (value === '') {
            return value;
        }
        if (this.def.is_base_currency) {
            // usdollar field, treat the field as base currency
            transactionalCurrencyId = convertedCurrencyId = app.currency.getBaseCurrencyId();
        } else {
            if (this.def.convertToBase && transactionalCurrencyId !== app.currency.getBaseCurrencyId()) {
                if (this.def.showTransactionalAmount) {
                    this.transactionValue = app.currency.formatAmountLocale(
                        this.model.get(this.name) || 0,
                        transactionalCurrencyId
                    );
                }
                value = app.currency.convertWithRate(value, baseRate) || 0;
                convertedCurrencyId = app.currency.getBaseCurrencyId();
            }
        }
        // convert value to user preferred currency
        if ((this.def.is_base_currency || this.def.convertToBase) &&
            !this.def.skip_preferred_conversion &&
            app.user.get('preferences').currency_show_preferred) {
                var userPreferredCurrencyId = app.user.getPreference('currency_id');
                if (userPreferredCurrencyId !== transactionalCurrencyId) {
                    convertedCurrencyId = userPreferredCurrencyId;

                    // when we are displaying in the user preferred currency, the transactional
                    // amount should equal the row amount
                    this.transactionValue = app.currency.formatAmountLocale(
                        this.model.get(this.name) || 0,
                        transactionalCurrencyId
                    );
                    value = app.currency.convertWithRate(
                        value,
                        '1.0',
                        app.metadata.getCurrency(userPreferredCurrencyId).conversion_rate
                    );
                } else {
                    // user preferred same as transactional, no conversion required
                    this.transactionValue = '';
                    convertedCurrencyId = transactionalCurrencyId;
                    value = origTransactionValue;
                }
        }
        return app.currency.formatAmountLocale(value, convertedCurrencyId);
    },

    /**
     * @inheritdoc
     *
     * @param {String} value The value to unformat.
     * @return {Number} Unformatted value.
     */
    unformat: function(value) {
        var unformattedValue;
        if (this.tplName === 'edit') {
            unformattedValue = app.utils.unformatNumberStringLocale(value);
        } else {
            unformattedValue = app.currency.unformatAmountLocale(value);
        }

        // if we got a number back and we have a precision we should round to that precision as that is what will
        // be stored in the db, this is needed just in case SugarLogic is used on this field's value
        if (_.isFinite(unformattedValue)) {
            // if no precision is defined, default to 6 which is the system default
            var precision = this.def && this.def.precision || 6;
            return app.math.round(unformattedValue, precision, true);
        }

        return value;
    },

    /**
     * update dropdown css to active state
     */
    updateCss: function() {
        $('div.select2-drop.select2-drop-active').width('auto');
    },

    /**
     * Get the currency field related to this currency amount.
     *
     * @return {View.Field} the currency field associated.
     */
    getCurrencyField: function() {

        if (!_.isNull(this._currencyField)) {
            return this._currencyField;
        }

        var currencyDef = this.model.fields[this.def.currency_field || 'currency_id'];
        currencyDef.type = 'enum';
        currencyDef.options = app.currency.getCurrenciesSelector(Handlebars.compile('{{symbol}} ({{iso4217}})'));
        currencyDef.enum_width = '100%';
        currencyDef.searchBarThreshold = this.def.searchBarThreshold || 7;

        this._currencyField = app.view.createField({
            def: currencyDef,
            view: this.view,
            viewName: this.tplName,
            model: this.model
        });
        this._currencyField.defaultOnUndefined = false;

        return this._currencyField;
    },

    /**
     * set the mode of the dropdown field
     * @param {String} the mode name.
     */
    setMode: function(name) {
        this._super('setMode', [name]);
        if (this.action === 'edit') {
            this.getCurrencyField().setMode(name);
        }
    },

    /**
     * @inheritdoc
     */
    dispose: function() {
        if (this._currencyField) {
            this._currencyField.dispose();
            this._currencyField = null;
        }
        this._super('dispose');
    }
}) },
"colorpicker": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Colorpicker
 * @alias SUGAR.App.view.fields.BaseColorpicker
 * @extends View.Fields.Base.BaseField
 */
({
	// Colorpicker Field (base) 

    direction: 'ltr',

    /**
     * @inheritdoc
     */
    shouldInitDefaultValue: true,

    /**
     * @inheritdoc
     */
    render: function() {
        this._super('render');

        var field = this.$('.hexvar[rel=colorpicker]');
        var preview = this.$('.color-preview');

        field.colorpicker();
        field.on('blur', _.bind(function() {
            var value = field.val();
            preview.css('backgroundColor', value);
            this.model.set(this.name, value);
        }, this));
    }
}) },
"pipeline-type": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Fields.Base.PipelineTypeField
 * @alias SUGAR.App.view.fields.BasePipelineTypeField
 * @extends View.Fields.Base.BaseField
 */

({
	// Pipeline-type Field (base) 

    /**
     * @inheritdoc
     * @param options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.getTabs();
    },

    /**
     * Getting various PipelineType tabs with their header and module fields
     */
    getTabs: function() {
        this.tabs = [];
        var fieldsForTabs = [];
        var config = app.metadata.getModule('VisualPipeline', 'config');
        fieldsForTabs.push(config.table_header[this.module]);
        var fieldMeta = app.metadata.getModule(this.module, 'fields');

        _.each(fieldsForTabs, function(field) {
            var fieldLabel = app.lang.getModString(fieldMeta[field].vname, this.module);
            var metaObject = {
                headerLabel: fieldLabel,
                moduleField: field,
                tabLabel: app.lang.get('LBL_PIPELINE_VIEW_TAB_NAME', this.module, {
                    module: app.lang.getModuleName(this.module, {plural: true}),
                    fieldName: fieldLabel
                })
            };
            this.tabs.push(metaObject);
        }, this);
    }
}) },
"preview-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Preview-button Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * True if the preview button is for a BWC module, false if not
     * @property {boolean}
     */
    isBwcEnabled: undefined,

    /**
     * Holds the proper tooltip label key
     */
    tooltip: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var fieldModule = options.model.get('_module') || options.model.module;

        this.isBwcEnabled = app.metadata.getModule(fieldModule).isBwcEnabled;

        this._super('initialize', [options]);

        if(this.isBwcEnabled) {
            this.tooltip = 'LBL_PREVIEW_BWC_TOOLTIP';
        } else {
            this.tooltip = this.def.tooltip;
        }
    }
}) },
"source": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.SourceField
 * @alias SUGAR.App.view.fields.BaseSourceField
 * @extends View.Fields.Base.BaseField
 */
({
	// Source Field (base) 

    /**
     * @inheritdoc
     * Format source field based on what model is received.
     */
    format: function(value) {
        var subject = value ? value.subject : null;
        var attributes = value ? value.attributes : null;

        if (!subject) {
            return '';
        }

        if (subject.impersonated) {
            this.buildImpersonatedRoute(subject.impersonated._module, subject.impersonated.id);
            this.impersonatedValue = subject.impersonated.name;
        }

        // Try to create a link for the source field
        this.buildRoute(subject._module, subject.id);

        // When we receive full data (name & module & id), return name
        if (subject._module && subject.id && subject.name) {
            return subject.name;
        }

        // If data is incomplete, fall back to label
        var labelValue = this._getValidLabelValue(this.module, subject._type);

        if (labelValue) {
            if (subject.label) {
                labelValue += ' ' + subject.label;
            }
            return labelValue;
        }

        // If no label found, fall back to name
        if (subject.name) {
            return subject.name;
        }

        // No subject module and name found, this is likely an external source
        // If identityAwareDataSource is set in attributes (via API), we want to display it
        if (attributes && attributes.identityAwareDataSource &&
            !_.isEmpty(attributes.identityAwareDataSource)) {
            return attributes.identityAwareDataSource;
        }

        // Worst case scenario: try to display the id of the source or empty string
        return subject.id ? subject.id : '';
    },

    /**
     * Builds the route for the source model.
     * @param {string} module The module to link to.
     * @param {string} id The record id to link to.
     */
    buildRoute: function(module, id) {
        if (_.isUndefined(module) || _.isUndefined(id) || _.isEmpty(module)) {
            return;
        }

        var oldModule = module;
        if (module === 'Users') {
            module = 'Employees';
        }

        if (app.acl.hasAccess('view', oldModule)) {
            this.href = '#' + app.router.buildRoute(module, id);
        } else {
            this.href = undefined;
        }
    },

    /**
     * Builds the route for the impersonated source.
     * @param {string} module The module to link to.
     * @param {string} id The record id to link to.
     */
    buildImpersonatedRoute: function(module, id) {
        if (_.isUndefined(module) || _.isUndefined(id) || _.isEmpty(module)) {
            return;
        }

        var oldModule = module;
        if (module === 'Users') {
            module = 'Employees';
        }

        if (app.acl.hasAccess('view', oldModule)) {
            this.impersonatedHref = '#' + app.router.buildRoute(module, id);
        } else {
            this.impersonatedHref = undefined;
        }
    },

    /**
     * Dynamically generate label for model in case, and if the label is
     * defined return label value or null.
     * @param {Object} module Current audit module.
     * @param {string} type Source type.
     * @return {string|null} Label value or null if the label is not found.
     * @private
     */
    _getValidLabelValue: function(module, type) {
        var fullLabel = 'LBL_AUDIT_SUBJECT_' + type.toUpperCase();
        var labelValue =  app.lang.get(fullLabel, module);

        // If we get the same value from translate, return null
        return fullLabel === labelValue ? null : labelValue;
    }
}) },
"image": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ImageField
 * @alias SUGAR.App.view.fields.BaseImageField
 * @extends View.Fields.Base.BaseField
 */
({
	// Image Field (base) 

    fieldTag: 'input[type=file]',

    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    events: {
        "click .delete": "delete",
        "change input[type=file]": "selectImage"
    },

    plugins: ['File', 'FieldDuplicate'],

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @override
     *
     * FIXME: The {@link #model} used by this view should be a {@link Data.Bean}
     * and not a simple {@link Backbone.Model}. This should be removed when
     * {@link View.Views.Base.HistorySummaryView} view is refactored to use a
     * true {@link Data.MixedBeanCollection}.
     */
    initialize: function(options) {
        app.view.Field.prototype.initialize.call(this, options);

        // FIXME: This needs an API instead. SC-3369 should address this.
        // Also, this field should extend the file field to inherit these
        // error properties.
        app.error.errorName2Keys['tooBig'] = 'ERROR_MAX_FILESIZE_EXCEEDED';
        app.error.errorName2Keys['uploadFailed'] = 'ERROR_UPLOAD_FAILED';

        // FIXME: we should have a {@link Da
        if (_.isFunction(this.model.addValidationTask)) {
            this.model.hasImageRequiredValidator = true;
            this.model.addValidationTask('image_required_' + this.cid, _.bind(this._doValidateImageField, this));
        }
    },

    /**
     * @override
     * @private
     */
    _dispose: function() {
        //Remove specific validation task from the model
        this.model.hasImageRequiredValidator = false;
        if (this.model.removeValidationTask) {
            this.model.removeValidationTask('image_required_' + this.cid);
        }
        app.view.Field.prototype._dispose.call(this);
    },

    /**
     * Handler to refresh field state.
     *
     * Called from {@link app.plugins._onFieldDuplicate}
     */
    onFieldDuplicate: function() {
        if (this.disposed || this.view.name !== 'merge-duplicates') {
            return;
        }
        this.render();
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        this.model.fileField = this.name;
        app.view.Field.prototype._render.call(this);

        //Define default sizes
        if (this.view && this.view.meta && this.view.meta.type === 'list') {
            this.width = this.height = this.$el.parent().height() || 42;
            this.def.width = this.def.height = undefined;
        } else {
            this.width = parseInt(this.def.width || this.def.height, 10) || 42;
            this.height = parseInt(this.def.height, 10) || this.width;
        }

        //Resize widget before the image is loaded
        this.resizeWidth(this.width);
        this.resizeHeight(this.height);
        this.$('.image_field').removeClass('hide');
        //Resize widget once the image is loaded
        this.$('img').addClass('hide').on('load', $.proxy(this.resizeWidget, this));
        return this;
    },

    /**
     * @override
     * @param value
     * @return value
     */
    format: function(value) {
        if (value) {
            value = this.buildUrl() + "&_hash=" + value;
        }
        return value;
    },

    /**
     * @override
     */
    bindDataChange: function() {
        //Keep empty for edit because you cannot set a value of an input type `file`
        var viewType = this.view.name || this.options.viewName;
        var ignoreViewType = ["edit", "create"];
        if ((_.indexOf(ignoreViewType, viewType) < 0)
            && (this.view.action !== "edit")
            && (this.view.name !== 'merge-duplicates')) {
            app.view.Field.prototype.bindDataChange.call(this);
        }
    },

    /**
     * @override
     */
    bindDomChange: function() {
        //Override default behavior
        this.$(this.fieldTag).on('focus', _.bind(this.handleFocus, this));
    },

    /**
     * This is the custom implementation of bindDomChange. Here we upload the image to give a preview to the user.
     * @param e
     */
    selectImage: function(e) {
        var self = this,
            $input = self.$('input[type=file]');

        //Set flag to indicate we are previewing an image
        self.preview = true;

        //Remove error message
        self.clearErrorDecoration();

        // Upload a temporary file for preview
        self.model.uploadFile(
            self.name,
            $input,
            {
                field: self.name,
                //Callbacks
                success: function(rsp) {
                    //read the guid
                    var fileId = (rsp[self.name]) ? rsp[self.name]['guid'] : null;
                    var url = app.api.buildFileURL({
                        module: self.module,
                        id: 'temp',
                        field: self.name,
                        fileId: fileId
                    }, {keep: true});
                    // show image
                    var image = $('<img>').addClass('hide').attr('src', url).on('load', $.proxy(self.resizeWidget, self));
                    self.$('.image_preview').html(image);

                    // Add the guid to the list of fields to set on the model.
                    if (fileId) {
                        if (!self.model.fields[self.name + '_guid']) {
                            self.model.fields[self.name + '_guid'] = {
                                type: 'file_temp',
                                group: self.name
                            };
                        }
                        self.model.unset(self.name);
                        self.model.set(self.name + '_guid', fileId);
                    }
                },
                error: function(resp) {
                    var errors = errors || {},
                        fieldName = self.name;
                    errors[fieldName] = {};

                    switch (resp.error) {
                        case 'request_too_large':
                           errors[fieldName].tooBig = true;
                           break;
                        default:
                            errors[fieldName].uploadFailed = true;
                    }
                    self.model.unset(fieldName + '_guid');
                    self.model.trigger('error:validation:' + this.field, errors[fieldName]);
                    self.model.trigger('error:validation', errors);
                }
            },
            { temp: true }); //for File API to understand we upload a temporary file
    },

    /**
     * Calls when deleting the image or canceling the preview
     * @param e
     */
    'delete': function(e) {
        var self = this;
        //If we are previewing a file and want to cancel
        if (this.preview === true) {
            self.preview = false;
            self.clearErrorDecoration();
            self.render();
            return;
        }

        // If it's a duplicate, don't delete the file
        if (this._duplicateBeanId) {
            self.model.unset(self.name);
            self.model.set(self.name, null);
            self.render();
            return;
        }

        var confirmMessage = app.lang.get('LBL_IMAGE_DELETE_CONFIRM', self.module);
        if (confirm(confirmMessage)) {
            //Otherwise delete the image
            app.api.call('delete', self.buildUrl({htmlJsonFormat: false}), {}, {
                    success: function(response) {
                        //Need to fire the change event twice so model.previous(self.name) is also changed.
                        self.model.unset(self.name);
                        self.model.set(self.name, null);
                        if (response.record && response.record.date_modified) {
                            self.model.set('date_modified', response.record.date_modified);
                        }
                        if (!self.disposed) {
                            self.render();
                        }
                    },
                    error: function(data) {
                        // refresh token if it has expired
                        app.error.handleHttpError(data, {});
                    }}
            );
        }
    },

    /**
     * Build URI for File API
     * @param options
     */
    buildUrl: function(options) {
        return app.api.buildFileURL({
            module: this._duplicateBeanModule ? this._duplicateBeanModule : this.module,
            id: this._duplicateBeanId ? this._duplicateBeanId : this.model.id,
            field: this.name
        }, options);
    },

    /**
     * Resize widget based on field defs and image size
     */
    resizeWidget: function() {
        var image = this.$('.image_preview img, .image_detail img');

        if (!image[0]) return;

        var isDefHeight = !_.isUndefined(this.def.height) && this.def.height > 0,
            isDefWidth = !_.isUndefined(this.def.width) && this.def.width > 0;

        //set width/height defined in field defs
        if (isDefWidth) {
            image.css('width', this.width);
        }
        if (isDefHeight) {
            image.css('height', this.height);
        }

        if (!isDefHeight && !isDefWidth)
            image.css({
                'height': this.height,
                'width': this.width
            });

        //now resize widget
        //we resize the widget based on current image height
        this.resizeHeight(image.height());
        //if height was defined but not width, we want to resize image width to keep
        //proportionality: this.height/naturalHeight = newWidth/naturalWidth
        if (isDefHeight && !isDefWidth) {
            var newWidth = Math.floor((this.height / image[0].naturalHeight) * image[0].naturalWidth);
            image.css('width', newWidth);
            this.resizeWidth(newWidth);
        }

        image.removeClass('hide');
        this.$('.delete').remove();
        var icon = this.preview === true ? 'close-lg' : 'trash-lg';
        image.closest('label, a').after('<span class="image_btn delete sicon sicon-lg sicon-' + icon + ' " />');
    },

    /**
     * Utility function to append px to an integer
     *
     * @param size
     * @return {string}
     */
    formatPX: function(size) {
        size = parseInt(size, 10);
        return size + 'px';
    },

    /**
     * Resize the elements carefully to render a pretty input[type=file]
     * @param height (in pixels)
     */
    resizeHeight: function(height) {
        var $imageField = this.$('.image_field');
        var isEditAndIcon = this.$('.sicon-plus-lg').length > 0;

        if (isEditAndIcon) {
            var $imageBtn = $imageField.find('.image_btn');
            var editBtnHeight = parseInt($imageBtn.css('height'), 10);

            var previewHeight = parseInt(height, 10);
            //Remove the edit button height in edit view so that the icon is centered.
            previewHeight -= editBtnHeight ? editBtnHeight : 0;
            previewHeight = this.formatPX(previewHeight);

            $imageField.find('.sicon-plus-lg').css({lineHeight: previewHeight});
        }


        var totalHeight = this.formatPX(height);
        $imageField.css({'height': totalHeight, minHeight: totalHeight, lineHeight: totalHeight});
    },

    /**
     * Resize the elements carefully to render a pretty input[type=file]
     * @param width (in pixels)
     */
    resizeWidth: function(width) {
        var $image_field = this.$('.image_field'),
            width = this.formatPX(width),
            isInHeaderpane = $(this.el).closest('.headerpane').length > 0,
            isInRowFluid = $(this.el).closest('.row-fluid').closest('.record').length > 0;

        if (isInHeaderpane || !isInRowFluid) {
            //Need to fix width
            $image_field.css({'width': width});
        } else {
            //Width will be the biggest possible
            $image_field.css({'maxWidth': width});
        }
    },

    /**
     * Custom requiredValidator for image field because we need to check if the
     * input inside the view is empty or not.
     *
     * @param {Object} fields Hash of field definitions to validate.
     * @param {Object} errors Error validation errors.
     * @param {Function} callback Async.js waterfall callback.
     */
    _doValidateImageField: function(fields, errors, callback) {
        if (this.def.required && !this.model.get(this.name + '_guid') && !this.model.get(this.name)) {
            errors[this.name] = errors[this.name] || {};
            errors[this.name].required = true;
        }

        callback(null, fields, errors);
    },

    /**
     * Handles errors message
     *
     * @override
     * @param errors
     */
    handleValidationError: function(errors) {
        var errorMessages = [];

        if (this.action === 'detail') {
            this.setMode('edit');
        }

        //Change the preview of the image widget
        this.$('.image_preview').html('<i class="sicon sicon-close"></i>');
        //Put the cancel icon
        this.$('label').after('<span class="image_btn delete sicon sicon-close" />');

        this.$el.closest('.record-cell').addClass("error");
        this.$el.addClass('input-append error');

        _.each(errors, function(errorContext, errorName) {
            errorMessages.push(app.error.getErrorString(errorName, errorContext));
        });
        this.$('.image_field').append(this.exclamationMarkTemplate(errorMessages));
    },

    /**
     * @override
     */
    clearErrorDecoration: function() {
        //Remove the current icon
        this.$('.delete').remove();
        //Remove error message
        this.$('.error-tooltip').remove();
        this.$el.closest('.record-cell').removeClass('error');
        this.$el.removeClass('input-append error');
    }
}) },
"participants": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * ParticipantsField is a field for Meetings/Calls that manages the invitees of an event
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.ParticipantsField
 * @alias SUGAR.App.view.fields.BaseParticipantsField
 * @extends View.Fields.Base.BaseField
 */
({
	// Participants Field (base) 

    fieldTag: 'input.select2',

    plugins: ['SearchForMore'],

    events: {
        'click button[data-action=addRow]': 'addRow',
        'click button[data-action=removeRow]:not(.disabled)': 'removeRow',
        'click button[data-action=previewRow]:not(.disabled)': 'previewRow',
        'click button[data-action=show-more]': 'showMore'
    },

    placeholder: 'LBL_SEARCH_SELECT',

    // Number of hours before the meeting start datetime that will be the beginning
    // of the free/busy schedule timeline.
    timelineStart: 4,
    // Number of hours to display on free/busy schedule timeline.
    timelineLength: 9,
    // Regular Expression that parses module and ID from url
    moduleAndIdParserRegExp: new RegExp('/v\\d+_?\\d+/([^/]+)/([^/]+)/freebusy'),

    /**
     * @inheritdoc
     *
     * View.Fields.Base.ParticipantsField#placeholder can be overridden via
     * options.
     *
     * Adds a delay to the View.Fields.Base.ParticipantsField#addRow,
     * View.Fields.Base.ParticipantsField#removeRow,
     * View.Fields.Base.ParticipantsField#previewRow, and
     * View.Fields.Base.ParticipantsField#search methods so that these event
     * handlers do not execute too frequently.
     */
    initialize: function(options) {
        var fieldValue;

        this.addRow = _.debounce(this._addRowImmediately, 200);
        this.removeRow = _.debounce(this._removeRowImmediately, 200);
        this.previewRow = _.debounce(this._previewRowImmediately, 200);
        this.search = _.debounce(this.search, app.config.requiredElapsed || 500);

        this._super('initialize', [options]);

        // translate the placeholder
        this.placeholder = app.lang.get(this.def.placeholder || this.placeholder, this.module);

        if (this.model.isNew()) {
            try {
                fieldValue = this.getFieldValue();
            } catch (e) {
                // create a new virtual collection
                this.model.set(this.name, []);
            }
        }

        // get template for timeline header
        this.timelineHeaderTemplate = app.template.getField(this.type, 'timeline-header.partial', this.module);

        // get template for search result formatting
        this.searchResultTemplate = app.template.getField(this.type, 'search-result.partial', this.module);

        // caches the string "More {{field label}}..." for use in the template
        this.showMoreTemplate = app.lang.get('LBL_SHOW_MORE_GENERIC', this.module, {name: this.label});

        // adjust the start and end date/time indicator on the scheduler to fit the resized window
        $(window).on('resize.' + this.cid, _.bind(this.adjustStartAndEnd, this));
    },

    /**
     * @inheritdoc
     */
    getFieldElement: function() {
        return this.$(this.fieldTag);
    },

    /**
     * Returns the collection stored for this field.
     *
     * @throws An exception when the value is not a collection
     * @return {VirtualCollection}
     */
    getFieldValue: function() {
        var value = this.model.get(this.name);

        if (!(value instanceof app.BeanCollection)) {
            throw 'the value must be a BeanCollection';
        }

        return value;
    },

    /**
     * @inheritdoc
     *
     * Renders the field anytime the collection is changed. Updates the
     * scheduler UI anytime the start date or end date changes on the model.
     * Attempts to hide the show more button anytime the collection is
     * synchronized.
     */
    bindDataChange: function() {
        this.model.on('change:' + this.name, this.render, this);
        this.model.on('change:date_start', function() {
            this.clearFreeBusyInformationCache();
            this.renderTimelineInfo();
        }, this);
        this.model.on('change:date_end', function() {
            this.adjustStartAndEnd();
            this.clearFreeBusyInformationCache();
            this.renderTimelineInfo();
        }, this);
        this.model.on('sync:' + this.name, this.hideShowMoreButton, this);

        // Fetch free/busy information again on save to get the latest.
        this.model.on('sync', function() {
            this.clearFreeBusyInformationCache();
            this.fetchFreeBusyInformation();
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Adds the selected record to the collection.
     */
    bindDomChange: function() {
        var onChange = _.bind(function(event) {
            try {
                this.getFieldValue().add(event.added.attributes);
            } catch (e) {
                app.logger.warn(e);
            }
        }, this);

        this.getFieldElement().on('change', onChange);
    },

    /**
     * @inheritdoc
     *
     * Destroys the Select2 element.
     */
    unbindDom: function() {
        this._super('unbindDom');
        this.getFieldElement().select2('destroy');
    },

    /**
     * @inheritdoc
     *
     * @chainable
     * @private
     */
    _render: function() {
        var $el;

        this._super('_render');

        $el = this.getFieldElement();
        $el.select2({
            allowClear: false,
            formatInputTooShort: '',
            formatSearching: app.lang.get('LBL_LOADING', this.module),
            formatResult: _.bind(this.formatSearchResult, this),
            minimumInputLength: 1,
            query: _.bind(this.search, this),
            selectOnBlur: false
        });
        this.addSearchForMoreButton($el);

        this._renderWithNewRow();

        this.renderTimelineInfo();

        this.hideShowMoreButton();

        if (this.options.viewName === 'edit') {
            this.focusFirstInput();
        }

        return this;
    },

    /**
     * Called by {@link #_render} to handle the visibility of the new
     * participant row during rendering of the field.
     *
     * The select2 widget is hidden by default and never shown unless in edit
     * mode. The select2 widget is shown after render if in edit mode and the
     * collection is empty.
     *
     * If the select2 widget is shown, the delete button is disabled to prevent
     * users from deleting the row and putting the field in a state where new
     * participants cannot be added without re-rendering.
     */
    _renderWithNewRow: function() {
        var value;

        this.$('[name=newRow]').hide();

        if (this.action !== 'edit') {
            return;
        }

        try {
            value = this.getFieldValue();

            if (value.length === 0) {
                this._addRowImmediately();
                this.$('button[data-action=removeRow]').addClass('disabled');
            }
        } catch (e) {
            app.logger.warn(e);
        }
    },

    /**
     * Render timeline header, meeting start and end lines, and fill in busy
     * schedule timeslots.
     */
    renderTimelineInfo: function() {
        var startAndEndDates = this.getStartAndEndDates();

        if ((this.getTimelineBlocks().length > 0) && (!_.isEmpty(startAndEndDates))) {
            this.renderTimelineHeader();
            this.adjustStartAndEnd();
            this.fetchFreeBusyInformation();
        }
    },

    /**
     * Render timeline header. It begins 4 hours before the meeting start datetime
     * and ends 5 hours after.
     */
    renderTimelineHeader: function() {
        var timelineHeader = [],
            startAndEndDates = this.getStartAndEndDates(),
            timeFormat,
            timelineStart;

        if (_.isEmpty(startAndEndDates)) {
            return;
        }

        timeFormat = this.getTimeFormat();
        timelineStart = startAndEndDates.timelineStart;

        for (var index = 0; index < this.timelineLength; index++) {
            timelineHeader.push({
                hour: timelineStart.format(timeFormat),
                alt: (index % 2 === 0)
            });
            timelineStart.add(1, 'hours');
        }

        this.$('[data-render=timeline-header]').html(this.timelineHeaderTemplate(timelineHeader));
    },

    /**
     * Get the time display format for timeline header.
     * @return {string}
     */
    getTimeFormat: function() {
        var timeFormat = app.date.getUserTimeFormat(),
            hourFormat = timeFormat.charAt(0),
            meridiem = '';

        if (hourFormat === 'h') {
            meridiem = timeFormat.substr(-1, 1);
        }

        return (hourFormat + meridiem);
    },

    /**
     * Adjust the start and end overlay on the timeline for all users.
     */
    adjustStartAndEnd: function() {
        var startAndEndDates = this.getStartAndEndDates(),
            timelineBlockStartIndex, //index of timeline block when the meeting starts
            timelineBlockEndIndex, //index of timeline block when the meeting ends
            $timelineBlocks, //all timeline blocks in a given timeline
            $startBlock, //timeline block when the meeting starts
            $endBlock, //timeline block when the meeting ends
            overlayLeft, //left position of the overlay
            overlayWidth = 1, //width of the overlay
            $startEndOverlays = this.$('.start_end_overlay'), //all overlays
            firstUserOverlay, //first user overlay
            firstUserData; //first user module and ID

        if (_.isEmpty(startAndEndDates) || ($startEndOverlays.length === 0)) {
            return;
        }

        // Get timeline blocks that represents the start and end datetime for the meeting
        firstUserOverlay = $startEndOverlays.first();
        firstUserData = firstUserOverlay.closest('.participant').data();
        $timelineBlocks = this.getTimelineBlocks(firstUserData.module, firstUserData.id);

        timelineBlockStartIndex = startAndEndDates.meetingStart.diff(startAndEndDates.timelineStart, 'hours', true) * 4;
        timelineBlockStartIndex = Math.round(timelineBlockStartIndex);

        timelineBlockEndIndex = (startAndEndDates.meetingEnd.diff(startAndEndDates.timelineStart, 'hours', true) * 4) - 1;
        timelineBlockEndIndex = Math.round(timelineBlockEndIndex);

        $startBlock = $timelineBlocks.eq(timelineBlockStartIndex);
        $endBlock = $timelineBlocks.eq(timelineBlockEndIndex);

        if ($endBlock.length === 0) {
            $endBlock = $timelineBlocks.last();
            $startEndOverlays.removeClass('right_border');
        } else {
            $startEndOverlays.addClass('right_border');
        }

        // calculate the left position of the overlay
        overlayLeft = $startBlock.position().left;

        // calculate the width of the overlay for meetings that last more than 0 minutes
        if (timelineBlockEndIndex - timelineBlockStartIndex >= 0) {
            // Note: Need to use getBoundingClientRect() so that we can get subpixel measurements.
            overlayWidth = $endBlock.position().left - overlayLeft + $endBlock.get(0).getBoundingClientRect().width;
            // subtract left and right border width
            overlayWidth -= parseInt(firstUserOverlay.css('border-left-width'), 10) + parseInt(firstUserOverlay.css('border-right-width'), 10);
        }

        $startEndOverlays.css({
            left: overlayLeft + 'px',
            width: overlayWidth + 'px'
        });
    },

    /**
     * Fetch schedules for Users.
     */
    fetchFreeBusyInformation: function() {
        var self = this,
            requests = [],
            startAndEndDates = this.getStartAndEndDates(),
            participants;

        try {
            participants = this.getFieldValue();
        } catch (e) {
            app.logger.warn(e);
            return;
        }

        if (this.freebusy.isFetching() || _.isEmpty(startAndEndDates)) {
            return;
        }

        participants.each(function(participant) {
            var url,
                freeBusyFromCache,
                moduleName = participant.module,
                id = participant.get('id');

            if (moduleName === 'Users') {
                freeBusyFromCache = self.getFreeBusyInformationFromCache(moduleName, id);

                if (freeBusyFromCache) {
                    self.fillInFreeBusyInformation(freeBusyFromCache);
                } else {
                    url = app.api.buildURL(moduleName, 'freebusy', {id: id}, {
                        start: startAndEndDates.timelineStart.formatServer(),
                        end: startAndEndDates.timelineEnd.formatServer()
                    });
                    requests.push({
                        url: url.substring(4) //need to remove "rest" from the URL to be compatible with the bulk API
                    });

                    self.showLoadingOnTimeline(moduleName, id);
                }
            }
        });

        this.freebusy.fetch(requests, {
            success: function(data) {
                if (!self.disposed) {
                    _.each(data, function(response) {
                        self.fillInFreeBusyInformation(response.contents);
                    });
                }
            },
            error: function() {
                app.logger.warn('Error received from server while retrieving free/busy information.');
                app.alert.show('freebusy-error', {
                    level: 'warning',
                    autoClose: true,
                    messages: 'LBL_ERROR_RETRIEVING_FREE_BUSY'
                });
            },
            complete: function(request) {
                var data;
                if (!self.disposed && request.params.data) {
                    data = JSON.parse(request.params.data);
                    _.each(data.requests, function(requestData) {
                        var moduleAndId = self.parseModuleAndIdFromUrl(requestData.url);
                        self.hideLoadingOnTimeline(moduleAndId.module, moduleAndId.id);
                    });
                }
            }
        });
    },

    freebusy: (function() {
        var fetching = false;

        return {
            /**
             * Calls the bulk api to make multiple free/busy GET requests in a single call.
             * @param {Array} requests
             * @param {Object} options
             */
            fetch: function(requests, options) {
                var self = this;
                if (!_.isEmpty(requests)) {
                    options.complete = _.wrap(options.complete, function(func, request) {
                        func(request);
                        self.isFetching(false);
                    }, this);
                    app.api.call('create', app.api.buildURL(null, 'bulk'), {requests: requests}, options);
                    this.isFetching(true);
                }
            },

            /**
             * Is it currently in the process of fetching?
             * @param {boolean} [isFetching] Set whether or not it is currently fetching
             * @return {boolean}
             */
            isFetching: function(isFetching) {
                if (_.isUndefined(isFetching)) {
                    return fetching;
                } else {
                    fetching = isFetching;
                }
            }
        }
    })(),

    /**
     * Fill in the busy slots on the timeline.
     * @param {Object} scheduleInfo - free/busy info from the server
     */
    fillInFreeBusyInformation: function(scheduleInfo) {
        var startAndEndDates = this.getStartAndEndDates(),
            timelineStart = startAndEndDates.timelineStart,
            timelineEnd = startAndEndDates.timelineEnd;

        if (!scheduleInfo || _.isEmpty(startAndEndDates)) {
            return;
        }

        this.cacheFreeBusyInformation(scheduleInfo);
        this.getTimelineBlocks(scheduleInfo.module, scheduleInfo.id).removeClass('busy');

        _.each(scheduleInfo.freebusy, function(busy) {
            var busyStartDate = app.date(busy.start),
                busyEndDate = app.date(busy.end);

            if (busyStartDate.isBefore(timelineEnd) && !busyEndDate.isBefore(timelineStart)) {
                this.setAsBusy(busy, scheduleInfo.module, scheduleInfo.id);
            }
        }, this);
    },

    /**
     * Mark the timeslot as busy.
     * @param {Object} busy - start and end datetime that should be marked as busy
     * @param {string} moduleName
     * @param {string} id
     */
    setAsBusy: function(busy, moduleName, id) {
        var startAndEndDates = this.getStartAndEndDates(),
            busyStartDate = app.date(busy.start),
            busyEndDate = app.date(busy.end),
            diffInHours,
            $timelineBlocks = this.getTimelineBlocks(moduleName, id);

        if (_.isEmpty(startAndEndDates)) {
            return;
        }

        // To optimize, we set the busyStartDate as the beginning of the timeline.
        if (busyStartDate.isBefore(startAndEndDates.timelineStart)) {
            busyStartDate = app.date(startAndEndDates.timelineStart);
        }

        // Shift Start and End Times backward/forward to the next 15 minute interval as needed
        busyStartDate.subtract(busyStartDate.minutes() % 15, 'minutes');
        if (busyEndDate.minutes() % 15 > 0) {
            busyEndDate.add((15 - (busyEndDate.minutes() % 15)), 'minutes');
        }

        while (busyStartDate.isBefore(busyEndDate) && busyStartDate.isBefore(startAndEndDates.timelineEnd)) {
            diffInHours = busyStartDate.diff(startAndEndDates.timelineStart, 'hours', true);

            if (diffInHours >= 0) {
                $timelineBlocks.eq(diffInHours * 4).addClass('busy');
            }

            busyStartDate.add(15, 'minutes');
        }
    },

    /**
     * Get timeline start and end datetime and meeting start and end datetimes.
     * Returns empty object if the meeting start and end datetimes are invalid.
     * @return {Object}
     */
    getStartAndEndDates: function() {
        var dateStartString = this.model.get('date_start'),
            dateEndString = this.model.get('date_end'),
            durationHours = this.model.get('duration_hours'),
            durationMins = this.model.get('duration_minutes'),
            meetingStart,
            meetingEnd,
            result = {};

        // must have date_start, but if we don't have date_end we need to have at least
        // duration_hours or duration_minutes to judge an end time
        if (!dateStartString ||
            (!dateEndString && !(_.isFinite(durationHours) || _.isFinite(durationMins)))) {
            return result;
        }

        meetingStart = app.date(dateStartString);

        // if we don't have the date_end string, create it from the duration times
        if (dateEndString) {
            meetingEnd = app.date(dateEndString);
        } else {
            meetingEnd = app.date(meetingStart)
                .add(durationHours || 0, 'hours')
                .add(durationMins || 0, 'minutes');
        }


        if (!meetingStart.isAfter(meetingEnd)) {
            result.meetingStart = meetingStart;
            result.meetingEnd = meetingEnd;
            result.timelineStart = app.date(meetingStart).subtract(this.timelineStart, 'hours').minutes(0);
            result.timelineEnd = app.date(result.timelineStart).add(this.timelineLength, 'hours').minutes(0);
        }

        return result;
    },

    /**
     * Get timeline timeslots for a given module and ID. If moduleName and ID are
     * not specified, return timeslots for all timelines.
     * @param {string} moduleName (optional)
     * @param {string} id (optional)
     * @return {jQuery}
     */
    getTimelineBlocks: function(moduleName, id) {
        var selector;

        if (moduleName && id) {
            selector = '[data-module=' + moduleName + '][data-id=' + id + ']';
        } else {
            selector = '.participant';
        }

        selector += ' .times .timeblock span';

        return this.$(selector);
    },

    /**
     * Cache free/busy data received from the server.
     * @param {Object} data - the free/busy data from the server
     */
    cacheFreeBusyInformation: function(data) {
        if (_.isUndefined(this._freeBusyCache)) {
            this._freeBusyCache = [];
        } else {
            this._freeBusyCache = _.reject(this._freeBusyCache, function(freebusy) {
                return (freebusy.id === data.id) && (freebusy.module === data.module);
            });
        }

        this._freeBusyCache.push(data);
    },

    /**
     * Get free/busy data from cache.
     * @param {string} moduleName
     * @param {string} id
     * @return {Object}
     */
    getFreeBusyInformationFromCache: function(moduleName, id) {
        return _.findWhere(this._freeBusyCache, {
            module: moduleName,
            id: id
        });
    },

    /**
     * Clear free/busy data cache.
     */
    clearFreeBusyInformationCache: function() {
        this._freeBusyCache = [];
    },

    /**
     * Show loading message on timeline.
     * @param {string} moduleName
     * @param {string} id
     */
    showLoadingOnTimeline: function(moduleName, id) {
        this.$('[data-module=' + moduleName + '][data-id=' + id + '] .times')
            .addClass('loading')
            .find('[data-toggle=loading]')
            .removeClass('hide');
    },

    /**
     * Hide loading message on timeline.
     * @param {string} moduleName
     * @param {string} id
     */
    hideLoadingOnTimeline: function(moduleName, id) {
        this.$('[data-module=' + moduleName + '][data-id=' + id + '] .times')
            .removeClass('loading')
            .find('[data-toggle=loading]')
            .addClass('hide');
    },

    /**
     * Get module name and ID from URL.
     * @param {string} url
     * @return {Object}
     */
    parseModuleAndIdFromUrl: function(url) {
        var moduleAndId = {},
            parsed = this.moduleAndIdParserRegExp.exec(url);

        if (parsed) {
            moduleAndId.module = parsed[1];
            moduleAndId.id = parsed[2];
        }

        return moduleAndId;
    },

    /**
     * @inheritdoc
     *
     * Converts the models found in the collection to ones that can be used in
     * the templates.
     *
     * @param {VirtualCollection} value
     * @return {Object} Array of models with view properties defined
     * @return {string} return.accept_status The translated string
     * indicating the model's accept status
     * @return {string} return.accept_class The CSS class representing
     * the model's accept status per Twitter Bootstrap's label component
     * @return {string} return.avatar The URL where the model's avatar
     * can be downloaded or undefined if one does not exist
     * @return {boolean} return.deletable Whether or not the model can
     * be removed from the collection
     * @return {boolean} return.last Whether or not the model is the
     * last one in the collection
     * @return {Object} return.preview Preview information for model
     * @return {boolean} return.preview.enabled Whether or not preview
     * is enabled for the model
     * @return {string} return.preview.label The tooltip to be shown for
     * the model when hovering over the preview button
     */
    format: function(value) {
        var acceptStatus, acceptStatusFieldName, deletable, i, preview, rows, self;

        self = this;

        acceptStatusFieldName = 'accept_status_' + this.module.toLowerCase();
        acceptStatus = function(participant) {
            var status = {};

            switch (participant.get(acceptStatusFieldName)) {
                case 'accept':
                    status.label = 'LBL_CALENDAR_EVENT_RESPONSE_ACCEPT';
                    status.css_class = 'success';
                    break;
                case 'decline':
                    status.label = 'LBL_CALENDAR_EVENT_RESPONSE_DECLINE';
                    status.css_class = 'important';
                    break;
                case 'tentative':
                    status.label = 'LBL_CALENDAR_EVENT_RESPONSE_TENTATIVE';
                    status.css_class = 'warning';
                    break;
                default:
                    status.label = 'LBL_CALENDAR_EVENT_RESPONSE_NONE';
                    status.css_class = '';
            }

            return status;
        };

        deletable = function(participant) {
            if (participant.deletable === false) {
                return false;
            }

            return participant.id !== self.model.get('assigned_user_id');
        };

        preview = function(participant) {
            var isBwc, moduleMetadata, preview;

            isBwc = false;
            preview = {
                enabled: true,
                label: 'LBL_PREVIEW'
            };

            moduleMetadata = app.metadata.getModule(participant.module);
            if (moduleMetadata) {
                isBwc = moduleMetadata.isBwcEnabled;
            }

            if (isBwc) {
                preview.enabled = false;
                preview.label = 'LBL_PREVIEW_BWC_TOOLTIP';
            } else if (_.isEmpty(participant.module) || _.isEmpty(participant.id)) {
                preview.enabled = false;
                preview.label = 'LBL_PREVIEW_DISABLED_NO_RECORD';
            } else if (!app.acl.hasAccess('view', participant.module)) {
                preview.enabled = false;
                preview.label = 'LBL_PREVIEW_DISABLED_NO_ACCESS';
            }

            return preview;
        };

        try {
            i = 1;
            rows = value.length;
            value = value.map(function(participant) {
                var attributes;
                var isNameErased = app.utils.isNameErased(participant);

                attributes = {
                    accept_status: acceptStatus(participant),
                    deletable: deletable(participant),
                    email: app.utils.getPrimaryEmailAddress(participant),
                    last: (rows === i++),
                    preview: preview(participant),
                    isNameErased: isNameErased,
                    name: isNameErased ? app.lang.get('LBL_VALUE_ERASED', participant.module) :
                        app.utils.getRecordName(participant),
                    module: participant.module
                };

                if (!_.isEmpty(participant.get('picture'))) {
                    attributes.avatar = app.api.buildFileURL({
                        module: participant.module,
                        id: participant.id,
                        field: 'picture'
                    });
                }

                return _.extend({}, participant.attributes, attributes);
            });
        } catch (e) {
            app.logger.warn(e);
            value = [];
        }

        return value;
    },

    /**
     * Displays the search and select to add a new participant.
     *
     * Hides the [+] button.
     *
     * @private
     * @param {Event} [event]
     */
    _addRowImmediately: function(event) {
        this.$('.participants-schedule').addClass('new');
        this.$('[name=newRow]').css('display', 'table-row');

        if (event) {
            $(event.currentTarget).hide();
        }

        this.getFieldElement().select2('open');
        this.adjustStartAndEnd();
    },

    /**
     * Removes the row where the [-] button was clicked.
     *
     * The participant is removed from the collection if it is an participant
     * row. Otherwise, the search and select row is hidden and the [+] is shown
     * again.
     *
     * @private
     * @param {Event} event
     */
    _removeRowImmediately: function(event) {
        var id, participants;

        id = $(event.currentTarget).data('id');

        if (id) {
            try {
                participants = this.getFieldValue();
                participants.remove(participants.get(id));
            } catch (e) {
                app.logger.warn(e);
            }
        } else {
            this.$('[name=newRow]').hide();
            this.$('button[data-action=addRow]').show();
            this.$('.participants-schedule').removeClass('new');
            this.adjustStartAndEnd();
        }
    },

    /**
     * Shows or hides the preview of the participant.
     *
     * @private
     * @param {Event} event
     */
    _previewRowImmediately: function(event) {
        var data, model, success;

        success = _.bind(function(model) {
            model.module = data.module;
            app.events.trigger('preview:render', model);
        }, this);

        data = $(event.currentTarget).data();

        if (data && data.module && data.id) {
            model = app.data.createBean(data.module, {id: data.id});
            model.fetch({
                showAlerts: true,
                success: success,
                params: {
                    erased_fields: true
                }
            });
        }
    },

    /**
     * Loads the next set of participants.
     *
     * The new participants will be rendered once they are added to the
     * collection.
     *
     * @param {Event} event
     */
    showMore: function(event) {
        var options;

        options = {
            fields: this._getRelatedFieldNames(),
            order_by: 'name:asc'
        };

        try {
            this.getFieldValue().paginate(options);
        } catch (e) {
            app.logger.warn(e);
        }
    },

    /**
     * Hides the pagination button if creating a new record -- because there is
     * no need for it -- or if the virtual collection indicates that there are
     * no additional participants to fetch.
     */
    hideShowMoreButton: function() {
        try {
            if (this.model.isNew() || !this.getFieldValue().hasMore()) {
                this.$('[data-action=show-more]').hide();
            }
        } catch (e) {
            app.logger.warn(e);
        }
    },

    /**
     * Searches for more participants that match the query.
     *
     * Matches that already exist in the collection are suppressed. See
     * [Select2](http://ivaynberg.github.io/select2/) for documentation on
     * using the query function.
     *
     * Pagination is disabled.
     *
     * @param {Object} query
     * @param {string} query.term The search term
     * @param {Function} query.callback The callback where data should be
     * passed once it has been loaded
     */
    search: function(query) {
        var data, fields, participants, success;

        data = {
            results: [],
            more: false
        };

        success = function(result) {
            result.each(function(record) {
                var participant = participants.get(record.id);

                if (participant) {
                    app.logger.debug(record.module + '/' + record.id + ' is already in the collection');
                } else {
                    record.text = record.get('name');
                    data.results.push(record);
                }
            });
        };

        try {
            fields = _.union(
                // fields that are needed for the detail, edit, and preview templates
                this._getRelatedFieldNames(),
                // fields for which there may be a match to show
                ['full_name', 'first_name', 'last_name', 'email', 'account_name']
            );

            participants = this.getFieldValue();
            participants.search({
                query: query.term,
                success: success,
                search_fields: ['full_name', 'email', 'account_name'],
                fields: fields,
                complete: function() {
                    query.callback(data);
                }
            });
        } catch (e) {
            app.logger.warn(e);
            query.callback(data);
        }
    },

    /**
     * Returns an array of strings representing the names of related fields.
     *
     * The related fields are defined under `this.def.fields`. Some of these
     * fields may be objects, while others strings.
     *
     * @return {Array}
     * @private
     */
    _getRelatedFieldNames: function() {
        var fields = this.def.fields || [];

        if (fields.length === 0) {
            return [];
        }

        return _.map(fields, function(field) {
            return _.isObject(field) ? field.name : field;
        });
    },

    /**
     * Format the search result for display in select2 result list
     *
     * @param {Data.Bean} bean A bean result
     * @return {string}
     */
    formatSearchResult: function(bean) {
        var nameIsErased = app.utils.isNameErased(bean);
        var result = {
            module: bean.module,
            name: nameIsErased ? app.lang.get('LBL_VALUE_ERASED', bean.module) : app.utils.getRecordName(bean),
            email: app.utils.getPrimaryEmailAddress(bean),
            name_is_erased: nameIsErased
        };

        _.each(bean.searchInfo.highlighted, function(field) {
            result.field_name = app.lang.get(field.label, field.module);
            result.field_value = field.text;
        });

        return this.searchResultTemplate(result);
    },

    /**
     * Remove resize event.
     * @inheritdoc
     * @private
     */
    _dispose: function() {
        $(window).off('resize.' + this.cid);
        this._super('_dispose');
    },

    /**
     * We do not support this field for preview edit
     * @inheritdoc
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        if (this.view.name === 'preview') {
            this.template = app.template.getField('participants', 'preview', this.model.module);
        }
    },

    /**
     * Focus the first text input in the topmost active drawer when the DOM is ready, if
     * it's not focused already. ParticipantsField is the last item to finish
     * rendering in a drawer, so the similar function in record.js will not work
     */
    focusFirstInput: function() {
        if (app.drawer && (app.drawer.count() > 0)) {
            $(function() {
                var $firstInput = app.drawer._components[app.drawer.count() - 1].$el
                    .find('input[type=text]')
                    .first();

                if (($firstInput.length > 0) && !$firstInput.is(':focus') && $firstInput.is(':visible')) {
                    $firstInput.focus();
                }
            });
        }
    }
}) },
"stage2_url": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.UrlField
 * @alias SUGAR.App.view.fields.BaseUrlField
 * @extends View.Fields.Base.BaseField
 */
({
	// Stage2_url Field (base) 

    extendsFrom: 'UrlField',

    /**
     * @inheritdoc
     */
    format: function(value) {
        value = this._super('format', [value]);
        if (value) {
            this.def.isClickable = true;

            if (!(value.indexOf('http://') === 0 || value.indexOf('https://') === 0)) {
                this.def.isClickable = false;
            }
        }
        return value;
    },

    /**
     * Check to see if is standard view
     *
     * @return {boolean} true if is standard view
     */
    isStandardView: function() {
        return _.contains(['record', 'list', 'create'], this.view.name);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (this.isStandardView() && this.name === 'hint_account_website' && this.module === 'Leads') {
            this.$el.parent().addClass('hidden');
        }
        this.def.link_target = (_.isUndefined(this.def.link_target) ||
             _.isEmpty(this.def.link_target)) ? '_blank' : this.def.link_target;
        app.view.Field.prototype._render.call(this);
    },
}) },
"label": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.LabelField
 * @alias SUGAR.App.view.fields.BaseLabelField
 * @extends View.Fields.Base.BaseField
 */
({
	// Label Field (base) 

    /**
     * @override
     *
     * No-op function because this field is static.
     */
    bindDataChange: $.noop,

    /**
     * @override
     *
     * No-op function because this field is static.
     */
    bindDomChange: $.noop,

    /**
     * @override
     *
     * No-op function because this field is static.
     */
    unbindDom: $.noop,

    /**
     * @inheritdoc
     */
    format: function(value) {
        if (this.def.formatted_value) {
            value = this.def.formatted_value;
        } else {
            value = app.lang.get(this.def.default_value, this.module);
        }
        return value;
    },

    /**
     * @inheritdoc
     */
    _isErasedField: function() {
        //Labels cannot be erased, they contain no data.
        return false;
    }
}) },
"status": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.StatusField
 * @alias SUGAR.App.view.fields.BaseStatusField
 * @extends View.Fields.Base.BaseField
 */
({
	// Status Field (base) 

    /**
     * Additional CSS Classes to be added to hbs
     */
    cssClasses: '',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.buildCSSClasses();
    },

    /**
     * Gets the field value and sets cssClasses
     */
    buildCSSClasses: function() {
        var status = this.model.get(this.name);
        if (status) {
            status = status.replace(' ', '_');
            this.cssClasses = 'field_' + this.name + '_' + status;
        }
    }
}) },
"avatar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.AvatarField
 * @alias SUGAR.App.view.fields.BaseAvatarField
 * @extends View.Fields.Base.ImageField
 */
({
	// Avatar Field (base) 

    extendsFrom: 'ImageField',

    plugins: ['File', 'FieldDuplicate'],

    MAPSIZECLASS: {
        'large': 'label-module-lg',
        'medium': 'label-module-md',
        'button': 'label-module-btn',
        'default': '',  //This field does not fallback to this size
        'small': 'label-module-sm',
        'mini': 'label-module-mini'
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        var template,
            className;
        this._super("_render");
        if (this.action !== 'edit' ||
            this.view.name === 'merge-duplicates' ||
            this.view.name === 'side-drawer-headerpane') {
            if (_.isEmpty(this.value)) {
                className = _.isUndefined(this.MAPSIZECLASS[this.def.size]) ? this.MAPSIZECLASS['large'] : this.MAPSIZECLASS[this.def.size];
                // replace the image field with the module icon when there is no avatar to display
                // load the module icon template
                template = app.template.getField(this.type, 'module-icon', this.module);
                if (template) {
                    this.$('.image_field').replaceWith(template({
                        module: this.module,
                        labelSizeClass: className,
                        tooltipPlacement: app.lang.direction === 'ltr' ? 'right' : 'left'
                    }));
                }
            } else {
                // add the image_rounded class to the image_field div when there is an avatar to display
                this.$('.image_field').addClass('image_rounded');
            }
        }
        return this;
    },

    /**
     * To inherit templates from the image field, we want to tell sidecar to load the templates from the image field's
     * directory. To do this, we must change this.type to "image" temporarily. We want to restore this.type before
     * exiting, however, so that we don't really change the field's attributes.
     *
     * Beware that this causes sidecar to never automatically load any templates found in the avatar field's directory.
     * Sidecar will always look for templates in the image field's directory, by default.
     *
     * @override
     * @private
     */
    _loadTemplate: function() {
        this.type = 'image';
        this._super("_loadTemplate");
        this.type = this.def.type;
    }
}) },
"actiondropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Create a dropdown button that contains multiple
 * {@link View.Fields.Base.RowactionField} fields.
 *
 * Supported Properties:
 *
 * - {Boolean} primary True if the entire dropdown group shows as primary.
 * - {String} icon Css icon that places on dropdown caret.
 * - {Boolean} switch_on_click True if the selected action needs to switch
 *   against the default action.
 * - {Boolean} no_default_action True if the default action should be empty and
 *   all buttons place under the dropdown action.
 * - {Array} buttons List of actions.
 *   First action goes to the default action (unless no_default_action set as `true`)
 *
 * Example usage:
 *
 *      array(
 *          'type' => 'actiondropdown',
 *          'primary' => true,
 *          'switch_on_click' => true,
 *          'no_default_action' => false,
 *          'icon' => 'sicon-settings',
 *          'buttons' => array(
 *              ...
 *          )
 *      )
 *
 * @class View.Fields.Base.ActiondropdownField
 * @alias SUGAR.App.view.fields.BaseActiondropdownField
 * @extends View.Fields.Base.FieldsetField
 */
({
	// Actiondropdown Field (base) 

    extendsFrom: 'FieldsetField',

    events: {
        'click [data-toggle=dropdown]' : 'renderDropdown',
        'shown.bs.dropdown': '_toggleAria',
        'hidden.bs.dropdown': '_toggleAria'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        /**
         * A subset of {@link #fields}.
         * Contains ACL accessible fields that are part of the dropdown.
         *
         * @property {Array}
         */
        this.dropdownFields = [];

        /**
         * Dom element selector for dropdown action.
         *
         * @property {string}
         */
        this.actionDropDownTag = '[data-toggle=dropdown]';

        /**
         * Dom element selector for mobile dropdown selector.
         *
         * @property {string}
         */
        this.selectDropdownTag = '[data-toggle=dropdownmenu]';

        /**
         * The dropdown tag to append the dropdown list to.
         *
         * @property {string}
         */
        this.dropdownTag = '[data-menu=dropdown]';

        /**
         * The default action button. An item in {@link #fields}.
         * This is a readonly property. Use {@link #_setDefaultBtn} to modify.
         *
         * @property {Object}
         */
        this.defaultActionBtn = {};

        /**
         * @inheritdoc
         *
         * This field doesn't support `showNoData`.
         */
        this.showNoData = false;

        /**
         * @inheritdoc
         *
         * This field's user action is enabled.
         */
        this.tabIndex = 0;

        this._super('initialize', [options]);

        /**
         * The caret icon class.
         *
         * @property {string}
         */
        this.caretIcon = this.def.icon || 'sicon-chevron-down';

        this.def.css_class = this.def.css_class ?
            this.def.css_class + ' actions' : 'actions';

        if (this.def.no_default_action) {
            this.def.switch_on_click = false;
        }

        //shortcut keys
        app.shortcuts.register({
            id: 'Dropdown:More',
            keys: 'm',
            component: this,
            description: 'LBL_SHORTCUT_OPEN_MORE_ACTION',
            handler: function() {
                var $primaryDropdown = this.$('.btn-primary[data-toggle=dropdown]');
                if ($primaryDropdown.is(':visible') && !$primaryDropdown.hasClass('disabled')) {
                    $primaryDropdown.click();
                }
            }
        });
        this.model.on('acl:change', function() {
            if (this.disposed) {
                return;
            }
            this._orderButtons();
            this.render();
        }, this);
    },

    /**
     * @inheritdoc
     */
    _getChildFieldsMeta: function() {
        return app.utils.deepCopy(this.def.buttons);
    },

    /**
     * @inheritdoc
     *
     * Calls {@link #_reorganizeButtons} if creating fields for the first time.
     * @return {Array} Array of accessible fields, a subset of {@link #fields}.
     */
    _getChildFields: function() {
        if (_.isEmpty(this.fields)) {
            var fields = this._super('_getChildFields');
            this._orderButtons(fields);
        }
        return !_.isEmpty(this.defaultActionBtn) ?
            [this.defaultActionBtn].concat(this.dropdownFields) :
            this.dropdownFields;
    },

    /**
     * Orders the fields according to order given and places the ACL accessible
     * fields in {@link #defaultActionBtn} and {@link #dropdownFields}.
     *
     * @param {Array} [fields=this.fields] Buttons in a specific order.
     * @private
     */
    _orderButtons: function(fields) {
        //Set to `true` to avoid starting the list with a divider.
        var prevIsDivider = true,
            orderedFields = fields || this.fields;
        this.dropdownFields = _.filter(orderedFields, function(field) {
            var actionHidden = (_.isFunction(field.hasAccess) && !field.hasAccess()) ||
                (_.isFunction(field.isVisible) && !field.isVisible()) ||
                (_.isFunction(field.isOnForbiddenLayout) && field.isOnForbiddenLayout());

            if (actionHidden || (field.type === 'divider' && prevIsDivider)) {
                return false;
            }
            prevIsDivider = field.type === 'divider';
            // If we have a predefined button filter function, apply it
            if (field.def.filterForRecordDashlet && _.isFunction(field.isAllowedDropdownButton)) {
                return field.isAllowedDropdownButton();
            }
            return true;
        });

        if (!this.def.no_default_action && !_.isEmpty(this.dropdownFields)) {
            this._setDefaultBtn(_.first(this.dropdownFields));
            this.dropdownFields = _.rest(this.dropdownFields);
        }
    },

    /**
     * Gets the dropdown template and caches it to `this.dropdownTpl`.
     *
     * @return {Function} The handlebars dropdown template.
     * @protected
     */
    _getDropdownTpl: function() {
        this.dropdownTpl = this.dropdownTpl ||
            app.template.getField('actiondropdown', 'dropdown', this.module);
        return this.dropdownTpl;
    },

    /**
     * Appends the dropdown from `dropdown.hbs` and binds the
     * {@link #switchButton} method to the dropdown buttons if necessary.
     *
     * @param {Event} evt The `click` event.
     */
    renderDropdown: function(evt) {
        var $dropdown = this.$(this.dropdownTag);

        if (_.isEmpty(this.dropdownFields) || this.isDisabled() || !$dropdown.is(':empty')) {
            return;
        }
        var dropdownTpl = this._getDropdownTpl();

        $dropdown.append(dropdownTpl(this));

        _.each(this.dropdownFields, function(field) {
            field.setElement(this.$('span[sfuuid="' + field.sfId + '"]'));
            if (this.def['switch_on_click'] && !this.def['no_default_action']) {
                field.$el.on('click.' + this.cid, _.bind(this.switchButton, this));
            }
            field.render();
        }, this);
    },

    /**
     * Sets a button accessibility class 'aria-expanded' to true or false
     * depending on if the dropdown menu is open or closed.
     *
     * @private
     */
    _toggleAria: function() {
        var $button = this.$(this.actionDropDownTag);
        $button.attr('aria-expanded', this.$el.hasClass('open'));
    },

    /**
     * Sets a button to {@link #defaultActionBtn} and to have default-button
     * properties. Unsets the previous {@link #defaultActionBtn}.
     *
     * @param {Object} button The button of interest.
     * @private
     */
    _setDefaultBtn: function(button) {
        if (!button || button.disposed) {
            return;
        }
        if (!_.isEmpty(this.defaultActionBtn)) {
            this.defaultActionBtn.def.primary = this.defaultActionBtn.def.button = false;
        }
        this.defaultActionBtn = button;
        this.defaultActionBtn.def.primary = this.def.primary;
        this.defaultActionBtn.def.button = true;
    },

    /**
     * Switch the default button against one that is clicked.
     *
     * @param {Event} evt The `click` event
     */
    switchButton: function(evt) {
        var sfId = parseInt(this.$(evt.currentTarget).attr('sfuuid'), 10),
            index = -1;

        if (sfId === this.defaultActionBtn.sfId) {
            return;
        }
        var selectedField = _.find(this.dropdownFields, function(field, idx) {
            if (field.sfId === sfId) {
                index = idx;
                return true;
            }
            return false;
        });

        if (!selectedField) {
            return;
        }

        //rebuild `dropdownFields` with the new ordering
        this.dropdownFields.splice(index, 1, this.defaultActionBtn);
        this._setDefaultBtn(selectedField);
        this.render();
    },

    /**
     * @inheritdoc
     *
     * Rendering an `ActiondropdownField` will always force the dropdown to be
     * re-rendered.
     */
    _render: function() {
        this.$(this.dropdownTag).empty();

        this._super('_render');
        this._updateCaret();
        this._renderDefaultActionBtn();
        this.$el.toggleClass('btn-group', !_.isEmpty(this.dropdownFields));

        return this;
    },

    /**
     * Renders the default action button only.
     * The fields in the dropdown will be rendered on click on the dropdown
     * button with {@link #renderDropdown}.
     *
     * @override
     * @protected
     */
    _renderFields: function() {
        if (!_.isEmpty(this.defaultActionBtn)) {
            this.defaultActionBtn.setElement(this.$('span[sfuuid="' + this.defaultActionBtn.sfId + '"]'));
            this.defaultActionBtn.render();
        }
    },

    /**
     * Formats the default action button if it exists.
     * Sets the mode of the button to `small` if it is in a subpanel.
     *
     * A button is in `small` mode when it contains only the icon, with the label
     * shown as a tooltip.
     *
     * @protected
     */
    _renderDefaultActionBtn: function() {
        if (_.isEmpty(this.defaultActionBtn)) {
            return;
        }
        //FIXME: SC-3366 Should not explicitly look for `closestComponent`
        if (this.defaultActionBtn.def.icon &&
            this.defaultActionBtn.closestComponent('subpanel')) {
            this.defaultActionBtn.setMode('small');
        }

        if (!this.def['switch_on_click'] || this.def['no_default_action']) {
            return;
        }

        this.defaultActionBtn.$el.on('click.' + this.cid, _.bind(this.switchButton, this));
        app.accessibility.run(this.defaultActionBtn.$el, 'click');
    },

    /**
     * Enable or disable caret depending on if there are any enabled actions in the dropdown list
     * @private
     */
    _updateCaret: function() {
        if (_.isEmpty(this.dropdownFields)) {
            return;
        }
        //FIXME: SC-3365 Should not need to check for 'disabled' in css_class
        var caretEnabled = _.some(this.dropdownFields, function(field) {
            if (_.isFunction(field.hasAccess) && field.hasAccess()) {
                if (field.def.css_class && field.def.css_class.indexOf('disabled') > -1) {
                    //If action disabled in metadata
                    return false;
                } else if (field.isDisabled()) { //Or disabled via field controller
                    return false;
                } else {
                    return true;
                }
            }
            return false;
        });
        this.$('.' + this.caretIcon)
            .closest('a')
                .toggleClass('disabled', !caretEnabled)
                .attr('aria-haspopup', caretEnabled)
                .attr('tabindex', caretEnabled ? 0 : -1);
    },

    /**
     * @inheritdoc
     */
    setDisabled: function(disable) {
        this._super('setDisabled', [disable]);
        disable = _.isUndefined(disable) ? true : disable;
        this.tabIndex = disable ? -1 : 0;
        if (this.$el) {
            this.$(this.actionDropDownTag)
                .toggleClass('disabled', disable)
                .attr('aria-haspopup', !disable)
                .attr('tabindex', this.tabIndex);
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        _.each(this.fields, function(field) {
            if (!field.disposed) {
                field.$el.off('click.' + this.cid);
            }
        }, this);
        this.defaultActionBtn = null;
        this.dropdownFields = null;
        this._super('_dispose');
    }
}) },
"change-password": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Widget for changing a password.
 *
 * It does not require old password confirmation.
 *
 * @class View.Fields.Base.ChangePasswordField
 * @alias SUGAR.App.view.fields.BaseChangePasswordField
 * @extends View.Fields.Base.BaseField
 */
({
	// Change-password Field (base) 

    fieldTag: 'input:not(:disabled)',

    events: {
        'click .togglePasswordFields': 'togglePasswordFields'
    },

    /**
     * Cache of original functions modified during _extendModel
     */
    originalFunctions: {},

    /**
     * List of function names added during _extendModel
     */
    extendFunctions: [
        '_doValidatePasswordConfirmation',
        'revertAttributes'
    ],

    /**
     * @override
     * @param options
     */
    initialize: function(options) {
        app.view.Field.prototype.initialize.call(this, options);
        /**
         * Manually adds the validation error label to errorName2Keys
         * @type {string}
         */
        app.error.errorName2Keys['confirm_password'] = 'ERR_REENTER_PASSWORDS';
        this._extendModel();
    },

    /**
     * Extends the model
     * - adds a validation task _doValidatePasswordConfirmation : handle the password confirmation validation
     * - revertAttributes : to unset temporary attributes _new_password and _confirm_password
     */
    _extendModel: function() {
        var isPasswordValidationSkipped = this.fieldDefs && this.fieldDefs.skip_password_validation;
        // _hasChangePasswordModifs is a flag to make sure model methods are overridden only once
        if (this.model && !this.model._hasChangePasswordModifs) {
            // Make a copy of the model
            var _proto = _.clone(this.model);

            // This is the flag to make sure we do extend model only once
            this.model._hasChangePasswordModifs = true;

            // Cache overridden functions to remove on dispose
            _.each(this.extendFunctions, function(functionName) {
                this.originalFunctions[functionName] = this.model[functionName];
            }, this);

            /**
             * Validates new password and confirmation match
             *
             * @param {Object} fields Hash of field definitions to validate.
             * @param {Object} errors Error validation errors
             * @param {Function} callback Async.js waterfall callback
             */
            this.model._doValidatePasswordConfirmation = function(fields, errors, callback) {
                var showPasswordAlert = false;
                // Find any change password field
                var changePasswordFields = _.filter(fields, function(field) {
                    return field.type === 'change-password' || field.type === 'change-my-password';
                });
                _.each(changePasswordFields, function(field) {
                    var fieldName = field.name;
                    // Get the new password and the confirmation
                    var password = this.get(fieldName + '_new_password');
                    var confirmation = this.get(fieldName + '_confirm_password');

                    /**
                     * Passwords don't match
                     */
                    if (password !== confirmation) {
                        // Adds the validation error
                        // confirm_password is added to errorName2Keys on initialize
                        errors[fieldName] = errors[fieldName] || {};
                        errors[fieldName].confirm_password = true;
                        showPasswordAlert = true;
                        if (this.showPopupAlerts) {
                            app.alert.show('passwords_mismatch', {
                                level: 'error',
                                messages: app.lang.get('ERR_REENTER_PASSWORDS'),
                                autoClose: true,
                                autoCloseDelay: 5000,
                            });
                        }
                    } else {
                        // Custom password validation set by admin.
                        var data = app.utils.validatePassword(password);
                        if (!data.isValid && !isPasswordValidationSkipped) {
                            var errMsg = app.lang.get('LBL_PASSWORD_ENFORCE_TITLE');
                            errors[fieldName] = errors[fieldName] || {};
                            errors[fieldName].confirm_password = true;
                            if (data.error) {
                                errMsg += '<br><br>' + data.error;
                            }
                            showPasswordAlert = true;
                            app.alert.show('passwords_invalid', {
                                level: 'error',
                                messages: errMsg,
                            });
                        } else if (!errors[fieldName]) {
                            /**
                             * Passwords match
                             */
                            this.unset(fieldName + '_current_password'); //Needs to be cleared for change-my-password
                            if (password !== '') {
                                this.unset(fieldName + '_new_password');
                                this.unset(fieldName + '_confirm_password');
                                this.set(fieldName, password);
                            }
                        }
                    }

                }, this);

                callback(null, fields, errors);
                if (showPasswordAlert) {
                    app.alert.dismiss('invalid-data');
                }
            };

            /**
             * Adds the validation task to the model
             * @override
             * @param options
             */
            this.model.addValidationTask('password_confirmation_' + this.cid, _.bind(this.model._doValidatePasswordConfirmation, this.model));

            /**
             * Unsets new password and confirmation values on revertAttributes
             * @override
             * @param options
             */
            this.model.revertAttributes = function(options) {
                // Find any change password field
                var attrs = _.clone(this.attributes);
                _.each(attrs, function(value, attr) {
                    if (attr.match('_new_password') || attr.match('_confirm_password')) {
                        this.unset(attr);
                    }
                }, this);
                // Call the old method
                _proto.revertAttributes.call(this, options);
            };
        }
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        if (this.model) {
            this.newPassword = this.model.get(this.name + '_new_password');
            this.confirmPassword = this.model.get(this.name + '_confirm_password');
            // Decides to display inputs or the link
            this.showPasswordFields = this.showPasswordFields ||
                //Show password fields if the formatted value is empty
                !this.format(this.value) ||
                //Show password fields if they aren't empty
                !!(this.newPassword || this.confirmPassword);
        }
        this.maxPasswordLength = parseInt(this.def.len);
        app.view.Field.prototype._render.call(this);
        this.showPasswordFields = false;
        this.$inputs = this.$(this.fieldTag);
        this.focusIndex = 0;
        return this;
    },

    /**
     * Sets an arbitrary value just to display stars on detail view
     * @override
     * @param {Boolean} value
     * @return {string} value
     */
    format: function(value) {
        if (value === true) return 'value_setvalue_set';
        return value;
    },

    /**
     * Reset the arbitrary value
     * @override
     * @param {String} value
     * @return {Mixed} value boolean is the value is not set
     */
    unformat: function(value) {
        if (value === 'value_setvalue_set') return true;
        return value;
    },

    /**
     * Sets a password attribute on the model of this field.
     *
     * @private
     * @param {Event} evt The event object.
     */
    _setPasswordAttribute: function(evt) {
        var $el = this.$(evt.currentTarget);
        var attr = $el.attr('name');
        var val = $el.val();

        this.model.set(this.name + '_' + attr, this.unformat(val));
    },

    /**
     * @override
     */
    bindDomChange: function() {
        if (!(this.model instanceof Backbone.Model)) return;

        this.$('input[name=new_password]').on('change.' + this.cid, _.bind(this._setPasswordAttribute, this));

        var self = this;
        this.$('input[name=confirm_password]').on('change.' + this.cid, function() {
            var val = self.unformat($(this).val());
            self.model.set(self.name + '_confirm_password', val);
            self.model.set(self.name, val);
        });

        this.$('input[name=new_password], input[name=confirm_password]').on('focus.' + this.cid, _.bind(this.handleFocus, this));
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        this.$('input[name=new_password], input[name=confirm_password]')
            .off('change.' + this.cid)
            .off('focus.' + this.cid);
        this._super('unbindDom');
    },

    /**
     * @return {Boolean} `true` if there is another input to focus, `false` if
     *   it is the last input already.
     */
    focus: function() {
        if (!this.$inputs.length) {
            this.togglePasswordFields();
        }
        // this should be zero but lets make sure
        if (this.focusIndex < 0) {
            this.focusIndex = 0;
        }

        if (this.focusIndex >= this.$inputs.length) {
            // done focusing our inputs return false
            this.focusIndex = -1;
            return false;
        } else {
            // focus the next item in our list of inputs
            this.$inputs[this.focusIndex].focus();
            this.focusIndex++;
            return true;
        }
    },

    /**
     * Displays inputs for the new password and the confirmation
     * @param event
     */
    togglePasswordFields: function(event) {
        this.showPasswordFields = true;
        this.render();
    },

    /**
     * Remove extensions added to model.
     * @inheritdoc
     */
    _dispose: function() {
        this._resetModelExtensions();
        this._super('_dispose');
    },

    /**
     * Undo changes made in _extendModel when field is disposed
     *
     * @private
     */
    _resetModelExtensions: function() {
        _.each(this.originalFunctions, function(value, key) {
            this.model[key] = value;
        }, this);
        this.model._hasChangePasswordModifs = false;
        this.model.removeValidationTask('password_confirmation_' + this.cid);
    },
}) },
"record-count": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RecordCountField
 * @alias SUGAR.App.view.fields.BaseRecordCountField
 * @extends View.Fields.Base.BaseField
 */
({
	// Record-count Field (base) 

    /**
     * Module name.
     *
     * @property {string}
     */
    module: '',

    /**
     * Filter definition.
     *
     * @property {Object}
     */
    filter: {},

    /**
     * CSS class.
     *
     * @property {string}
     */
    cssClass: '',

    /**
     * Total amount of filtered records.
     *
     * @property {number}
     */
    count: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.module = options.def.module || '';
        this.filter = options.def.filter || {};
        this.cssClass = options.def.cssClass || '';
        this.tooltipLabel = options.def.tooltip || '';
        this.autoRefresh(true);
    },

    /**
     * Auto refresh the badges every 5 min
     *
     * @param {boolean} start `true` to start the timer, `false` to stop it
     */
    autoRefresh: function(start) {
        if (start) {
            clearInterval(this._timerId);
            this._timerId = setInterval(_.bind(function() {
                this._getCount(true);
            }, this), 5 * 1000 * 60); // 5 min default
        } else {
            clearInterval(this._timerId);
        }
    },

    /**
     * Get the total amount of filtered records and display it.
     *
     * @param {boolean} forceReload `true` to ignore cache and force a new request
     * @private
     */
    _getCount: function(forceReload) {
        if (!this.module) {
            return;
        }
        var params = this.filter ? {filter: this.filter} : {};
        var url = app.api.buildURL(this.module, 'count', {}, params);
        // if cached
        var recordCounts = this.context.get('recordCounts');
        if (!forceReload && recordCounts && !_.isUndefined(recordCounts[url])) {
            this.count = recordCounts[url];
            this.render();
            return;
        }
        app.api.call('read', url, null, {
            success: _.bind(function(data) {
                this.count = data.record_count;
                if (this.context) {
                    // cache it
                    var recordCounts = this.context.get('recordCounts') || {};
                    recordCounts[url] = this.count;
                    this.context.set('recordCounts', recordCounts);
                }
                if (!this.disposed) {
                    this.render();
                }
            }, this),
        });
    },

    /**
     * @inheritdoc
     */
    render: function() {
        if (_.isNull(this.count)) {
            this._getCount();
            return;
        } else if (this.count > 0) {
            this._super('render');
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.autoRefresh(false);
        this._super('_dispose');
    }
}) },
"focuscab": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FocuscabField
 * @alias SUGAR.App.view.fields.BaseFocuscabField
 * @extends View.Fields.Base.CabField
 */
({
	// Focuscab Field (base) 

    extendsFrom: 'CabField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'cab';
    },

    /**
     * Handle the click event of focus icon
     */
    handleClick: function() {
        if (!_.isEmpty(app.sideDrawer)) {
            app.utils.openFocusDrawer(app.sideDrawer, this.module, this.view.model.get('id'));
        }
    },

    /**
     * @inheritdoc
     */
    hasAccess: function() {
        return this.isFocusDrawerEnabled() && this._super('hasAccess');
    },

    /**
     * Check if the focus drawer can be used or not.
     *
     * @return {boolean} True if the focus drawer is ready for use.
     */
    isFocusDrawerEnabled: function() {
        return app.utils.isTruthy(app.config.enableLinkToDrawer);
    }
}) },
"module": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ModuleField
 * @alias SUGAR.App.view.fields.BaseModuleField
 * @extends View.Fields.Base.BaseField
 */
({
	// Module Field (base) 

    format: function(value){
        value = app.lang.getModuleName(value, {plural: true});
        return value;
    }
}) },
"bing-map": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Assign Record action configuration view
 *
 * @class View.Fields.Base.BingMapField
 * @alias SUGAR.App.view.fields.BaseBingMapField
 * @extends View.Fields.Base.BaseField
 */
({
	// Bing-map Field (base) 

    events: {
        'click [data-action=map-close]': 'closeMap',
        'click [data-action=map-expand]': 'expandMap',
        'click [data-action=map-to-pdf]': 'saveMapAsPdf',
        'click [data-action=map-share]': 'emailMap',
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this._initProperties(options);
    },

    /**
     * Property initialization, nothing to do for this view
     *
     * @param {Object} options
     */
    _initProperties: function(options) {
        this._map = null;
        this._searchManager = null;
        this._directionsManager = null;
        this._infoBox = null;
        this._locations = [];
        this._pushPins = [];
        this._itinerary = {};
        this._showCloseButton = options.showCloseButton;
        this._showExpandButton = options.showExpandButton;
        this._showMapToPdfButton = options.showMapToPdfButton;
        this._showMapShareButton = options.showMapShareButton;
        this._showDirections = false;
        this._expanded = false;
        this._pushPinIcon = 'styleguide/assets/img/map-blue-pushpin.svg';
    },

    /**
     * Create the map
     */
    createMap: function() {
        const path = 'maps/getApiKey/bing';
        const requestType = 'read';

        const apiUrl = app.api.buildURL(path, requestType);

        const callbacks = {
            success: _.bind(this._buildMap, this)
        };

        app.api.call(requestType, apiUrl, null, callbacks);
    },

    /**
     * Trigger close map event
     */
    closeMap: function() {
        this._expanded = false;

        this.trigger('map:expand', this._expanded);
        this.trigger('map:close');
    },

    /**
     * Trigger expand map event
     */
    expandMap: function() {
        this._expanded = !this._expanded;
        this.trigger('map:expand', this._expanded);
    },

    /**
     * Trigger to save the map as pdf
     */
    saveMapAsPdf: function() {
        this.trigger('map:save:pdf');
    },

    /**
     * Trigger to share the map via email
     */
    emailMap: function() {
        this.trigger('map:share:email');
    },

    /**
     * Generate the Bing Map
     *
     * @param {string} bingMapKey
     */
    _buildMap: function(bingMapKey) {
        if (this.disposed) {
            return;
        }

        const $mapContainer = this.$('div[data-container="map-container"]');
        const mapHtmlEl = $mapContainer.get(0);

        $mapContainer.show();

        this._map = new Microsoft.Maps.Map(mapHtmlEl, {
            navigationBarMode: Microsoft.Maps.NavigationBarMode.square,
            credentials: bingMapKey,
            supportedMapTypes: [
                Microsoft.Maps.MapTypeId.road,
                Microsoft.Maps.MapTypeId.aerial,
                Microsoft.Maps.MapTypeId.roadDark,
                Microsoft.Maps.MapTypeId.streetside,
            ]
        });

        this._registerMapEvents();
        this._loadMapModules();
    },

    /**
     * Register map related events
     */
    _registerMapEvents: function() {
        this._map.getMapLoadedEvent().addOne(_.bind(this._onMapReady, this));

        Microsoft.Maps.Events.addHandler(this._map, 'click', _.bind(this._onMapPointClick, this));
    },

    /**
     * Called when map is completely loaded
     */
    _onMapReady: function() {
        if (!this._showDirections) {
            this.$('[data-widget=map-loading]').hide();
        }

        if (this._showCloseButton) {
            this.$('[data-action=map-close]').css('display', 'flex');
        }

        if (this._showExpandButton) {
            this.$('[data-action=map-expand]').css('display', 'flex');
        }

        if (this._showMapToPdfButton) {
            this.$('[data-action=map-to-pdf]').css('display', 'flex');
        }

        if (this._showMapShareButton) {
            this.$('[data-action=map-share]').css('display', 'flex');
        }

        this.trigger('map:load:complete');
    },

    /**
     * Called when map is being clicked
     *
     * @param {Event} e
     */
    _onMapPointClick: function(e) {
        this.trigger('map:map:click', e);
    },

    /**
     * Load additional BingMap modules
     */
    _loadMapModules: function() {
        Microsoft.Maps.loadModule('Microsoft.Maps.Search', {
            callback: _.bind(this._searchModuleLoaded, this)
        });

        Microsoft.Maps.loadModule('Microsoft.Maps.Directions', {
            callback: _.bind(this._directionsModuleLoaded, this)
        });
    },

    /**
     * Called when MapsSearch module is completely loaded
     */
    _searchModuleLoaded: function() {
        this._searchManager = new Microsoft.Maps.Search.SearchManager(this._map);

        this.trigger('map:search:load:complete');
    },

    /**
     * Called when MapsDirection module is completely loaded
     */
    _directionsModuleLoaded: function() {
        this._directionsManager = new Microsoft.Maps.Directions.DirectionsManager(this._map);

        Microsoft.Maps.Events.addHandler(
            this._directionsManager,
            'directionsError',
            _.bind(this._directionsError, this)
        );

        Microsoft.Maps.Events.addHandler(
            this._directionsManager,
            'directionsUpdated',
            _.bind(this._directionsUpdated, this)
        );

        this.trigger('map:directions:load:complete');
    },

    /**
     * Handler from when a direction cannot be computed
     *
     * @param {Object} e
     */
    _directionsError: function(e) {
        this.$('[data-widget=map-loading]').hide();
        this.$('[data-container=driving-directions]').hide();

        app.alert.dismiss('maps_calculating_route');
        app.alert.show('maps_invalid_route', {
            level: 'warning',
            messages: e.message,
        });

        this._map.setView({
            zoom: 1
        });
    },

    /**
     * Dismiss the popup when the directions are ready
     *
     * @param {Object} itinerary
     */
    _directionsUpdated: function(itinerary) {
        this._itinerary = itinerary;

        this.$('[data-widget=map-loading]').hide();
        app.alert.dismiss('maps_calculating_route');
    },

    /**
     * Show directions
     *
     * @param {Array} points
     * @param {Object} startingPoint
     */
    showDirections: function(points, startingPoint) {
        const $itineraryContainer = this.$('[data-container=driving-directions]');

        $itineraryContainer.show();

        app.alert.show('maps_calculating_route', {
            level: 'info',
            messages: app.lang.get('LBL_MAP_CALCULATING_DIRECTIONS'),
            autoClose: false,
        });

        this._directionsManager.addWaypoint(new Microsoft.Maps.Directions.Waypoint({
            address: startingPoint.address,
            location: new Microsoft.Maps.Location(startingPoint.coords.latitude, startingPoint.coords.longitude)
        }));

        _.each(points, function addWaypoint(point) {
            this._directionsManager.addWaypoint(new Microsoft.Maps.Directions.Waypoint({
                address: point.address,
                location: new Microsoft.Maps.Location(point.coords.latitude, point.coords.longitude)
            }));
        }, this);

        this._directionsManager.setRequestOptions({
            distanceUnit: Microsoft.Maps.Directions.DistanceUnit[app.config.maps.unitType],
        });

        this._directionsManager.setRenderOptions({
            itineraryContainer: $itineraryContainer[0],
            drivingPolylineOptions: {
                strokeColor: 'green',
                strokeThickness: 6
            },
        });

        this._directionsManager.calculateDirections();

        this._showDirections = true;
    },

    /**
     * Looking into BingMap for an address
     *
     * @param {string} address
     * @param {Function} callback
     * @param {Function} errorCallback
     */
    searchByAddress: function(address, callback, errorCallback) {
        if (!this._searchManager) {
            if (errorCallback) {
                const noResults = {};

                errorCallback(noResults);
            }

            return;
        }

        const geocodeRequest = {
            where: address,
            count: 20,
            callback,
            errorCallback,
        };

        this._searchManager.geocode(geocodeRequest);
    },

    /**
     * Reset current locations
     */
    resetLocations: function() {
        this._locations = [];
    },

    /**
     * Create new BingMaps locations
     *
     * @param {Array} locationsData
     */
    createLocations: function(locationsData) {
        _.each(locationsData, function createLocation(locationData) {
            this.createLocation(locationData);
        }, this);
    },

    /**
     * Generate a new location for PushPin
     *
     * @param {Object} locationData
     */
    createLocation: function(locationData) {
        if (!locationData.latitude || !locationData.longitude) {
            return;
        }

        const location = new Microsoft.Maps.Location(locationData.latitude, locationData.longitude);
        const assignedUserNameKey = 'parent_user_name';
        const parentNameKey = 'parent_name';
        const parentIdKey = 'parent_id';
        const parentTypeKey = 'parent_type';

        location.sugarRecordDetails = {
            address: locationData.address,
            country: locationData.country,
            assignedUserName: locationData[assignedUserNameKey],
            name: locationData[parentNameKey],
            id: locationData[parentIdKey],
            module: locationData[parentTypeKey],
        };

        this._locations.push(location);
    },

    /**
     * Reset current pushpins
     */
    resetPushPins: function() {
        this._pushPins = [];
    },

    /**
     * Generate a new PushPin based on long and lat from record.
     *
     * @param {Microsoft.Maps.Location} location
     */
    _createPushPin: function(location) {
        const recordDetails = location.sugarRecordDetails;

        const pushpinMeta = {
            title: recordDetails.name,
            username: recordDetails.assignedUserName,
            icon: this._pushPinIcon,
            address: recordDetails.address,
            country: recordDetails.country,
            id: recordDetails.id,
            recordRoute: '#' + app.router.buildRoute(recordDetails.module, recordDetails.id),
        };

        const pushPin = new Microsoft.Maps.Pushpin(location, pushpinMeta);

        Microsoft.Maps.Events.addHandler(pushPin, 'mouseover', _.bind(this.showInfoBox, this, pushpinMeta));
        Microsoft.Maps.Events.addHandler(this._map, 'click', _.bind(this.hideInfoBox, this));

        this._pushPins.push(pushPin);
    },

    /**
     * Generate an array of PushPins
     */
    createPushPins: function() {
        _.each(this._locations, function processRecord(location) {
            this._createPushPin(location);
        }, this);
    },

    /**
     * Add pushpins to be drawed
     */
    drawPushPins: function() {
        this._map.entities.push(this._pushPins);
    },

    /**
     * Called on pushpin hover
     *
     * @param {Object} meta
     * @param {Event} e
     */
    showInfoBox: function(meta, e) {
        const location = e.target.getLocation();

        const handlebars = app.template.getField('bing-map', 'infobox')(meta);

        if (this._infoBox) {
            this._infoBox.setLocation(location);
            this._infoBox.setOptions({
                htmlContent: handlebars,
                visible: true,
            });
        } else {
            this._infoBox = new Microsoft.Maps.Infobox(location, {
                htmlContent: handlebars
            });

            this._infoBox.setMap(this._map);
        }

        setTimeout(_.bind(this.registerInfoBoxStreetViewClick, this, meta, location), 500);
    },

    /**
     * Register StreetView Click event on InfoBox
     *
     * @param {Object} meta
     * @param {Object} location
     */
    registerInfoBoxStreetViewClick: function(meta, location) {
        const $infoBox = $(this._infoBox._getInfoboxElement());
        const $streetViewIcon = $infoBox.find('[data-action=street-view]');

        $streetViewIcon.off('click', _.bind(this.openStreetView, this, meta, location));
        $streetViewIcon.on('click', _.bind(this.openStreetView, this, meta, location));
    },

    /**
     * Called on infobox leave
     *
     * @param {Event} e
     */
    hideInfoBox: function(e) {
        if (this._infoBox) {
            this._infoBox.setOptions({visible: false});
        }
    },

    /**
     * Open Street View
     *
     * @param {Object} meta
     * @param {Object} location
     * @param {Event} e
     */
    openStreetView: function(meta, location, e) {
        this.hideInfoBox();

        this._map.setView({
            center: location,
            zoom: 18,
            mapTypeId: Microsoft.Maps.MapTypeId.streetside,
            streetsideOptions: {
                overviewMapMode: Microsoft.Maps.OverviewMapMode.hidden,
                showCurrentAddress: true,
                showProblemReporting: false,
                disablePanoramaNavigation: true,
                showHeadingCompass: false,
                showZoomButtons: false,
                onErrorLoading: function() {
                    app.alert.show('maps-street-points-not-available', {
                        level: 'warning',
                        messages: app.lang.get('LBL_MAPS_STREET_VIEW_POINT_NOT_AVAILABLE'),
                        autoClose: true,
                    });
                },
            }
        });

    },

    /**
     * Get address data from a point
     *
     * @param {Object} location
     */
    getAddressFromPoint(location, successCallback, errorCallback) {
        this._searchManager.reverseGeocode({
            callback: successCallback,
            errorCallback: errorCallback,
            location: location
        });
    },

    /**
     * Clear the map
     */
    clearMap: function() {
        this._map.entities.clear();
        this.resetLocations();
        this.resetPushPins();
    },

    /**
     * Center the map based on the added PushPins
     *
     * @param {Object} mapViewOptions
     */
    centerMap: function(mapViewOptions) {
        mapViewOptions = mapViewOptions ? mapViewOptions : {};

        if (_.isEmpty(this._locations)) {
            this._map.setView({
                zoom: 1
            });
            return;
        }

        const centerMap = Microsoft.Maps.LocationRect.fromLocations(this._locations);

        if (_.has(mapViewOptions, 'height')) {
            centerMap.height = mapViewOptions.height;
        }

        if (_.has(mapViewOptions, 'width')) {
            centerMap.width = mapViewOptions.width;
        }

        let mapOptions = {
            mapTypeId: mapViewOptions.mapTypeId ? mapViewOptions.mapTypeId : Microsoft.Maps.MapTypeId.road,
        };

        if (_.keys(this._locations).length > 1) {
            mapOptions.bounds = centerMap;
        } else {
            const firstLocationKey = _.chain(this._locations)
                                    .keys()
                                    .first()
                                    .value();

            mapOptions.center = this._locations[firstLocationKey];
        }

        this._map.setView(mapOptions);

        if (_.has(mapViewOptions, 'zoom')) {
            let correctZoom = Infinity;

            if (mapOptions.bounds) {
                correctZoom = this._map.getZoom();
                mapOptions.center = mapOptions.bounds.center;

                delete mapOptions.bounds;
            }

            mapOptions.zoom = Math.min(Number(mapViewOptions.zoom), correctZoom);

            this._map.setView(mapOptions);
        }
    },
}) },
"chart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ChartField
 * @alias SUGAR.App.view.fields.BaseChartField
 * @extends View.Fields.Base.BaseField
 */
({
	// Chart Field (base) 

    /**
     * Direction for the user's language - ltr or rtl
     */
    langDirection: 'ltr',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.chart = null;
        this.chart_loaded = false;
        this.chartType = '';
        this.locale = SUGAR.charts.getSystemLocale();

        this.langDirection = app.lang.direction;
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('change:rawChartData', function(model, newChartData) {
            // make sure this.model.get('rawChartData') is not null by checking that
            // the newChartData (data set for the model's rawChartData) is not null
            if (newChartData && this.model.get('rawChartData').values.length > 0) {
                this.displayNoData(false);
                // if the chart already exists, remove it before we generate the new one
                if (this.chart_loaded) {
                    this.$('#d3_' + this.cid + ' svg').remove();
                }
                this.generateD3Chart();
            } else {
                this.displayNoData(true);
            }
        }, this);
    },

    overflowHandler: function(distance) {
        var b = this.view.$el.parents().filter(function() {
            return $(this).css('overflow-y') === 'auto' || $(this).css('overflow-y') === 'scroll';
        }).first();

        b.scrollTop(b.scrollTop() - distance);
    },

    /**
     * Callback function on chart render complete.
     *
     * @param {Function} chart sucrose chart instance
     * @param {Object} params chart display parameters
     * @param {Object} data report data with properties and data array
     */
    chartComplete: function(chart, params, reportData, chartData) {
        app.logger.warn('chartComplete has been deprecated. Chart click event is now handled by onClickHander');
        this.chart = chart;
        this.chart_loaded = _.isFunction(chart.update);

        if (!this.chart_loaded) {
            return;
        }

        this.view.trigger('chart:complete', chart, params, reportData, chartData);
    },

    /**
     * Generate the D3 Chart Object
     */
    generateD3Chart: function() {
        var id = this.cid;
        var chartData = this.model.get('rawChartData');
        var params = this.getChartParams(chartData); //NOTE: This is where groupType comes from
        var config = this.getChartConfig(chartData, params);

        if (this.view.layout && this.view.layout.layout && this.view.layout.layout.name === 'drillthrough-pane') {
            params.isOnDrillthrough = true;
        }

        loadSugarChart(id, chartData, [], config, params, chart => {
            this.chart = chart;
            if (this.chart && this.chart.wrapperProperties) {
                this.updateChartWrapperCss(this.chart.wrapperProperties);
            }
        });

        // Resize chart on print.
        this.handlePrinting('on');
    },

    /**
     * Given a set of key/value CSS properties, applies them to the wrapper
     * element around the chart canvas
     *
     * @param {Object} properties the key/value CSS property pairs to set
     */
    updateChartWrapperCss: function(properties) {
        let chartWrapper = document.getElementById(`chart_${this.cid}_wrapper`);
        if (chartWrapper) {
            Object.assign(chartWrapper.style, properties);
        }
    },

    getChartParams: function(chartData) {
        var chartId = this.cid;
        var chartParams = this.model.get('rawChartParams') || {};
        // Get properties from rawChartData
        var properties = !_.isUndefined(chartData.properties) && Array.isArray(chartData.properties) ?
                chartData.properties[0] :
                {};
        // These params will be overriden the SugarCharts defaults
        var params = {
                chart_type: 'multibar',
                margin: {top: 0, right: 10, bottom: 10, left: 10},
                allowScroll: true,
                module: properties.base_module,
                overflowHandler: _.bind(this.overflowHandler, this),
                baseModule: properties.base_module
            };
        var state = this.context.get('chartState');

        if (!_.isEmpty(chartParams)) {
            params = _.extend(params, chartParams);
        }
        if (!_.isEmpty(state)) {
            params.state = state;
        }

        params.onClick = this.onClickHandler();
        delete params.chartElementId;

        return params;
    },

    /**
     * Tells parent view to handle chart click
     */
    onClickHandler: function() {
        let self = this;
        return function(event, activeElements, chart) {
            let reportData = self.model.get('rawReportData');
            // `this` is of type BaseChart
            self.view.trigger('chart:clicked', event, activeElements, chart, this, reportData);
        };
    },

    /**
     * Builds the chart config based on the type of chart
     * @return {Mixed}
     */
    getChartConfig: function(chartData, chartParams) {
        var data = chartData || this.model.get('rawChartData');
        var params = chartParams || this.model.get('rawChartParams');
        var chartConfig;
        var chartGroupType;

        // chartData artifact
        if (!_.isEmpty(chartData) && !_.isUndefined(chartData.properties)) {
            data.properties[0].type = params.chart_type;
        }

        switch (params.chart_type) {
            case 'pie chart':
                chartConfig = {
                    pieType: 'basic',
                    chartType: 'pieChart'
                };
                break;

            case 'donut chart':
                chartConfig = {
                    pieType: 'basic',
                    chartType: 'donutChart',
                };
                break;

            case 'treemap chart':
                chartConfig = {
                    treemapType: 'basic',
                    chartType: 'treemapChart',
                };
                break;

            case 'line chart':
                chartConfig = {
                    lineType: 'grouped',
                    chartType: 'lineChart'
                };
                break;

            case 'funnel chart':
            case 'funnel chart 3D':
                chartConfig = {
                    funnelType: 'basic',
                    chartType: 'funnelChart'
                };
                break;

            case 'gauge chart':
                chartConfig = {
                    gaugeType: 'basic',
                    chartType: 'gaugeChart'
                };
                break;

            case 'stacked group by chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'stacked',
                    chartType: 'barChart'
                };
                break;

            case 'group by chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'grouped',
                    chartType: 'barChart'
                };
                break;

            case 'bar chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'basic',
                    chartType: 'barChart'
                };
                break;

            case 'horizontal group by chart':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'stacked',
                    chartType: 'barChart'
                };
                break;

            case 'horizontal grouped bar chart':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'grouped',
                    chartType: 'barChart'
                };
                break;
            case 'vertical grouped bar chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'grouped',
                    chartType: 'barChart'
                };
                break;

            case 'horizontal bar chart':
            case 'horizontal':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'basic',
                    chartType: 'barChart'
                };
                break;

            default:
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'stacked',
                    chartType: 'barChart'
                };
                break;
        }

        // Not all the charts config has barType key, before we are checking agains barType value
        // we have to ensure that this key exists
        if (params.stacked && _.has(chartConfig, 'barType') && chartConfig.barType !== 'basic') {
            chartConfig.barType = 'stacked';
        }

        chartConfig.direction = app.lang.direction;

        // chartParams artifact
        chartGroupType = chartConfig.barType ||
            chartConfig.lineType ||
            chartConfig.pieType ||
            chartConfig.treemapType ||
            chartConfig.funnelType ||
            'basic';
        chartParams.dataType = chartGroupType === 'stacked' ? 'grouped' : chartGroupType;

        this.chartType = chartConfig.chartType;

        return chartConfig;
    },

    /**
     * Attach and detach a resize method to the print event
     * @param {string} The state of print handling.
     */
    handlePrinting: function(state) {
        var self = this,
            mediaQueryList = window.matchMedia && window.matchMedia('print'),
            pausecomp = function(millis) {
                // www.sean.co.uk
                var date = new Date(),
                    curDate = null;
                do {
                    curDate = new Date();
                } while (curDate - date < millis);
            },
            printResize = function(mql) {
                if (mql.matches) {
                    if (!_.isUndefined(self.chart.legend) && _.isFunction(self.chart.legend.showAll)) {
                        self.chart.legend.showAll(true);
                    }
                    self.chart.width(640).height(320).update();
                    pausecomp(200);
                } else {
                    browserResize();
                }
            },
            browserResize = function() {
                if (!_.isUndefined(self.chart.legend) && _.isFunction(self.chart.legend.showAll)) {
                    self.chart.legend.showAll(false);
                }
                self.chart.width(null).height(null).update();
            };

        if (state === 'on') {
            if (window.matchMedia) {
                mediaQueryList.addListener(printResize);
            } else if (window.attachEvent) {
                window.attachEvent('onbeforeprint', printResize);
                window.attachEvent('onafterprint', browserResize);
            } else {
                window.onbeforeprint = printResize;
                window.onafterprint = browserResize;
            }
        } else {
            if (window.matchMedia) {
                mediaQueryList.removeListener(printResize);
            } else if (window.detachEvent) {
                window.detachEvent('onbeforeprint', printResize);
                window.detachEvent('onafterprint', browserResize);
            } else {
                window.onbeforeprint = null;
                window.onafterprint = null;
            }
        }
    },

    /**
     * Toggle display of dashlet content and NoData message
     * @param {boolean} state The visibility state of the dashlet content.
     */
    displayNoData: function(state) {
        this.$('[data-content="chart"]').toggleClass('hide', state);
        this.$('[data-content="nodata"]').toggleClass('hide', !state);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.handlePrinting('off');
        if (this.chart) {
            this.chart.destroyChart();
        }
        this._super('_dispose');
    },
}) },
"link-action": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * "Link existing record" action used in Subpanels.
 *
 * It needs to be sticky so that we keep things lined up nicely.
 *
 * @class View.Fields.Base.LinkActionField
 * @alias SUGAR.App.view.fields.BaseLinkActionField
 * @extends View.Fields.Base.StickyRowactionField
 */
({
	// Link-action Field (base) 

    extendsFrom: 'StickyRowactionField',
    events: {
        'click a[name=select_button]': 'openSelectDrawer'
    },

    /**
     * Click handler for the select action.
     *
     * Opens a drawer for selecting records to link to the current record.
     */
    openSelectDrawer: function() {
        if (this.isDisabled()) {
            return;
        }

        app.drawer.open(
            this.getDrawerOptions(),
            _.bind(this.selectDrawerCallback, this)
        );
    },

    /**
     * Format drawer options used by {@link #openSelectDrawer}.
     *
     * By default it uses {@link View.Layouts.Base.SelectionListLayout} layout.
     * You can extend this method if you need to pass more or different options.
     *
     * @return {Object}
     * @return {string} return.module The module to select records from.
     * @return {Object} return.parent The parent context of the selection list
     *                                context to pass to the drawer.
     * @return {Data.Bean} return.recParentModel The current record to link to.
     * @return {string} return.recLink The relationship link.
     * @return {View.View} return.recView The view for the selection list.
     * @return {Backbone.Model} return.filterOptions The filter options object.
     * */
    getDrawerOptions: function() {
        var parentModel = this.context.get('parentModel');
        var linkModule = this.context.get('module');
        var link = this.context.get('link');

        var filterOptions = new app.utils.FilterOptions().config(this.def);
        filterOptions.setInitialFilter(this.def.initial_filter || '$relate');
        filterOptions.populateRelate(parentModel);

        return {
            layout: 'multi-selection-list-link',
            context: {
                module: linkModule,
                recParentModel: parentModel,
                recLink: link,
                recContext: this.context,
                recView: this.view,
                independentMassCollection: true,
                filterOptions: filterOptions.format()
            }
        };
    },

    /**
     * Callback method used when the drawer is closed.
     *
     * If a record has been selected, it makes a request to the server to link
     * it to the parent record.
     * On success, it refreshes the subpanel collection so the new record
     * appears in the subpanel.
     *
     * Finally, it expands the subpanel context by setting the `collapsed`
     * property to `false`.
     *
     * @param {Data.Bean} model The selected record to link to parent record.
     */
    selectDrawerCallback: function(model) {
        if (!model) {
            return;
        }

        var parentModel = this.context.get('parentModel');
        var link = this.context.get('link');

        var relatedModel = app.data.createRelatedBean(parentModel, model.id, link),
            options = {
                //Show alerts for this request
                showAlerts: true,
                relate: true,
                success: _.bind(function() {
                    //We've just linked a related, however, the list of records from
                    //loadData will come back in DESC (reverse chronological order
                    //with our newly linked on top). Hence, we reset pagination here.
                    this.context.get('collection').resetPagination();
                    this.context.set('collapsed', false);
                }, this),
                error: function() {
                    app.alert.show('server-error', {
                        level: 'error',
                        messages: 'ERR_GENERIC_SERVER_ERROR'
                    });
                }
            };
        relatedModel.save(null, options);
    },

    /**
     * Check if link action should be disabled or not.
     *
     * The side effect of linking another record on a required relationship is
     * that the record could be already linked to a record and in that case we
     * would delete this existing link.
     *
     * @return {boolean} `true` if it should be disabled, `false` otherwise.
     * @override
     */
    isDisabled: function() {
        if (this._super('isDisabled')) {
            return true;
        }
        var link = this.context.get('link'),
            parentModule = this.context.get('parentModule'),
            required = app.utils.isRequiredLink(parentModule, link);
        return required;
    }
}) },
"teamset": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TeamsetField
 * @alias SUGAR.App.view.fields.BaseTeamsetField
 * @extends View.Fields.Base.RelateField
 */
({
	// Teamset Field (base) 

    extendsFrom: 'RelateField',

    events: {
        'click .btn[name=add]': 'addItem',
        'click .btn[name=remove]': 'removeItem',
        'click .btn[name=primary]': 'setPrimaryItem',
        'change input.select2': 'inputChanged'
    },
    plugins: ['FieldDuplicate', 'TbACLs'],

    /**
     * HTML tag of the append team checkbox.
     *
     * @property {String}
     */
    appendTeamTag: 'input[name=append_team]',

    /**
     * Group fit class.
     *
     * @property {String}
     */
    fitGroupClass: 'three',

    /**
     * Button fit class.
     *
     * @property {String}
     */
    fitButtonClass: 'third',

    initialize: function (options) {
        this._super('initialize', [options]);
        /**
         * @inheritdoc
         */
        this._allow_single_deselect = false;

        /**
         * @inheritdoc
         */
        this._minChars = 1;

        this._currentIndex = 0;
        this.model.on("change:team_name_type", this.appendTeam, this);

        // Set appendTeamValue for mass update
        if (!_.isUndefined(this.model.get('team_name_type'))) {
            this.appendTeamValue = this.model.get('team_name_type') === '1';
        }
    },

    /**
     * @inheritdoc
     *
     * Binds append team checkbox change for massupdate.
     */
    bindDomChange: function() {
        var $el = this.$(this.appendTeamTag);
        if ($el.length) {
            $el.on('change', _.bind(function() {
                this.appendTeamValue = $el.prop('checked');
                this.model.set('team_name_type', this.appendTeamValue ? '1' : '0');
            }, this));
        }
        this._super('bindDomChange');
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        this.$(this.appendTeamTag).off();
        this._super('unbindDom');
    },

    /**
     * Handler on copy teamset values from one model to another.
     *
     * Prevent unchecking last team in team set in order to force the existence
     * of at least one checked team. If primary team is unchecked the next
     * checked team is defined as primary. Set up `checked` property for
     * current team and render field. Returns `false` to prevent processing
     * of teamset field copy cause all logic is implemented in this method.
     *
     * Called from {@link app.plugins._beforeFieldDuplicate}.
     */
    beforeFieldDuplicate: function(params) {

        if (!params.model || !params.data) {
            return false;
        }

        if (this.name !== params.data.fieldName ||
            params.model.get('id') !== this.model.get('id')
        ) {
            return true;
        }

        var checked = params.data.checked || false,
            teamId = params.data.recordItemId || null,
            teams = this.model.get(this.name),
            team = _.findWhere(teams, {'id': teamId}),
            primaryTeam = _.findWhere(teams, {'primary': true}),
            checkedTeams = _.where(teams, {'checked': true}),
            newPrimaryTeam = null;

        if (checked === false && checkedTeams.length === 1) {
            if (!this.disposed) {
                this.render();
            }
            return false;
        }

        if (checked === false && primaryTeam === team) {
            newPrimaryTeam = _.find(checkedTeams, function(item) {
                return item.id !== team.id;
            });
            if (newPrimaryTeam) {
                team.primary = false;
                newPrimaryTeam.primary = true;
            }
        }

        if (team) {
            team.checked = checked;
        }

        if (!this.disposed) {
            this.render();
        }
        return false;
    },

    /**
     * Handler to format field for `merge-duplicate` view.
     *
     * For teamset field we override value to have set of teams from all models
     * for primary record in merge-duplicate view.
     *
     * Called from {@link app.plugins._formatFieldForDuplicate}.
     */
    formatFieldForDuplicate: function() {
        if (_.isUndefined(this.view.generatedValues) ||
            _.isUndefined(this.view.generatedValues.teamsets)
        ) {
            return;
        }

        var allTeams = this.view.generatedValues.teamsets[this.name];

        if (!(this.view.collection instanceof Backbone.Collection)) {
            return;
        }

        _.each(this.view.collection.models, function(model) {
            var teamIds = _.compact(_.pluck(model.get(this.name), 'id')),
                primaryTeam = _.findWhere(model.get(this.name), {primary: true}),
                teams = [];

            _.each(allTeams, function(team) {
                if (model === this.view.primaryRecord || _.contains(teamIds, team.id)) {
                    var extendedTeam = _.extend(
                        app.utils.deepCopy(team),
                        {
                            checked: (model === this.view.primaryRecord && _.contains(teamIds, team.id) === true),
                            primary: (primaryTeam && primaryTeam.id === team.id)
                        }
                    );
                    if (this.isTBAEnabled) {
                        extendedTeam.selected = (
                            _.contains(teamIds, team.id) === true &&
                            _.where(model.get(this.name), {id: team.id})[0].selected
                        );
                    }
                    teams.push(extendedTeam);
                } else {
                    teams.push({
                        checked: false,
                        primary: false
                    });
                }
            }, this);
            model.set(this.name, teams, {silent: true});
        }, this);
    },

    /**
     * Handler to unformat field for `merge-duplicate` view.
     *
     * For teamset field we should exclude teams that are not selected before
     * save primary record.
     *
     * Called from {@link app.plugins._unformatFieldForDuplicate}.
     */
    unformatFieldForDuplicate: function() {
        if (!this.view.primaryRecord) {
            return;
        }

        this.view.primaryRecord.set(
            this.name,
            _.where(this.view.primaryRecord.get(this.name), {'checked': true}),
            {silent: true}
        );
    },

    /**
     * Changes default behavior when doing inline editing on a List view.  We want to
     * load 'list' template instead of 'edit' template because this keeps the teamset widget
     * read-only during inline editing. See SP-1197.
     * Overrides templates for `merge-duplicate` view.
     * @override
     * @private
     */
    _loadTemplate: function() {
        this._super("_loadTemplate");

        if (!_.isUndefined(this.isTBAEnabled) && this.isTBAEnabled) {
            this.fitGroupClass = 'four';
            this.fitButtonClass = 'fourth';
        }

        var template = app.template.getField(
            this.type,
            this.view.name + '-' + this.tplName,
            this.model.module);

        if (!template && this.view.meta && this.view.meta.template) {
            template = app.template.getField(
                this.type,
                this.view.meta.template + '-' + this.tplName,
                this.model.module);
        }

        // Make sure the correct template and module are used when this field is used
        // in the audit log.
        if (!template && this.view.name === 'audit') {
            template = app.template.getField(this.type, 'audit-list', this.view.baseModule);
            this.tplName = 'audit-list';
        }

        // If we're loading edit template on List view switch to detail template instead
        if (!template && this.view.action === 'list' && _.contains(['edit','detail'], this.tplName)) {
            this.template = app.template.getField(
                this.type,
                'list',
                this.module, this.tplName
            ) || app.template.empty;
            this.tplName = 'list';
        }

        this.template = template || this.template;
    },

    /**
     * @inheritdoc
     * Add ability to edit and save an invalid team set.
     */
    _render: function () {
        var self = this;

        if (_.isEmpty(this.value) && this.action == 'edit' && this._checkAccessToAction(this.action)) {
            // Leave an empty team set on list view in case of cancel.
            this.value = app.utils.deepCopy(app.user.getPreference('default_teams'));
            this._updateAndTriggerChange(this.value);
        }
        this._super('_render');

        if (this.tplName === 'edit') {
            this.$(this.fieldTag).each(function (index, el) {
                var plugin = $(el).data("select2");
                // If there is a plugin but no team index, set it
                if (!_.isUndefined(plugin) && _.isUndefined(plugin.setTeamIndex)) {
                    plugin.setTeamIndex = function () {
                        self._currentIndex = $(this).data("index");
                    };
                    plugin.opts.element.on("select2-open", plugin.setTeamIndex);
                }
            });
        }
    },

    /**
     * Called to update value when a selection is made from options view dialog
     * @param model New value for teamset
     */
    setValue: function (model) {
        if (!model) {
            return;
        }
        var index = this._currentIndex,
            team = this.value;
        team[index || 0].id = model.id;
        team[index || 0].name = model.value;
        this._updateAndTriggerChange(team);
    },

    /**
     * @override
     */
    _isErasedField: function() {
        if (!this.model) {
            return false;
        }

        return !this.model.get(this.name) && _.contains(this.model.get('_erased_fields'), this.name);
    },

    format: function (value) {
        if (this.model.isNew() && (_.isEmpty(value) || this.model.get(this.name) != value)) {
            //load the default team setting that is specified in the user profile settings
            if (_.isEmpty(value)) {
                //Here default_teams with "selected teams" are copied from user to module.
                //This "teams" will be send to server with "selected" options
                value = app.utils.deepCopy(app.user.getPreference("default_teams"));
                //If TBA not enabled for module "selected" can be set to false.
                _.each(value, function(team, index, list) {
                    if (!_.isUndefined(team.selected) && !this.isTBAEnabled) {
                        team.selected = false;
                    }
                }, this);
                this.model.setDefault(this.name, value);
            }
        }
        value = app.utils.deepCopy(value);
        if (!_.isArray(value)) {
            value = [
                {
                    name: value
                }
            ];
        }
        // FIXME: SC-3836 will replace special-casing view names/actions via
        // action based templates.
        if (this.view.action === 'list' && this.view.name !== 'merge-duplicates' && this.view.name !== 'audit') {
            //Display primary team in list view
            var primaryTeam = _.find(value, function (team) {
                return team.primary;
            });
            // If there is no primary team discovered return an empty string
            return !_.isUndefined(primaryTeam) && !_.isUndefined(primaryTeam.name) ? primaryTeam.name : "";
        }
        // Place the add button as needed
        if (_.isArray(value) && !_.isEmpty(value)) {
            _.each(value, function(team, index, list) {
                delete team.remove_button;
                if (!team.add_button && index === list.length - 1) {
                    team.add_button = true;
                } else {
                    delete team.add_button;
                }
            });

            // number of valid teams
            var numTeams = _.filter(value, function (team) {
                return !_.isUndefined(team.id);
            }).length;
            // Show remove button for all unset combos and only set combos if there are more than one
            _.each(value, function (team) {
                if (_.isUndefined(team.id) || numTeams > 1) {
                    team.remove_button = true;
                }
            });
        }
        return value;
    },

    /**
     * Validates for equality on id and primary properties
     * since other attributes are used for rendering.
     *
     * @override
     */
    equals: function(other) {
        var validateMap = function(item) {
            return {
                id: item.id,
                primary: item.primary
            };
        };
        return _.isEqual(
            _.map(this.getFormattedValue(), validateMap),
            _.map(other.getFormattedValue(), validateMap)
        );
    },

    addTeam: function () {
        this.value.push({});
        this._currentIndex++;
        this._updateAndTriggerChange(this.value);
    },
    removeTeam: function (index) {
        // Do not remove last team.
        if (index === 0 && this.value.length === 1) {
            return;
        }
        if (this._currentIndex === this.value.length - 1) {
            this._currentIndex--;
        }
        //Pick first team to be Primary if we're removing Primary team
        var removed = this.value.splice(index, 1);
        if (removed && removed.length > 0 && removed[0].primary) {
            this.setPrimary(0);
        }
        this._updateAndTriggerChange(this.value);
    },
    appendTeam: function () {
        var appendTeam = this.model.get("team_name_type");
        if (appendTeam !== "1") {
            var primaryTeam = _.find(this.value, function (team) {
                return team.primary;
            }, this);
            if (_.isEmpty(primaryTeam)) {
                this.setPrimary(0);
            }
        }
    },
    setPrimary: function (index) {
        var previousPrimary = null,
            appendTeam = this.model.get("team_name_type");
        _.each(this.value, function (team, i) {
            if (team.primary && appendTeam === "1") {
                previousPrimary = i;
            }
            team.primary = false;
        });
        //If this team is set, then allow it to turn primary
        if (previousPrimary !== index && this.value[index].name) {
            this.value[index].primary = true;
        }
        this._updateAndTriggerChange(this.value);
        return (this.value[index]) ? this.value[index].primary : false;
    },
    //Forcing change event since backbone isn't picking up on changes within an object within the array.
    inputChanged: function (evt) {
        this._updateAndTriggerChange(this.value);
    },
    /**
     * @inheritdoc
     * Restore the select2 focus location after refresh the dom.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:' + this.name, function() {
                var teamList = this.model.get(this.name);

                if (!_.isUndefined(teamList) && (this._currentIndex !== teamList.length - 1)) {
                    this._currentIndex = teamList.length - 1;
                }

                this.render();

                var $fieldTag = this.$(this.fieldTag);
                if (!_.isEmpty($fieldTag.data('select2'))) {
                    this.$($fieldTag.get(this._currentIndex)).focus();
                }
            }, this);
        }
    },
    /**
     * Forcing change event on value update since backbone isn't picking up on changes within an object within the array.
     * @param value New value for teamset field
     * @private
     */
    _updateAndTriggerChange: function (value) {
        // SP-1437: No Warning message when update with Team field only

        // The following is provided for your convenience should you wish to learn more about
        // Backbone Model .changedAttributes() not showing all changes.
        // For a list of the actual third party software used in this Sugar product,
        // please visit http://support.sugarcrm.com/06_Customer_Center/11_Third_Party_Software/.
        //
        // http://stackoverflow.com/questions/17221680/backbone-model-changedattributes-not-showing-all-changes
        _.each(value, function(team) {
            // "add_button" and "remove_button" are JS elements, don't track them.
            delete team.add_button;
            delete team.remove_button;
        });
        this.model.unset(this.name, {silent: true}).set(this.name, value);//force changedAttributes
        this.model.trigger('change');
    },
    addItem: _.debounce(function (evt) {
        var index = $(evt.currentTarget).data('index');
        //Only allow adding a Team when ones been selected (SP-534)
        if (!index || this.value[index].id) {
            this.addTeam();
        }
    }, 0),
    removeItem: _.debounce(function (evt) {
        var index = $(evt.currentTarget).data('index');
        if (_.isNumber(index)) {
            this.removeTeam(index);
        }
    }, 0),
    setPrimaryItem: _.debounce(function (evt) {
        var index = $(evt.currentTarget).data('index');

        //Don't allow setting to primary until user's selected an actual team (SP-530)
        if (!this.value[index] || !this.value[index].id) {
            return;
        }
        this.$(".btn[name=primary]").removeClass("active");
        if (this.setPrimary(index)) {
            this.$(".btn[name=primary][data-index=" + index + "]").addClass("active");
        }
    }, 0)
}) },
"email": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EmailField
 * @alias SUGAR.App.view.fields.BaseEmailField
 * @extends View.Fields.Base.BaseField
 */
({
	// Email Field (base) 

    events: {
        'change .existingAddress': 'updateExistingAddress',
        'click  .btn-edit':        'toggleExistingAddressProperty',
        'click  .removeEmail':     'removeExistingAddress',
        'click  .addEmail':        'addNewAddress',
        'change .newEmail': 'addNewAddress',
        'click [data-action=audit-email-address]': 'auditEmailAddress',
    },

    _flag2Deco: {
        primary_address: {lbl: "LBL_EMAIL_PRIMARY", cl: "primary"},
        opt_out: {lbl: "LBL_EMAIL_OPT_OUT", cl: "opted-out"},
        invalid_email: {lbl: "LBL_EMAIL_INVALID", cl: "invalid"}
    },

    plugins: ['ListEditable', 'EmailClientLaunch'],

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     * @param options
     */
    initialize: function(options) {
        options     = options || {};
        options.def = options.def || {};

        // By default, compose email link should be allowed
        if (_.isUndefined(options.def.emailLink)) {
            options.def.emailLink = true;
        }

        // Check if the email1 field was made required, if-so copy that property to the dynamic field.
        if (options.model &&
            options.model.fields &&
            options.model.fields.email1 &&
            options.model.fields.email1.required) {
            options.def.required = options.model.fields.email1.required;
        }

        if (options.view.action === 'filter-rows') {
            options.viewName = 'filter-rows-edit';
        }

        this._super('initialize', [options]);

        //set model as the related record when composing an email (copy is made by plugin)
        this.addEmailOptions({related: this.model});
    },

    /**
     * When data changes, re-render the field only if it is not on edit (see MAR-1617).
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('change:' + this.name, function() {
            if (this.action !== 'edit') {
                this.render();
            }
        }, this);
    },

    /**
     * In edit mode, render email input fields using the edit-email-field template.
     * @inheritdoc
     * @private
     */
    _render: function() {
        var emailsHtml = '';

        this._super("_render");

        if (this.tplName === 'edit') {
            // Add email input fields for edit
            _.each(this.value, function(email) {
                emailsHtml += this._buildEmailFieldHtml(email);
            }, this);
            this.$el.prepend(emailsHtml);
        }
    },

    /**
     * Get HTML for email input field.
     * @param {Object} email
     * @return {Object}
     * @private
     */
    _buildEmailFieldHtml: function(email) {
        var editEmailFieldTemplate = app.template.getField('email', 'edit-email-field'),
            emails = this.model.get(this.name),
            index = _.indexOf(emails, email);

        return editEmailFieldTemplate({
            max_length: this.def.len,
            index: index === -1 ? emails.length-1 : index,
            email_address: email.email_address,
            primary_address: email.primary_address,
            opt_out: email.opt_out,
            invalid_email: email.invalid_email
        });
    },

    /**
     * Event handler to add a new address field.
     * @param {Event} evt
     */
    addNewAddress: function(evt){
        if (!evt) return;

        var email = this.$(evt.currentTarget).val() || this.$('.newEmail').val(),
            currentValue,
            emailFieldHtml,
            $newEmailField;

        email = email.trim();

        if ((email !== '') && (this._addNewAddressToModel(email))) {
            // build the new email field
            currentValue = this.model.get(this.name);
            emailFieldHtml = this._buildEmailFieldHtml({
                email_address: email,
                primary_address: currentValue && (currentValue.length === 1),
                opt_out: app.config.newEmailAddressesOptedOut || false,
                invalid_email: false
            });

            // append the new field before the new email input
            $newEmailField = this._getNewEmailField()
                .closest('.email')
                .before(emailFieldHtml);

            if (this.def.required && this._shouldRenderRequiredPlaceholder()) {
                // we need to remove the required place holder now
                var label = app.lang.get('LBL_REQUIRED_FIELD', this.module),
                    el = this.$(this.fieldTag).last(),
                    placeholder = el.prop('placeholder').replace('(' + label + ') ', '');

                el.prop('placeholder', placeholder.trim()).removeClass('required');
            }
        }

        this._clearNewAddressField();
    },

    /**
     * Event handler to update an email address.
     * @param {Event} evt
     */
    updateExistingAddress: function(evt) {
        if (!evt) return;
        var $inputs = this.$('.existingAddress'),
            $input = this.$(evt.currentTarget),
            index = $inputs.index($input),
            newEmail = $input.val(),
            emails = this.model.get(this.name) || [],
            primaryRemoved;

        newEmail = newEmail.trim();

        if (newEmail === '') {
            // remove email if email is empty
            primaryRemoved = this._removeExistingAddressInModel(index);

            $input
                .closest('.email')
                .remove();

            if (primaryRemoved) {
                // on list views we need to set the current value on the input
                if (this.view && this.view.action === 'list') {
                    var primaryAddress = _.filter(emails, function(address) {
                        if (address.primary_address) {
                            return true;
                        }
                    });
                    if(primaryAddress[0] && primaryAddress[0].email_address) {
                        app.alert.show('list_delete_email_info', {
                            level: 'info',
                            autoClose: true,
                            messages: app.lang.get('LBL_LIST_REMOVE_EMAIL_INFO')
                        });
                        $input.val(primaryAddress[0].email_address);
                    }
                }
                this.$('[data-emailproperty=primary_address]')
                    .first()
                    .addClass('active');
            }
            return;
        }
        if (this.tplName === 'list-edit') {
            // In list-edit mode the index is not always at the index of the current target.
            _.find(emails, function(email, i) {
                if (email.primary_address) {
                    index = i;
                    return true;
                }
            });
        }
        this._updateExistingAddressInModel(index, newEmail);
    },

    /**
     * Event handler to remove an email address.
     * @param {Event} evt
     */
    removeExistingAddress: function(evt) {
        if (!evt) return;

        var $deleteButtons = this.$('.removeEmail'),
            $deleteButton = this.$(evt.currentTarget),
            index = $deleteButtons.index($deleteButton),
            primaryRemoved,
            $removeThisField;

        primaryRemoved = this._removeExistingAddressInModel(index);

        $removeThisField = $deleteButton.closest('.email');
        $removeThisField.remove();

        if (primaryRemoved) {
            // If primary has been removed, the first email address is the primary address.
            this.$('[data-emailproperty=primary_address]')
                .first()
                .addClass('active');
        }

        // if this field is required, and there is nothing in the model, then we should decorate it as required
        if (this.def.required && _.isEmpty(this.model.get(this.name))) {
            this.decorateRequired();
        }
    },

    /**
     * Event handler to toggle email address properties.
     * @param {Event} evt
     */
    toggleExistingAddressProperty: function(evt) {
        if (!evt) return;

        var $property = this.$(evt.currentTarget),
            property = $property.data('emailproperty'),
            $properties = this.$('[data-emailproperty='+property+']'),
            index = $properties.index($property);

        if (property === 'primary_address') {
            $properties.removeClass('active').attr('aria-pressed', false);
        }
        $property.attr('aria-pressed', !$property.hasClass('active'));

        this._toggleExistingAddressPropertyInModel(index, property);
    },

    /**
     * Add the new email address to the model.
     * @param {String} email
     * @return {boolean} Returns true when a new email is added.  Returns false if duplicate is found,
     *          and was not added to the model.
     * @private
     */
    _addNewAddressToModel: function(email) {
        var existingAddresses = this.model.get(this.name) ? app.utils.deepCopy(this.model.get(this.name)) : [],
            dupeAddress = _.find(existingAddresses, function(address){
                return (address.email_address === email);
            }),
            success = false;

        if (_.isUndefined(dupeAddress)) {
            existingAddresses.push({
                email_address: email,
                primary_address: (existingAddresses.length === 0),
                opt_out: app.config.newEmailAddressesOptedOut || false
            });
            this.model.set(this.name, existingAddresses);
            success = true;
        }

        return success;
    },

    /**
     * Update email address in the model.
     * @param {Number} index
     * @param {String} newEmail
     * @private
     */
    _updateExistingAddressInModel: function(index, newEmail) {
        var existingAddresses = app.utils.deepCopy(this.model.get(this.name));
        //Simply update the email address
        existingAddresses[index].email_address = newEmail;
        if (this.tplName === 'edit') {
            this.model.set(this.name + (index + 1), newEmail);
        }
        this.model.set(this.name, existingAddresses);
    },

    /**
     * Toggle email address properties: primary, opt-out, and invalid.
     * @param {Number} index
     * @param {String} property
     * @private
     */
    _toggleExistingAddressPropertyInModel: function(index, property) {
        var existingAddresses = app.utils.deepCopy(this.model.get(this.name));

        //If property is primary_address, we want to make sure one and only one primary email is set
        //As a consequence we reset all the primary_address properties to 0 then we toggle property for this index.
        if (property === 'primary_address') {
            existingAddresses[index][property] = false;
            _.each(existingAddresses, function(email, i) {
                if (email[property]) {
                    existingAddresses[i][property] = false;
                }
            });
        }

        // Toggle property for this email
        if (existingAddresses[index][property]) {
            existingAddresses[index][property] = false;
        } else {
            existingAddresses[index][property] = true;
        }

        this.model.set(this.name, existingAddresses);
    },

    /**
     * Remove email address from the model.
     * @param {Number} index
     * @return {boolean} Returns true if the removed address was the primary address.
     * @private
     */
    _removeExistingAddressInModel: function(index) {
        var existingAddresses = app.utils.deepCopy(this.model.get(this.name)),
            primaryAddressRemoved = !!existingAddresses[index]['primary_address'];

        //Reject this index from existing addresses
        existingAddresses = _.reject(existingAddresses, function (emailInfo, i) { return i == index; });

        // If a removed address was the primary email, we still need at least one address to be set as the primary email
        if (primaryAddressRemoved) {
            //Let's pick the first one
            var address = _.first(existingAddresses);
            if (address) {
                address.primary_address = true;
            }
        }

        this.model.set(this.name, existingAddresses);
        return primaryAddressRemoved;
    },

    /**
     * Clear out the new email address field.
     * @private
     */
    _clearNewAddressField: function() {
        this._getNewEmailField()
            .val('');
    },

    /**
     * Get the new email address input field.
     * @return {jQuery}
     * @private
     */
    _getNewEmailField: function() {
        return this.$('.newEmail');
    },

    /**
     * Need to call `decorateError` after all email fields are rendered.
     * @inheritdoc
     *
     * FIXME This is a temporary fix due to time constraints, a proper solution will be implemented in SC-4358
     */
    handleValidationError: function(errors) {
        this._super('handleValidationError', [errors]);
        _.defer(function (field) {
            field.decorateError(errors);
        }, this);
    },

    /**
     * Custom error styling for the e-mail field
     * @param {Object} errors
     * @override BaseField
     */
    decorateError: function(errors){
        var emails;

        this.$el.closest('.record-cell').addClass("error");

        //Select all existing emails
        emails = this.$('input:not(.newEmail)');

        _.each(errors, function(errorContext, errorName) {
            //For `email` validator the error is specific to an email
            if (errorName === 'email' || errorName === 'duplicateEmail') {

                // For each of our `sub-email` fields
                _.each(emails, function(e) {
                    var $email = this.$(e),
                        email = $email.val();

                    var isError = _.find(errorContext, function(emailError) { return emailError === email; });
                    // if we're on an email sub field where error occurred, add error styling
                    if(!_.isUndefined(isError)) {
                        this._addErrorDecoration($email, errorName, [isError]);
                    }
                }, this);
            //For required or primaryEmail we want to decorate only the first email
            } else {
                var $email = this.$('input:first');
                this._addErrorDecoration($email, errorName, errorContext);
            }
        }, this);
    },

    _addErrorDecoration: function($input, errorName, errorContext) {
        var isWrapped = $input.parent().hasClass('input-append');
        if (!isWrapped)
            $input.wrap('<div class="input-append error '+this.fieldTag+'">');
        $input.next('.error-tooltip').remove();
        $input.after(this.exclamationMarkTemplate([app.error.getErrorString(errorName, errorContext)]));
    },

    /**
     * {@inheritdoc}
     *
     * Updates the email address' `confirmation_requested_on` datetime to "now"
     * when the user copies an opted out email address' confirmation URL to the
     * clipboard.
     */
    bindDomChange: function() {
        if(this.tplName === 'list-edit') {
            this._super("bindDomChange");
        }

        this.$('[data-clipboard=enabled]').on('clipboard.success', function() {
            var id = $(this).data('email-address-id');
            var bean;

            if (!id) {
                return;
            }

            bean = app.data.createBean('EmailAddresses', {id: id});
            bean.set('confirmation_requested_on', app.date().format());
            bean.save();
        });
    },

    /**
     * {@inheritdoc}
     *
     * Removes the listeners for clipboard-enabled elements.
     */
    unbindDom: function() {
        this.$('[data-clipboard=enabled]').off('clipboard');
        this._super('unbindDom');
    },

    /**
     * To display representation
     * @param {string|Array|Object} value single email address or set of email addresses.
     */
    format: function(value) {
        /**
         * Get the confirmation URL for an email address.
         *
         * @param {string} id
         * @return {string}
         */
        function getConfirmationUrl(id) {
            return app.utils.getSiteUrl() + '?entryPoint=ConfirmEmailAddress&email_address_id=' + id;
        }

        value = app.utils.deepCopy(value);
        if (_.isArray(value) && value.length > 0) {
            // got an array of email addresses
            _.each(value, function(email) {
                // On render, determine which e-mail addresses need anchor tag included
                // Needed for handlebars template, can't accomplish this boolean expression with handlebars
                email.hasAnchor = this.def.emailLink && !email.invalid_email;
                email.confirmation_url = getConfirmationUrl(email.email_address_id);
            }, this);
        } else if (_.isObject(value) && !_.isEmpty(value)) {
            // Expecting an object containing attributes for an email address
            value = [{
                email_address: value.email_address,
                email_address_id: value.id,
                primary_address: value.primary_address,
                confirmation_url: getConfirmationUrl(value.id)
            }];
        } else if ((_.isString(value) && value !== "") || this.view.action === 'list') {
            // expected an array with a single address but got a string or an empty array
            value = [{
                email_address: value,
                primary_address: true,
                hasAnchor: true,
                confirmation_url: ''
            }];
        }

        if (value && value.length === 1) {
            value[0].soleEmail = true;
        }

        value = this.addFlagLabels(value);
        return value;
    },

    /**
     * Build label that gets displayed in tooltips.
     * @param {Object} value
     * @return {Object}
     */
    addFlagLabels: function(value) {
        var flagStr = "", flagArray;
        _.each(value, function(emailObj) {
            flagStr = "";
            flagArray = _.map(emailObj, function (flagValue, key) {
                if (!_.isUndefined(this._flag2Deco[key]) && this._flag2Deco[key].lbl && flagValue) {
                    return app.lang.get(this._flag2Deco[key].lbl);
                }
            }, this);
            flagArray = _.without(flagArray, undefined);
            if (flagArray.length > 0) {
                flagStr = flagArray.join(", ");
            }
            emailObj.flagLabel = flagStr;
        }, this);
        return value;
    },

    /**
     * To API representation
     * @param {String|Array} value single email address or set of email addresses
     */
    unformat: function(value) {
        if (this.view.action === 'list') {
            var emails = app.utils.deepCopy(this.model.get(this.name));

            if (!_.isArray(emails)) { // emails is empty, initialize array
                emails = [];
            }

            emails = _.map(emails, function(email) {
                if (email.primary_address && email.email_address !== value) {
                    email.email_address = value;
                }
                return email;
            }, this);

            // Adding a new email
            if (emails.length == 0) {
                emails.push({
                    email_address: value,
                    primary_address: true
                });
            }

            return emails;
        }

        if (this.view.action === 'filter-rows') {
            return value;
        }
    },

    /**
     * Opens a drawer to audit the email address.
     */
    auditEmailAddress: function() {
        var email = _.first(this.value);
        var emailModel = app.data.createBean('EmailAddresses', {
            name: email.email_address,
            id: email.email_address_id
        });

        var parentContext = this.context.getChildContext({
            forceNew: true,
            model: emailModel,
            module: 'EmailAddresses',
            modelId: email.email_address_id
        });

        app.drawer.open({
            layout: 'audit',
            context: {
                module: 'Audit',
                model: emailModel,
                parent: parentContext,
            }
        });
    },

    /**
     * Apply focus on the new email input field.
     */
    focus: function () {
        if(this.action !== 'disabled') {
            this._getNewEmailField().focus();
        }
    },

    /**
     * Retrieve link specific email options for launching the email client
     * Builds upon emailOptions on this
     *
     * @param {jQuery} $link
     * @private
     */
    _retrieveEmailOptionsFromLink: function($link) {
        return {
            to: [
                {
                    email: app.data.createBean('EmailAddresses', {
                        id: $link.data('email-address-id'),
                        email_address: $link.data('email-to'),
                        opt_out: $link.data('email-opt-out')
                    }),
                    bean: this.model
                }
            ]
        };
    },

    /**
     * @override
     *
     * Check if the value is a string representing the UUID.
     */
    _isErasedField: function() {
        if (!this.model) {
            return false;
        }

        var value = this.model.get(this.name);
        var erasedFields = this.model.get('_erased_fields');
        return _.isString(value) && _.contains(erasedFields, this.name);
    }
}) },
"email-attachments": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EmailAttachmentsField
 * @alias SUGAR.App.view.fields.BaseEmailAttachmentsField
 * @extends View.Fields.Base.BaseField
 */
({
	// Email-attachments Field (base) 

    /**
     * The selector for accessing the Select2 field when in edit mode. The
     * Select2 field is where the attachments are displayed.
     *
     * @property {string}
     */
    fieldTag: 'input.select2',

    /**
     * The selector for accessing the file input field when in edit mode.
     *
     * @property {string}
     */
    _fileTag: 'input[type=file]',

    /**
     * A collection of models that represent promises for an attachment that is
     * being retrieved asynchronously. Each placeholder model's cid can be used
     * to determine which request is associated with that placeholder.
     *
     * @property {Data.BeanCollection}
     */
    _placeholders: null,

    /**
     * Keeps track of active requests so that they can be aborted if the user
     * cancels an action. The key of a request is the unique number of the
     * placeholder associated with that request, so that requests can be
     * singled out by their placeholder and removed from this object without
     * affecting other active requests.
     *
     * @property {Object}
     */
    _requests: null,

    /**
     * @inheritdoc
     *
     * Adds events for uploading a file when the file input changes and
     * downloading a file when a file link is clicked in detail mode.
     *
     * Adds listeners for the `email_attachments:file` and
     * `email_attachments:document` events that are triggered on the view to
     * add attachments. `email_attachments:file` will launch the file picker
     * dialog. `email_attachments:document` accepts a document to attach.
     */
    initialize: function(options) {
        var events = {};

        events['change ' + this._fileTag] = '_uploadFile';
        events['click [data-action=download]'] = '_downloadFile';
        this.events = _.extend({}, this.events, options.def.events, events);
        this.plugins = _.union(this.plugins || [], ['CollectionFieldLoadAll', 'ListEditable']);
        this._super('initialize', [options]);

        this.listenTo(this.view, 'email_attachments:file', this._openFilePicker);
        this.listenTo(this.view, 'email_attachments:document', this._attachDocument);

        this._placeholders = app.data.createBeanCollection('Notes');
        this._requests = {};
    },

    /**
     * @inheritdoc
     *
     * @fires change:<field_name> on the model when placeholder attachments are
     * added or removed. Internally, this causes the field to be rendered with
     * the updated placeholders. And it avoids an expensive full render when
     * in edit mode.
     * @fires <field_name>:under_max_total_bytes on the model when the total
     * bytes of all attachments is under the maximum from the
     * max_aggregate_email_attachments_bytes configuration. The total bytes,
     * maximum allowed bytes, and bytes remaining under the limit (positive)
     * are passed as parameters.
     * @fires <field_name>:over_max_total_bytes on the model when the total
     * bytes of all attachments exceeds the maximum from the
     * max_aggregate_email_attachments_bytes configuration. The total bytes,
     * maximum allowed bytes, and bytes remaining under the limit (negative)
     * are passed as parameters.
     */
    bindDataChange: function() {
        /**
         * Sums the bytes for each attachment in the collection.
         *
         * @param {Data.BeanCollection} attachments
         * @return {int}
         */
        function getTotalBytes(attachments) {
            var bytes;

            if (!(attachments instanceof app.BeanCollection)) {
                return 0;
            }

            bytes = attachments.reduce(function(total, attachment) {
                var fileSize = attachment.get('file_size');

                if (_.isNaN(fileSize) || !_.isNumber(fileSize)) {
                    try {
                        fileSize = parseInt(fileSize, 10) || 0;
                    } catch (err) {
                        // If failed conversion, treat attachment as 0 bytes.
                        fileSize = 0;
                    }
                }

                return total + fileSize;
            }, 0);

            return bytes;
        }

        if (this.model) {
            this.listenTo(this.model, 'change:' + this.name, function() {
                var $el = this.$(this.fieldTag);
                var maxBytes = app.config.maxAggregateEmailAttachmentsBytes;
                var totalBytes;
                var bytesRemaining;

                if (_.isEmpty($el.data('select2'))) {
                    this.render();
                } else {
                    $el.select2('data', this.getFormattedValue());
                }

                totalBytes = getTotalBytes(this.model.get(this.name));
                bytesRemaining = maxBytes - totalBytes;

                if (bytesRemaining > 0) {
                    this.model.trigger(this.name + ':under_max_total_bytes', totalBytes, maxBytes, bytesRemaining);
                } else {
                    this.model.trigger(this.name + ':over_max_total_bytes', totalBytes, maxBytes, bytesRemaining);
                }
            });
        }

        if (this._placeholders) {
            this.listenTo(this._placeholders, 'update', function() {
                this.model.trigger('change:' + this.name);
            });
        }
    },

    /**
     * @inheritdoc
     *
     * Prevents the Select2 dropdown from opening, as the Select2 field is used
     * as a container only.
     *
     * Removes an attachment when an item is removed from the Select2 field.
     */
    bindDomChange: function() {
        var $el = this.$(this.fieldTag);

        $el.on('select2-opening', function(event) {
            event.preventDefault();
        });

        $el.on('select2-removed', _.bind(function(event) {
            this.model.get(this.name).remove(event.val) || this._placeholders.remove(event.val);
        }, this));
    },

    /**
     * Returns `true` if there are any attachments or placeholders.
     * {@link BaseEmailsCreateView} uses this method to determine whether to
     * hide or show the field as it changes.
     *
     * @return {boolean}
     */
    isEmpty: function() {
        return this.model.get(this.name).isEmpty() && this._placeholders.isEmpty();
    },

    /**
     * @inheritdoc
     *
     * Initializes Select2 when in edit mode and disables all but the delete
     * and backspace keys in the Select2 input field.
     */
    _render: function() {
        var $el;
        var select2Input;

        /**
         * Returns `true` when the event occurs for the delete and backspace
         * keys and `false` for all other keys.
         *
         * @param {Object} event DOM event.
         * @return {boolean}
         */
        var isDeleteKey = function(event) {
            return event.keyCode == 8 || event.keyCode == 46;
        };

        this._super('_render');

        $el = this.$(this.fieldTag);

        if ($el.length > 0) {
            $el.select2({
                multiple: true,
                data: this.getFormattedValue(),
                initSelection: _.bind(function(element, callback) {
                    callback(this.getFormattedValue());
                }, this),
                containerCssClass: 'select2-choices-pills-close',
                containerCss: {
                    width: '100%'
                },
                width: 'off',
                /**
                 * Use `cid` as a choice's ID. Some models are not yet synchronized
                 * and can only be identified by their `cid`. All models have a
                 * `cid`.
                 *
                 * See [Select2 Documentation](https://select2.github.io/select2/#documentation).
                 *
                 * @param {Object} choice
                 * @return {null|string|number}
                 */
                id: function(choice) {
                    return _.isEmpty(choice) ? null : choice.cid;
                },
                /**
                 * Formats an attachment object for rendering.
                 *
                 * See [Select2 Documentation](https://select2.github.io/select2/#documentation).
                 *
                 * @param {Object} choice
                 * @return {string}
                 */
                formatSelection: _.bind(function(choice) {
                    var $selection = '<span class="ellipsis-value ellipsis_inline" title="' +
                        Handlebars.Utils.escapeExpression(choice.name) + '">' +
                        Handlebars.Utils.escapeExpression(choice.name) +
                        '</span>';

                    if (this._placeholders.get(choice.cid)) {
                        $selection +=
                            '<span class="ellipsis-extra"><i class="sicon sicon-refresh sicon-is-spinning"></i></span>';
                    } else {
                        $selection += '<span class="ellipsis-extra">(' + choice.file_size + ')</span>';
                    }

                    $selection = '<span data-id="' + choice.cid + '">' + $selection + '</span>';

                    return $selection;
                }, this),
                /**
                 * Don't escape a choice's markup since we built the HTML.
                 *
                 * See [Select2 Documentation](https://select2.github.io/select2/#documentation).
                 *
                 * @param {string} markup
                 * @return {string}
                 */
                escapeMarkup: function(markup) {
                    return markup;
                }
            }).select2('val', []);

            select2Input = this.$('.select2-input');

            if (select2Input) {
                select2Input.keypress(isDeleteKey);
                select2Input.keyup(isDeleteKey);
                select2Input.keydown(isDeleteKey);
            }

            if (this.isDisabled()) {
                $el.select2('disable');
            }
        }

        return this;
    },

    /**
     * Returns the file input field.
     *
     * Used for mocking the file input field so that its value can be set
     * programmatically. Stubbing `this.$` for only the parameter
     * `this._fileTag` is not possible; it would cause `this.$` to be stubbed
     * for all calls.
     *
     * @return {jQuery}
     * @private
     */
    _getFileInput: function() {
        return this.$(this._fileTag);
    },

    /**
     * @inheritdoc
     *
     * Select2 expects an array of objects to display. The attachments marked
     * for removal are excluded. The attributes of the remaining attachments
     * and placeholders are returned. Each model's `cid` is returned as that is
     * the `id` that Select2 is using. Each model's `file_url` is returned if
     * the attachment has an `id`. The model's `file_size` is returned as a
     * human-readable string, by way of {@link Utils#getReadableFileSize}.
     */
    format: function(value) {
        var urlAttributes = {
            module: 'Notes',
            field: 'filename'
        };
        var urlOptions = {
            htmlJsonFormat: false,
            passOAuthToken: false,
            cleanCache: true,
            forceDownload: true
        };

        value = value instanceof app.BeanCollection ? value.models : value;
        value = _.map(_.union(value || [], this._placeholders.models), function(model) {
            var modelJSON = model instanceof Backbone.Model ? model.toJSON() : model;
            var attachment = _.extend({cid: model.cid}, modelJSON);

            attachment.file_url = attachment.id ?
                app.api.buildFileURL(_.extend({}, urlAttributes, {id: attachment.id}), urlOptions) :
                null;
            attachment.file_size = app.utils.getReadableFileSize(attachment.file_size);

            return attachment;
        });

        this.tooltip = _.pluck(value, 'name').join(', ');

        return value;
    },

    /**
     * @inheritdoc
     *
     * Destroys the Select2 element.
     */
    unbindDom: function() {
        this.$(this.fieldTag).select2('destroy');
        this._super('unbindDom');
    },

    /**
     * @inheritdoc
     *
     * Aborts any active requests. Stops listening to events on the view.
     */
    _dispose: function() {
        _.each(this._requests, function(request) {
            if (request && request.uid) {
                app.api.abortRequest(request.uid);
            }
        });

        this._requests = null;
        this.stopListening(this.view);
        this._super('_dispose');
    },

    /**
     * Makes a request to download the file based on the URL identified in the
     * attributes of the current target of the event.
     *
     * @param {Object} event DOM event.
     * @param {Object} event.currentTarget The current target of the event.
     * @private
     */
    _downloadFile: function(event) {
        var url = this.$(event.currentTarget).data('url');

        if (this.disposed === true) {
            return;
        }

        if (!_.isEmpty(url)) {
            app.api.fileDownload(url, {}, {iframe: this.getFieldElement()});
        }
    },

    /**
     * Launches the file picker dialog.
     *
     * @private
     */
    _openFilePicker: function() {
        if (this.disposed === true) {
            return;
        }

        this._getFileInput().click();
    },

    /**
     * Uploads the files selected from the file picker as a temporary file.
     *
     * A placeholder attachment is added to the Select2 field while the file is
     * being uploaded.
     *
     * @private
     */
    _uploadFile: function() {
        var $file = this._getFileInput();
        var ajaxParams = {
            temp: true,
            iframe: true,
            deleteIfFails: true,
            htmlJsonFormat: true
        };
        var note = app.data.createBean('Notes');
        var placeholder;
        var val = $file.val();

        if (_.isEmpty(val)) {
            return;
        }

        if (!_.isEmpty($file[0].files)) {
            _.each($file[0].files, _.bind(function(file, i) {
                var dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);

                var $domInput = $('<input/>').attr('type', 'file');
                $domInput[0].files = dataTransfer.files;

                var cid = this._addPlaceholderAttachment(file.name).cid;
                this._requests[cid] = note.uploadFile('filename', $domInput, {
                    success: _.bind(this._handleFileUploadSuccess, this),
                    error: _.bind(this._handleFileUploadError, this),
                    complete: _.bind(function() {
                        $file.val(null);
                        for (var k in this._placeholders.models) {
                            var phModel = this._placeholders.models[k];
                            var cid = phModel.cid;
                            if (!_.isEmpty(this._requests[cid].status)) {
                                this._removePlaceholderAttachment(phModel);
                            }
                        }
                    }, this)
                }, ajaxParams);
            }, this));
        } else {
            placeholder = this._addPlaceholderAttachment(val.split('\\').pop());
            this._requests[placeholder.cid] = note.uploadFile('filename', $file, {
                success: _.bind(this._handleFileUploadSuccess, this),
                error: _.bind(this._handleFileUploadError, this),
                complete: _.bind(function() {
                    $file.val(null);
                    this._removePlaceholderAttachment(placeholder);
                }, this)
            }, ajaxParams);
        }
    },

    /**
     * Handles a successful response from the API for uploading the file.
     *
     * The relevant data is taken from the record and added as an attachment.
     * An error is shown to the user if the record does not have a GUID.
     *
     * @param {Object} data The data from a successful API response.
     * @param {Object} data.record The record representing the temporary Notes
     * object.
     * @param {string} data.record.id The GUID of the uploaded file.
     * @private
     */
    _handleFileUploadSuccess: function(data) {
        var file;
        var error;

        if (this.disposed === true) {
            return;
        }

        if (!data.record || !data.record.id) {
            error = new Error('Temporary file has no GUID');
            app.logger.error(error.message);
            app.alert.show('upload_error', {
                level: 'error',
                autoClose: true,
                messages: app.lang.get('ERROR_UPLOAD_FAILED')
            });

            // Track errors attaching a file.
            app.analytics.trackEvent('email_attachment', 'upload_error', error);
        } else {
            file = app.data.createBean('Notes', {
                _link: 'attachments',
                filename_guid: data.record.id,
                name: data.record.filename || data.record.name,
                filename: data.record.filename || data.record.name,
                file_mime_type: data.record.file_mime_type,
                file_size: data.record.file_size,
                file_ext: data.record.file_ext
            });
            this.model.get(this.name).add(file, {merge: true});

            // Track attaching a file.
            app.analytics.trackEvent('email_attachment', 'attached_file', file);
        }
    },

    /**
     * Handles an error response from the API for uploading the file.
     *
     * If the error status is 'request_too_large' or 413, then an error is
     * shown to the user indicating that the error was due to exceeding the
     * maximum filesize. Otherwise, the error is handled by the framework.
     *
     * @param {HttpError} error AJAX error.
     * @private
     */
    _handleFileUploadError: function(error) {
        if (this.disposed === true) {
            return;
        }

        // Track errors attaching a file.
        app.analytics.trackEvent('email_attachment', 'upload_error', error);

        if (error && (error.error === 'request_too_large' || error.status == 413)) {
            // Mark the error as having been handled so that it doesn't get
            // handled again.
            error.handled = true;
            app.alert.show(error.error, {
                level: 'error',
                autoClose: true,
                messages: app.lang.get('ERROR_MAX_FILESIZE_EXCEEDED')
            });
        }

        if (_.isFunction(app.api.defaultErrorHandler)) {
            app.api.defaultErrorHandler(error);
        }
    },

    /**
     * Called when the Document selection drawer is closed. If a Document was
     * selected, then the Document is fetched.
     *
     * The Document must be fetched because it is unlikely that the model
     * retrieved for {@link BaseSelectionListView} contains all of the data that
     * is needed. A placeholder attachment is added to the Select2 field while
     * the Document is being retrieved.
     *
     * @param {Data.Bean} doc The selected Document.
     * @private
     */
    _attachDocument: function(doc) {
        var placeholder;
        var placeholderName;

        if (this.disposed === true) {
            return;
        }

        placeholderName = app.utils.getRecordName(doc) || app.lang.getModuleName(doc.module);
        placeholder = this._addPlaceholderAttachment(placeholderName);
        this._requests[placeholder.cid] = doc.fetch({
            success: _.bind(this._handleDocumentFetchSuccess, this),
            error: function(error) {
                // Track errors attaching a document.
                app.analytics.trackEvent('email_attachment', 'doc_error', error);
            },
            complete: _.bind(function() {
                this._removePlaceholderAttachment(placeholder);
            }, this)
        });
    },

    /**
     * Handles a successful response from the API for fetching the Document.
     *
     * The relevant data is taken from the record and added as an attachment.
     *
     * @param {Object} doc The fetched record.
     * @private
     */
    _handleDocumentFetchSuccess: function(doc) {
        var file;

        if (this.disposed === true) {
            return;
        }

        file = app.data.createBean('Notes', {
            _link: 'attachments',
            upload_id: doc.get('document_revision_id'),
            name: doc.get('filename') || doc.get('name'),
            filename: doc.get('filename') || doc.get('name'),
            file_mime_type: doc.get('latest_revision_file_mime_type'),
            file_size: doc.get('latest_revision_file_size'),
            file_ext: doc.get('latest_revision_file_ext'),
            file_source: 'DocumentRevisions'
        });
        this.model.get(this.name).add(file, {merge: true});

        // Track attaching a document.
        app.analytics.trackEvent('email_attachment', 'attached_doc', file);
    },

    /**
     * Adds a placeholder attachment to the Select2 field.
     *
     * @param {string} name The display name for the placeholder attachment.
     * @return {Data.Bean} The placeholder model.
     * @private
     */
    _addPlaceholderAttachment: function(name) {
        return this._placeholders.add({name: name});
    },

    /**
     * Removes a placeholder attachment from the Select2 field and aborts the
     * associated request, if it is active.
     *
     * @param {Data.Bean} placeholder The placeholder model.
     * @private
     */
    _removePlaceholderAttachment: function(placeholder) {
        var request = this._requests[placeholder.cid];

        this._placeholders.remove(placeholder);

        if (request && request.uid) {
            // Abort the request if it is still active.
            app.api.abortRequest(request.uid);
            delete this._requests[placeholder.cid];
        }
    }
}) },
"hint-email": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EmailField
 * @alias SUGAR.App.view.fields.BaseEmailField
 * @extends View.Fields.Base.BaseField
 */
({
	// Hint-email Field (base) 

    extendsFrom: 'EmailField',

    /**
     * @inheritdoc
     * @param {Object} options Intialization options.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.events = _.extend({}, this.events, {
            'change [type="text"]': 'emailFieldChange',
        });
        var newMailEvent = 'app:' + this.module + ':addNewEmail';
        this.context.on(newMailEvent, this.updateEmailFieldWithImportedData, this);
    },

    /**
     * Update email field with imported data
     *
     * @param {Array} newEmails
     */
    updateEmailFieldWithImportedData: function(newEmails) {
        _.each(newEmails, this.addNewAddressOnCreate, this);
    },

    /**
     * Add new imported email address.
     *
     * @param {string} emailItem
     */
    addNewAddressOnCreate: function(emailItem) {
        var email = emailItem.email_address.trim();

        if (email !== '') {
            var emailFieldHtml = this._buildEmailFieldHtml({
                email_address: email,
                primary_address: emailItem.primary_address,
                opt_out: false,
                invalid_email: false
            }, this);

            this._getNewEmailField().closest('.email').before(emailFieldHtml);

            if (this.def.required && this._shouldRenderRequiredPlaceholder()) {
                var label = app.lang.get('LBL_REQUIRED_FIELD', this.module);
                var el = this.$(this.fieldTag).last();
                var placeholder = el.prop('placeholder').replace('(' + label + ') ', '');

                el.prop('placeholder', placeholder.trim()).removeClass('required');
            }
        }
    },

    /**
     * Check to see if the email is valid
     *
     * @param {string} email
     * @return {string}
     */
    isValidEmail: function(email) {
        var regEx = new RegExp(/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))/.source +
            /@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.source);

        return email.trim() !== '' && regEx.test(email);
    },

    /**
     * Get the email address
     *
     * @param {Object} event
     * @return {string}
     */
    getEmailAddress: function(event) {
        var eventTarget = this.$(event.currentTarget);
        var existingAddress = this.$('.existingAddress');
        return existingAddress.length === 1 ? existingAddress.val() : eventTarget.val();
    },

    /**
     * Check to see if the address already exists
     *
     * @return {boolean} if the addres exists or not
     */
    hasExistingAddress: function() {
        return this.$('.existingAddress').length === 1;
    },

    /**
     * Email field change event
     *
     * @param {Object} event
     */
    emailFieldChange: function(event) {
        var email = this.getEmailAddress(event);
        var index = this.$('input').index(this.$(event.currentTarget));

        if ((index === 0 || this.hasExistingAddress()) && this.isValidEmail(email)) {
            this.reloadPreview();
        }
    },

    /**
     * Reload preview
     */
    reloadPreview: function() {
        app.events.trigger('preview:close');
        app.events.trigger('preview:render', this.model);
        app.events.trigger('hint:user-input', true);
    }
}) },
"linkfromreportbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * LinkFromReportButton allows user to select a report and relate records to
 * primary record.
 *
 * @class View.Fields.Base.LinkfromreportbuttonField
 * @alias SUGAR.App.view.fields.BaseLinkfromreportbuttonField
 * @extends View.Fields.Base.StickyRowactionField
 */
({
	// Linkfromreportbutton Field (base) 

    extendsFrom: 'StickyRowactionField',
    events: {
        'click a[name=select_button]': 'openSelectDrawer'
    },

    /**
     * Event handler for the select button that opens a
     * {@link View.Layouts.Base.SelectionListLinkLayout} in  a drawer for linking
     * an existing record.
     */
    openSelectDrawer: function() {
        if (this.isDisabled()) {
            return;
        }

        var filteredModule = 'Reports',
            filterOptions = new app.utils.FilterOptions().config(this.def);

        var thisContextModule = this.context.get('module');
        if (thisContextModule !== filteredModule) {
            filterOptions.setLangModules([thisContextModule, filteredModule, 'Filters']);
        }

        app.drawer.open({
            layout: 'selection-list',
            context: {
                module: 'Reports',
                filterOptions: filterOptions.format()
            }
        }, _.bind(this.selectDrawerCallback, this));
    },

    /**
     * Process the report that was selected by the user.
     * @param {Object} model
     */
    selectDrawerCallback: function(model) {
        if (!model || _.isEmpty(model.id)) {
            return;
        }

        if (model.module != this.context.get('module')) {
            app.alert.show('listfromreport-warning', {
                level: 'warning',
                messages: app.lang.get('LBL_LINK_FROM_REPORT_WRONG_MODULE'),
                autoClose: true
            });
            return;
        }

        var recordListUrl = app.api.buildURL('Reports', 'record_list', {id: model.id}),
            self = this;

        app.alert.show('listfromreport_loading', {level: 'process', title: app.lang.get('LBL_LOADING')});

        app.api.call(
            'create',
            recordListUrl,
            null,
            {
                success: _.bind(self.linkRecordList, self),
                error: function(error) {
                    app.alert.dismiss('listfromreport_loading');
                    app.alert.show('server-error', {
                        level: 'error',
                        title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                        messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                    });
                }
            }
        );
    },

    /**
     * Links records from a report to the parent record
     * @param {Object} response
     */
    linkRecordList: function(response) {
        var parentModel = this.context.get('parentModel'),
            parentModule = parentModel.get('module') || parentModel.get('_module'),
            link = this.context.get('link'), action = 'link/' + link + '/add_record_list',
            url = app.api.buildURL(
                parentModule,
                action,
                {
                    id: parentModel.get('id'),
                    relatedId: response.id
                }
            );

        app.api.call('create', url, null, {
            success: _.bind(this.linkSuccessCallback, this),
            error: _.bind(this.linkErrorCallback, this),
            complete: function(data) {
                app.alert.dismiss('listfromreport_loading');
            }
        });
    },

    /**
     * Success callback function for api call
     * @param {Object} results
     */
    linkSuccessCallback: function(results) {
        var message, messageLevel;
        if (results.related_records.success.length > 0) {
            messageLevel = 'success';
            message = app.lang.get('LBL_LINK_FROM_REPORT_SUCCESS', null, {
                reportCount: results.related_records.success.length
            });
        } else {
            messageLevel = 'warning';
            message = app.lang.get('LBL_LINK_FROM_REPORT_NO_DATA');
        }

        app.alert.show('server-success', {
            level: messageLevel,
            messages: message,
            autoClose: true
        });

        this.context.resetLoadFlag();
        this.context.set('skipFetch', false);
        this.context.loadData();
    },

    /**
     * Error callback function for api call
     * @param {Object} error
     */
    linkErrorCallback: function(error) {
        app.alert.show('server-error', {
            level: 'error',
            title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
            messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
        });
    },

    /**
     * Returns false if current user does not have access to Reports module - ACL checks
     * @return {Boolean} true if allow access, false otherwise
     * @override
     */
    isDisabled: function() {
        return !app.acl.hasAccess('view', 'Reports');
    }
}) },
"maps-distance": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.MapsDistanceField
 * @alias SUGAR.App.view.fields.BaseMapsDistanceField
 * @extends View.Fields.Base.BaseField
 */
({
	// Maps-distance Field (base) 


    /**
     * Event listeners
     */
    events: {
        'change [data-fieldname=countries]': 'mapParamsChanged',
        'change [data-fieldname=unitType]': 'mapParamsChanged',
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this._initProperties();
    },

    /**
     * Property initialization
     *
     */
    _initProperties: function() {
        this._countries = this._getCountryLabels();
        this._unitTypes = {
            'miles': app.lang.getModString('LBL_MAPS_UNIT_TYPE_MILES', 'Administration'),
            'km': app.lang.getModString('LBL_MAPS_UNIT_TYPE_KM', 'Administration')
        };

        if (!this.model.get(this.name)) {
            this.model.set(
                this.name, {
                    radius: 0,
                    countries: 'United States',
                    zipCode: '',
                    unitType: 'miles'
                },{
                    slient: true
                }
            );
        }

        this.DEBOUNCE_DELAY = 400;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        this._select2 = {};
        this.select2('countries', '_queryCountries', {
            formatResult: _.bind(this._getSelect2CountryOption, this),
            formatSelection: _.bind(this._getSelect2CountrySelection, this),
        });
        this.select2('unitType', '_queryUnitTypes', {
            minimumResultsForSearch: Infinity
        });

        this._unregisterJQueryEvents();
        this._registerJQueryEvents();

        this._updateUIElements();

        if (!app.user.hasMapsLicense()) {
            this._showNoAccessAlert();
        }
    },

    /**
     * Update UI Elements
     */
    _updateUIElements: function() {
        const mapsDistance = this.model.get(this.name);

        this.$('[data-fieldname="radius"]').val(mapsDistance.radius);
        this.$('[data-fieldname="zipCode"]').val(mapsDistance.zipCode);

        this._select2.countries.data({
            id: _.invert(this._countries)[mapsDistance.countries],
            text: mapsDistance.countries
        });
        this._select2.unitType.data({
            id: mapsDistance.unitType,
            text: this._unitTypes[mapsDistance.unitType]
        });
    },

    /**
     * Register jquery elements events
     */
    _registerJQueryEvents: function() {
        this.$('[data-fieldname="radius"]').on(
            'keyup',
            _.debounce(_.bind(this.mapParamsChanged, this), this.DEBOUNCE_DELAY)
        );
        this.$('[data-fieldname="zipCode"]').on(
            'keyup',
            _.debounce(_.bind(this.mapParamsChanged, this), this.DEBOUNCE_DELAY)
        );
    },

    /**
     * Unregister jquery elements events
     */
    _unregisterJQueryEvents: function() {
        this.$('[data-fieldname="radius"]').off(
            'keyup',
            _.debounce(_.bind(this.mapParamsChanged, this), this.DEBOUNCE_DELAY)
        );
        this.$('[data-fieldname="zipCode"]').off(
            'keyup',
            _.debounce(_.bind(this.mapParamsChanged, this), this.DEBOUNCE_DELAY)
        );
    },

    /**
     * Handle radius changes
     *
     * @param {jQuery} e
     */
    mapParamsChanged: function(e) {
        let value = e.currentTarget.value;
        const fieldName = e.currentTarget.dataset.fieldname;

        if (fieldName === 'countries') {
            value = this._countries[e.currentTarget.value];
        }

        let mapsDistance = app.utils.deepCopy(this.model.get(this.name));

        mapsDistance[fieldName] = value;

        if (app.user.hasMapsLicense()) {
            this.model.set(this.name, mapsDistance, {silent: true});
            this.model.trigger('change');
        } else {
            this._showNoAccessAlert();
        }
    },

    /**
     * Stop default behavior
     *
     * @param {jQuery} e
     */
    stopKeyUpEvent: function(e) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();

        return false;
    },

    /**
     * Populate the countries list select2 component
     *
     * @param {Object} query
     *
     */
    _queryCountries: function(query) {
        this._query(query, '_countries');
    },

    /**
     * Populate the unit types list select2 component
     *
     * @param {Object} query
     *
     */
    _queryUnitTypes: function(query) {
        this._query(query, '_unitTypes');
    },

    /**
     * Generic select2 selection list builder
     *
     * @param {Object} query
     * @param {string} list
     *
     */
    _query: function(query, list) {
        var listElements = this[list];
        var data = {
            results: [],
            more: false
        };

        if (_.isObject(listElements)) {
            _.each(listElements, function pushValidResults(element, index) {
                if (query.matcher(query.term, element)) {
                    data.results.push({id: index, text: element});
                }
            });
        } else {
            listElements = null;
        }

        query.callback(data);
    },

    /**
     * Format the select2 element
     *
     * @param {Object} item
     * @return {string}
     */
    _getSelect2CountryOption: function(item) {
        return `<div>
                    <i class="flag-icon flag-icon-${item.id}"></i>
                    <span class="map-small-left-padding">${item.text}</span>
                </div>`;
    },

    /**
     * Format the select2 element
     *
     * @param {Object} item
     * @return {string}
     */
    _getSelect2CountrySelection: function(item) {
        return `<div>
                    <i class="flag-icon flag-icon-${item.id}"></i>
                </div>`;
    },

    /**
     * Create generic Select2 options object
     *
     * @return {Object}
     */
    _getSelect2Options: function(additionalOptions) {
        var select2Options = _.extend({}, additionalOptions);

        select2Options.placeholder = app.lang.get('LBL_MAPS_SELECT_NEW_MODULE_TO_GEOCODE', 'Administration');
        select2Options.dropdownAutoWidth = true;

        return select2Options;
    },

    /**
     * Create generic Select2 component or return a cached select2 element
     *
     * @param {string} fieldname
     * @param {string} queryFunc
     */
    select2: function(fieldname, queryFunc, additionalOptions) {
        if (this._select2 && this._select2[fieldname]) {
            return this._select2[fieldname];
        };

        this._disposeSelect2(fieldname);

        if (queryFunc && this[queryFunc]) {
            additionalOptions.query = _.bind(this[queryFunc], this);
        }

        var el = this.$('[data-fieldname=' + fieldname + ']')
            .select2(this._getSelect2Options(additionalOptions))
            .data('select2');

        this._select2 = this._select2 || {};
        this._select2[fieldname] = el;

        return el;
    },

    /**
     * Dispose a select2 element
     */
    _disposeSelect2: function(name) {
        if (this._select2 && _.isObject(this._select2)) {
            delete this._select2[name];
        }

        this.$('[data-fieldname=' + name + ']').select2('destroy');
    },

    /**
     * Get a list with mapping for countries
     *
     * @return {Object}
     */
    _getCountryLabels: function() {
        return {
            'us': 'United States',
            'ae': 'United Arab Emirates', 'al': 'Albania', 'am': 'Armenia', 'ar': 'Argentina', 'at': 'Austria',
            'au': 'Australia', 'az': 'Azerbaijan', 'ba': 'Bosnia and Herzegovina', 'be': 'Belgium', 'bg': 'Bulgaria',
            'bh': 'Bahrain', 'bo': 'Bolivia', 'br': 'Brazil', 'ca': 'Canada', 'ch': 'Switzerland', 'cl': 'Chile',
            'cn': 'China', 'co': 'Colombia', 'cr': 'Costa Rica', 'cz': 'Czechia', 'de': 'Germany', 'dk': 'Denmark',
            'do': 'Dominican Republic', 'dz': 'Algeria', 'ec': 'Ecuador', 'ee': 'Estonia', 'es': 'Spain', 'eg': 'Egypt',
            'fi': 'Finland', 'fr': 'France', 'gb': 'United Kingdom', 'ge': 'Georgia', 'gr': 'Greece', 'gt': 'Guatemala',
            'hk': 'Hong Kong SAR', 'hn': 'Honduras', 'hr': 'Croatia', 'hu': 'Hungary', 'id': 'Indonesia',
            'ie': 'Ireland', 'il': 'Israel', 'in': 'India', 'iq': 'Iraq', 'ir': 'Iran', 'is': 'Iceland', 'it': 'Italy',
            'jo': 'Jordan', 'jp': 'Japan', 'ke': 'Kenya', 'kr': 'Korea', 'kw': 'Kuwait', 'lb': 'Lebanon',
            'lt': 'Lithuania', 'lv': 'Latvia', 'lu': 'Luxembourg', 'ly': 'Libya', 'ma': 'Morocco',
            'mk': 'North Macedonia', 'mt': 'Malta', 'my': 'Malaysia', 'mx': 'Mexico', 'ni': 'Nicaragua',
            'nl': 'Netherlands', 'nz': 'New Zealand', 'no': 'Norway', 'om': 'Oman', 'pa': 'Panama', 'pe': 'Peru',
            'ph': 'Philippines', 'pl': 'Poland', 'pk': 'Pakistan', 'pr': 'Puerto Rico', 'pt': 'Portugal',
            'py': 'Paraguay', 'qa': 'Qatar', 'ro': 'Romania', 'ru': 'Russia', 'sa': 'Saudi Arabia', 'se': 'Sweden',
            'sg': 'Singapore', 'sk': 'Slovakia', 'sl': 'Slovenia', 'sp': 'Serbia', 'sv': 'El Salvador', 'sy': 'Syria',
            'tw': 'Taiwan', 'th': 'Thailand', 'tn': 'Tunisia', 'tr': 'Turkey', 'ua': 'Ukraine', 'vn': 'Vietnam',
            'ye': 'Yemen', 'za': 'South Africa'
        };
    },

    /**
     * Prevent triggering the model change to avoid the api call for filtering
     * before our values are collected
     *
     * @inheritdoc
     */
    unformat: function() {
        return this.model.get(this.name);
    },

    /**
     * Show no access alert
     */
    _showNoAccessAlert: function() {
        app.alert.show('maps_invalid_license', {
            level: 'error',
            messages: app.lang.get('LBL_MAPS_NO_LICENSE_ACCESS'),
        });
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this._unregisterJQueryEvents();
        this._disposeSelect2('countries');
        this._disposeSelect2('unitType');

        this._select2 = {};

        this._super('_dispose');
    },
}) },
"repeat-count": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * RepeatCount field is a special int field for Meetings/Calls that adds
 * max validation (which can't be done via metadata due to config value)
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.RepeatCountField
 * @alias SUGAR.App.view.fields.BaseRepeatCountField
 * @extends View.Fields.Base.IntField
 */
({
	// Repeat-count Field (base) 

    extendsFrom: 'IntField',

    /**
     * @property {int} defaultCount
     *
     * The number of occurrences to use as a default in the UI when creating a
     * new record.
     */
    defaultCount: 10,

    /**
     * @inheritdoc
     *
     * Add custom max value validation. The value of the field is defaulted in
     * the UI when creating a new record.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        // setting type & def.type so number validator will run
        this.type = this.def.type = 'int';

        this.def['default'] = this.def['default'] || this.defaultCount;

        this.model.addValidationTask(
            'repeat_count_max_validator_' + this.cid,
            _.bind(this._doValidateRepeatCountMax, this)
        );
    },

    /**
     * @inheritdoc
     *
     * Always returns an empty string if the value is 0, '0', null, or
     * undefined.
     */
    format: function(value) {
        value = this._super('format', [value]);

        return (value === '0' || value == null) ? '' : value;
    },

    /**
     * @inheritdoc
     *
     * Converts the value to an integer so that the integer representation is
     * always used in the model. If the value cannot be expressed as an number,
     * then it is left untouched. If the value is an empty string, then it is
     * converted to 0.
     */
    unformat: function(value) {
        if (!_.isString(value)) {
            // can't unformat it, so let the validator do the work
            return value;
        }

        // get the unformatted number
        value = this._super('unformat', [value]);

        if (_.isString(value)) {
            // it couldn't be unformatted
            if (value.trim() === '') {
                // it's the equivalent of 0
                value = 0;
            }
        }

        return value;
    },

    /**
     * Custom required validator for the `repeat_count` field.
     *
     * This validates `repeat_count` is not above the max allowed value
     * Since max value is in a config, cannot use sidecar maxValue validator.
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateRepeatCountMax: function(fields, errors, callback) {
        var repeatCount = parseInt(this.model.get(this.name), 10),
            maxRepeatCount = app.config.calendar.maxRepeatCount;

        if (repeatCount > maxRepeatCount) {
            errors[this.name] = {'maxValue': maxRepeatCount};
        }
        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('repeat_count_max_validator_' + this.cid);
        this._super('_dispose');
    }
}) },
"text": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TextField
 * @alias SUGAR.App.view.fields.BaseTextField
 * @extends View.Fields.Base.BaseField
 */
({
	// Text Field (base) 

    /**
     * @inheritdoc
     */
    shouldInitDefaultValue: true,

    /**
     * @inheritdoc
     * @override
     */
    _initDefaultValue: function() {
        if (!this.model.isNew() || this.model.get(this.name) || !this.def.default) {
            return;
        }

        if (_.isFunction(this.model.setDefault) && this.def.default) {
            this.model.setDefault(this.name, app.lang.get(this.def.default, this.module));
        }
    },

    /**
     * @inheritdoc
     *
     * Format the value to a string.
     * Return an empty string for undefined, null and object types.
     * Convert boolean to 1 or 0.
     * Convert array, int and other types to a string.
     *
     * @param {mixed} value to format
     * @return {string} the formatted value
     */
    format: function(value) {
        if (_.isString(value)) {
            return value;
        }

        if (_.isUndefined(value) || 
            _.isNull(value) ||
            (_.isObject(value) && !_.isArray(value))
        ) {
            return '';
        }

        if (_.isBoolean(value)) {
            return value === true ? '1' : '0';
        }

        return value.toString();
    },

    /**
     * @inheritdoc
     *
     * Trim whitespace from value.
     */
    unformat: function(value) {
        return value.trim();
    }
}) },
"vcard": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Unlink row action used in subpanels and dashlets.
 *
 * @class View.Fields.Base.VcardField
 * @alias SUGAR.App.view.fields.BaseVcardField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Vcard Field (base) 

    extendsFrom: 'RowactionField',

    initialize: function(options) {
        this._super("initialize", [options]);
        this.type = 'rowaction';
    },

    /**
     * Downloads the vCard from the Rest API.
     *
     * First we do an ajax call to the `ping` API. This will check if the token
     * hasn't expired before we append it to the URL of the VCardDownload.
     *
     */
    rowActionSelect: function() {
        var url = app.api.buildURL(this.model.module, 'vcard', {id: this.model.id}, {platform: app.config.platform});

        if (_.isEmpty(url)) {
            app.logger.error('Unable to get the vCard download uri.');
            return;
        }

        app.api.fileDownload(url, {
            error: function(data) {
                // refresh token if it has expired
                app.error.handleHttpError(data, {});
            }
        }, {iframe: this.$el});
    },

    bindDataChange: function() {
        if (this.model) {
            this.model.on('change', this.render, this);
        }
    }
}) },
"sticky-rowaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Sticky Rowaction does not disappear when user does not have access.
 *
 * It becomes disabled instead. This allows us to keep things lined up nicely
 * in Subpanel.
 *
 * @class View.Fields.Base.StickyRowactionField
 * @alias SUGAR.App.view.fields.BaseStickyRowactionField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Sticky-rowaction Field (base) 

    extendsFrom: 'RowactionField',
    /**
     * @param options
     * @override
     */
    initialize: function(options) {
        this._super("initialize", [options]);
        this.type = 'rowaction';  //TODO Hack that loads rowaction templates.  I hope to remove this when SP-966 is fixed.
    },
    /**
     * We always render StickyRowactions and instead set disable class when the user has no access
     * @private
     */
    _render: function() {
        if(this.isDisabled()){
            if(_.isUndefined(this.def.css_class) || this.def.css_class.indexOf('disabled') === -1){
                this.def.css_class = (this.def.css_class) ? this.def.css_class + " disabled" : "disabled";
            }
            //Remove event listeners on this action since it is disabled
            this.undelegateEvents();
        }
        // this can't be inside the isDisabled if block above because css_class can be set to 'disabled' by metadata
        if (!_.isUndefined(this.def.css_class) && this.def.css_class.indexOf('disabled') !== -1) {
            this.tabIndex = -1;
        }

        this._super("_render");
    },
    /**
     * Essentially the replacement of 'hasAccess' method for implementors of StickyRowactionField.
     * Used to determine if this rowaction should be rendered in a disabled state because the user lacks permission, etc.
     *
     * This is a default implementation disables when the user lacks access.
     * @return {boolean}
     */
    isDisabled: function(){
        return !this._super("hasAccess");
    },
    /**
     * Forces StickyRowaction to be rendered and visible in Actiondropdowns.
     * @return {boolean} `true` always
     */
    hasAccess: function(){
        return true;
    }

}) },
"actionbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ActionbuttonField
 * @alias SUGAR.App.view.fields.BaseActionbuttonField
 * @extends View.Fields.Base.BaseField
 */
({
	// Actionbutton Field (base) 

    plugins: ['ActionRunner', 'LinkedModel'],

    events: {
        'click .actionbuttons': 'onClick',
    },

    actionMeta: {},
    activeButtonMeta: {
        buttons: {},
        settings: {},
    },

    loadingPlaceholderActionIdExt: '_loading',

    className: 'actionbutton-wrapper',
    supportedViews: [
        'record',
        'recordlist',
        'subpanel-list',
        'dashlet-toolbar',
        'dashablerecord',
        'preview',
        'actionbutton-preview-record',
        'actionbutton-preview-action-menu',
        'omnichannel-config',
        'omnichannel-detail',
        'config-preview',
    ],
    _calculateDependencyOnDemandViews: [
        'recordlist',
        'dashlet-toolbar',
        'subpanel-list',
    ],

    /**
     * Initializes the ActionButton field.
     *
     * Unencodes, unserializes and resolves the field options/meta.
     *
     * @param {Object} options
     *
     */
    initialize: function(options) {
        /**
         * @inheritdoc
         *
         * This field doesn't support `showNoData`.
        */
        this.showNoData = false;
        this._dependencyCalculated = false;
        this._previousButtonState = false;
        this._initialViewName = options.viewName;
        this._initialTplName = this.tplName;

        this._super('initialize', [options]);

        if (this._isSugarLive() && this.view.type === 'config-preview') {
            this._setDisabledMode('disabled');

            return;
        }

        if (this.view.type === 'dashlet-toolbar') {
            this._initDashableActionButton();
        }

        if (this.view && _.contains(this.supportedViews, this.view.type)) {
            let encodedData = {};

            if (!_.has(options, 'def') || !_.has(options.def, 'options')) {
                encodedData = options.model.fields[options.def.name].options;
            } else {
                encodedData = options.def.options;
            }

            this.actionMeta = this.parseButtonMeta(encodedData);

            this._resolveActiveButtonMeta();
            this._registerEvents();
        }
    },

    /**
     * We have to change the view and model if we are on a dashable toolbar
     */
    _initDashableActionButton() {
        const dashableRecord = this.view.layout.getComponent('dashablerecord');

        this.model = dashableRecord.model;
    },

    /**
     * @inheritdoc
     */
    setMode(mode) {
        this._super('setMode', [mode]);

        if (!this._isSugarLive() ||
            !this.view.type === 'config-preview' ||
            !this.view.type === 'omnichannel-detail' ||
            this._previousButtonState === mode) {
            return;
        }

        this._setDisabledMode(mode);
        this.render();
    },

    /**
     * Check if we are in a OmniChannel layout.
     *
     * @return {boolean}
     */
    _isSugarLive() {
        if ((this.view && this.view.layout && this.view.layout.type.indexOf('omni') === 0) ||
            (_.has(this.view, 'layout') && _.has(this.view.layout, 'module') &&
            this.view.layout.module === 'SugarLive')) {
            return true;
        }

        return false;
    },

    /**
     * Change tpl to disabled
     *
     * @param {string} mode
     */
    _setDisabledMode(mode) {
        const disabledState = 'disabled';
        this._previousButtonState = mode;

        if (mode === disabledState) {
            this._initialViewName = this.options.viewName;
            this._initialTplName = this.tplName;

            this.tplName = disabledState;
            this.options.viewName = disabledState;
        } else {
            this.options.viewName = this._initialViewName;
            this.tplName = this._initialTplName;
        }
    },

    /**
     *
     * Calculate button visibility values and re-renders the component.
     *
     * @param {Data.Bean} model
     *
     */
    _resolveFieldDependency(model, skipRender) {
        if (this.$el === undefined) {
            return;
        }

        this._dependencyCalculated = true;
        this._resolveActiveButtonMeta();

        if (!skipRender) {
            this.render();
        }

        let computedFieldsMeta = {};
        let buttonFieldNameMapping = {};

        _.each(this.actionMeta.buttons, function fieldsEach(item, itemKey) {
            if (item.properties.isDependent) {
                const fieldName = app.utils.generateUUID();
                const formula = item.properties.formula;
                const isCalculated = true;

                buttonFieldNameMapping[fieldName] = {
                    id: item.buttonId,
                    isDropDown: false
                };

                if (this.actionMeta.settings.type === 'dropdown' && item.orderNumber === 0) {
                    buttonFieldNameMapping[fieldName].isDropDown = true;
                }

                computedFieldsMeta[fieldName] = {
                    fieldName: fieldName,
                    formula: formula,
                    isCalculated: isCalculated,
                };
            }
        }, this);

        if (this._hasDependentFields()) {
            this._resolveDependency(computedFieldsMeta, buttonFieldNameMapping);
        }
    },

    /**
     * Checks wether we have dependent fields
     *
     * @return {Bool}
     */
    _hasDependentFields() {
        const noCalculatedFields = _.filter(this.actionMeta.buttons, function search(button) {
            return button.properties.isDependent;
        }).length;

        return noCalculatedFields > 0;
    },

    /**
     * Listening to external events
     */
    _registerEvents: function() {
        this.listenTo(this.model, 'sync', this._resolveFieldDependency);

        if (this.view) {
            this.listenTo(this.view, 'editable:toggle_fields', function toggleActionButton(fields, viewName) {
                // This looks like it makes no sense, however the actionbutton field type is set as readonly
                // via metadata/studio, that means that it will not toggle edit/detail mode like the other fields
                // which is something that we need to enable the "Hide Label on Edit" functionality
                // Therefore we need to hook into the editable:toggle_fields event and implement this functionality
                // We only currently support edit/detail templates, that is why we're checking against the two
                // rather than just doing a this.setMode(viewName)
                this.options.def.readonly = false;

                if (viewName === 'edit' || viewName === 'detail') {
                    this.setMode(viewName);
                }
            }, this);
        }
    },

    /**
     * Flag buttons that have a visibility dependency
     *
     */
    _resolveActiveButtonMeta() {
        this.activeButtonMeta = {
            buttons: {},
            settings: this.actionMeta.settings
        };

        this.activeButtonMeta.settings.hasCalculatedButtons = false;

        _.each(this.actionMeta.buttons, function fieldsEach(item, itemKey) {
            var activeItem = Object.assign({}, item);

            let isDependent = activeItem.properties.isDependent;

            activeItem.properties.hasBeenCalculated = !isDependent;

            if (this.view.type === 'config-preview') {
                activeItem.properties.hasBeenCalculated = false;
                this.activeButtonMeta.settings.hasCalculatedButtons = true;
            }

            this.activeButtonMeta.buttons[itemKey] = activeItem;

            if (isDependent) {
                this.activeButtonMeta.settings.hasCalculatedButtons = true;
            }
        }, this);

        const fromCalculatedValue = false;

        this._reorderActionButton(fromCalculatedValue);
    },

    /**
     * We need to make sure that the actionbutton field has access to both the edit and detail views
     *
     * @inheritdoc
     */
    _checkAccessToAction: function(actionName) {
        if (actionName === 'edit' || actionName === 'detail') {
            return true;
        }

        return this._super('_checkAccessToAction', [actionName]);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (this._isEditDropdownOption() && this._hasDependentFields() && !this._dependencyCalculated) {
            this._resolveFieldDependency(this.model, true);
        } else {
            this._buildUIButtonsData();
        }

        this._super('_render');

        if (this.view && this.view.action === 'create') {
            // We do not support action buttons in create view
            this._hideShowFieldLabel(true);
        }

        if (this.view && this.view.action === 'edit') {
            // We need to set the correct padding while on edit view
            this._adjustButtonsPadding(true);
        }
    },

    /**
     * If the button is in Edit view
     * we have to adjust the padding
     *
     * @return {Bool}
     */
    _adjustButtonsPadding: function() {
        this.$el.css('padding', '5px 7px');
    },

    /**
     * If the button is part of an Edit dropdown
     * we have to calculate the dependency on render
     *
     * @return {Bool}
     */
    _isEditDropdownOption() {
        return _.contains(this._calculateDependencyOnDemandViews, this.view.type);
    },

    /**
     * Reorder buttons after visibility dependencies are applied
     *
     * @param {Bool} fromCalculatedValue
     *
     */
    _reorderActionButton(fromCalculatedValue) {
        let minOrderNumber = 999;
        let buttonId = null;

        _.each(this.activeButtonMeta.buttons, function reorder(item, key) {
            if (item.orderNumber < minOrderNumber) {
                minOrderNumber = item.orderNumber;
                buttonId = key;
            }
        });

        if (_.has(this.activeButtonMeta.buttons, buttonId)) {
            this.activeButtonMeta.buttons[buttonId].orderNumber = 0;
        }

        this._handleFieldLabel(fromCalculatedValue);
        this.setDropDownCaretTheme(this.activeButtonMeta);
    },

    /**
     * Build ordered buttons list
     */
    _buildUIButtonsData: function() {
        if (this.activeButtonMeta && this.activeButtonMeta.buttons) {
            this.activeButtonMeta.uiButtons = _.sortBy(this.activeButtonMeta.buttons, 'orderNumber');
        }
    },

    /**
     * Handle field label visibility
     *
     * @param {Bool} fromCalculatedValue
     *
     */
    _handleFieldLabel(fromCalculatedValue) {
        const buttonNr = Object.keys(this.activeButtonMeta.buttons).length;
        const showFieldLabelSetting = this.activeButtonMeta.settings.showFieldLabel;

        let hideLabel = true;

        if (!showFieldLabelSetting) {
            this._hideShowFieldLabel(hideLabel);
        } else if (fromCalculatedValue && buttonNr === 0) {
            this._hideShowFieldLabel(hideLabel);
        } else if (showFieldLabelSetting) {
            this._hideShowFieldLabel(!hideLabel);
        }
    },

    /**
     * Calculate and apply button visibility dependencies.
     *
     * @param {Object} computedFieldsMeta
     * @param {Object} buttonFieldNameMapping
     *
     */
    _resolveDependency(computedFieldsMeta, buttonFieldNameMapping) {
        const requestType = 'create';
        const apiPath = 'actionButton/evaluateExpression';

        const requestMeta = {
            'targetFields': computedFieldsMeta,
            'targetRecordId': this.model.id,
            'targetModule': this.model.module
        };

        const apiCallbacks = {
            success: _.bind(function resolveDependencyCallback(result) {
                _.each(result, function resolveButtonVisibility(showField, fieldId) {
                    const buttonMeta = buttonFieldNameMapping[fieldId];
                    const buttonId = buttonMeta.id;

                    if (!showField) {
                        delete this.activeButtonMeta.buttons[buttonId];
                    } else {
                        this.activeButtonMeta.buttons[buttonId].properties.hasBeenCalculated = true;
                    }
                }, this);

                if (Object.keys(this.activeButtonMeta.buttons).length > 0) {
                    this.activeButtonMeta.settings.hasCalculatedButtons = false;
                } else {
                    this.activeButtonMeta.settings.hasCalculatedButtons = true;
                }

                const fromCalculatedValue = true;

                this._reorderActionButton(fromCalculatedValue);

                this.render();
            }, this)
        };

        const apiUrl = app.api.buildURL(apiPath, requestType, requestMeta, {});

        app.api.call(requestType, apiUrl, requestMeta, null, apiCallbacks);
    },

    /**
     * Show/Hide the field label
     *
     * @param {Bool} hideLabel
     *
     */
    _hideShowFieldLabel(hideLabel) {
        if (!this.$el) {
            return;
        }

        const $headerpane = this.$el.closest('headerpane');
        const isHeaderButton = $headerpane.length !== 0;

        if (isHeaderButton) {
            return true;
        }

        if (!this.view) {
            return;
        }

        if (this.view.name === 'record' || this.view.name === 'create') {
            this._hideShowFieldLabelRecordView(hideLabel);
        } else if (this.view.name === 'preview') {
            this._hideShowFieldLabelPreview(hideLabel);
        } else if (this.view.name === 'dashablerecord') {
            this._hideShowFieldLabelDashableRecordView(hideLabel);
        }
    },

    /**
     * Toggle field labels on RecordView
     *
     * @param {Bool} hideLabel
     */
    _hideShowFieldLabelRecordView(hideLabel) {
        const labelsOnTop = this._isLabelPlacementOnTop();

        let labelHolder = null;

        if (labelsOnTop) {
            labelHolder = this.$el.parent().siblings('[class*=label]');
        } else {
            labelHolder = this.$el.parents().eq(1).siblings('[class*=label]');
        }

        if (labelHolder) {
            this._showHideElement(labelHolder, !hideLabel);
        }
    },

    /**
     * Toggle field labels on PreviewView
     *
     * @param {Bool} hideLabel
     */
    _hideShowFieldLabelPreview(hideLabel) {
        let labelHolder = this.$el.parents().eq(1).find('[class*=label]');

        if (labelHolder) {
            this._showHideElement(labelHolder, !hideLabel);
        }
    },

    /**
     * Toggle field labels on DashablerecordView
     *
     * @param {Bool} hideLabel
     */
    _hideShowFieldLabelDashableRecordView(hideLabel) {
        let labelHolder = this.$el.parents().eq(1).find('[class*=label]');

        if (labelHolder) {
            this._showHideElement(labelHolder, !hideLabel);
        }
    },

    /**
     * Handle field label visibility
     *
     * @param {string} id
     * @param {Bool} showField
     * @param {Bool} isDropDown
     *
     */
    _hideShowFieldById(id, showField, isDropDown) {
        let buttonEl = this.$('#' + id);

        this._showHideElement(buttonEl, showField);

        if (isDropDown && !buttonEl.attr('is_action_button_loading')) {
            let dropdownToggleEl = buttonEl.siblings('.dropdown-toggle[class*=actionbtn]');

            this._showHideElement(dropdownToggleEl, showField);
        }
    },

    /**
     * Show/Hide a html element
     *
     * @param {jQuery} element
     * @param {Bool} showElement
     */
    _showHideElement(element, showElement) {
        element.toggle(showElement);
    },

    /**
     * Handle button click event, start executing button actions.
     *
     * @param {Event} e
     *
     */
    onClick(e) {
        const buttonId = e.currentTarget.id;

        let actions = this._getActionsByButtonId(buttonId);

        this.execute(actions, {
            createLinkModelFct: _.bind(this.createLinkModel, this),
            recordModel: this.model,
            recordView: this.view,
            buttonField: this,
            stopOnError: this.actionMeta.buttons[buttonId].properties.stopOnError,
        });
    },

    /**
     * Remove field label from record view
     *
     */
    _resolveElementLabel() {
        const showFieldLabel = this.actionMeta.settings.showFieldLabel;

        if (showFieldLabel) {
            return;
        }

        const labelsOnTop = this._isLabelPlacementOnTop();

        labelsOnTop ? this._hideElementLabelOnTop() : this._hideElementLabelOnLeft();
    },

    /**
     * Remove field label when label on top.
     *
     */
    _hideElementLabelOnTop() {
        const titleEl = this.$el.parent().siblings('div');

        if (titleEl.length > 0) {
            titleEl.hide();
        }

    },

    /**
     * Remove field label when label to the left
     *
     */
    _hideElementLabelOnLeft() {
        const titleEl = this.$el.parents().eq(2).siblings('div');

        if (titleEl.length > 0) {
            titleEl.hide();
        }
    },

    /**
     * Returns label placement.
     *
     * Used to set labelsOnTop in views. Returns true if user preference is
     * 'field_on_top', else false.
     *
     * @return {Bool}
     */
    _isLabelPlacementOnTop: function() {
        return app.user.getPreference('field_name_placement') === 'field_on_top';
    },

    /**
     *
     * Returns button actions definition
     *
     * @param {string} buttonId
     *
     * @return {Object}
     */
    _getActionsByButtonId(buttonId) {
        let actionsMeta = this.actionMeta;
        let buttons = actionsMeta.buttons;

        if (!_.has(buttons, buttonId)) {
            throw new Error('Failed to execute action for button id: '.buttonId);
        }

        const actions = buttons[buttonId].actions;

        return actions;
    },

    /**
     * Removes actions and dependencies from buttons
     *
     * @param {Object} buttonsData
     * @return {Object}
     */
    _getPreparedButtonsData: function(buttonsData) {
        var data = app.utils.deepCopy(buttonsData);

        // remove dependencies and actions
        data.buttons = _.each(data.buttons, function(buttonData, id) {
            buttonData.properties.isDependent = false;
            buttonData.actions = {};
        });

        // if there are no settings yet applied, set default ones
        if (Object.keys(data.settings).length < 1) {
            data.settings = {
                type: 'button',
                size: 'default'
            };
        }

        return data;
    },

    /**
     * Encode/Decode the base64 field meta, recursively.
     *
     *
     * @param {Object|string} data
     * @param {Bool} encode
     *
     * @return {Array}
     */
    base64Parse(data, encode) {
        _.each(data, function parseButtons(childData, key) {
            if (typeof childData === 'object' && childData !== null) {
                data[key] = this.base64Parse(childData, encode);
            } else if (typeof childData === 'string') {
                data[key] = encode ? btoa(childData) : atob(childData);
            }
        }, this);

        return data;
    },

    /**
     * Inject the color schema to be used in hbs template.
     *
     * @param {Object} meta
     *
     * @return {Object}
     */
    setDropDownCaretTheme(meta) {
        if (meta.settings.type !== 'dropdown') {
            return meta;
        }

        var minItem = {index: 1000, id: null, colorScheme: null};

        _.each(meta.buttons, function parseMeta(item) {
            if (item.orderNumber < minItem.index) {
                minItem.index = item.orderNumber;
                minItem.id = item.buttonId;
                minItem.colorScheme = item.properties.colorScheme;
            }
        });

        meta.settings.colorScheme = minItem.colorScheme;

        return meta;
    },

    /**
     * Decode the metadata
     *
     * @param {string} meta
     *
     * @return {Object}
     */
    parseButtonMeta(meta) {
        let newMeta = {};

        try {
            let base64Encoded = JSON.parse(meta);
            let baseEncode = false;
            let decodedMeta = this.base64Parse(base64Encoded, baseEncode);

            newMeta = this.setDropDownCaretTheme(decodedMeta);
        } catch (e) {
            app.logger.fatal(e.stack);
        }

        return newMeta;
    },
}) },
"editrecurrencesbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * EditrecurrencesbuttonField is a field for Meetings/Calls for the ability editing all recurring events for a parent record
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.EditrecurrencesbuttonField
 * @alias SUGAR.App.view.fields.BaseEditrecurrencesbuttonField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Editrecurrencesbutton Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * @inheritdoc
     *
     * Button should be hidden if meeting displayed is not recurring
     */
    _render: function() {
        if (_.isEmpty(this.model.get('repeat_type'))) {
            this.hide();
        } else {
            this._super('_render');
        }
    },

    /**
     * Re-render the field when the status on the record changes.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:repeat_type', this.render, this);
        }
    },

    /**
     * Event handler for editing all recurring records of a series
     * @inheritdoc
     */
    rowActionSelect: function() {
        this.context.trigger('all_recurrences:edit');
    }
}) },
"guest": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Fields.Base.GuestField
 * @alias SUGAR.App.view.fields.BaseGuestField
 * @extends View.Fields.Base.RelateField
 */
({
	// Guest Field (base) 

    extendsFrom: 'RelateField',

    /**
     * @inheritdoc
     * @param {Object} options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.customDropdownRender = this._renderEditableDropdown;
    },

    /**
     * Extend the parent(relate) _loadTemplate
     */
    _loadTemplate: function() {
        this.type = 'relate';
        this._super('_loadTemplate');
        this.type = this.def.type;
    },

    /**
     * @override
     * @return {Array}
     */
    getSearchModules: function() {
        return _.chain(this.def.links).map(function(link) {
            return app.data.getRelatedModule(this.module, this.module === 'Messages' ? 'invitee_' + link : link);
        }, this).value();
    },

    /**
     * @override
     * @return {string}
     */
    getPlaceHolder: function() {
        return app.lang.get('LBL_SEARCH_SELECT');
    },

    /**
     * @override
     */
    openSelectDrawer: function() {
        var layout;
        var module;
        var modules;

        if (!_.isUndefined(this.def.links)) {
            layout = 'selection-list-module-switch';
            modules = this.getSearchModules();
            module = _.first(modules);
        } else {
            layout = 'selection-list';
            module = this.module;
            modules = [module];
        }

        app.drawer.open({
            layout: layout,
            context: {
                module: module,
                filterList: modules
            }
        }, _.bind(this.setValue, this));
    },

    /**
     * @override
     * @param {Object} value
     * @return {Object} This field's value. Need to change to object with all
     *   data that we need to render the field.
     */
    format: function(value) {
        if (value && value.models) {
            var model = _.last(value.models);
            if (model) {
                this.formattedIds = model.get('id');
                this.formattedRname = model.get('name');
            } else {
                this.formattedIds = '';
                this.formattedRname = '';
            }
        }
        return value;
    },

    /**
     * @override
     * @return {app.BeanCollection}
     */
    getFieldValue: function() {
        var value = this.model.get(this.name);

        if (!(value instanceof app.BeanCollection)) {
            app.logger.error('The value must be a BeanCollection');
        }

        return value;
    },

    /**
     * @override
     * @param e
     * @private
     */
    _onSelect2Change: function(e) {
        var attributes = {};
        if (e.added) {
            attributes = e.added.attributes;
        }

        this.setValue(attributes);
    },

    /**
     * @override
     * @param model
     */
    setValue: function(model) {
        var guest;
        try {
            guest = this.getFieldValue();
        } catch (err) {
            app.logger.error('Unable to fetch the invitees collection');
        }
        if (guest.length) {
            guest.reset();
        }
        if (model && model.id) {
            guest.add(model);
        }
    },

    /**
     * @override
     * @private
     */
    _updateField: function() {
        if (this.disposed) {
            return;
        }
        var $dropdown = this.$(this.fieldTag);
        var field;
        try {
            field = this.getFieldValue();
        } catch (err) {
            app.logger.error('Unable to fetch the invitees collection');
        }
        if (!_.isEmpty($dropdown.data('select2')) && field.length) {
            var value = _.first(field.models).get('name');
            value = _.isArray(value) ? value.join(this._separator) : value;
            value = value ? value.trim() : value;
            if (this._isErasedField()) {
                value = app.lang.getAppString('LBL_VALUE_ERASED');
            }

            $dropdown.data('rname', value);

            // `id` can be an array of ids if the field is a multiselect.
            var id = _.first(field.models).get('id');
            if (_.isEqual($dropdown.select2('val'), id)) {
                return;
            }

            $dropdown.select2('val', id);
        } else {
            this.render();
        }
    },

    /**
     * @override
     * @param query
     */
    search: _.debounce(function(query) {
        var data;
        var fields;
        var participants;
        var success;

        data = {
            results: [],
            more: false
        };

        success = function(result) {
            result.each(function(record) {
                var participant = participants.get(record.id);

                if (participant) {
                    app.logger.debug(record.module + '/' + record.id + ' is already in the collection');
                } else {
                    record.text = record.get('name');
                    data.results.push(record);
                }
            });
        };

        try {
            participants = this.getFieldValue();
            participants.search({
                query: query.term,
                success: success,
                search_fields: ['full_name', 'email', 'account_name'],
                fields: ['name'],
                complete: function() {
                    query.callback(data);
                }
            });
        } catch (e) {
            app.logger.warn(e);
            query.callback(data);
        }
    }, app.config.requiredElapsed || 500),
}) },
"file": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FileField
 * @alias SUGAR.App.view.fields.BaseFileField
 * @extends View.Fields.Base.BaseField
 */
({
	// File Field (base) 

    fieldTag: 'input[type=file]',
    supportedImageExtensions: {
        'image/jpeg': 'jpg',
        'image/png': 'png',
        'image/gif': 'gif'
    },
    events: {
        'click [data-action=download]': 'startDownload',
        'click [data-action=delete]': 'deleteFile',
        'click [data-action=selectFile]': '_handleSelectFileClicked',
        'click [data-action=toggleExternalApiDirection]': '_handleApiDirectionClicked'
    },
    fileUrl: '',
    plugins: ['File', 'FieldDuplicate'],

    /**
     * For file fields that allow file selection from external APIs, this stores
     * the options for the external API file selector popup window
     */
    externalApiPopupOptions: {
        width: 600,
        height: 400,
        menubar: 'no',
        toolbar: 'no',
        status: 'no',
        resizable: 'yes',
        scrollbars: 'yes'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // FIXME: This needs an API instead. SC-3369 should address this.
        app.error.errorName2Keys['tooBig'] = 'ERROR_MAX_FILESIZE_EXCEEDED';
        app.error.errorName2Keys['uploadFailed'] = 'ERROR_UPLOAD_FAILED';

        if (this.model) {
            this.model.addValidationTask('file_upload_' + this.cid, _.bind(this._doValidateFile, this));
        }

        // Set up for external API options
        if (this.def.allowEapm) {
            this.allowEapm = true;
            this.docTypeField = this.def.docType;
            this.docUrlField = this.def.docUrl;
            this.docIdField = this.def.docId;
        }

        // Check if the field def specifies whether the file should be deletable
        // after the record has been created
        this.allowDelete = !this.def.noChange || this.view.action === 'create';
    },

    /**
     * @inheritdoc
     *
     * Overrides `change` event for file field.
     * We should call `render` method when change event is triggered if:
     * 1. it is not duplicate-merge view and field isn't in edit mode. If it is
     * in edit mode we cannot set a value of a type `file` input.
     * 2. it is duplicate-merge view and field is in edit mode. Because
     * for this view we display file field as label (not input[type=file])
     * in edit mode we should update view on change.
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }
        this.listenTo(this.model, 'change:' + this.name, this._handleFileChanged);

        // Listeners for External API functionality
        if (this.allowEapm) {
            this.listenTo(this.model, 'change:' + this.docTypeField, this._handleDocTypeChanged);
            this.listenTo(app.events, 'external:document:selected:' + this.cid, this._handleExternalFileSelected);
        }
    },

    /**
     * Handles when the file field value is changed on the model
     *
     * @private
     */
    _handleFileChanged: function() {
        // Clear any errors on the field if we are changing the value.
        this._errors = {};
        this.clearErrorDecoration();
        if (_.isUndefined(this.options.viewName) || this.options.viewName !== 'edit') {
            this.render();
        }
        // check if other fields want use the name of the file
        if (!_.isUndefined(this.def.populate_list)) {
            _.each(this.def.populate_list, function(field) {
                if (!this.model.get(field) && app.acl.hasAccessToModel('edit', this.model, field)) {
                    this.model.set(field, this.model.get(this.name));
                }
            }, this);
        }

        // Update the value, then update the DOM to display correctly
        this.value = this.getFormattedValue();
        this._updateDom();
    },

    /**
     * Handles when the button to select a file is clicked
     *
     * @private
     */
    _handleSelectFileClicked: function() {
        // If selecting a file from an external API, open Sugar's external API
        // file selector. Otherwise, the default file selector will open
        if (this.allowEapm && this.docTypeField) {
            var docType = this.model.get(this.docTypeField);
            if (!_.isEmpty(docType) && docType !== 'Sugar' && this.externalApiDirectionFrom) {
                this.openExternalFileSelector(docType);
            }
        }
    },

    /**
     * Opens a popup window to select a file stored on an external drive
     *
     * @param docType the type of external API (e.g. 'Google')
     */
    openExternalFileSelector: function(docType) {
        var url = 'index.php?module=Documents&action=extdoc&isPopup=1&sidecarCid=' +
            this.cid + '&apiName=' + docType;
        var windowOptions = _.map(this.externalApiPopupOptions, function(value, key) {
            return key + '=' + value;
        });

        window.open(
            url,
            'sugarPopup',
            windowOptions.join(',')
        );
    },

    /**
     * Handles when a file has been selected from an external API file selector
     * popup
     *
     * @param docId the ID of the external document that was selected
     * @param docName the name of the external document that was selected
     * @param docUrl the URL to the external document that was selected
     * @private
     */
    _handleExternalFileSelected: function(docId, docName, docUrl) {
        // Update the attributes of the model to link it to the external file
        var attrUpdates = {};
        attrUpdates[this.name] = docName;
        attrUpdates[this.name + '_remoteName'] = docName;
        attrUpdates[this.docIdField] = docId;
        attrUpdates[this.docUrlField] = docUrl;
        this.model.set(attrUpdates);
    },

    /**
     * Handles when the document type (e.g. 'Sugar', 'Google', etc.) is changed
     *
     * @private
     */
    _handleDocTypeChanged: function() {
        var docType = this.model.get(this.docTypeField);
        if (_.isEmpty(docType) || docType === 'Sugar') {
            // The document type is not an external API
            this.externalApi = false;
            this.externalApiDirectionFrom = false;
        } else {
            // The document type is an external API
            this.externalApi = docType;
        }

        this._updateDom();
    },

    /**
     * Handles when the user clicks to change the direction of the external API
     * (either uploading a file to it, or linking to a file from it)
     *
     * @private
     */
    _handleApiDirectionClicked: function() {
        this.externalApiDirectionFrom = !this.externalApiDirectionFrom;
        this._updateDom();
    },

    /**
     * Updates the DOM to display the field correctly given its current state.
     * We cannot rely on render() since that will re-render the file input
     * element as well, which would remove its stored data that we need later to
     * upload the file with. Instead, we re-render only the parts of the DOM
     * that we need to
     *
     * @private
     */
    _updateDom: function() {
        this._updateFilenameDom();
        this._updateFileSelectorDom();
        this._updateApiDirectionSelectorDom();
    },

    /**
     * Re-renders the filename pill partial template
     *
     * @private
     */
    _updateFilenameDom: function() {
        var filenameTemplate = app.template.getField(this.type, 'edit-filename', this.module);
        this.$('.file-name').empty();
        this.$('.file-name').html(filenameTemplate(this));
    },

    /**
     * Hides or shows the file selector depending on whether a file is selected
     *
     * @private
     */
    _updateFileSelectorDom: function() {
        var fileSelectorEl = this.$('.file-select');
        var valueExists = !_.isEmpty(this.value);
        fileSelectorEl.toggleClass('hidden', valueExists);
    },

    /**
     * Re-renders the external API direction selector partial template
     *
     * @private
     */
    _updateApiDirectionSelectorDom: function() {
        var apiDirectionTemplate = app.template.getField(this.type, 'edit-api-direction-selector', this.module);
        this.$('.external-api-direction-selector').empty();
        this.$('.external-api-direction-selector').html(apiDirectionTemplate(this));
    },

    /**
     * Validator for the file field. If the field is required and has no value,
     * it will fail validation prior to performing a file upload. If there is a
     * value, it will perform a file upload to the temporary folder (required in
     * order to test uploads for files that are potentially larger than
     * `upload_max_filesize` in php.ini).
     *
     * @param {Object} fields The list of fields to validate.
     * @param {Object} errors The errors object during this validation task.
     * @param {Function} callback The callback function to continue validation.
     */
    _doValidateFile: function(fields, errors, callback) {
        var fieldName = this.name;

        if (this.def.required && _.isEmpty(this.model.get(this.name))) {
            errors[fieldName] = errors[fieldName] || {};
            errors[fieldName].required = true;
            callback(null, fields, errors);
            return;
        }

        var fileInputEl = this.$(this.fieldTag);
        if (fileInputEl.length === 0) {
            callback(null, fields, errors);
            return;
        }

        var val = fileInputEl.val();
        if (!_.isEmpty(val)) {
            this._uploadFile(fieldName, fileInputEl, fields, errors, callback);
        } else {
            callback(null, fields, errors);
            return;
        }
    },

    /**
     * Attempts to upload a file to Sugar, validating the upload status in the
     * process
     *
     * @param {string} fieldName the name of the field
     * @param {Object} fileInputEl the file input element containing the user-selected file to upload
     * @param {Object} fields The list of fields to validate
     * @param {Object} errors The errors object during this validation task
     * @param {Function} callback The callback function to continue validation
     * @private
     */
    _uploadFile: function(fieldName, fileInputEl, fields, errors, callback) {
        var ajaxParams = {
            temp: true,
            iframe: true,
            deleteIfFails: false,
            htmlJsonFormat: true
        };

        app.alert.show('upload', {
            level: 'process',
            title: app.lang.get('LBL_UPLOADING'),
            autoclose: false
        });

        this.model.uploadFile(fieldName, fileInputEl, {
            success:_.bind(this._doValidateFileSuccess, this, fields, errors, callback),
            error:_.bind(this._doValidateFileError, this, fields, errors, callback)
        }, ajaxParams);
    },

    /**
     * Success callback for the {@link #_doValidateFile} function.
     *
     * @param {Object} fields The list of fields to validate.
     * @param {Object} errors The errors object during this validation task.
     * @param {Function} callback The callback function to continue validation.
     * @param {Object} data File data returned from the successful file upload.
     */
    _doValidateFileSuccess: function(fields, errors, callback, data) {
        app.alert.dismiss('upload');

        var guid = data.record && data.record.id;
        if (!guid) {
            app.logger.error('Temporary file uploaded has no GUID.');
            this._doValidateFileError(fields, errors, callback, data);
            return;
        }

        var fieldName = this.name;
        // Add the guid to the list of fields to set on the model.
        if (!this.model.fields[fieldName + '_guid']) {
            this.model.fields[fieldName + '_guid'] = {
                type: 'file_temp',
                group: fieldName
            };
        }
        this.model.set(fieldName + '_guid', guid);

        // Update filename and mime_type of the model with the value from
        // response, since it may have been modified on the server side
        this.model.set('file_mime_type', data.record.file_mime_type);
        this.model.set(fieldName, data.record[fieldName]);

        callback(null, fields, errors);
    },

    /**
     * Error callback for the {@link #_doValidateFile} function.
     *
     * @param {Object} fields The list of fields to validate.
     * @param {Object} errors The errors object during this validation task.
     * @param {Function} callback The callback function to continue validation.
     * @param {Object} resp Error object returned from the API.
     */
    _doValidateFileError: function(fields, errors, callback, resp) {
        app.alert.dismiss('upload');

        var errors = errors || {},
            fieldName = this.name;
        errors[fieldName] = {};

        switch (resp.error) {
            case 'request_too_large':
                errors[fieldName].tooBig = true;
                break;
            default:
                errors[fieldName].uploadFailed = true;
        }
        this.model.unset(fieldName + '_guid');
        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        // Remove specific validation task from the model.
        this.model.removeValidationTask('file_upload_' + this.cid);
        this._super('_dispose');
    },

    /**
     * Handler for delete file control
     *
     * Calls api to remove attached file from the model and
     * clear value and shows input[type=file] to upload new file
     * @param {Event} e
     */
    deleteFile: function(e) {
        var self = this;

        if (this.model.isNew()) {
            this._unsetFileAttributes();
            if (this.disposed) {
                return;
            }
            this.render();
            return;
        }

        app.alert.show('delete_file_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_FILE_DELETE_CONFIRM', self.module),
            onConfirm: _.bind(function() {
                var data = {
                    module: self.module,
                    id: self.model.id,
                    field: self.name
                };
                this._unsetFileAttributes();
                app.utils.deleteFileFromField(self, data, true);
            }, this)
        });
    },

    _unsetFileAttributes: function() {
        this.model.unset(this.name);
        this.$(this.fieldTag).val('');
        if (this.allowEapm) {
            this.model.unset(this.name + '_remoteName');
            this.model.unset(this.docIdField);
            this.model.unset(this.docUrlField);
        }
    },

    /**
     * @inheritdoc
     */
    setMode: function(name) {
        if (!_.isEmpty(this._errors)) {
            if (this.action === 'edit') {
                this.clearErrorDecoration();
                this.decorateError(this._errors);
                return;
            }
        }

        this._super('setMode', [name]);
    },

    /**
     * @inheritdoc
     *
     * Override field templates for merge-duplicate view.
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');
        if (this.view.name === 'merge-duplicates') {
            this.template = app.template.getField(this.type,
                'merge-duplicates-' + this.tplName,
                this.module, this.tplName
            ) || app.template.empty;
            this.tplName = 'list';
        }
    },

    /**
     * Handler to refresh field state.
     *
     * Called from {@link app.plugins._onFieldDuplicate}.
     */
    onFieldDuplicate: function() {
        if (this.disposed ||
            this.view.name !== 'merge-duplicates' ||
            this.options.viewName !== 'edit'
        ) {
            return;
        }
        this.render();
    },

    _render: function() {
        // This array will contain objects accessible in the view
        this.model = this.model || this.view.model;
        app.view.Field.prototype._render.call(this);
        return this;
    },

    format: function(value) {
        var attachments = [];
        // Not the same behavior either the value is a string or an array of files
        if (_.isArray(value)) {
            // If it's an array, we get the uri for each files in the response
            _.each(value, function(file) {
                var fileObj = {
                    name: file.name,
                    url: this.formatUri(file.uri)
                };
                attachments.push(fileObj);
            }, this);
        } else if (value) {
            // If it's a string, build the uri with the api library
            var urlOpts = {
                    module: this.module,
                    id: this.model.id,
                    field: this.name
                },
                fileObj = this._createFileObj(value, urlOpts);
            attachments.push(fileObj);
        }
        // Cannot be a hard check against "list" since subpanel-list needs this too
        return attachments;
    },

    /**
     * Creates a file object
     * @param {string} value The file name
     * @param {Object} urlOpts URL options
     * @return {Object} The created file object
     * @return {string} return.name The file name
     * @return {string} return.docType The document type
     * @return {string} return.mimeType The file's MIME type
     * @return {string} return.url The file resource url
     * @private
     */
    _createFileObj: function (value, urlOpts) {
        var isImage = this._isImage(this.model.get('file_mime_type')),
            forceDownload = !isImage,
            mimeType = isImage ? 'image' : '',
            docType = this.model.get('doc_type');
        return {
            name: value,
            mimeType: mimeType,
            docType: docType,
            url: app.api.buildFileURL(urlOpts,
                {
                    htmlJsonFormat: false,
                    passOAuthToken: false,
                    cleanCache: true,
                    forceDownload: forceDownload
                })
        };
    },

    /**
     * This is overridden by portal in order to prepend site url
     * @param {String} uri
     * @return {string} formatted uri
     */
    formatUri: function(uri) {
        return uri;
    },

    startDownload: function(e) {
        var uri = this.$(e.currentTarget).data('url');

        app.api.fileDownload(uri, {
            error: function(data) {
                // refresh token if it has expired
                app.error.handleHttpError(data, {});
            }
        }, {iframe: this.$el});
    },

    /**
     * @inheritdoc
     *
     * Because input file uses full local path to file as value,
     * value can contains directory names.
     * Unformat value to have file name only in it.
     */
    unformat: function (value) {
        return value.split('/').pop().split('\\').pop();
    },

    /**
     * Check if input mime type is an image or not.
     *
     * @param {String} mime type.
     * @return {Boolean} true if mime type is an image.
     * @private
     */
    _isImage: function(mimeType) {
        return !!this.supportedImageExtensions[mimeType];
    }
}) },
"username": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.UsernameField
 * @alias SUGAR.App.view.fields.BaseUsernameField
 * @extends View.Fields.Base.BaseField
 */
({
	// Username Field (base) 

    //FIXME: SC-3447 this field should have bidirectional input
    direction: 'ltr'
}) },
"repeat-days": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Repeat Days of Month is a custom field for Meetings/Calls used to set
 * day(s) of the month for a Monthly recurring record.
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.RepeatDaysField
 * @alias SUGAR.App.view.fields.BaseRepeatDaysField
 * @extends View.Fields.Base.Field
 */
({
	// Repeat-days Field (base) 

    /**
     * The Enum field with selected dates
     * @type {View.Fields.Base.EnumField}
     */
    select2Field: undefined,

    /**
     * Array of currently selected dates
     * @type {Array}
     */
    selectedDates: undefined,

    /**
     * The select2/enum field sfid
     * @type {String}
     */
    select2SfId: '',

    /**
     * AppListStrings repeat_days_dom values for the template
     * @type {Array}
     */
    datesDom: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.datesDom = app.lang.getAppListStrings('repeat_days_dom');

        this.model.addValidationTask(
            'repeat_days_validator_' + this.cid,
            _.bind(this._doValidateRepeatDays, this)
        );

        this.selectedDates = this.model.get(this.name) || [];
        if (_.isString(this.selectedDates)) {
            this.selectedDates = this.format(this.selectedDates);
        }
    },

    /**
     * @inheritdoc
     */
    setMode: function(name) {
        this._super('setMode', [name]);
        if (!this.model.isNew() && this.action === 'edit') {
            this.getSelect2Field().setMode(name);
            // if this is a create view we don't need to set the options on the model here
            this._updateSelect2SelectedDates(true, false);
            // update calendar dates with a selected class
            this.decorateCalendarDates();
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:' + this.name, function(model, value) {
                if (this.action === 'edit' || this.action === 'detail') {
                    var dates = this.model.get(this.name);
                    if (dates) {
                        this.selectedDates = dates;
                        if (_.isString(this.selectedDates)) {
                            this.selectedDates = this.format(this.selectedDates);
                            this.render();
                        }
                    }
                }
            }, this);
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this.getSelect2Field().setElement(this.$('div[sfuuid="' + this.select2SfId + '"]'));
        if (_.isEmpty(this.select2Field.items) && this.selectedDates.length) {
            this._updateSelect2SelectedDates(true, false);
        } else {
            this.select2Field.render();
        }

        if (this.action === 'edit' && this.selectedDates.length) {
            this.decorateCalendarDates();
        }

        this._addDateFieldEvents();
    },

    /**
     * Model days format is a string of comma separated numbers (1-31)
     * Select2 needs an array of these values
     *
     * @inheritdoc
     */
    format: function(value) {
        if (!_.isString(value)) {
            return value;
        } else if (value === '') {
            return [];
        } else {
            return _.sortBy(value.split(','), function(num) {
                return parseInt(num);
            });
        }
    },

    /**
     * Select2 array of numeric strings to model comma separated number format
     *
     * @inheritdoc
     */
    unformat: function(value) {
        return _.isArray(value) ? value.join(',') : value;
    },

    /**
     * Adds the click event listeners to the days in the dropdown
     * and adds a change listener to the select2 field
     *
     * @protected
     */
    _addDateFieldEvents: function() {
        this.$('.multi-column-dropdown a[id^="repeat-on-day-"]').on('click', _.bind(this._onDatePicked, this));
        this.select2Field.$el.on('change', _.bind(this._onSelect2Change, this));
        /**
         * Disables dropdown for `Select2`
         */
        this.select2Field.$el.on('select2-opening', _.bind(function(evt) {
            evt.preventDefault();
            this.$('[data-toggle=dropdown]').dropdown('toggle');
        }, this));
    },

    /**
     * Adds the `selected` class to each calendar item in `this.selectedDates`
     */
    decorateCalendarDates: function() {
        if (this.selectedDates.length) {
            _.each(this.selectedDates, function(item) {
                this.$('#repeat-on-day-' + item).addClass('selected');
            }, this);
        }
    },

    /**
     * Handles when a day is picked from the dropdown
     *
     * @param {jQuery.Event} evt The `click` event from the day
     * @protected
     */
    _onDatePicked: function(evt) {
        var $target = $(evt.target),
            isSelected = $target.hasClass('selected'),
            val = $target.text();

        $(evt.target).toggleClass('selected');

        if (isSelected) {
            this.selectedDates = _.without(this.selectedDates, val);
        } else {
            this.selectedDates.push(val);
        }

        this._updateSelect2SelectedDates();
    },

    /**
     * Handles when the select2 field changes from removing an item
     *
     * @param {Select2.Event} evt The Select2 `change` Event
     * @protected
     */
    _onSelect2Change: function(evt) {
        if (evt.removed) {
            this.$('#repeat-on-day-' + evt.removed.id).removeClass('selected');
            this.selectedDates = _.without(this.selectedDates, evt.removed.id);

            if (this.selectedDates.length) {
                this._updateSelect2SelectedDates(false);
            } else {
                this._setSelectedDatesOnModel(null);
                this.select2Field.items = null;
            }
        }
    },

    /**
     * Parses `this.selectedDates` Array into an Object for the select2
     *
     * @param {boolean} [renderField] Optional - True if the select2's _render should be called
     * @param {boolean} [setModelOptions] Optional - True if we should update this.model with the options
     * @protected
     */
    _updateSelect2SelectedDates: function(renderField, setModelOptions) {
        renderField = _.isUndefined(renderField) ? true : renderField;
        setModelOptions = _.isUndefined(setModelOptions) ? true : setModelOptions;

        // sort numerically
        this.selectedDates = _.sortBy(this.selectedDates, function(val) {
            return parseInt(val);
        });

        var items = {};
        _.each(this.selectedDates, function(item) {
            items[item] = item;
        }, this);

        if (setModelOptions) {
            this._setSelectedDatesOnModel(this.selectedDates);
        }
        this.select2Field.items = items;

        if (renderField) {
            this.select2Field.render();
        }
    },

    /**
     * Sets the model with the selected dates in `items`
     *
     * @param {String|Array} items The selected dates to set on the model, converts to String if sent as Array
     * @protected
     */
    _setSelectedDatesOnModel: function(items) {
        if (_.isArray(items)) {
            items = items.toString();
        }

        this.model.set(this.name, items);
    },

    /**
     * If `this.select2Field` has not been created yet, it creates the enum field and returns it,
     * otherwise it just returns the already created field
     *
     * @returns {View.Fields.Base.EnumField}
     */
    getSelect2Field: function() {
        if (this.select2Field) {
            this.select2Field.setMode(this.action);
            return this.select2Field;
        }

        var select2Defs = _.clone(this.def);
        select2Defs.type = 'enum';
        this.select2Field = app.view.createField({
            def: select2Defs,
            model: this.model,
            viewName: 'detail',
            view: this.view
        });
        this.select2SfId = this.select2Field.sfId;
        this.select2Field.setMode(this.action);

        return this.select2Field;
    },

    /**
     * Custom required validator for the `repeat_days` field.
     *
     * This validates `repeat_days` based on the value of `repeat_selector` -
     * if "Each", repeat days must be specified
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateRepeatDays: function(fields, errors, callback) {
        var repeatSelector = this.model.get('repeat_selector'),
            repeatDays = this.model.get(this.name);

        if (repeatSelector === 'Each' && (!_.isString(repeatDays) || repeatDays.length < 1)) {
            errors[this.name] = {'required': true};
        }
        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('repeat_days_validator_' + this.cid);
        this.$('.multi-column-dropdown a[id^="repeat-on-day-"]').off('click');
        // removes 'change' and 'select2-opening' events
        this.select2Field.$el.off();
        this.select2Field.dispose();

        this._super('_dispose');
    }
}) },
"badge": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.BadgeField
 * @alias SUGAR.App.view.fields.BaseBadgeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Badge Field (base) 

    /**
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        if (this.isHidden()) {
            this._super('hide');
        } else {
            this._super('show');
        }

        this.hideLabel();
    },

    /**
     * @override
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }

        this.model.on('change:' + this.name, this.render, this);
    },

    /**
     * Checks if a field is hidden in the UI. Returns false if field is not hidden.
     *
     * @return {boolean}
     */
    isHidden: function() {
        var value = this.model.get(this.name);
        return _.isUndefined(value) ? true : !value;
    },

    /**
     * @inheritdoc
     */
    hide: function() {
        this.toggleCell('hide');
        // calling the super hide method to trigger the right events and
        // set properties correctly on the actual field as well
        this._super('hide');
    },

    /**
     * @inheritdoc
     */
    show: function() {
        this.toggleCell('show');
        // calling the super show method to trigger the right events and
        // set properties correctly on the actual field as well
        this._super('show');
    },

    /**
     * Return parent DOM object of the current badge
     * @return {Object} jQuery object
     */
    getParentElem: function() {
        return this.$el.closest('[data-type="badge"]') || {};
    },

    /**
     * Hide a label of the current badge if it's exist
     */
    hideLabel: function() {
        var cellEl = !_.isEmpty(this.getParentElem()) ?
            this.getParentElem().parent() :
            {};

        if (!_.isEmpty(cellEl) && cellEl.hasClass('record-cell')) {
            cellEl.find('>.field-label').hide();
        }
    },

    /**
     * Hide or show the badge cell. Badge field might be present on a different views which
     * in turn have their own visibilities. This means that depending on the parent's
     * visibility we must use the correct method for hiding/displaying the field.
     * Note: using `toggle` might result in unwanted behaviour.
     *
     * @param {string} toggleMethod The method name to use for changing element visibility.
     */
    toggleCell: function(toggleMethod) {
        var parentElem = this.getParentElem();
        if (!_.isEmpty(parentElem)) {
            parentElem[toggleMethod]();
            parentElem.closest('.record-cell')[toggleMethod]();
        }
    },
}) },
"module-enum": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ModuleEnumField
 * @alias SUGAR.App.view.fields.BaseModuleEnumField
 * @extends View.Fields.Base.BaseEnumField
 */
 ({
	// Module-enum Field (base) 

    extendsFrom: 'BaseEnumField',

    /**
     * Modules which can't be used to create events from
     */
    denyModules: [
        'Home',
        'Calendar',
        'Forecasts',
        'Reports',
        'ops_Backups',
        'Documents',
        'Campaigns',
        'pmse_Inbox',
        'BusinessCenters',
        'DataPrivacy',
        'Emails',
        'OutboundEmail',
        'ProductTemplates',
        'Shifts',
        'Tags',
        'pmse_Business_Rules',
        'pmse_Emails_Templates',
        'pmse_Project',
        'RevenueLineItems',
        'ProspectLists',
        'PurchasedLineItems',
    ],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // filter-rows does not know about this field type, so we have to handle it ourself
        if (options.view.name == 'filter-rows') {
            options.def.isMultiSelect = true;//atm we have $in and $not_in operators, so multi select
            options.def.searchBarThreshold = -1;// a solution in sugar10 to hide the search input
        }
        this._super('initialize', [options]);
    },

    /**
     * @override
     */
    _loadTemplate: function() {
        this.type = 'enum';
        this._super('_loadTemplate');
        this.type = 'module-enum';
    },

    /**
     * Load enum list
     */
    loadEnumOptions: function() {
        this.items = {};

        if (typeof this.options.def.options == 'undefined') {
            this.items = this.getModuleItems();
        } else {
            this.items = this.options.def.options;
        }
    },

    /**
     * Get modules which can be represented as events
     *
     * @return {Object} Dictionary with modules
     */
    getModuleItems: function() {
        var modules = {};
        var moduleList = app.metadata.getModuleNames({
            filter: 'display_tab',
            access: true
        });

        _.each(moduleList, function(module) {
            if (this.denyModules.indexOf(module) == -1 && this.hasStartDate(module)) {
                modules[module] = app.lang.getModuleName(module, {plural: true});
            }
        }, this);

        return modules;
    },

    /**
     * Has Start Date
     *
     * Checks whether module given has date or datetime fields except of deny list
     *
     * @param {string} module
     * @return {boolean}
     */
    hasStartDate: function(module) {
        let moduleMetadata = app.metadata.getModule(module);
        let fieldTypesAllowed = ['date', 'datetime'];

        if (moduleMetadata) {
            let hasStartDate = false;
            let fieldsMetadata = moduleMetadata.fields;

            _.each(fieldsMetadata, function(fieldMetadata) {
                if (typeof fieldMetadata == 'object') {
                    let fieldType = fieldMetadata.dbType || fieldMetadata.dbtype || fieldMetadata.type;
                    let fieldSource = fieldMetadata.source || '';
                    if (
                        fieldTypesAllowed.indexOf(fieldType) >= 0 &&
                        fieldSource != 'non-db' &&
                        this.model.denyFields.indexOf(fieldMetadata.name) == -1
                    ) {
                        hasStartDate = true;
                    }
                };
            }, this);

            if (hasStartDate) {
                return true;
            }
        }

        return false;
    }
}) },
"iframe": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.IframeField
 * @alias SUGAR.App.view.fields.BaseIframeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Iframe Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * The sepcurity policy violation event handler. We keep it as a property
     * so we could remove it when disposing of this component.
     */
    spvEventHandler: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.spvEventHandler = _.bind(this.securityPolicyViolationHandler, this);
        this.helpBlockContext = {
            linkToDocumentation: app.help.getDocumentationUrl('ContentSecurityPolicy')
        };
        document.addEventListener('securitypolicyviolation', this.spvEventHandler);
    },

    /**
     * If the uri ends with a slash, remove it.
     *
     * @param {string} uri An uri address.
     * @return {string} The escaped uri.
     */
    removeLastSlashFromURI: function(uri) {
        if (uri.slice(-1) === '/') {
            return uri.substr(0, uri.length - 1);
        }
        return uri;
    },

    /**
     * In case the current iframe's uri is blocked set the error message to be displayed.
     * It triggers a render to hide the empty iframe and render the message.
     *
     * @param {Event} event The security policy violation handler.
     */
    securityPolicyViolationHandler: function(event) {
        var currentURI = this.removeLastSlashFromURI(this.value);
        var blockedURI = this.removeLastSlashFromURI(event.blockedURI);

        // Create regex that will make sure our csp message only triggers for things directly related to the embedded
        // content, and makes sure that subdirectories will trigger the message
        var re = new RegExp('^(' + blockedURI + ')(\\\.*)*');

        if (re.test(currentURI)) {
            // If securitypolicyviolation event triggers and we have a URI match, render our CSP message
            this.cspMessage = this.getCSPMessage();
            this.render();
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        if (this.tplName === 'disabled') {
            this.$(this.fieldTag).attr('disabled', 'disabled');
        }
    },

    /**
     * It will look up a content security message.
     *
     * @return {string} The content security message.
     */
    getCSPMessage: function() {
        if (app.user.get('type').toLowerCase() === 'admin') {
            return app.lang.get('LBL_CSP_ERROR_MESSAGE_ADMIN', null, this.helpBlockContext);
        } else {
            return app.lang.get('LBL_CSP_ERROR_MESSAGE_USER', null, this.helpBlockContext);
        }
    },

    /**
     * Check if a field has a value.
     * Custom iFrame fields can have a default value defined from Studio, which also counts as a value.
     *
     * @return {boolean} True if the field is empty.
     */
    isFieldEmpty: function() {
        return this._super('isFieldEmpty') && !this.def.default;
    },

    /**
     * @inheritdoc
     */
    unformat: function(value) {
        value = (value !== '' && value != 'http://') ? value.trim() : '';
        return value;
    },

    /**
     * @inheritdoc
     *
     * Formatter for the iframe field. If the iframe field definition is
     * configured with a generated url (`this.def.gen`) by another field, those
     * field values (defined in curly braces) are parsed from the model and set
     * on the value to be returned. Finally, if the value doesn't contain
     * 'http://' or 'https://', it is prepended on the value before being
     * returned.
     *
     * @param {String} value The value set on the iframe field.
     * @return {String} The formatted iframe value.
     */
    format: function(value) {
        if (_.isEmpty(value)) {
            // Name conflict with iframe's default value def and the list view's
            // default column flag
            value = _.isString(this.def['default']) ? this.def['default'] : undefined;
        }

        if (this.def.gen == '1') {
            var regex = /{(.+?)}/,
                result = null;
            do {
                result = regex.exec(value);
                if (result) {
                    value = value.replace(result[0], this.model.get(result[1]));
                }
            } while (result);
        }

        if (_.isString(value) && !value.match(/^(http|https):\/\//)) {
            value = 'http://' + value.trim();
        }
        return value;
    },

    /**
     * @inheritdoc
     */
    dispose: function() {
        this._super('dispose');
        document.removeEventListener('securitypolicyviolation', this.spvEventHandler);
    }
}) },
"add-on-to": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Fields.Base.AddOnToField
 * @alias SUGAR.App.view.fields.BaseAddOnToField
 * @extends View.Fields.Base.RelateField
 */
({
	// Add-on-to Field (base) 

    extendsFrom: 'RelateField',

    /**
     * Gets the names of fields to include from the related record when fetching
     * data. Overridden to ensure that the fields defined in the
     * 'copyFromPurchasedLineItem' property of field vardefs are included in the
     * fetch
     *
     * @return {Array} the array of related field names to include in the search
     *                 query
     */
    getSearchFields: function() {
        var searchFields = this._super('getSearchFields');
        return _.union(searchFields, _.keys(this.def.copyFromPurchasedLineItem || {}));
    },

    /**
     * Formats the filter options for add_on_to_name field.
     *
     * @param {boolean} force `true` to force retrieving the filter options
     *                  whether or not it is available in memory.
     * @return {Object} The filter options.
     */
    getFilterOptions: function(force) {
        if (this.model && !_.isEmpty(this.model.get('account_id'))) {
            return new app.utils.FilterOptions()
                .config({
                    'initial_filter': 'add_on_plis',
                    'initial_filter_label': 'LBL_PLI_ADDONS',
                    'filter_populate': {
                        'account_id': [this.model.get('account_id')]
                    },
                })
                .format();
        } else {
            return this._super('getFilterOptions', [force]);
        }
    },

    /**
     * Overrides the parent updateRelatedFields so that when the "Add On To"
     * field is changed, we can import values from both the related PLI and
     * the related-related Product Template
     *
     * @param {Object} relatedAttributes the attributes of the related record
     */
    updateRelatedFields: function(relatedAttributes) {
        this._super('updateRelatedFields', [relatedAttributes]);
        this._updateAddOnToRelatedFields(relatedAttributes);
    },

    /**
     * Sets values on the model from both the related PLI as well as the
     * related-related Product Template.
     *
     * To specify the field value mappings from the related PLI, you can modify
     * the 'copyFromPurchasedLineItem' property of the field vardefs
     *
     * To specify the field value mappings from the related-related Product Template,
     * you can modify the 'copyFromPurchasedLineItem' property of the field vardefs
     *
     * @param {Object} relatedAttributes the attributes of the related record
     */
    _updateAddOnToRelatedFields: function(relatedAttributes) {
        relatedAttributes = relatedAttributes || {};
        var attrs = {};

        // Copy fields from the related PLI
        if (this.def && this.def.copyFromPurchasedLineItem) {
            _.each(this.def.copyFromPurchasedLineItem, function(fromField, toField) {
                if (relatedAttributes[fromField] !== attrs[toField]) {
                    attrs[toField] = relatedAttributes[fromField];
                }
            }, this);
        }

        // Copy fields from the related-related Product Template
        if (this.def && this.def.copyFromProductTemplate && !_.isEmpty(attrs.product_template_id)) {
            var productTemplateBean = app.data.createBean('ProductTemplates', {id: attrs.product_template_id});
            app.alert.show('fetching_product_template', {
                level: 'process',
                title: app.lang.get('LBL_LOADING'),
                autoClose: false
            });
            productTemplateBean.fetch({
                success: _.bind(function(templateData) {
                    _.each(this.def.copyFromProductTemplate, function(toField, fromField) {
                        var fromValue = templateData.get(fromField);
                        if (fromValue !== this.model.get(toField)) {
                            attrs[toField] = fromValue;
                        }
                    }, this);
                    this.model.set(attrs);
                    this.model.trigger('addon:pli:changed');
                }, this),
                complete: function() {
                    app.alert.dismiss('fetching_product_template');
                }
            });
        } else {
            this.model.set(attrs);
            this.model.trigger('addon:pli:changed');
        }
    },

    /**
     * Extends the parent _loadTemplate to ensure that this field uses the relate
     * field templates
     */
    _loadTemplate: function() {
        this.type = 'relate';
        this._super('_loadTemplate');
        this.type = this.def.type;
    },
}) },
"hint-accounts-search-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.hint-accounts-search-dropdownField
 * @alias SUGAR.App.view.fields.Base.hint-accounts-search-dropdownField
 * @extends View.Fields.Base.BaseField
 */
({
	// Hint-accounts-search-dropdown Field (base) 

    plugins: ['MetadataEventDriven', 'Stage2CssLoader'],

    events: {
        'click': 'showList',
        'keyup': 'handleKeyUpActions',
        'keydown': 'handleKeyDownActions',
    },

    accounts: [],

    listSelector: '.search-dropdown-list',

    activeClass: 'search-dropdown-list__item--active',

    activeSelector: '.search-dropdown-list__item--active',

    activeDarkModeClass: 'search-dropdown-darkmode-list__item--active',

    activeDarkModeSelector: '.search-dropdown-darkmode-list__item--active',

    hintMetricsToken: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var self = this;
        this._super('initialize', [options]);
        this.activeIndex = -1;
        this.throttledSearch = _.debounce(this.search, 200);
        this.keyCodes = {
            TAB: 9,
            ENTER: 13,
            ARROW_LEFT: 37,
            ARROW_UP: 38,
            ARROW_RIGHT: 39,
            ARROW_DOWN: 40
        };
        // This piece of code handles the case when the user clicks outside the dropdown
        // in which case the dropdown should be closed. Also, the initialize function is called only once
        // hence it will be added only once.
        window.document.addEventListener('mousedown', function(event) {
            if (!($(event.target).closest('.search-dropdown-list').length)) {
                $('.search-dropdown-list').hide();
                // we set this to true as we don't want to auto enrich when the user
                // has clicked somewhere outside of the dropdown
                if (self.context) {
                    self.context.get('model').exitDropdownNoEnrich = true;
                }
            }
        }, false);

        if (self.isTokenExpired(app.user.get('dataEnrichmentAccessTokenExpiration'))) {
            self._callStage2API('create', 'stage2/token', {
                success: function(data) {
                    app.user.set({
                        'dataEnrichmentAccessToken': data.accessToken,
                        'dataEnrichmentAccessTokenExpiration': Date.now() + 3600 * 1000
                    });
                },
                error: function(err) { }
            });
        }

        if (!app.user.get('dataEnrichmentUrl')) {
            self._callStage2API('GET', 'stage2/params', {
                success: function(data) {
                }
            });
        }
    },

    /**
     * Populate hint account search dropdown list
     *
     * @param {Array} accounts
     */
    populateList: function(accounts) {
        this.accounts = accounts;
        var list = this.$el.find(this.listSelector);
        if (accounts) {
            $('.search-dropdown-list').css('border-color', '#FFFFFF');
            if (this.isDarkMode) {
                $('.search-dropdown-list').css('border-top-color', '#000000');
            }
        }
        list.html('');
        _.each(accounts, function(account) {
            list.append('<li data-key=\"' + account.name + '\">' +
                '<img rel=\"noopener\" src=' + account.logo + '/>' +
                '<span>' + account.name + '</span>' +
                '<span><a>' + account.domain + '</a></span>'
            );
        });
        if (app.controller.layout.type !== 'record') {
            list.show();
        }
    },

    /**
     * Search the desired term
     *
     * @param {string} searchTerm
     */
    search: function(searchTerm) {
        var self = this;
        var dataEnrichmentAccessTokenExpiration = app.user.get('dataEnrichmentAccessTokenExpiration');
        // It checks if the token is valid and is not expired.
        // If expired, it re-assigns it new token to dataEnrichmentAccessToken.
        if (self.isTokenExpired(dataEnrichmentAccessTokenExpiration)) {
            self._callStage2API('create', 'stage2/token', {
                success: function(data) {
                    app.user.set({
                        'dataEnrichmentAccessToken': data.accessToken,
                        'dataEnrichmentAccessTokenExpiration': Date.now() + 3600 * 1000
                    });
                    app.user.set();
                    self.callToSearchEndpoint(searchTerm, app.user.get('dataEnrichmentAccessToken'));
                },
                error: function(err) {
                    app.logger.error('Cannot create Hint Token: ' + JSON.stringify(err));
                }
            });
        } else {
            self.callToSearchEndpoint(searchTerm, app.user.get('dataEnrichmentAccessToken'));
        }
    },

    /**
     * Call to search endpoint in order to populate the list
     *
     * @param {string} searchTerm
     * @param {string} dataEnrichmentAccessToken
     */
    callToSearchEndpoint: function(searchTerm, dataEnrichmentAccessToken) {
        var self = this;
        self.hintMetricsToken = app.user.get('hintMetricsToken');
        $.ajax({
            type: 'GET',
            url: app.user.get('dataEnrichmentUrl') + '/autocomplete-for-companies',
            data: {
                'search': {
                    'name': searchTerm,
                },
                'metricsToken': self.hintMetricsToken,
            },
            beforeSend: function(xhr) {
                xhr.setRequestHeader('authToken', dataEnrichmentAccessToken);
            },
            success: _.bind(this.populateList, this)
        });
    },

    /**
     * Stage2 data enrichment call
     *
     * @param {string} method
     * @param {string} api
     * @param {Object} options
     */
    _callStage2API: function(method, api, options) {
        app.api.call(method, app.api.buildURL(api), null, {
            success: function(data) {
                if (api === 'stage2/params') {
                    app.user.set('dataEnrichmentUrl', data.enrichmentServiceUrl);
                }
                options && options.success && options.success(data);
            },
            error: function(err) {
                app.logger.error('Failed to get Hint param: ' + JSON.stringify(err));
            }
        });
    },

    /**
     * Select account from the hint list fields
     *
     * @param {Object} event
     */
    selectAccountFromList: function(event) {
        var self = this;
        var list = self.$el.find(this.listSelector);
        var accountsHintFields = [
            'website',
            'description',
            'sic_code',
            'annual_revenue',
            'twitter',
            'hint_account_size',
            'hint_account_location',
            'hint_account_industry',
            'hint_account_founded_year',
            'hint_account_facebook_handle',
            'hint_account_industry_tags',
            'hint_account_naics_code_lbl',
            'hint_account_fiscal_year_end',
        ];

        // It checks if in the create record view other hint fields are populated and
        // then sets the populatedAccountRecord based on it.
        _.each(accountsHintFields, function(field) {
            if (self.model.get(field)) {
                self.model.populatedAccountRecord = true;
            }
        });

        if (list.is(':visible')) {
            list.hide();
            var activeItem;
            if (this.isDarkMode) {
                activeItem = event ? $(event.currentTarget) : self.$el.find(self.activeDarkModeSelector);
            } else {
                activeItem = event ? $(event.currentTarget) : self.$el.find(self.activeSelector);
            }
            var nameFieldValue = activeItem.attr('data-key') || self.model.get('name');
            self.model.set('name', nameFieldValue);
        }
    },

    /**
     * Navigate to accounts list using keyup actions
     *
     * @param {number} dir
     */
    navigateAccountsList: function(dir) {
        var boxItems = this.$el.find('li');
        this.activeIndex = (this.activeIndex + boxItems.length + dir) % boxItems.length;
        if (this.isDarkMode) {
            boxItems.removeClass(this.activeDarkModeClass)
                .eq(this.activeIndex).addClass(this.activeDarkModeClass);
        } else {
            boxItems.removeClass(this.activeClass)
                .eq(this.activeIndex).addClass(this.activeClass);
        }
    },

    /**
     * Handle keyup actions
     *
     * @param {Object} e
     */
    handleKeyUpActions: function(e) {
        switch (e.keyCode) {
            // ArrowLeft.
            case this.keyCodes.ARROW_LEFT:
            // ArrowRight.
            case this.keyCodes.ARROW_RIGHT:
                break;
            // ArrowDown.
            case this.keyCodes.ARROW_DOWN:
                this.navigateAccountsList(1);
                break;
            // ArrowUp.
            case this.keyCodes.ARROW_UP:
                if (this.activeIndex === -1) {
                    this.navigateAccountsList(0);
                } else {
                    this.navigateAccountsList(-1);
                }
                break;
            // Enter.
            case this.keyCodes.ENTER:
                this.context.get('model').exitDropdownNoEnrich = false;
                this.activeIndex = -1;
                this.selectAccountFromList();
                break;
            default:
                this.context.get('model').exitDropdownNoEnrich = false;
                this.accounts = [];
                this.activeIndex = -1;
                this.throttledSearch(e.target.value);
                break;
        }
    },

    /**
     * Handle keydown actions
     *
     * @param {Object} e
     */
    handleKeyDownActions: function(e) {
        // if the user tabs out of the dropdown without selecting a company, we
        // do not want to auto enrich.
        if (e.keyCode === this.keyCodes.TAB) {
            if (this.context) {
                this.context.get('model').exitDropdownNoEnrich = true;
            }
            this.$el.find(this.listSelector).hide();
        }
    },

    /**
     * Show the accounts list
     *
     * @param {Object} event
     */
    showList: function(event) {
        if (this.accounts.length && event.target.value) {
            this.$el.find(this.listSelector).show();
            this.context.get('model').exitDropdownNoEnrich = false;
        }
    },

    /**
     * Bind selected event
     */
    bindSelectEvent: function() {
        $(this.$el).on(
            'click', this.listSelector + ' li',
            _.bind(this.selectAccountFromList, this)
        );
    },

    /**
     * Check the expiration time token
     *
     * @param {number} dataEnrichmentAccessTokenExpiration
     * @return {number}
     */
    isTokenExpired: function(dataEnrichmentAccessTokenExpiration) {
        return (!dataEnrichmentAccessTokenExpiration || dataEnrichmentAccessTokenExpiration < Date.now());
    },

    /**
     * @inheritdoc
     */
    render: function() {
        this._super('render');
        this.isDarkMode = app.utils.isDarkMode();
        if (!this.hasBoundEvent) {
            this.bindSelectEvent();
            this.hasBoundEvent = true;
        }
    }
}) },
"language": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.LanguageField
 * @alias SUGAR.App.view.fields.BaseLanguageField
 * @extends View.Fields.Base.EnumField
 */
({
	// Language Field (base) 

    extendsFrom: 'EnumField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.model.setDefault(this.name, this._getDefaultOption());
    },

    /**
     * Ensure we load enum templates
     *
     * @override
     * @private
     */
    _loadTemplate: function() {
        this.type = 'enum';
        app.view.Field.prototype._loadTemplate.call(this);
        this.type = 'language';
    },

    /**
     * @inheritdoc
     * If no value, set the application default language as default value.
     * If edit mode, set the application default language on the model.
     */
    format: function(value) {
        if (!this.items[value]) {
            value = this._getDefaultOption();
            this.model.set(this.name, value);
        }

        return value;
    },

    /**
     * @override
     *
     * @return {string}  The default language as the default value
     */
    _getDefaultOption: function(optionsKeys) {
        return app.lang.getDefaultLanguage();
    },
}) },
"copy": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.CopyField
 * @alias SUGAR.App.view.fields.BaseCopyField
 * @extends View.Fields.Base.BaseField
 */
({
	// Copy Field (base) 

    'events': {
        'click button': 'copyOnce'
    },

    _initialValues: null,
    _fields: null,
    _inSync: false,

    /**
     * Initializes the copy field component.
     *
     * Initializes the initialValues and fields properties.
     * Enables sync by default.
     *
     * @inheritdoc
     */
    initialize: function(options) {

        this._super('initialize', [options]);
        this._initialValues = {};
        this._fields = {};

        if (_.isUndefined(this.def.sync)) {
            this.def.sync = true;
        }

        this.before('render', function() {
            this.setDisabled(!this.hasAccess());
            return true;
        }, this);
    },

    /**
     * Function called for each click on checkbox (normally acts as toggle
     * function).
     *
     * If the checkbox is checked, copy all the source fields to target ones
     * based on the mapping definition of this field and disable target fields.
     * Otherwise, restore all the values of the modified fields by this copy
     * widget and enable target fields.
     *
     */
    toggle: function() {
        this.sync(this.$fieldTag.is(':checked'));
    },

    sync: function(enable) {

        enable = this.hasAccess() && (_.isUndefined(enable) || enable);

        if (this._inSync === enable) {
            return;
        }
        this._inSync = enable;

        if (!enable) {
            this.syncCopy(false);
            this.restore();
            return;
        }

        _.each(this.def.mapping, function(target, source) {
            this.copy(source, target);
            var field = this.getField(target);
            if (!_.isUndefined(field)) {
                field.setDisabled(true);
            }
        }, this);

        this.syncCopy(true);
    },

    /**
     * Function called for each click on button (normally acts as copy once).
     *
     * If the button is pressed, copy all the source fields to target ones
     * based on the mapping definition of this field.
     *
     * @param {Event} evt
     *   The event (expecting a click event) that triggers the copy once.
     */
    copyOnce: function(evt) {

        _.each(this.def.mapping, function(target, source) {
            this.copy(source, target);
        }, this);
    },

    /**
     * Copies the source field value to the target field.
     *
     * Store the initial value of the target field to be able to restore it
     * after. Copy the source field value to the target field.
     *
     * @param {View.Field} from
     *   The source field to get the value from.
     * @param {View.Field} to
     *   The target field to set the value to.
     */
    copy: function(from, to) {

        if (!this.model.has(from)) {
            return;
        }

        if (_.isUndefined(this._initialValues[to])) {
            this._initialValues[to] = this.model.get(to);
        }

        if (app.acl.hasAccessToModel('edit', this.model, to)) {
            this.model.set(to, this.model.get(from));
        }
    },

    /**
     * Restores all the initial value of the fields that were modified by this
     * copy command.
     */
    restore: function() {

        _.each(this._initialValues, function(value, field) {
            this.model.set(field, value);
        }, this);

        _.each(this.def.mapping, function(target, source) {
            var field = this.getField(target);
            if (!_.isUndefined(field)) {
                field.setDisabled(false);
            }
        }, this);

        this._initialValues = {};
    },

    /**
     * Enables or disables the sync copy only if the field has the `sync`
     * definition to set to TRUE.
     *
     * @param {Boolean} enable
     *   TRUE to keep the mapping fields in sync, FALSE otherwise.
     */
    syncCopy: function(enable) {

        if (!this.def.sync) {
            return;
        }

        if (!enable) {
            this.model.off(null, this.copyChanged, this);
            return;
        }

        var events = _.map(_.keys(this.def.mapping), function(field) {
            return 'change:' + field;
        });
        this.model.on(events.join(' '), this.copyChanged, this);
    },

    /**
     * Callback for the syncCopy binding.
     *
     * @param {Backbone.Model} model
     *   The model that was changed.
     * @param {*} value
     *   The value of the field that was changed.
     */
    copyChanged: function(model, value) {
        _.each(model.changedAttributes(), function(newValue, field) {
            model.set(this.def.mapping[field], model.get(field));
        }, this);
    },

    /**
     * Get the field with the supplied name.
     *
     * Cache the fields locally to be faster on next request of the same field.
     *
     * @param {String} name
     *   The name of the field to search for.
     *
     * @return {View.Field}
     *   The field with the name given.
     */
    getField: function(name) {

        if (_.isUndefined(this._fields[name])) {
            this._fields[name] = _.find(this.view.fields, function(field) {
                return field.name == name;
            });
        }

        return this._fields[name];
    },

    unformat: function(value) {
        // TODO this should change once we save this in the db
        return null;
    },

    /**
     * @inheritdoc
     *
     * @return {Boolean}
     */
    format: function(value) {
        if (_.isNull(value)) {
            // TODO this should change to the value once we get it from the model
            return this._inSync;
        }
        return value;
    },
    /**
     * Binds DOM changes to a model.
     */
    bindDomChange: function() {

        if (!(this.model instanceof Backbone.Model)) return;

        var self = this;
        var el = this.$fieldTag = this.$el.find(this.fieldTag);
        el.on("change", function() {
          self.toggle();
        });
    },
    /**
     * @inheritdoc
     *
     * This will make the fields in sync if it is on by default.
     */
    bindDataChange: function() {

        // TODO this field should be saved on the DB so we don't have this hack
        if (this.model && this.def.sync) {

            var active = !_.isUndefined(this.def['default']) ? this.def['default'] : true;
            if (!active && this.model.isNew()) {
                return;
            }

            var inSync = this.model.isNew() || _.all(this.def.mapping, function(target, source) {
                return this.model.has(source) && this.model.get(source) === this.model.get(target);
            }, this);
            this.sync(inSync);
        }
    },

    /**
     * Determine if ACLs allow for the copy to show
     * ACL check should return true if there is access to read target and edit
     * source for at least to one mapped field
     * @return {Boolean}
     */
    hasAccess: function() {
        return _.some(this.def.mapping || [], function(toField, fromField) {
            return app.acl.hasAccessToModel('read', this.model, fromField) &&
                app.acl.hasAccessToModel('edit', this.model, toField);
        }, this);
    }
}) },
"forecast-pareto-chart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ForecastParetoChartField
 * @alias SUGAR.App.view.fields.BaseForecastParetoChartField
 * @extends View.Fields.Base.BaseField
 */
({
	// Forecast-pareto-chart Field (base) 

    /**
     * The data from the server
     */
    _serverData: undefined,

    /**
     * The open state of the sidepanel
     */
    state: "open",

    /**
     * Visible state of the preview window
     */
    preview_open: false,

    /**
     * Is the dashlet collapsed or not
     */
    collapsed: false,

    /**
     * Throttled Set Server Data call to prevent it from firing multiple times right in a row.
     */
    throttledSetServerData: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.once('render', function() {
            this.renderChart();
        }, this);

        this._super('initialize', [options]);

        // we need this if because Jasmine breaks with out as you can't define a view with a layout in Jasmine Test
        // @see BR-1217
        if (this.view.layout) {
            // we need to listen to the context on the layout for this view for when it collapses
            this.view.layout.on('dashlet:collapse', this.handleDashletCollapse, this);
            this.view.layout.context.on('dashboard:collapse:fire', this.handleDashletCollapse, this);
            // We listen to this event to call the chart resize method
            // because the size of the dashlet can change in the dashboard.
            this.view.layout.context.on('dashlet:draggable:stop', this.handleDashletCollapse, this);
        }

        // Localization parameters for the system
        this.locale = SUGAR.charts.getSystemLocale();
        this.throttledSetServerData = _.throttle(this._setServerData, 1000);
        this.barTooltipTemplate = app.template.getField(this.type, 'bartooltiptemplate', this.module);
        this.lineTooltipTemplate = app.template.getField(this.type, 'linetooltiptemplate', this.module);
        this.quotaTooltipTemplate = app.template.getField(this.type, 'quotatooltiptemplate', this.module);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        app.events.on('preview:open', function() {
            this.preview_open = true;
        }, this);
        app.events.on('preview:close', function() {
            this.preview_open = false;
            this.renderDashletContents();
        }, this);

        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            this.listenTo(defaultLayout, 'sidebar:state:changed', function(state) {
                this.state = state;
                this.renderDashletContents();
            });
        }

        this.model.on('change', function(model) {
            var changed = _.keys(model.changed);
            if (!_.isEmpty(_.intersection(['user_id', 'display_manager', 'timeperiod_id'], changed))) {
                this.renderChart();
            }
        }, this);

        this.model.on('change:group_by change:dataset change:ranges', this.renderDashletContents, this);
    },

    /**
     * Utility method to check is the dashlet is visible
     *
     * @return {boolean}
     */
    isDashletVisible: function() {
        return (!this.disposed && this.state === 'open' &&
                !this.preview_open && !this.collapsed && !_.isUndefined(this._serverData));
    },

    /**
     * Utility method to resize dashlet with check for visibility
     *
     * @return {boolean}
     */
    resize: function() {
        if (this.isDashletVisible() && this.paretoChart && _.isFunction(this.paretoChart.update)) {
            this.paretoChart.update();
        }
    },

    /**
     * Utility method to render the chart if the dashlet is visible
     *
     * @return {boolean}
     */
    renderDashletContents: function() {
        if (this.isDashletVisible()) {
            this.convertDataToChartData();
            this.generateD3Chart();

            return true;
        }

        return false;
    },

    /**
     * Utility method since there are two event listeners
     *
     * @param {Boolean} collapsed       Is this dashlet collapsed or not
     */
    handleDashletCollapse: function(collapsed) {
        this.collapsed = collapsed;

        this.renderDashletContents();
    },

    /**
     * Attach and detach a resize method to the print event
     * @param {string} The state of print handling.
     */
    handlePrinting: function(state) {
        var self = this,
            mediaQueryList = window.matchMedia && window.matchMedia('print'),
            pausecomp = function(millis) {
                // www.sean.co.uk
                var date = new Date(),
                    curDate = null;
                do {
                    curDate = new Date();
                } while (curDate - date < millis);
            },
            printResize = function(mql) {
                if (mql.matches) {
                    self.paretoChart.width(640).height(320).update();
                    // Pause for a second to let chart finish rendering
                    pausecomp(200);
                } else {
                    browserResize();
                }
            },
            browserResize = function() {
                self.paretoChart.width(null).height(null).update();
            };

        if (state === 'on') {
            if (window.matchMedia) {
                mediaQueryList.addListener(printResize);
            } else if (window.attachEvent) {
                window.attachEvent('onbeforeprint', printResize);
                window.attachEvent('onafterprint', printResize);
            } else {
                window.onbeforeprint = printResize;
                window.onafterprint = browserResize;
            }
        } else {
            if (window.matchMedia) {
                mediaQueryList.removeListener(printResize);
            } else if (window.detachEvent) {
                window.detachEvent('onbeforeprint', printResize);
                window.detachEvent('onafterprint', printResize);
            } else {
                window.onbeforeprint = null;
                window.onafterprint = null;
            }
        }
    },

    /**
     * @inheritdoc
     * Clean up!
     */
    unbindData: function() {
        // we need this if because Jasmine breaks with out as you can't define a view with a layout in Jasmine Test
        // @see BR-1217
        if (this.view.layout) {
            this.view.layout.off('dashlet:collapse', null, this);
            this.view.layout.context.off('dashboard:collapse:fire', null, this);
            this.view.layout.context.off('dashlet:draggable:stop', null, this);
        }
        app.events.off(null, null, this);
        this._super('unbindData');
    },

    /**
     * Render the chart for the first time
     *
     * @param {Object} [options]        Options from the dashlet loaddata call
     */
    renderChart: function(options) {
        if (this.disposed || !this.triggerBefore('chart:pareto:render') ||
            _.isUndefined(this.model.get('timeperiod_id')) ||
            _.isUndefined(this.model.get('user_id'))
        ) {
            return;
        }

        this._serverData = undefined;

        this.chartId = this.cid + '_chart';
        this.paretoChart = sucrose.charts.paretoChart()
            .margin({top: 0, right: 10, bottom: 0, left: 10})
            .showTitle(false)
            .tooltips(true)
            .direction(app.lang.direction)
            .tooltipQuota(_.bind(function(key, x, y, e, graph) {
                // Format the value using currency class and user settings
                var point = {};
                point.key = e.key;
                point.y = app.currency.formatAmountLocale(y, app.currency.getBaseCurrencyId());
                return this.quotaTooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
            }, this))
            .tooltipLine(_.bind(function(key, x, y, e, graph) {
                // Format the value using currency class and user settings
                var point = {};
                point.key = key;
                point.y = app.currency.formatAmountLocale(y, app.currency.getBaseCurrencyId());
                return this.lineTooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
            }, this))
            .tooltipBar(_.bind(function(key, x, y, e, graph) {
                // Format the value using currency class and user settings
                var point = {};
                point.lbl = this.model.get('group_by') === 'probability' ?
                    (app.lang.get('LBL_OW_PROBABILITY', 'Forecasts') + ' (%)') :
                    app.lang.get('LBL_SALES_STAGE', 'Forecasts');
                point.key = key;
                point.y = app.currency.formatAmountLocale(y, app.currency.getBaseCurrencyId());
                //TODO: check all percent precision
                //TODO: should % be in template?
                point.x = sucrose.utility.numberFormat(x, 1, false, this.locality) + '%';
                return this.barTooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
            }, this))
            .colorData('default')
            .colorFill('default')
            .yValueFormat(function(d) {
                //TODO: is this correct?
                var f = d3sugar.formatPrefix(',.0', 1000);
                return app.currency.getCurrencySymbol(app.currency.getBaseCurrencyId()) + f(d);
            })
            .quotaValueFormat(function(d) {
                //TODO: is this correct?
                var f = d3sugar.formatPrefix(',.2', 1000);
                return app.currency.getCurrencySymbol(app.currency.getBaseCurrencyId()) + f(d);
            })
            //TODO: only do barClick if dashlet in Forecasts intelligence pane
            .seriesClick(function(data, eo, chart, container) {
                var d = eo.series,
                    selectedSeries = eo.seriesIndex;

                d.disabled = !d.disabled;

                chart.dispatch.call('tooltipHide', this);

                if (!chart.stacked()) {
                    data.filter(function(d) {
                        return d.series === selectedSeries && d.type === 'line';
                    }).map(function(d) {
                        d.disabled = !d.disabled;
                        return d;
                    });
                }

                // if there are no enabled data series, enable them all
                if (!data.filter(function(d) {
                    return !d.disabled && d.type === 'bar';
                }).length) {
                    data.map(function(d) {
                        d.disabled = false;
                        container.selectAll('.sc-series').classed('disabled', false);
                        return d;
                    });
                }

                container.call(chart);
            })
            .id(this.chartId)
            .strings({
                barLegend: {
                    close: app.lang.get('LBL_CHART_BAR_LEGEND_CLOSE', 'Forecasts'),
                    open: app.lang.get('LBL_CHART_BAR_LEGEND_OPEN', 'Forecasts')
                },
                lineLegend: {
                    close: app.lang.get('LBL_CHART_LINE_LEGEND_CLOSE', 'Forecasts'),
                    open: app.lang.get('LBL_CHART_LINE_LEGEND_OPEN', 'Forecasts')
                },
                noData: app.lang.get('LBL_CHART_NO_DATA'),
                noLabel: app.lang.get('LBL_CHART_NO_LABEL')
            })
            .locality(this.locale);

        this.locality = this.paretoChart.locality();

        this.paretoChart.displayNoData = _.bind(function(state) {
            this.$('[data-content="chart"]').toggleClass('hide', state);
            this.$('[data-content="nodata"]').toggleClass('hide', !state);
        }, this);

        // just on the off chance that no options param is passed in
        options = options || {};
        options.success = _.bind(function(data) {
            if(this.model) {
                this.model.set({
                    title: data.title
                });
                this._serverData = data;
                if (data.error) {
                    app.alert.show('chart_error', {
                        level: 'error',
                        messages: data.error
                    });

                    if (!_.isEmpty(this.paretoChart)) {
                        this.paretoChart.displayNoData(true);
                    }

                    this.trigger('chart:pareto:rendered');
                } else {
                    if (!_.isEmpty(this.paretoChart)) {
                        this.paretoChart.displayNoData(false);
                    }

                    this.convertDataToChartData();
                    this.generateD3Chart();
                }
            }
        }, this);

        var read_options = {};
        if (this.model.has('no_data') && this.model.get('no_data') === true) {
            read_options['no_data'] = 1;
        }

        // if this is a manager view, send the target_quota param to the endpoint
        if(this.model.get('display_manager')) {
            read_options['target_quota'] = (this.model.get('show_target_quota')) ? 1 : 0;
        }

        var url = app.api.buildURL(this.buildChartUrl(), null, null, read_options);

        app.api.call('read', url, {}, options);
    },

    /**
     * Generate the D3 Chart Object
     */
    generateD3Chart: function() {
        var params = this.model.toJSON();

        // clear out the current chart before a re-render
        if (!_.isEmpty(this.paretoChart)) {
            $(window).off('resize.' + this.sfId);
            d3sugar.select('#' + this.chartId + ' svg').remove();
        }

        this.paretoChart.stacked(!params.display_manager);

        if (this.d3Data.data.length > 0) {
            // if the chart element is hidden by a previous render, but has data now, show it
            this.$('.sc-chart').toggleClass('hide', false);
            this.$('.block-footer').toggleClass('hide', true);

            // After the .call(paretoChart) line, we are selecting the text elements for the Y-Axis
            // only so we can custom format the Y-Axis values
            d3sugar.select('#' + this.chartId)
                .append('svg')
                .datum(this.d3Data)
                .call(this.paretoChart);

            $(window).on('resize.' + this.sfId, _.debounce(_.bind(this.resize, this), 100));
            this.handlePrinting('on');

            this.$('.sc-chart').on('click', _.bind(function(e) {
                this.paretoChart.dispatch.call('chartClick', this);
            }, this));
        } else {
            this.$('.sc-chart').toggleClass('hide', true);
            this.$('.block-footer').toggleClass('hide', false);
        }

        this.trigger('chart:pareto:rendered');
    },

    /**
     * Utility method to determine which data we need to parse,
     */
    convertDataToChartData: function() {
        if(this.state == 'closed' || this.preview_open || this.collapsed || _.isUndefined(this._serverData)) {
            return -1;
        }

        if (this.model.get('display_manager')) {
            this.convertManagerDataToChartData();
        } else {
            this.convertRepDataToChartData(this.model.get('group_by'));
        }
    },

    /**
     * Parse the Manager Data and set the d3Data object
     */
    convertManagerDataToChartData: function() {
        var dataset = this.model.get('dataset'),
            records = this._serverData.data,
            chartData = {
                'properties': {
                    'name': this._serverData.title,
                    'quota': parseFloat(this._serverData.quota),
                    'yDataType': 'currency',
                    'xDataType': 'string',
                    'quotaLabel': app.lang.get((this.model.get('show_target_quota')) ? 'LBL_QUOTA_ADJUSTED' : 'LBL_QUOTA', 'Forecasts'),
                    'groupData': records.map(function(record, i) {
                        return {
                            group: i,
                            l: record.name,
                            t: parseFloat(record[dataset]) + parseFloat(record[dataset + '_adjusted'])
                        };
                    })
                },
                'data': []
            },
            disabledKeys = this.getDisabledChartKeys(),
            barData = [dataset, dataset + '_adjusted'].map(function(ds, seriesIdx) {
                var vals = records.map(function(rec, recIdx) {
                        return {
                            series: seriesIdx,
                            x: recIdx + 1,
                            y: parseFloat(rec[ds]),
                            y0: 0
                        };
                    }),
                    label = this._serverData.labels['dataset'][ds];

                return {
                    disabled: (_.contains(disabledKeys, label)),
                    key: label,
                    series: seriesIdx,
                    type: 'bar',
                    values: vals,
                    valuesOrig: vals
                };
            }, this),
            lineData = [dataset, dataset + '_adjusted'].map(function(ds, seriesIdx) {
                var vals = records.map(function(rec, recIdx) {
                        return {
                            series: seriesIdx,
                            x: recIdx + 1,
                            y: parseFloat(rec[ds])
                        };
                    }),
                    addToLine = 0,
                    label = this._serverData.labels['dataset'][ds];

                _.each(vals, function(val, i, list) {
                    list[i].y += addToLine;
                    addToLine = list[i].y;
                });

                return {
                    disabled: (_.contains(disabledKeys, label)),
                    key: label,
                    series: seriesIdx,
                    type: 'line',
                    values: vals,
                    valuesOrig: vals
                };
            }, this);

        if(this.model.get('show_target_quota')) {
            // add target quota to chart data
            chartData.properties.targetQuota = +this._serverData.target_quota;
            chartData.properties.targetQuotaLabel = app.lang.get('LBL_QUOTA', 'Forecasts');
        }

        chartData.data = barData.concat(lineData);
        this.d3Data = chartData;
    },

    /**
     * Convert the Rep Data and set the d3Data Object
     *
     * @param {string} type     What we are dispaying
     */
    convertRepDataToChartData: function(type) {
        // clear any NaNs
        _.each(this._serverData.data, function(point) {
            if (_.has(point, 'likely') && isNaN(point.likely)) {
                point.likely = 0;
            }
            if (_.has(point, 'best') && isNaN(point.best)) {
                point.best = 0;
            }
            if (_.has(point, 'worst') && isNaN(point.worst)) {
                point.worst = 0;
            }
        });

        var dataset = this.model.get('dataset'),
            ranges = this.model.get('ranges'),
            seriesIdx = 0,
            barData = [],
            lineVals = this._serverData['x-axis'].map(function(axis, i) {
                return { series: seriesIdx, x: i + 1, y: 0 };
            }),
            line = {
                'key': this._serverData.labels.dataset[dataset],
                'type': 'line',
                'series': seriesIdx,
                'values': [],
                'valuesOrig': []
            },
            chartData = {
                'properties': {
                    'name': this._serverData.title,
                    'quota': parseFloat(this._serverData.quota),
                    'yDataType': 'currency',
                    'xDataType': 'datetime',
                    'quotaLabel': app.lang.get('LBL_QUOTA', 'Forecasts'),
                    'groupData': this._serverData['x-axis'].map(function(item, i) {
                        return {
                            'group': i,
                            'l': item.label,
                            't': 0
                        };
                    })
                },
                'data': []
            },
            records = this._serverData.data,
            data = (!_.isEmpty(ranges)) ? records.filter(function(rec) {
                return _.contains(ranges, rec.forecast);
            }) : records,
            disabledKeys = this.getDisabledChartKeys();

        _.each(this._serverData.labels[type], function(label, value) {
            var td = data.filter(function(d) {
                return (d[type] == value);
            });

            if (!_.isEmpty(td)) {
                var barVal = this._serverData['x-axis'].map(function(axis, i) {
                        return { series: seriesIdx, x: i + 1, y: 0, y0: 0 };
                    }),
                    axis = this._serverData['x-axis'];

                // loop though all the data and map it to the correct x series
                _.each(td, function(record) {
                    for (var y = 0; y < axis.length; y++) {
                        if (record.date_closed_timestamp >= axis[y].start_timestamp &&
                            record.date_closed_timestamp <= axis[y].end_timestamp) {
                            // add the value
                            var val = parseFloat(record[dataset]);
                            barVal[y].y += val;
                            chartData.properties.groupData[y].t += val;
                            lineVals[y].y += val;
                            break;
                        }
                    }
                }, this);

                barData.push({
                    disabled: (_.contains(disabledKeys, label)),
                    key: label,
                    series: seriesIdx,
                    type: 'bar',
                    values: barVal,
                    valuesOrig: app.utils.deepCopy(barVal)
                });

                // increase the series
                seriesIdx++;
            }
        }, this);

        if (!_.isEmpty(barData)) {
            // fix the line
            var addToLine = 0;
            _.each(lineVals, function(val, i, list) {
                list[i].y += addToLine;
                addToLine = list[i].y;
            });

            line.values = lineVals;
            line.valuesOrig = app.utils.deepCopy(lineVals);

            barData.push(line);
            chartData.data = barData;
        }

        this.d3Data = chartData;
    },

    /**
     * Look at the current chart if it exists and return the keys that are currently
     * disabled they can still be disabled when the chart is re-rendered
     *
     * @return {Array}
     */
    getDisabledChartKeys: function() {
        var currentChartData = d3sugar.select('#' + this.chartId + ' svg').data();
        var disabledBars = (!_.isUndefined(currentChartData[0])) ?
                _.filter(currentChartData[0].data, function(d) {
                    return (!_.isUndefined(d.disabled) && d.disabled === true);
                }) : [];

        return (!_.isEmpty(disabledBars)) ? _.map(disabledBars, function(d) {
            return d.key;
        }) : [];
    },

    /**
     * Accepts params object and builds the proper endpoint url for charts
     *
     * @return {String} has the proper structure for the chart url.
     */
    buildChartUrl: function() {
        var baseUrl = this.model.get('display_manager') ? 'ForecastManagerWorksheets' : 'ForecastWorksheets';
        return baseUrl + '/chart/' + this.model.get('timeperiod_id') + '/' + this.model.get('user_id');
    },

    /**
     * Do we have serverData yet?
     * @return {boolean}
     */
    hasServerData: function() {
        return !_.isUndefined(this._serverData);
    },

    /**
     * Return the data that was passed back from the server
     * @return {Object}
     */
    getServerData: function() {
        return this._serverData;
    },

    /**
     *
     * @param {Object} data
     * @param {Boolean} [adjustLabels]
     */
    setServerData: function(data, adjustLabels) {
        this.throttledSetServerData(data, adjustLabels);
    },

    /**
     * This method is called by the _.throttle call in initialize
     *
     * @param {Object} data
     * @param {Boolean} [adjustLabels]
     * @private
     */
    _setServerData: function(data, adjustLabels) {
        this._serverData = data;

        if (adjustLabels === true) {
            this.adjustProbabilityLabels();
        }
        this.renderDashletContents();
    },

    /**
     * When the Probability Changes on the Rep Worksheet, The labels in the chart data need to be updated
     * to Account for the potentially new label.
     */
    adjustProbabilityLabels: function() {
        var probabilities = _.unique(_.map(this._serverData.data, function(item) {
            return item.probability;
        })).sort();

        this._serverData.labels.probability = _.object(probabilities, probabilities);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.handlePrinting('off');
        $(window).off('resize.' + this.sfId);
        this.$('.sc-chart').off('click');
        this._super('_dispose');
    }

}) },
"pdfaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.PdfactionField
 * @alias SUGAR.App.view.fields.BasePdfactionField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Pdfaction Field (base) 

    extendsFrom: 'RowactionField',
    events: {
        'click [data-action=link]': 'linkClicked',
        'click [data-action=download]': 'downloadClicked',
        'click [data-action=email]': 'emailClicked'
    },

    /**
     * PDF Template collection.
     *
     * @type {Data.BeanCollection}
     */
    templateCollection: null,

    /**
     * Visibility property for available template links.
     *
     * @property {Boolean}
     */
    fetchCalled: false,

    /**
     * @inheritdoc
     * Create PDF Template collection in order to get available template list.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.templateCollection = app.data.createBeanCollection('PdfManager');
        this._fetchTemplate();
    },

    /**
     * @inheritdoc
     *
     * Prevents the "Email PDF" button from rendering if the user
     * doesn't have a valid email configuration or the user chooses to use an
     * external email client. RFC 2368 suggests only the "subject" and "body"
     * headers are safe headers and that other, unsafe headers do not need to
     * be supported by the "mailto" implementation. We cannot guarantee that
     * the "mailto" implementation for the user will allow for adding a PDF
     * attachment. To be consistent with existing application behavior, the
     * "Email PDF" option should be hidden for users when they cannot use the
     * internal email client.
     *
     * @private
     */
    _render: function() {
        var emailClientPreference = app.user.getPreference('email_client_preference');
        if (!this.templateCollection.length > 0 ||
            (this.def.action === 'email' && emailClientPreference.type !== 'sugar')) {
            this.hide();
        } else {
            this._super('_render');
        }
    },

    /**
     * Define proper filter for PDF template list.
     * Fetch the collection to get available template list.
     * @private
     */
    _fetchTemplate: function() {
        this.fetchCalled = true;
        var collection = this.templateCollection;
        collection.filterDef = {'$and': [{
            'base_module': this.module
        }, {
            'published': 'yes'
        }]};
        collection.fetch();
    },

    /**
     * Build email pdf link url.
     *
     * @param {String} templateId PDF Template id.
     * @return {string} Email pdf url.
     * @private
     */
    _buildEmailLink: function(templateId) {
        return '#' + app.bwc.buildRoute(this.module, null, 'sugarpdf', {
            'sugarpdf': 'pdfmanager',
            'record': this.model.id,
            'pdf_template_id': templateId,
            'to_email': '1'
        });
    },

    /**
     * Handle the button click event.
     * Stop event propagation in order to keep the dropdown box.
     *
     * @param {Event} evt Mouse event.
     */
    linkClicked: function(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        if (this.templateCollection.dataFetched) {
            this.fetchCalled = !this.fetchCalled;
        } else {
            this._fetchTemplate();
        }
        this.render();
    },

    /**
     * Handles email pdf link.
     *
     * @param {Event} evt Mouse event.
     */
    emailClicked: function(evt) {
        var templateId = this.$(evt.currentTarget).data('id');
        app.router.navigate(this._buildEmailLink(templateId), {
            trigger: true
        });
    },

    /**
     * Build download link url.
     *
     * @param string templateId PDF Template id.
     * @return string Link url.
     * @private
     */
    _buildDownloadLink: function(templateId) {
        var urlParams = $.param({
            'action': 'sugarpdf',
            'module': this.module,
            'sugarpdf': 'pdfmanager',
            'record': this.model.id,
            'pdf_template_id': templateId
        });
        return '?' + urlParams;
    },

    /**
     * Handles download pdf link.
     *
     * Authenticate in bwc mode before triggering the download.
     *
     * @param {Event} evt The `click` event.
     */
    downloadClicked: function(evt) {
        var $target = this.$(evt.currentTarget);
        var templateId = $target.data('id');

        app.alert.show('generating_pdf', {
            level: 'process',
            title: app.lang.get('LBL_GENERATING_PDF')
        });

        app.bwc.login(null, _.bind(function() {
            this._triggerDownload(this._buildDownloadLink(templateId));
        }, this));
    },

    /**
     * Download the file once authenticated in bwc mode.
     *
     * @param string url The file download url.
     * @protected
     */
    _triggerDownload: function(url) {
        app.api.fileDownload(url, {
            success: function() {
                app.alert.dismiss('generating_pdf');
            },
            error: function(data) {
                // refresh token if it has expired
                app.alert.dismiss('generating_pdf');
                app.error.handleHttpError(data, {});
            }
        }, {iframe: this.$el});
    },

    /**
     * @inheritdoc
     * Bind listener for template collection.
     */
    bindDataChange: function() {
        this.templateCollection.on('reset', this.render, this);
        this._super('bindDataChange');
    },

    /**
     * @inheritdoc
     * Dispose safe for templateCollection listeners.
     */
    unbindData: function() {
        this.templateCollection.off(null, null, this);
        this.templateCollection = null;
        this._super('unbindData');
    },

    /**
     * @inheritdoc
     * Check additional access for PdfManager Module.
     */
    hasAccess: function() {
        var pdfAccess = app.acl.hasAccess('view', 'PdfManager');
        return pdfAccess && this._super('hasAccess');
    }
}) },
"unlinkcab": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.UnlinkcabField
 * @alias SUGAR.App.view.fields.BaseUnlinkcabField
 * @extends View.Fields.Base.CabField
 */
({
	// Unlinkcab Field (base) 

    extendsFrom: 'CabField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'cab';
    },

    /**
     * Handle the click event on "Unlink" dropdown menu item
     *
     * @param {Event}
     */
    handleClick: function() {
        var unlinkMessages = this.getUnlinkMessages(this.model);

        app.alert.show('unlink_confirmation', {
            level: 'confirmation',
            messages: unlinkMessages.confirmation,
            onConfirm: _.bind(this.destroyModel, this, this.model, unlinkMessages.success)
        });
    },

    /**
     * Destroy the selected model
     */
    destroyModel: function(model, unlinkMessagesSuccess) {
        model.destroy({
            showAlerts: {
                'process': true,
                'success': {
                    messages: unlinkMessagesSuccess
                }
            },
            relate: true,
            success: _.bind(this.reloadData, this)
        });
    },

    /**
     * Format the messages to display in the alerts when unlinking a record.
     *
     * @param {Data.Bean} model The model concerned.
     * @return {Object} The list of messages.
     * @return {string} return.confirmation Confirmation message.
     * @return {string} return.success Success message.
     */
    getUnlinkMessages: function(model) {
        var module = model.get('_module') || '';
        var moduleName = app.lang.getModuleName(module) || '';
        var msgContext = [moduleName.toLowerCase(), model.get('name')].join(' ');
        var messages = {
            confirmation: app.utils.formatString(app.lang.get('NTC_UNLINK_CONFIRMATION_FORMATTED'), [msgContext]),
            success: app.utils.formatString(app.lang.get('NTC_UNLINK_SUCCESS'), [msgContext])
        };

        return messages;
    },

    /**
     * Reload data after unlink
     */
    reloadData: function() {
        if (_.isFunction(this.view.reloadData)) {
            this.view.reloadData();
        }
    }
}) },
"bool": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.BoolField
 * @alias SUGAR.App.view.fields.BaseBoolField
 * @extends View.Fields.Base.BaseField
 */
({
	// Bool Field (base) 

    /**
     * HTML tag of the select2 field.
     *
     * @property {String}
     */
    select2fieldTag: 'select',

    /**
     * @inheritdoc
     */
    shouldInitDefaultValue: true,

    /**
     * @inheritdoc
     *
     * Renders both checkbox and dropdown
     */
    _render: function() {
        this._super('_render');
        this.$(this.select2fieldTag).select2({'minimumResultsForSearch': -1});
    },

    /**
     * @inheritdoc
     */
    _getFallbackTemplate: function(viewName) {
        if (viewName === 'massupdate') {
            return 'dropdown';
        }
        return this._super('_getFallbackTemplate', [viewName]);
    },

    /**
     * Bool field always has a value whether checked or not
     *
     * @override
     */
    isFieldEmpty: function() {
        return false;
    },

    /**
     * @inheritdoc
     */
    bindDomChange: function() {
        var $el = this.$(this.select2fieldTag);
        if (!$el.length) {
            $el = this.$(this.fieldTag);
        }
        $el.on('change', _.bind(function() {
            var value = $el.is(this.select2fieldTag) ? $el.val() : $el.prop('checked');
            this.model.set(this.name, this.unformat(value));
        }, this));
    },

    /**
     * @inheritdoc
     *
     * Bypass `render` when action is `massupdate` or `edit`.
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }

        this.model.on('change:' + this.name, function(model, value) {
            if (this.action === 'massupdate') {
                this.$(this.select2fieldTag).val(this.format(value) ? '1' : '0');
            } else if (this.action === 'edit') {
                this.$(this.fieldTag).prop('checked', this.format(value));
            } else {
                this.render();
            }
        }, this);
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        this.$(this.select2fieldTag).off();
        this._super('unbindDom');
    },

    /**
     * @inheritdoc
     *
     * @param {String/Boolean} value The value to unformat.
     * @return {Boolean} Unformatted value.
     */
    unformat: function(value) {
        if (_.isString(value)) {
            value = value == '1';
        }
        return value;
    },

    /**
     * @inheritdoc
     *
     * @param {String/Boolean} value The value to format.
     * @return {Boolean} formatted value.
     */
    format: function(value) {
        if (_.isString(value)) {
            value = value == '1';
        }
        return value;
    }
}) },
"datetimecombo-colorcoded": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * DatetimecomboColorcodedField is a field for Meetings/Calls/Tasks that sets a background color for the field based on the value of the status field
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.DatetimecomboColorcodedField
 * @alias SUGAR.App.view.fields.BaseDatetimecomboColorcodedField
 * @extends View.Fields.Base.DatetimecomboField
 */
({
	// Datetimecombo-colorcoded Field (base) 

    extendsFrom: 'DatetimecomboField',

    colorCodeClasses: {
        overdue: 'label label-important',
        upcoming: 'label label-info'
    },

    /**
     * @inheritdoc
     *
     * Checks color code conditions to determine if field should have
     * color applied to it.
     */
    _render: function() {
        this.type = 'datetimecombo'; //use datetimecombo templates
        this._super('_render');
        this.setColorCoding();
    },

    /**
    * @inheritdoc
    *
    * Listen for status change - set color coding appropriately
    */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.model.on('change:status', this.setColorCoding, this);
    },

    /**
    * Set color coding based on completion status and date compared to today
    * This is only applied when the action is list (not inline edit on list view)
    */
    setColorCoding: function() {
        var colorCodeClass;

        this._clearColorCode();

        if (!this.model || this.action !== 'list') {
            return;
        }
        colorCodeClass = this._isCompletedStatus() ? null : this._getColorCodeClass();
        this._setColorCodeClass(colorCodeClass);
    },

    /**
    * Check if status is completed based on status value defined in the view def
    *
    * @return {Boolean}
    * @private
    */
    _isCompletedStatus: function() {
        if (_.isUndefined(this.def.completed_status_value)) {
            return false;
        }
        return (this.model.get('status') === this.def.completed_status_value);
    },

    /**
    * Get color code class based on the date compared to today
    * If event is today - use 'today' color code
    * If event is yesterday or earlier - use 'overdue' color code
    *
    * @return {String|null} One of the color codes or null if no color code
    * @private
    */
    _getColorCodeClass: function() {
        var eventDate,
            today,
            nextDay;

        if (_.isEmpty(this.model.get(this.name))) {
            return null;
        }

        eventDate = app.date(this.model.get(this.name));
        today = app.date();
        nextDay = app.date().add(1, 'days');

        if (eventDate.isBefore(today)) {
            return this.colorCodeClasses.overdue;
        } else if (eventDate.isBefore(nextDay)) {
            return this.colorCodeClasses.upcoming;
        } else {
            return null;
        }
    },

    /**
    * Set the color code class to the field tag or clear out if no
    * color code should be applied (colorCodeClass is null)
    *
    * @param {String|null} colorCodeClass
    * @private
    */
    _setColorCodeClass: function(colorCodeClass) {
        if (!_.isNull(colorCodeClass)) {
            this.$el.addClass(colorCodeClass);
        }
    },

    /**
     * Clear color coding classes
     *
     * @private
     */
    _clearColorCode: function() {
        _.each(this.colorCodeClasses, function(colorCodeClass) {
            this.$el.removeClass(colorCodeClass);
        }, this);
    }
}) },
"overdue-badge": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * EventStatusField is a field for Meetings/Calls that shows a date field as a badge when event is overdue
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.OverdueBadgeField
 * @alias SUGAR.App.view.fields.BaseOverdueBadgeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Overdue-badge Field (base) 

    _render: function() {
        var now = new Date(),
            due_date = this.model.get(this.name),
            date = new Date(due_date);
        this.model.set('overdue', !_.isNull(due_date) && date < now);
        this._super('_render');
    }
}) },
"piiname": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.PiinameField
 * @alias SUGAR.App.view.fields.BasePiinameField
 * @extends View.Fields.Base.BaseField
 */
({
	// Piiname Field (base) 

    /**
     * @inheritdoc
     *
     * Convert the raw field type name into the label of the field
     * of the Pii module or Pii parent module; if not available,
     * use raw value.
     */
    format: function(value) {
        var module;
        var field;

        if (!this.context) {
            return value;
        }

        if (this.context.has('piiModule')) {
            module = this.context.get('piiModule');
            field = app.metadata.getField({module: module, name: value});
        } else if (this.context.parent) {
            var model = this.context.parent.get('model');
            module = model.module;
            field = model.fields[value];
        }

        if (field) {
            value = app.lang.get(field.label || field.vname, module);
        }

        return value;
    }
}) },
"email-text": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EmailTextField
 * @alias SUGAR.App.view.fields.BaseEmailTextField
 * @extends View.Fields.Base.BaseField
 */
({
	// Email-text Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    // The purpose of email-text is to provide a simpler textfield email
    // when our main email widget is overkill. For example, the first time
    // login wizard uses email-text. Note that the email mutated is the
    // primary_address email.
    initialize: function(options) {
        options     = options || {};
        options.def = options.def || {};
        if (_.isUndefined(options.def.link)) {
            options.def.link = true;
        }

        this._super('initialize', [options]);
    },
   /**
     * Formats for display
     * If we have a proper email value from model we parse out just
     * the primary address part since we're using a simple text field.
     * @param  {Object} value The value retrieved from model for email
     * @return {Object}       Normalized email value for simple field
     */
    format: function(value) {
        if(_.isArray(value)) {
            var primaryEmail = _.find(value, function(email) {
                return email.primary_address && email.primary_address !== "0";
            });
            return primaryEmail ? primaryEmail.email_address : '';
        }
        return value;
    },
    /**
     * Prepares email for going back to API
     * @param  {Object} value The value
     * @return {Object}       API ready value for email
     */
    unformat: function(value) {
        var self = this,
            emails = this.model.get('email'),
            changed = false;
        if(!_.isArray(emails)){emails = [];}
        _.each(emails, function(email, index) {
            // If we find a primary address and its email_address is different
            if(email.primary_address &&
                email.primary_address !== "0" &&
                email.email_address !== value)
            {
                changed = true;
                emails[index].email_address = value;
            }
        }, this);
        // If brand new email we push a primary address
        if (emails.length == 0) {
            emails.push({
                email_address:   value,
                primary_address: "1",
                hasAnchor:       false,
                _wasNotArray:    true
            });
            changed = true;
        }
        if (changed) {
            this.model.set(this.name, emails);
            this.model.trigger('change:' + this.name, this, emails);
        }
        return emails;
    }
}) },
"external-app-field": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ExternalAppFieldField
 * @alias SUGAR.App.view.fields.BaseExternalAppFieldField
 * @extends View.Fields.Base.Field
 */
({
	// External-app-field Field (base) 

    mounted: false,
    rendered: false,
    className: 'external-app-field',
    extraParcelParams: {},

    /**
     * The element the MFE attaches to
     */
    root: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._onSugarAppLoad();
    },

    /**
     * Imports and loads the MFE
     * @private
     */
    _onSugarAppLoad: function() {
        var serverInfo = app.metadata.getServerInfo();

        // don't re-import already mounted parcel apps
        if (this.def.src && !this.parcelLib) {
            var url = this.def.src;
            if (this.def.appendVersion && serverInfo.version) {
                url += (url.indexOf('?') ? '&' : '?') + 'sugar_version=' + serverInfo.version;
            }

            System.import(url).then(function(mod) {
                if (!mod) {
                    app.log.error('Unable to load external module from ' + url);
                }

                //Check if the export was under 'default' rather than at the top level of the module
                for (var i = 0; i < 3; i++) {
                    var props = Object.getOwnPropertyNames(mod).filter(function(name) {
                        return name.substr(0, 2) !== '__';
                    });

                    if (mod.default && (props.length === 1 || mod.__useDefault)) {
                        mod = mod.default;
                    } else {
                        break;
                    }
                }

                // only if the app is allowed, continue loading it
                this.parcelLib = mod;
                //If we haven't been asked to render yet, don't force a render.
                //If we have been rendered, mount the app into our element.
                if (this.rendered) {
                    this._mountApp();
                }

            }.bind(this)).catch(function(e) {
                if (!this.allowApp) {
                    // catalog could not find the mfe, and the service url failed
                    this.errorCode = 'SVC-404';
                    this.displayError();
                }
                System.delete(url);
            }.bind(this));
        }
    },

    /**
     * Lets the MFE handle the rendering
     */
    render: function() {
        this.rendered = true;
        this._mountApp();
    },

    /**
     * singleSpa Update function is called when the component in render is called after the initial render
     * @private
     */
    _mountApp: function() {
        if (!this.mounted && this.parcelLib) {
            this.root = document.createElement('div');
            //Since we can't use a shadow dom, we can at least reset the css to isolate styling.
            this.el.appendChild(this.root);
            this.parcelParams = {
                domElement: this.root,
                view: this
            };

            // update parcelParams with any extra keys added
            if (this.extraParcelParams) {
                for (var key in this.extraParcelParams) {
                    if (this.extraParcelParams.hasOwnProperty(key)) {
                        this.parcelParams[key] = this.extraParcelParams[key];
                    }
                }
            }

            this.parcelApp = singleSpa.mountRootParcel(this.parcelLib, this.parcelParams);
            this.mounted = true;
            this.render();
        }

        if (this.mounted && this.parcelApp && this.parcelApp.update) {
            this.parcelApp.update(this.parcelParams);
        }
    },

    /**
     * Displays an error message with error code into the template
     */
    displayError: function() {
        this.errorMsg = app.lang.get('LBL_SUGAR_APPS_DASHLET_CATALOG_ERROR', null, {
            errorCode: this.errorCode
        });
        this.$el.empty();
        this.$el.append(this.template(this));
    },

    /**
     * singleSpa Unmount function is called when dispose is called on the sidecar view
     * @inheritdoc
     * @private
     */
    _dispose: function() {
        if (this.parcelApp && this.parcelApp.unmount) {
            this.parcelApp.unmount();
        }
        // Removing listener on sugar app dispose.
        this.off('sugarApp:' + this.appId + ':store:get', null, this);
        this._super('_dispose');
    }
}) },
"multi-attachments": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * Field for storing multiple attachments using Notes.
 *
 * @class View.Fields.Base.MultiAttachmentsField
 * @alias SUGAR.App.view.fields.BaseMultiAttachmentsField
 * @extends View.Fields.Base.BaseField
 */
({
	// Multi-attachments Field (base) 

    /**
     * @inheritdoc
     */
    events: {
        'click [data-action=download-all]': 'startDownloadArchive'
    },

    plugins: ['DragdropAttachments', 'Attachments'],

    /**
     * @property {Object} `Select2` object.
     */
    $node: null,

    /**
     * @property {string} Selector for `Select2` dropdown.
     */
    fieldSelector: '',

    /**
     * @property {string} Unique ID for file input.
     */
    cid: null,

    /**
     * @property {string} Selector for file input.
     */
    fileInputSelector: '',

    /**
     * @property {Object} Handlebar object.
     */
    _select2formatSelectionTemplate: null,

    /**
     * Label for `Download all`.
     */
    download_label: '',

    /**
     * Count of uploaded files.
     */
    uploaded: 0,

    /**
     * Count of files to upload.
     */
    filesToUpload: 0,

    /**
     * @inheritdoc
     */
    initialize: function (opts) {
        var evt = {},
            relate,
            self = this;
        evt['change ' + this.fileInputSelector + '[data-type=fileinput]'] = '_uploadFile';
        this.events = _.extend({}, this.events, opts.def.events, evt);

        this.fileInputSelector = opts.def.fileinput || '';
        this.fieldSelector = opts.def.field || '';
        this.value = opts.view.attachments || [];
        this.cid = _.uniqueId('attachment');

        this._super('initialize', [opts]);
        this._select2formatSelectionTemplate = app.template.get('f.multi-attachments.selection-partial');
        this._select2formatTmpSelectionTemplate = app.template.get('f.multi-attachments.selection-partial-tmp');

        /**
         * Override handling on drop attachment.
         */
        this.before('attachments:drop', this._onAttachmentDrop, this);
    },

    /**
     * Bind data changes to the field
     * @override Base attachments field made this a noop
     */
    bindDataChange: function() {
        if (this.model) {
            this.createTooltipText();
            this.model.on('change:' + this.name, function() {
                this.createTooltipText();
                if (!_.isEmpty(this.$node.data('select2'))) {
                    this.$node.select2('data', this.getFormattedValue());
                } else {
                    this.render();
                }
            }, this);
        }
    },

    /**
     * When the user clicks "Cancel" in edit or create mode, we destroy notes
     * created to show pills if they haven't been saved on the parent model.
     *
     * TODO: In the future this could be improved to not create Note records for
     * Attachments during edit/create until the user clicks save. That change
     * seems too risky for the week before release freeze.
     * @deprecated
     */
    cancelClicked: function() {
        app.logger.warn('View.Fields.Base.MultiAttachmentsField#cancelClicked is deprecated.');
    },

    /**
     * @inheritdoc
     */
    format: function (value) {
        var value = value instanceof app.BeanCollection ? value.models : value;

        return _.map(value, function (item) {
            item = item instanceof Backbone.Model ? item.toJSON() : item;
            var id = item.id || item.filename_guid;
            var name = item.name || item.filename;
            var isImage = item.file_mime_type && item.file_mime_type.indexOf('image') !== -1;
            var forceDownload = !isImage;
            var mimeType = isImage ? 'image' : 'application/octet-stream';
            var fileName = name.substring(0, name.lastIndexOf('.'));
            var fileExt = name.substring(name.lastIndexOf('.') + 1).toLowerCase();
            var urlOpts = {
                    module: this.def.module,
                    id: item.id,
                    field: this.def.modulefield
                };

            fileExt = !_.isEmpty(fileExt) ? '.' + fileExt : fileExt;

            return {
                id: id,
                mimeType: mimeType,
                fileName: fileName,
                fileExt: fileExt,
                tmpFile: (typeof(item.id) === 'undefined'),
                url: app.api.buildFileURL(
                    urlOpts,
                    {
                        htmlJsonFormat: false,
                        passOAuthToken: false,
                        cleanCache: true,
                        forceDownload: forceDownload
                    }
                )
            };
        }, this);
    },

    /**
     * Creates a list of file names that could be shown on a list view
     * in case the list of files is collapsed.
     *
     * @return {string} The list of files.
     */
    createTooltipText() {
        var files = this.model.get(this.name);
        this.fileList = '';

        if (files && files.length) {
            this.fileList = _.reduce(files.models, function(list, model) {
                list.push(model.get('filename'));
                return list;
            }, []).join(', ');
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (this.action == 'noaccess') {
            return;
        }
        this.download_label = (this.value && this.value.length > 1) ? 'LBL_DOWNLOAD_ALL' : 'LBL_DOWNLOAD_ONE';
        // Please, do not put this._super call before acl check,
        // due to _loadTemplate function logic from sidecar/src/view.js file
        this._super('_render', []);

        this.$node = this.$(this.fieldSelector + '[data-type=attachments]');
        this.setSelect2Node();
        if (this.$node.length > 0) {
            this.$node.select2({
                allowClear: true,
                multiple: true,
                containerCssClass: 'select2-choices-pills-close span12 with-padding multi-attachments-detail-view',
                tags: [],
                formatSelection: _.bind(this.formatSelection, this),
                width: 'off',
                escapeMarkup: function(m) {
                    return m;
                }
            });
            $(this.$node.data('select2').container).attr('data-attachable', true);
            this.refreshFromModel();
        }
        this._IEDownloadAttributeWorkaroud();
    },

    /**
     * 'Download' attribute workaround for IE browser (which does not support it)
     */
    _IEDownloadAttributeWorkaroud: function () {
        var isIE = /*@cc_on!@*/false || !!document.documentMode;
        var field = "";
        var href = "";
        if (isIE) {
            var downloadFile = function (event) {
                field = this.getAttribute("download");
                href = this.getAttribute("href");
                event.preventDefault();
                var request = new XMLHttpRequest();
                request.addEventListener("load",requestListener, false);
                request.open("get", this, true);
                request.responseType = 'blob';
                request.send();
            }
            var requestListener = function () {
                if (field == "") {
                    field = href;
                }
                var blobObject = this.response;
                window.navigator.msSaveBlob(blobObject, field);
            }
            var items = document.querySelectorAll('a[download], area[download]');
            for (var i = 0; i < items.length; i++) {
                items[i].addEventListener('click', downloadFile, false);
            }
        }
    },

    /**
     *  Update `Select2` data from model.
     */
    refreshFromModel: function () {
        this.$node.select2('data', this.getFormattedValue());
    },

    /**
     * Set `$node` as `Select2` object.
     * Unlink and delete attached notes on remove from select2.
     */
    setSelect2Node: function () {
        var self = this;
        if (!this.$node || this.$node.length == 0) {
            return;
        }
        this.$node.off('select2-removed');
        this.$node.off('select2-opening');

        this.$node.on('select2-removed', function(evt) {
            self.removeAttachment(evt);
        });

        /**
         * Disables dropdown for `Select2`
         */
        this.$node.on('select2-opening', function (evt) {
            evt.preventDefault();
        });

    },

    /**
     * Remove selected attachment.
     * @param {Event} event
     */
    removeAttachment: function(event) {
        var file = _.find(this.model.get(this.name).models, function(model) {
            return model.get('id') === event.val || model.get('filename_guid') === event.val;
        });
        if (file) {
            this.model.get(this.name).remove(file);
        }
    },

    /**
     * Return file input.
     * @return {Object}
     */
    getFileNode: function () {
        return this.$(this.fileInputSelector + '[data-type=fileinput]');
    },

    /**
     * @inheritdoc
     */
    bindDomChange: function () {
        this.setSelect2Node();
    },

    /**
     * A private helper function to call Attachment's uploadFile, as it needs extra arguments
     *
     * @private
     */
    _uploadFile: function() {
        this._toggleUploading(true);

        $input = this.getFileNode();
        this.uploaded = 0;
        this.filesToUpload = $input[0].files.length;

        _.each($input[0].files, _.bind(function(file) {
            var dt = new DataTransfer();
            dt.items.add(file);

            var input = document.createElement('input');
            input.type = 'file';
            input.files = dt.files;

            this.uploadFile([input], 'filename', {
                temp: true,
            });
        }, this));
    },

    /**
     * Private function which toggles the "Uploading..." message on file uplaods
     *
     * @param flag true to show, false to dismiss
     * @private
     */
    _toggleUploading: function(flag) {
        if (flag && _.isUndefined(app.alert.get('uploading_file'))) {
            app.alert.show('uploading_file', {
                level: 'process',
                title: app.lang.get('LBL_UPLOADING_DOTS'),
            });
        } else if (app.alert.get('uploading_file')) {
            app.alert.dismiss('uploading_file');
        }
    },

    /**
     * Handle a successful file upload
     *
     * @param {Object} data
     * @private
     */
    _handleFileUploadSuccess: function(data) {
        if (!data.record || !data.record.id) {
            error = new Error('Temporary file has no GUID');
            app.logger.error(error.message);
            app.alert.show('upload_error', {
                level: 'error',
                messages: app.lang.get('ERROR_UPLOAD_FAILED')
            });
            return;
        }
        var file = this.getUploadedFileBean(data);
        this.addUploadedFileToCollection(this.model.get(this.name), file);

        this.uploaded++;
        if (this.filesToUpload <= this.uploaded) {
            this._toggleUploading(false);
        }
    },

    /**
     * Clear input field after file is uploaded.
     *
     * @param {Object} data
     * @private
     */
    _handleFileUploadComplete: function(data) {
        $input = this.getFileNode();
        $input.val('');
    },

    /**
     * Handles an error response from the API for uploading the file.
     *
     * If the error code is 'request_too_large' or status is 413, then an error is
     * shown to the user indicating that the error was due to exceeding the
     * maximum filesize. Otherwise, the error is handled by the framework.
     *
     * @param {HttpError} error.
     * @private
     */
    _handleFileUploadError: function(error) {
        if (error && (error.code === 'request_too_large' || error.status === 413)) {
            // Mark the error as having been handled so that it doesn't get
            // handled again.
            error.handled = true;
            app.alert.show(error.code, {
                level: 'error',
                autoClose: true,
                messages: app.lang.get('ERROR_MAX_FILESIZE_EXCEEDED')
            });
        }

        if (error && !error.handled && _.isFunction(app.api.defaultErrorHandler)) {
            app.api.defaultErrorHandler(error);
        }

        this._toggleUploading(false);
    },

    /**
     * Handler for 'attachments:drop' event.
     * This event is triggered when user drops file on the file field.
     *
     * @param {Event} event Drop event.
     * @return {boolean} Returns 'false' to prevent running default behavior.
     */
    _onAttachmentDrop: function(event) {
        event.preventDefault();
        $input = this.getFileNode();

        _.each(event.dataTransfer.files, function(file) {
            var dt = new DataTransfer();
            dt.items.add(file);
            $input[0].files = dt.files;
            this._uploadFile();
        }, this);

        return false;
    },

    /**
     * Format selection for `Select2` to display.
     * @param {Object} attachment
     * @return {string}
     */
    formatSelection: function (attachment) {
        return (attachment.tmpFile) ?
            this._select2formatTmpSelectionTemplate(attachment) : this._select2formatSelectionTemplate(attachment);
    },

    /**
     * Download archived files from server.
     */
    startDownloadArchive: function () {
        var params = {
            format:'sugar-html-json',
            link_name: this.def.link,
            platform: app.config.platform
        };
        params[(new Date()).getTime()] = 1;

        // todo: change buildURL to buildFileURL when will be allowed "link" attribute
        var uri = app.api.buildURL(this.model.module, 'file', {
            module: this.model.module,
            id: this.model.id,
            field: this.def.modulefield
        }, params);

        app.api.fileDownload(
            uri,
            {
                error: function (data) {
                    // refresh token if it has expired
                    app.error.handleHttpError(data, {});
                }
            },
            {iframe: this.$el}
        );
    },

    /**
     * @inheritdoc
     *
     * Disposes event listeners on `Select2` object.
     */
    dispose: function () {
        // Clean up uploading popup if its still there
        this._toggleUploading(false);

        if (this.$node) {
            this.$node.off('select2-removed');
            this.$node.off('select2-opening');
        }
        this._super('dispose');
    },
}) },
"attachments": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.AttachmentsField
 * @alias SUGAR.App.view.fields.BaseAttachmentsField
 * @extends View.Fields.Base.BaseField
 * @deprecated Use {@link View.Fields.Base.EmailAttachmentsField} instead.
 */
({
	// Attachments Field (base) 

    fieldSelector: '.attachments',
    fileInputSelector: '.fileinput',
    $node: null,
    fileCounter: 0,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.logger.warn('View.Fields.Base.AttachmentsField is deprecated. Use ' +
            'View.Fields.Base.EmailAttachmentsField instead.');

        this.events = _.extend({}, this.events, options.def.events, {
            'change .fileinput': 'uploadFile'
        });
        app.view.Field.prototype.initialize.call(this, options);

        this.context.on('attachment:add', this.addAttachment, this);
        this.context.on('attachment:filepicker:launch', this.launchFilePicker, this);
        this.context.on('attachment:upload:remove', this.removeUploadedAttachment, this);
        this.context.on('attachments:remove-by-tag', this.removeAttachmentsByTag, this);
        this.context.on('attachments:remove-by-id', this.removeAttachmentsById, this);

        // Put id on the context so <label>s can be created elsewhere to trigger this file input
        // This is required to work around an IE issue (only files picked directly or
        // from click on label can be uploaded - not programatically)
        this.fileInputName = 'email_attachment';
        this.context.set('attachment_field_' + this.fileInputName, this.cid);

        this.clearUserAttachmentCache();

        // keep track of active file upload requests so that they can be
        // aborted when the user cancels an in-progress upload
        this.requests = {};
    },

    /**
     * Allow Backspace and Delete Keys for attachments (Select2) and disable all other keys
     * @param e
     * @return {Boolean}
     * @private
     */
    _keyHandler: function(e) {
        // if key is backspace or delete ...
        if ((event.keyCode == 8 || event.keyCode == 46)) {
            return true; // Allow
        }
        return false; // Ignore Any other Keyboard Input
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var result = app.view.Field.prototype._render.call(this);

        this.$node = this.$(this.fieldSelector);

        this.$node.select2({
            allowClear:          true,
            multiple:            true,
            containerCssClass:   'select2-choices-pills-close',
            containerCss:        {'width':'100%'},
            tags: [],
            formatSelection: this.formatSelection,
            width: 'off',
            escapeMarkup: function(m) { return m; }
        });

        var inp = this.$el.find('.attachments.select2-container .select2-choices .select2-search-field .select2-input');
        if (inp && inp[0]) {
            $(inp[0]).keypress(this._keyHandler);
            $(inp[0]).keyup(this._keyHandler);
            $(inp[0]).keydown(this._keyHandler);
        }

        //handle case where attachments are pre-populated on the model
        this.refreshFromModel();

        return result;
    },

    /**
     * Launch the file input picker.
     */
    launchFilePicker: function() {
        var $fileInput = this.$(this.fileInputSelector);
        $fileInput.click();
    },

    /**
     * Add attachment to the select2 field and update the model explicitly (because select2 does not fire change on add)
     *
     * @param attachment object containing at least guid and nameForDisplay attributes
     */
    addAttachment: function(attachment) {
        this.addAttachmentToContainer(attachment);
        this.updateModel();
    },

    /**
     * Just add the attachment to the container - useful for upload progress items
     * @param attachment
     */
    addAttachmentToContainer: function(attachment) {
        var attachments = this.getDisplayedAttachments();

        if (attachment.replaceId) {
            attachments = _.map(attachments, function(existing) {
                return (existing.id == attachment.replaceId) ? attachment : existing;
            });
            delete attachment.replaceId;
        } else {
            attachments.push(attachment);
        }

        this.setDisplayedAttachments(attachments);
    },

    /**
     * @inheritdoc
     * Update model if attachments are removed (select2-removing event fires when attachment removed)
     * Prevent dropdown from opening on this field (its a container only)
     */
    bindDomChange: function() {
        this.$node = this.$(this.fieldSelector);
        this.$node.on("select2-removing", _.bind(this.handleChange, this));
        this.$node.on("select2-opening", function(event) {
            event.preventDefault();
        });
    },

    /**
     * Before handling any attachment uploads, need to clear the user's attachment cache.
     */
    clearUserAttachmentCache: function() {
        var clearCacheUrl = app.api.buildURL('Mail/attachment', "cache");
        app.api.call('delete', clearCacheUrl);
    },

    /**
     * Format how the attachment should be displayed in the pill
     *
     * @param attachment
     * @return {String}
     */
    formatSelection: function(attachment) {
        var item = '<span data-id="'+attachment.id+'">'+attachment.nameForDisplay+'</span>';
        if (attachment.showProgress) {
            item += ' <i class="sicon sicon-refresh sicon-is-spinning"></i>';
        }
        return item;
    },

    /**
     * Get the attachments displayed in select2
     *
     * @return {array} of attachments
     */
    getDisplayedAttachments: function() {
        return this.$node.select2('data');
    },

    /**
     * Handle change event fired by select2 - this is really just remove attachment events
     * @param event
     */
    handleChange: function(event) {
        if (event && event.choice && event.choice.id) {
            this.removeAttachmentsById(event.choice.id);
        }

        this.updateModel();
        this.notifyAttachmentsChanged();
    },

    /**
     * Fire event when attachment is removed
     * (useful for attachment types that require cleanup)
     *
     * Aborts the associated request if it is still active.
     *
     * @param attachment
     */
    notifyAttachmentRemoved: function(attachment) {
        if (this.requests[attachment.id]) {
            app.api.abortRequest(this.requests[attachment.id]);
        }

        this.context.trigger('attachment:' + attachment.type + ':remove', attachment);
    },

    /**
     * Fire event when attachments displayed has changed
     *
     * @param attachments
     */
    notifyAttachmentsChanged: function(attachments) {
        attachments = attachments || this.getDisplayedAttachments();
        this.context.trigger('attachments:updated', attachments);
    },

    /**
     * Refresh select2 from model
     */
    refreshFromModel: function() {
        var attachments = [];
        if (this.model.has(this.name)) {
            attachments = this.model.get(this.name);
        }
        this.setDisplayedAttachments(attachments);
    },

    /**
     * Remove attachments in list based on a given truth test iterator
     * Removes from select2 and then updates the model
     *
     * @param iterator
     */
    removeAttachmentsByIterator: function(iterator) {
        var attachments = this.getDisplayedAttachments();
        attachments = _.reject(attachments, iterator);
        this.setDisplayedAttachments(attachments);
        this.updateModel();
    },

    /**
     * Remove attachments in list based on a given guid
     *
     * @param id
     */
    removeAttachmentsById: function(id) {
        this.removeAttachmentsByIterator(_.bind(function(attachment) {
            if (attachment.id && attachment.id === id) {
                this.notifyAttachmentRemoved(attachment);
                return true;
            }
        }, this));
    },

    /**
     * Remove attachments in list based on a given tag
     *
     * @param tag
     */
    removeAttachmentsByTag: function(tag) {
        this.removeAttachmentsByIterator(_.bind(function(attachment) {
            if (attachment.tag && attachment.tag === tag) {
                this.notifyAttachmentRemoved(attachment);
                return true;
            }
        }, this));
    },

    /**
     * Remove the given attachment from the server, if there is a problem doing this, no big deal (hence no error alert)
     * @param attachment
     */
    removeUploadedAttachment: function(attachment) {
        var deleteUrl = app.api.buildURL('Mail/attachment', "delete", {id:attachment.id});
        app.api.call('delete', deleteUrl);
    },

    /**
     * Sets the attachments on select2
     */
    setDisplayedAttachments: function(attachments) {
        this.$node.select2('data', attachments);
        this.notifyAttachmentsChanged(attachments);
    },

    /**
     * Update the model from the data stored in select2
     */
    updateModel: function() {
        this.model.set(this.name, this.getDisplayedAttachments());
    },

    /**
     * Returns a File object from the HTML element passed in.
     *
     * @private
     * @param {HTMLElement} el The <input> element containing the file.
     * @return {File} The File object, containing file information.
     */
    _getFileFromInput: function(el) {
        return el.files[0];
    },

    /**
     * Upload the file and define callbacks for success & failure
     */
    uploadFile: function() {
        var $fileInput = this.$(this.fileInputSelector),
            ajaxParams = {
                files: $fileInput,
                iframe: true
            },
            fileId,
            myURL,
            options;

        //don't do anything if user cancels out of picking a file
        if (_.isEmpty(this.getFileInputVal())) {
            return;
        }

        var inputEl = $fileInput.get(0);
        var file = this._getFileFromInput(inputEl);

        if (file.size > app.config.uploadMaxsize) {
            app.alert.show('large_attachment_error', {
                level: 'error',
                messages: app.lang.get('ERROR_MAX_FILESIZE_EXCEEDED')
            });
            return;
        }

        //Notify user of progress uploading by adding a placeholder pill
        this.fileCounter++;
        fileId = 'upload'+this.fileCounter;
        this.addAttachmentToContainer({
            id: fileId,
            nameForDisplay: this.getFileInputVal().split('\\').pop(),
            showProgress: true
        });

        options = {
            format: 'sugar-html-json',
        };
        myURL = app.api.buildURL('Mail/attachment', null, null, options);
        var request = app.api.call('create', myURL, null, {
                success: _.bind(function (result) {
                    if (this.disposed === true) return; //if field is already disposed, bail out
                    if (!result.guid) {
                        this.handleUploadError(fileId, result);
                        app.logger.error('Attachment Upload Failed - no guid returned from API');
                        return;
                    }

                    //add attachment to container, replacing placeholder pill from above
                    result.id = result.guid;
                    delete result.guid;
                    result.type = 'upload';
                    result.replaceId = fileId;
                    this.context.trigger('attachment:add', result);
                }, this),

                error: _.bind(function(e) {
                    //if field is already disposed, bail out
                    if (this.disposed === true) {
                        return;
                    }

                    // When a user cancels a file upload, the associated request
                    // is aborted. The error handler is called when a request is
                    // aborted. No error message needs to be shown in this case.
                    if (e && e.errorThrown === 'abort') {
                        return;
                    }

                    this.handleUploadError(fileId, e);
                    app.logger.error('Attachment Upload Failed: ' + e);
                }, this),

                complete: _.bind(function() {
                    // the request is done so there is nothing to cancel
                    // no need to keep track of finished requests
                    delete this.requests[fileId];

                    //clear out the file input so we can detect the next change, even if it is the same file
                    this.clearFileInputVal($fileInput);
                }, this)
            },
            ajaxParams
        );

        // keep track of the request so that it can be aborted when the user cancels the file upload
        if (request) {
            this.requests[fileId] = request.uid;
        }
    },

    /**
     * Retrieve the val from the file input element (return null if not there)
     */
    getFileInputVal: function($fileInput) {
        $fileInput = $fileInput || this.$(this.fileInputSelector);
        if (_.isUndefined($fileInput)) {
            return null;
        }
        return $fileInput.val();
    },

    /**
     * Clear the value of the file input element
     * This is a bit of a hack, but is required for cross-browser (read IE isn't playing nice)
     * FIXME: When we drop IE10 support, change to: $fileInput.val(null);
     *
     * @param $fileInput
     */
    clearFileInputVal: function($fileInput) {
        $fileInput = $fileInput || this.$(this.fileInputSelector);
        if (!_.isUndefined($fileInput)) {
            $fileInput.wrap('<form>').closest('form').get(0).reset();
            $fileInput.unwrap();
        }
    },

    /**
     * When upload fails, display an error alert and remove the placeholder pill
     * @param fileId
     * @param {Object} [error] The error object containing the message to display.
     * @param {string} [error.error_message] The error message to display.
     */
    handleUploadError: function(fileId, error) {
        var message = (error && error.error_message) ? error.error_message : 'LBL_EMAIL_ATTACHMENT_UPLOAD_FAILED';

        this.context.trigger('attachments:remove-by-id', fileId);
        app.alert.show('upload_error', {
            level: 'error',
            messages: message
        });
    },

    /**
     * Turn off re-rendering of field when model changes - let select2 handle how the field looks
     */
    bindDataChange:$.noop,

    _dispose: function() {
        this.$node.select2('destroy');
        app.view.Field.prototype._dispose.call(this);
    }
}) },
"event-status": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * EventStatusField is a field for Meetings/Calls that show the status field of the model as a badge field.
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.EventStatusField
 * @alias SUGAR.App.view.fields.BaseEventStatusField
 * @extends View.Fields.Base.BadgeSelectField
 */
({
	// Event-status Field (base) 

    extendsFrom: 'BadgeSelectField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * An object where its keys map to specific status and color to matching
         * CSS classes.
         */
        this.statusClasses = {
            'Held': 'label-success',
            'Not Held': 'label-important',
            'Planned': 'label-pending'
        };

        this.type = 'badge-select';
    },

    /**
     * @inheritdoc
     */
    _loadTemplate: function() {
        var action = this.action || this.view.action;
        if (action === 'edit') {
            this.type = 'enum';
        }

        this._super('_loadTemplate');
        this.type = 'badge-select';
    }
}) },
"enum-colorcoded-fore-bkgd": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * EnumColorcodedForeBkgdField extends EnumColorCodedField to set both foreground and background color
 * based on its value.
 *
 * @class View.Fields.Base.EnumColorcodedForeBkgdField
 * @alias SUGAR.App.view.fields.BaseEnumColorcodedForeBkgdField
 * @extends View.Fields.Base.EnumColorCodedField
 */
({
	// Enum-colorcoded-fore-bkgd Field (base) 

    extendsFrom: 'EnumColorcodedField',

    /**
     * Number of default colors
     *
     * @property {number}
     */
    colorCount: 12,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        // set default colors
        this._defaultColorCodes = [];
        _.times(this.colorCount, function(n) {
            this._defaultColorCodes.push('enum-color' + (n + 1));
        }, this);
    }
}) },
"emailaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * EmailactionField is a button that when selected will launch the appropriate
 * email client.
 *
 * @class View.Fields.Base.EmailactionField
 * @alias SUGAR.App.view.fields.BaseEmailactionField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Emailaction Field (base) 

    extendsFrom: 'ButtonField',

    /**
     * @inheritdoc
     *
     * Adds the EmailClientLaunch plugin to enable the field to be used for
     * sending email.
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['EmailClientLaunch']);
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.on('emailclient:close', function() {
            // propagate this event to the context if it occurred in the activity card
            if (this.action === 'activity-card-emailaction') {
                this.context.trigger('emailclient:close');
            }
        }, this);
    },

    /**
     * Set up email options, listening for parent model changes to update the
     * email options on change.
     *
     * @private
     * @deprecated The EmailClientLaunch plugin handles email options.
     */
    _initEmailOptions: function() {
        app.logger.warn('View.Fields.Base.EmailactionField#_initEmailOptions is deprecated. ' +
            'The EmailClientLaunch plugin handles email options.');
    },

    /**
     * Update email options based on field def settings
     *
     * @param {Object} parentModel
     * @private
     * @deprecated The EmailClientLaunch plugin handles email options.
     */
    _updateEmailOptions: function(parentModel) {
        app.logger.warn('View.Fields.Base.EmailactionField#_updateEmailOptions is deprecated. ' +
            'The EmailClientLaunch plugin handles email options.');
    }
}) },
"rowaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Rowaction is a button that when selected will trigger a Backbone Event.
 *
 * @class View.Fields.Base.RowactionField
 * @alias SUGAR.App.view.fields.BaseRowactionField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Rowaction Field (base) 

    extendsFrom: 'ButtonField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.def.events = _.extend({}, options.def.events, {
            'click .rowaction': 'rowActionSelect'
        });

        if (options.def.event === 'list:preview:fire') {
            options.def.css_class += ' border-none bg-none';
        }

        this._super('initialize', [options]);
    },

    /**
     * Triggers event provided at this.def.event on the view's context object by default.
     * Can be configured to trigger events on 'view' itself or the view's 'layout'.
     *
     * @see View.Fields.Base.RowactionField#getTarget
     * @param {Event} evt The click event.
     */
    rowActionSelect: function(evt) {
        var eventName = $(evt.currentTarget).data('event') || this.def.event;

        if (eventName) {
            this.getTarget().trigger(eventName, this.model, this, evt);
        }
    },

    /**
     * Returns the target on which the event should be triggered.
     *
     * @return {Core.Context} By default, the event should be triggered on the
     * context.
     * @return {View.View} The event should be triggered on the view.
     * @return {View.Layout} The event should be triggered on the layout.
     */
    getTarget: function() {
        var target;

        switch (this.def.target) {
            case 'view':
                target = this.view;
                break;
            case 'layout':
                target = this.view.layout;
                break;
            default:
                target = this.view.context;
        }

        return target;
    }
}) },
"duration": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * DurationFieldView is a fieldset for Meetings/Calls for managing duration of an event
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.DurationField
 * @alias SUGAR.App.view.fields.BaseDurationField
 * @extends View.Fields.Base.FieldsetField
 */
({
	// Duration Field (base) 

    extendsFrom: 'FieldsetField',

    detailViewNames: [
        'record',
        'create',
        'create-nodupecheck',
        'create-no-cancel-button',
        'preview',
        'pmse-case',
        'dashablerecord',
    ],

    /**
     * Set default start date time if date_start has not been set. Add custom validation
     * to make sure that the date range is valid before saving.
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        if (this.model.isNew() && (!this.model.get('date_start'))) {
            this.setDefaultStartDateTime();
            this.modifyEndDateToRetainDuration();
            this.updateDurationHoursAndMinutes();

            // Values for date_start, date_end, duration_hours, and duration_minutes
            // should be set as the default on the model.
            this.model.setDefault({
                'date_start': this.model.get('date_start'),
                'date_end': this.model.get('date_end'),
                'duration_hours': this.model.get('duration_hours'),
                'duration_minutes': this.model.get('duration_minutes')
            });
        }

        // Date range should be valid before saving the record.
        this.model.addValidationTask('duration_date_range_' + this.cid, _.bind(function(fields, errors, callback) {
            _.extend(errors, this.validate());
            callback(null, fields, errors);
        }, this));
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        // Change the end date when start date changes.
        this.model.on('change:date_start', this.modifyEndDateToRetainDuration, this);

        // Check for valid date range on edit. If not valid, show a validation error.
        // In detail mode, re-render the field if either start or end date changes.
        this.model.on('change:date_start change:date_end', function(model) {
            var dateStartField;
            var dateEndField;
            var errors;

            this.updateDurationHoursAndMinutes();

            if (this.action === 'edit') {
                dateStartField = this.view.getField('date_start');
                dateEndField = this.view.getField('date_end');

                if (dateStartField && !dateStartField.disposed && dateEndField && !dateEndField.disposed) {
                    dateStartField.clearErrorDecoration();
                    dateEndField.clearErrorDecoration();
                    errors = this.validate();

                    if (errors) {
                        dateStartField.decorateError(errors.date_start);
                        dateEndField.decorateError(errors.date_end);
                    }
                }
            } else {
                this.render();
            }
        }, this);

        this._super('bindDataChange');
    },

    /**
     * Check to see if there are any errors on the field. Returns undefined if it is valid.
     * @return {Object} Errors
     */
    validate: function() {
        var errors,
            dateStartField = this.view.getField('date_start'),
            dateEndField = this.view.getField('date_end');

        if (!this.isDateRangeValid()) {
            errors = {};
            errors.date_start = {
                isBefore: dateEndField.label
            };
            errors.date_end = {
                isAfter: dateStartField.label
            };
        }

        return errors;
    },

    /**
     * @override
     *
     * Return the display string for the start and date, along with the duration.
     *
     * @param {Array/Object/string/number/boolean} value The value to format.
     * @return {string} The duration string
     */
    format: function(value) {
        var displayString = '',
            startDateString = this.model.get('date_start'),
            endDateString = this.model.get('date_end'),
            startDate,
            endDate,
            duration,
            durationString;

        if (startDateString && endDateString) {
            startDate = app.date(startDateString);
            endDate = app.date(endDateString);
            duration = app.date.duration(endDate - startDate);
            durationString = duration.format() || ('0 ' + app.lang.get('LBL_DURATION_MINUTES'));

            if ((startDate.date() === endDate.date()) &&
                (startDate.month() === endDate.month()) &&
                (startDate.year() === endDate.year())
            ) {
                // Should not display the date twice when the start and the end dates are the same.
                displayString = app.lang.get('LBL_START_AND_END_DATE_SAME_DAY', this.module, {
                    date: startDate.formatUser(true),
                    start: startDate.format(app.date.getUserTimeFormat()),
                    end: endDate.format(app.date.getUserTimeFormat()),
                    duration: durationString
                });
            } else {
                displayString = app.lang.get('LBL_START_AND_END_DATE', this.module, {
                    start: startDate.formatUser(false),
                    end: endDate.formatUser(false),
                    duration: durationString
                });
            }
        }

        return displayString;
    },

    /**
     * Set the default start date time to the upcoming hour or half hour,
     * whichever is closest.
     * @param {Utils.Date} currentDateTime (optional) - current date time
     */
    setDefaultStartDateTime: function(currentDateTime) {
        var defaultDateTime = currentDateTime || app.date().seconds(0);

        if (defaultDateTime.minutes() > 30) {
            defaultDateTime
                .add(1, 'h')
                .minutes(0);
        } else if (defaultDateTime.minutes() > 0) {
            defaultDateTime.minutes(30);
        }

        this.model.set('date_start', defaultDateTime.formatServer());
    },

    /**
     * Set duration_hours and duration_minutes based upon date_start and date_end.
     */
    updateDurationHoursAndMinutes: function() {
        var diff = app.date(this.model.get('date_end')).diff(this.model.get('date_start'));
        this.model.set('duration_hours', Math.floor(app.date.duration(diff).asHours()));
        this.model.set('duration_minutes', app.date.duration(diff).minutes());
    },

    /**
     * If the start and end date has been set and the start date changes,
     * automatically change the end date to maintain duration.
     */
    modifyEndDateToRetainDuration: function() {
        var startDateString = this.model.get('date_start'),
            originalStartDateString = this.model.previous('date_start'),
            originalStartDate,
            endDateString = this.model.get('date_end'),
            endDate,
            duration,
            changedAttributes = this.model.changedAttributes();

        // Do not change the end date if the start date has not been set or if the start date
        // and the end date have been changed at the same time.
        if (!startDateString ||
            (changedAttributes.date_start && changedAttributes.date_end) ||
            !app.acl.hasAccessToModel('edit', this.model, 'date_end')
        ) {
            return;
        }

        if (endDateString && originalStartDateString) {
            // If end date has been set, maintain duration when the start
            // date changes.
            originalStartDate = app.date(originalStartDateString);
            duration = app.date(endDateString).diff(originalStartDate);

            // Only set the end date if start date is before the end date.
            if (duration >= 0) {
                endDate = app.date(startDateString).add(duration).formatServer();
                this.model.set('date_end', endDate);
            }
        } else {
            // Set the end date to be an hour from the start date if the end
            // date has not been set yet.
            endDate = app.date(startDateString).add(30, 'm').formatServer();
            this.model.set('date_end', endDate);
        }
    },

    /**
     * Is this date range valid?
     * @return {boolean} `true` when start date is before end date, `false` otherwise
     */
    isDateRangeValid: function() {
        var start = this.model.get('date_start'),
            end = this.model.get('date_end'),
            isValid = false;

        if (start && end) {
            if (app.date.compare(start, end) < 1) {
                isValid = true;
            }
        }

        return isValid;
    },

    /**
     * Inherit fieldset templates for edit.
     * FIXME: Will be refactored by SC-3471.
     * @inheritdoc
     * @private
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');
        // FIXME: SC-3836 will replace special-casing view names/actions via
        // action based templates.
        // Use detail view if the view.name is in list of views defined in detailViewNames
        if ((_.indexOf(this.detailViewNames, this.view.name) > -1) && (this.action === 'edit')) {
            this.template = app.template.getField('fieldset', 'record-detail', this.model.module);
        }
    },

    /**
     * Remove validation on the model.
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('duration_date_range_' + this.cid);
        this._super('_dispose');
    },

    /**
     * Forces the date and time pickers to close in the event that they remain
     * opened when the field is re-rendered.
     *
     * @inheritdoc
     */
    _render: function() {
        var start = this.view.getField('date_start');
        var end = this.view.getField('date_end');

        if (start) {
            start.$(start.fieldTag).datepicker('hide');
            start.$(start.secondaryFieldTag).timepicker('hide');
        }

        if (end) {
            end.$(end.fieldTag).datepicker('hide');
            end.$(end.secondaryFieldTag).timepicker('hide');
        }

        return this._super('_render');
    },

    /**
     * Special case for duration fields on preview view
     *
     * @inheritdoc
     */
    setMode: function(name) {
        //on preview view, we use the preview action instead of detail
        if (this.view.name === 'preview' && name === 'detail') {
            name = 'preview';
        }

        this._super('setMode', [name]);
    }
}) },
"discount-amount": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.DiscountField
 * @alias SUGAR.App.view.fields.BaseDiscountField
 * @extends View.Fields.Base.CurrencyField
 */
({
	// Discount-amount Field (base) 

    extendsFrom: 'CurrencyField',

    discountFieldName: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.discountFieldName = options.def.discountFieldName;

        // Store values for views that don't render twice.
        if (this.model.has('currency_id')) {
            this.lastCurrencyId = this.model.get('currency_id');
        }

        var numericValidationTaskName = 'isNumeric_validator_' + this.cid;

        // removing the validation task if it exists already for this field
        this.model.removeValidationTask(numericValidationTaskName);
        this.model.addValidationTask(numericValidationTaskName, _.bind(this._validateAsNumber, this));
    },

    /**
     * Callback for after validation runs.
     * @param {bool} isValid flag determining if the validation is correct
     * @private
     */
    _validationComplete: function(isValid) {
        if (isValid) {
            app.alert.dismiss('invalid-data');
        }
    },

    /**
     * @inheritdoc
     *
     * Listen for the discount_select field to change, when it does, re-render the field
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        // If discount select changes, we need to re-render this field
        this.model.on('change:' + this.discountFieldName, this.render, this);

        // If the discount type changes, we need to re-render this field
        this.model.on('change:currency_id', this.handleCurrencyFieldChange, this);
    },

    handleCurrencyFieldChange: function(model, currencyId, options) {
        if (!this.lastCurrencyId || !currencyId || _.property('revert')(options) === true) {
            this.lastCurrencyId = currencyId;
            return;
        }

        if (_.isEqual(this.model, model)) {
            // Should convert new discount_amount value if the new currency is different
            if (
                currencyId !== this.lastCurrencyId &&
                app.utils.isTruthy(model.get(this.discountFieldName)) === false
            ) {
                var convertedDiscountAmount = app.currency.convertAmount(
                    model.get(this.name),
                    this.lastCurrencyId,
                    currencyId
                );
                model.set(this.name, convertedDiscountAmount);
            }
            this.lastCurrencyId = currencyId;
        }
    },

    /**
     * @inheritdoc
     *
     * Special handling of the templates, if we are displaying it as a percent, then use the _super call,
     * otherwise get the templates from the currency field.
     */
    _loadTemplate: function() {
        if (app.utils.isTruthy(this.model.get(this.discountFieldName))) {
            this._super('_loadTemplate');
        } else {
            this._super('_loadTemplate');
            this.template = app.template.getField(
                'currency',
                this.action || this.view.action,
                this.module
            ) || app.template.empty;
            this.tplName = this.action || this.view.action;
        }
    },

    /**
     * @inheritdoc
     *
     * Special handling for the format, if we are in a percent, use the decimal field to handle the percent, otherwise
     * use the format according to the currency field
     */
    format: function(value) {
        if (app.utils.isTruthy(this.model.get(this.discountFieldName))) {
            return app.utils.formatNumberLocale(value);
        } else {
            //In edit mode hide the currency dropdown for the discount field
            this.hideCurrencyDropdown = this.tplName === 'edit' ? true : false;
            return this._super('format', [value]);
        }
    },

    /**
     * @inheritdoc
     *
     * Special handling for the unformat, if we are in a percent, use the decimal field to handle the percent,
     * otherwise use the format according to the currency field
     */
    unformat: function(value) {
        if (app.utils.isTruthy(this.model.get(this.discountFieldName))) {
            var unformattedValue = app.utils.unformatNumberStringLocale(value, true);
            // if unformat failed, return original value
            return _.isFinite(unformattedValue) ? unformattedValue : value;
        } else {
            return this._super('unformat', [value]);
        }
    },

    /**
     * Validate the discount field as a number - do not allow letters
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _validateAsNumber: function(fields, errors, callback) {
        var value = this.model.get(this.name);

        if (!_.isFinite(value)) {
            errors[this.name] = {'number': value};
        }

        callback(null, fields, errors);
    },

    /**
     * Extending to remove the custom validation task for this field
     *
     * @inheritdoc
     * @private
     */
    _dispose: function() {
        var numericValidationTaskName = 'isNumeric_validator_' + this.cid;
        this.model.removeValidationTask(numericValidationTaskName);

        this._super('_dispose');
    }
}) },
"relative-time": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RelativeTimeField
 * @alias SUGAR.App.view.fields.BaseRelativeTimeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Relative-time Field (base) 

    plugins: ['RelativeTime'],
}) },
"textarea": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TextareaField
 * @alias SUGAR.App.view.fields.BaseTextareaField
 * @extends View.Fields.Base.BaseField
 */
({
	// Textarea Field (base) 

    /**
     * @inheritdoc
     */
    fieldTag : 'textarea',

    /**
     * Default settings used when none are supplied through metadata.
     *
     * Supported settings:
     * - {Number} max_display_chars The maximum number of characters to be
     *   displayed before truncating the field.
     * - {Boolean} collapsed Defines whether or not the textarea detail view
     *   should be collapsed on initial render.
     *
     *     // ...
     *     'settings' => array(
     *         'max_display_chars' => 50,
     *         'collapsed' => false
     *         //...
     *     ),
     *     //...
     *
     * @protected
     * @type {Object}
     */
    _defaultSettings: {
        max_display_chars: 450,
        collapsed: true
    },

    /**
     * State variable that keeps track of whether or not the textarea field
     * is collapsed in detail view.
     *
     * @type {Boolean}
     */
    collapsed: undefined,

    /**
     * Settings after applying metadata settings on top of
     * {@link View.Fields.BaseTextareaField#_defaultSettings default settings}.
     *
     * @protected
     */
    _settings: {},

    /**
     * @inheritdoc
     */
    events: {
        'click [data-action=toggle]': 'toggleCollapsed'
    },

    rowCount: null,

    /**
     * @inheritdoc
     *
     * Initializes settings on the field by calling
     * {@link View.Fields.BaseTextareaField#_initSettings _initSettings}.
     * Also sets {@link View.Fields.BaseTextareaField#collapsed collapsed}
     * to the value in `this._settings.collapsed` (either default or metadata).
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.plugins = _.union(this.plugins, 'Tooltip');
        this._initSettings();
        this.collapsed = this._settings.collapsed;
        this.rowCount = this.def.rows;
    },

    /**
     * Initialize settings, default settings are used when none are supplied
     * through metadata.
     *
     * @return {View.Fields.BaseTextareaField} Instance of this field.
     * @protected
     */
    _initSettings: function() {
        this._settings = _.extend({},
            this._defaultSettings,
            this.def && this.def.settings || {}
        );
        return this;
    },

    /**
     * @inheritdoc
     *
     * Prevents editing the textarea field in a list view.
     *
     * @param {String} name The mode to set the field to.
     */
    setMode: function(name) {
        // FIXME: This will be updated pending changes to fields in sidecar,
        // see SC-2608, SC-2776.
        // FIXME: Check on 'merge-duplicates' to identify editable fields
        // see SC-3325
        var isList = (this.tplName === 'list') && _.contains(['edit', 'disabled'], name),
            mode = isList && this.view.name !== 'merge-duplicates' ? this.tplName : name;
        this._super('setMode', [mode]);
    },

    /**
     * @inheritdoc
     *
     * Formatter that always returns the value set on the textarea field. Sets
     * a `short` value for a truncated representation, if the lenght of the
     * value on the field exceeds that of `max_display_chars`. The return value
     * can either be a string, or an object such as {long: 'abc'} or
     * {long: 'abc', short: 'ab'}, for example.
     * @param {String} value The value set on the textarea field.
     * @return {String|Object} The value set on the textarea field.
     */
    format: function(value) {
        // If the tplName is 'edit' then value needs to be a string. Otherwise
        // send back the object containing `value.long` and, if necessary,
        // `value.short`.
        var shortComment = value;
        var max = this._settings.max_display_chars;

        var valueObj = {
            long: this.getDescription(value, false),
            defaultValue: value,
            short: '',
        };

        var longValueOverMaxChars = valueObj.long.string.length > max;

        if (valueObj.long && longValueOverMaxChars) {
            valueObj.short = this.getDescription(shortComment, true);
        }

        if (this.tplName === 'edit') {
            // Based on the value to be used, format the textarea field.
            this.updateTextAreaDimensions(valueObj, longValueOverMaxChars);
            return value;
        }

        return valueObj;
    },

    /**
     * This method will set the rows attribute on the textarea, corresponding to whichever value is going to be
     * displayed, based on this.format().
     * @param {Object} value The value set on the textarea field.
     * @param {boolean} longValueOverMaxChars Whether or not the max string value is over the defined char limit.
     */
    updateTextAreaDimensions: function(value, longValueOverMaxChars) {
        var shortValueRowCount = 0;
        var longValueRowCount = 0;

        if (value.short && !_.isEmpty(value.short.string)) {
            shortValueRowCount = this._countRows(value.short, this.def.cols);
        }

        if (value.long && !_.isEmpty(value.long.string)) {
            longValueRowCount = this._countRows(value.long, this.def.cols);
        }

        var newRowCount = this.collapsed && longValueOverMaxChars ? shortValueRowCount : longValueRowCount;
        this.rowCount = newRowCount > this.def.rows ? newRowCount : this.def.rows;
    },

    /**
     * The calculation that's done here is to take the total length of the string and divide it against the
     * total number of columns. This will not produce a number of rows that will be perfect everytime but it is
     * goood for these purposes. A textarea's cols attribute is a relative measurement, based on the average size
     * of a character.
     */
    _countRows: function(value, colCount) {
        var splitValue = value.string.split('\n');
        return _.chain(splitValue)
            .map(function(s) {
                return Math.ceil(s.length / colCount);
            })
            .reduce(function(curr, prev) {
                return curr + prev;
            })
            .value();
    },

    /**
     * Displaying full or short descriptions.
     *
     * @param {string} description The value set on the textarea field.
     * @param {boolean} short Need a short value of the comment.
     * @return {string} The entry with html for any links.
     */
    getDescription: function(description, short) {
        short = !!short;
        description = Handlebars.Utils.escapeExpression(description);
        description = short ? this.getShortComment(description) : description;
        description = this.insertHtmlLinks(description);
        return new Handlebars.SafeString(description);
    },

    /**
     * Replaces any text urls with html links
     * 1-th pattern - http://, https://, ftp://
     * 2-th pattern - www. sans http:// or https://
     * 3-th pattern - Email addresses
     *
     * @param {string} description The comment entry
     * @return {string} The entry with html for any links
     */
    insertHtmlLinks: function(description) {
        return description
            .replace(
                /((https?|ftp):\/\/[^\s]+)/g,
                '<a href="$&" target="_blank" rel="nofollow noopener noreferrer">$&</a>'
            )
            .replace(
                 /(^|[^\/])(www\.[\S]+(\b|$))/gim,
                 '$1<a href="http://$2" target="_blank" rel="nofollow noopener noreferrer">$2</a>'
            )
            .replace(
                  /[\w.]+@[a-zA-Z_-]+?(?:\.[a-zA-Z]{2,6})+/gim,
                  '<a href="mailto:$&">$&</a>'
            );
    },

    /**
     * Truncate the text area entry so it is shorter than the max_display_chars
     * Only truncate on full words to prevent ellipsis in the middle of words
     *
     * @param {string} description The comment log entry to truncate
     * @return {string} the shortened version of an entry if it was originally longer than max_display_chars
     */
    getShortComment: function(description) {
        if (!this.isLongSize(description)) {
            return description;
        }
        let shortDescription = description.substring(0, this._settings.max_display_chars);
        // let's cut at a full word by checking we are at a whitespace char
        while (!(/\s/.test(shortDescription[shortDescription.length - 1])) && shortDescription.length > 0) {
            shortDescription = shortDescription.substring(0, shortDescription.length - 1);
        }

        return shortDescription;
    },

    /**
     * To check size of description.
     *
     * @param {string} description The comment entry
     * @return {boolean}
     */
    isLongSize: function(description) {
        return description.length > this._settings.max_display_chars;
    },

    /**
     * Toggles the field between displaying the truncated `short` or `long`
     * value for the field, and toggles the label for the 'more/less' link.
     */
    toggleCollapsed: function() {
        this.collapsed = !this.collapsed;
        this.render();
    },

    /**
     * Overrides default implementation so that whitespaces won't be stripped.
     */
    unformat: function(value) {
        return value;
    }
}) },
"timeselect": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TimeselectField
 * @alias SUGAR.App.view.fields.BaseTimeselectField
 * @extends View.Fields.Base.BaseField
 */
({
	// Timeselect Field (base) 

    /**
     * @inheritdoc
     */
    fieldTag: 'input[data-type=time]',

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        _.extend(this.events, {
            'click [data-action="show-timepicker"]': 'showTimepicker'
        });

        this._super('initialize', [options]);

        this._hoursField = this.def.fields && this.def.fields[0].name;
        this._minutesField = this.def.fields && this.def.fields[1].name;

        // special handling for default values in create mode
        if (this.model && this.model.isNew() && this.def.default_times) {
            var defaultTimes = this.def.default_times;
            this.model.set(this.name, {hour: defaultTimes.hour, minute: defaultTimes.minute});
            this.model.set(this._hoursField, defaultTimes.hour);
            this.model.set(this._minutesField, defaultTimes.minute);
        }
    },

    /**
     * Binds model changes on this field, taking into account both field tags.
     *
     * @override
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }

        // propagate changes from this field to its component hour and minute fields
        this.model.on('change:' + this.name, function(model, value, options) {
            if (this.disposed) {
                return;
            }

            value = app.date(value);
            if (!options || options.updateSubFields !== false) {
                this.model.set(this._hoursField, value.hour());
                this.model.set(this._minutesField, value.minute());
            }

            if (this._inDetailMode()) {
                this.render();
                return;
            }

            this.$(this.fieldTag).val(this.format(value) || '');
        }, this);

        // update this field as the underlying hours and minutes change
        this.model.on('sync change:' + this._hoursField + ' change:' + this._minutesField, function(model, value) {
            var hour = parseInt(this.model.get(this._hoursField), 10) || 0;
            var minute = parseInt(this.model.get(this._minutesField), 10) || 0;
            this.model.set(this.name, {hour: hour, minute: minute}, {updateSubFields: false});
        }, this);

        this.view.on('editable:toggle_fields', function() {
            this.$(this.fieldTag).val(this.format(this.model.get(this.name)));
        }, this);
    },

    /**
     * @inheritdoc
     */
    bindDomChange: function() {
        this._super('bindDomChange');

        if (this._inDetailMode()) {
            return;
        }

        var $timeField = this.$(this.fieldTag);
        var selfView = this.view;

        $timeField.timepicker().on({
            showTimepicker: function() {
                selfView.trigger('list:scrollLock', true);
            },
            hideTimepicker: function() {
                selfView.trigger('list:scrollLock', false);
            },
            focus: _.bind(function() {
                this.handleFocus();
                var date = new Date();
                var value = this.model.get(this.name);
                var hours = value.hour;
                var minutes = value.minute;
                date.setHours(hours, minutes);
                $timeField.timepicker('setTime', date);
            }, this)
        });
    },

    /**
     * Format a time object in the user's time format.
     *
     * @param {Object} value Hour-minute object.
     * @param {number} value.hour The hour.
     * @param {number} value.minute The minute.
     * @return {string|undefined} The given time object in the user's time
     *   format.
     */
    format: function(value) {
        if (_.isNull(value) || _.isUndefined(value) || _.isNaN(value)) {
            return '';
        }

        value = app.date(value);

        if (!value.isValid()) {
            return;
        }

        return value.format(this._getMomentUserTimeFormat());
    },

    /**
     * Convert the string time in the user's time format to an object.
     *
     * Note, the value of this field itself is not used by the server.
     * It's simply designed to propagate to and from the relevant
     * hour and minute fields.
     *
     * @param {string} value Value to store as a time string in the user's
     *   preferred time format.
     * @return {Object|undefined} The date as an object.
     * @return {number} return.hour The hour.
     * @return {number} return.minute The minute.
     */
    unformat: function(value) {
        if (!value) {
            return value;
        }

        value = app.date(value, this._getMomentUserTimeFormat());

        if (!value.isValid()) {
            return;
        }

        return {hour: value.hour(), minute: value.minute()};
    },

    /**
     * Return user time format (for configuring the timepicker).
     *
     * @return {string} User time format.
     * @private
     */
    _getTimepickerUserTimeFormat: function() {
        return app.user.getPreference('timepref');
    },

    /**
     * Return user time format (for use with app.date).
     *
     * @return {string} User time format.
     * @private
     */
    _getMomentUserTimeFormat: function() {
        return app.date.getUserTimeFormat();
    },

    /**
     * Set up the time picker.
     *
     * @protected
     */
    _setupTimePicker: function() {
        var options;
        var localeData = app.date.localeData();
        var lang = {
            am: localeData.meridiem(1, 0, true),
            pm: localeData.meridiem(13, 0, true),
            AM: localeData.meridiem(1, 0, false),
            PM: localeData.meridiem(13, 0, false)
        };

        options = {
            timeFormat: this._getTimepickerUserTimeFormat(),
            scrollDefaultNow: _.isUndefined(this.def.scroll_default_now) ?
                true :
                !!this.def.scroll_default_now,
            step: this.def.step || 15,
            disableTextInput: _.isUndefined(this.def.disable_text_input) ?
                false :
                !!this.def.disable_text_input,
            className: this.def.css_class || 'prevent-mousedown',
            appendTo: this.$el,
            lang: lang
        };

        this.$(this.fieldTag).timepicker(options);
        this._hasTimePicker = true;
    },

    /**
     * Handler to show time picker on icon click.
     *
     * We trigger the focus on element instead of the jqueryfied element, to
     * trigger the focus on the input and avoid the `preventDefault()` imposed
     * in the library.
     */
    showTimepicker: function() {
        this.$(this.fieldTag)[0].focus();
    },

    /**
     * Hide the timepicker.
     */
    hideTimepicker: function() {
        this.$(this.fieldTag).timepicker('hide');
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (this._hasTimePicker) {
            this.hideTimepicker();
        }

        this._super('_render');

        if (this._inDetailMode()) {
            return;
        }

        this._setupTimePicker();
    },

    /**
     * Determine if the field is currently in a read-only (detail) mode.
     *
     * @return {boolean}
     * @protected
     */
    _inDetailMode: function() {
        return this.action !== 'edit' && this.action !== 'massupdate';
    },

    /**
     * @inheritdoc
     *
     * Add extra logic to unbind the field tag.
     */
    unbindDom: function() {
        this._super('unbindDom');

        if (this._inDetailMode()) {
            return;
        }

        this.$(this.fieldTag).off();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this._hasTimePicker) {
            this.$(this.fieldTag).timepicker('remove');
        }

        this._super('_dispose');
    }
}) },
"commentlog": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.CommentLogField
 * @alias SUGAR.App.view.fields.BaseCommentLogField
 * @extends View.Fields.Base.TextareaField
 */
({
	// Commentlog Field (base) 

    extendsFrom: 'TextareaField',

    fieldTag: 'textarea',

    plugins: ['Taggable'],

    /**
     * @inheritdoc
     */
    events: {
        'click [data-action=toggle]': 'toggleCollapsedEntry',
        'click [data-action=showall]': 'showAll',
        'click [data-action=save]': 'save',
    },

    /**
     * Object to keep track of what comment entries are collapsed
     */
    collapsedEntries: undefined,

    /**
     * Defaults
     */
    _defaultSettings: {
        max_display_chars: 500,
    },

    /**
     * Called when initializing the field
     * @param options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.collapsedEntries = {};
        this._initSettings();
        this.setUpTaggable();
    },

    /**
     * Set model info to to properly check acl access for mentions
     */
    setUpTaggable: function() {
        var module;
        var id;
        if (this.def.dashlet) {
            module = this.view.collection.link.bean.module;
            id = this.view.collection.link.bean.id;
        } else {
            module = this.context.get('module');
            id = this.context.get('modelId');
        }
        this.setTaggableRecord(module, id);
    },

    /**
     * Initialize settings, default settings are used when none are supplied
     * through metadata.
     *
     * @return {View.Fields.BaseCommentlogField} Instance of this field.
     * @protected
     */
    _initSettings: function() {
        var configSettings = {
            max_display_chars: app.config.commentlog.maxchars,
        };
        this._settings = _.extend({}, this._defaultSettings, configSettings);
        return this;
    },

    /**
     * Get the correct collection depending if this is a collection field
     * or a dashlet collection
     *
     * @return {Data.BeanCollection}
     */
    getCollection: function() {
        if (this.def.dashlet) {
            return this.view.collection;
        } else {
            return this.model.get(this.name);
        }
    },

    /**
     * Called when rendering the field
     * @private
     */
    _render: function() {
        this.showCommentLog();
        this._super('_render'); // everything showing in the UI should be done before this line.
    },

    /**
     * Called when formatting the value for display
     * @param value
     */
    format: function(value) {
        return value;
    },

    /**
     * Builds model for handlebar to show pass commentlog messages in record view.
     * This should only be called when there is need to render past messages, only
     * when this.getFormattedValue() returns the data format for message.
     */
    showCommentLog: function() {
        var collection = this.getCollection();
        if (!collection) {
            return;
        }

        // Set if we should show the View All button on the dashlet view
        this._showViewAll = collection.dataFetched && collection.next_offset !== -1;

        var comments = collection.models;

        if (comments) {
            this.msgs = [];
            // add readable time and user link to users
            _.each(comments, function(commentModel) {
                var id = commentModel.get('id');
                if (_.isUndefined(this.collapsedEntries[id])) {
                    this.collapsedEntries[id] = true;
                }

                var entry = this._escapeValue(commentModel.get('entry'));
                var entryShort = this.getShortComment(entry);
                var showShort = entry !== entryShort;

                entry = this.insertHtmlLinks(entry);
                entryShort = this.insertHtmlLinks(entryShort);

                entry = this.formatTags(entry);
                entryShort = this.formatTags(entryShort);

                var msg = {
                    id: commentModel.get('id'),
                    entry: new Handlebars.SafeString(entry),
                    entryShort: new Handlebars.SafeString(entryShort),
                    created_by_name: commentModel.get('created_by_name'),
                    collapsed: this.collapsedEntries[id],
                    showShort: showShort,
                    date_entered: commentModel.get('date_entered'),
                };

                // to date display format
                var enteredDate = app.date(commentModel.get('date_entered'));
                if (enteredDate.isValid()) {
                    msg.entered_date = enteredDate.formatUser();
                }

                var link = commentModel.get('created_by_link');
                if (link && link.id) {
                    if (app.acl.hasAccess('view', 'Employees', {acls: link._acl})) {
                        msg.href = '#' + app.router.buildRoute('Employees', link.id, 'detail');
                    }
                } else if (commentModel.has('created_by')) {
                    msg.href = '#' + app.router.buildRoute('Employees', commentModel.get('created_by'), 'detail');
                }

                if (commentModel === this._newEntryModel) {
                    msg.isNew = true;
                }
                this.msgs.push(msg);
            }, this);
        }

        this.newValue = this._newEntryModel ? this._newEntryModel.get('entry') : '';
    },

    /**
     * Escapes any dangerous values from the string
     *
     * @param {string} comment The comment entry
     * @return {string} The escaped string
     * @private
     */
    _escapeValue: function(comment) {
        return Handlebars.Utils.escapeExpression(comment);
    },

    /**
     * Save the id in this.collapsedEntries to keep track of what entries are shortened on view or not
     * @param event
     */
    toggleCollapsedEntry: function(event) {
        var id = $(event.currentTarget).data('commentId');
        this.collapsedEntries[id] = !this.collapsedEntries[id];
        this.render();
    },

    /**
     * Load all comments into the dashlet
     */
    showAll: function() {
        this.showAllClicked = true;
        this.view.loadData({loadAll: true});
    },

    /**
     * Called when unformatting the value for storage
     * @param value
     */
    unformat: function(value) {
        return value;
    },

    /**
     * Save a new comment on the dashlet
     */
    save: function() {
        if (this.view._mode === 'preview') {
            return;
        }
        var value = this.getCurrentCommentText();
        if (_.isEmpty(value)) {
            return;
        }
        var commentBean = app.data.createRelatedBean(this.model, null, 'commentlog_link', {entry: value});
        var success = _.bind(function() {
            this.setCurrentCommentText('');
            this.view.loadData({loadAll: !!this.showAllClicked});
        }, this);
        commentBean.sync('create', commentBean, {success: success, relate: true});
    },

    /**
     * Get the current comment text.
     *
     * @return {string} The current comment text.
     */
    getCurrentCommentText: function() {
        var el = this.getTextArea();
        return this.unformat(el.val());
    },

    /**
     * Set the current comment text.
     *
     * @param {string} text The desired comment text.
     */
    setCurrentCommentText: function(text) {
        var el = this.getTextArea();
        el.val(text);
    },

    /**
     * Get the comment log textarea
     *
     * @return {jQuery} The textarea element
     */
    getTextArea: function() {
        return this.$el.find(this.fieldTag);
    },

    /**
     * Commentlog needs to check if it has any messages in the collection
     * @override
     */
    isFieldEmpty: function() {
        return this.getCollection().length === 0;
    },

    /**
     * @inheritdoc
     */
    bindDomChange: function() {
        if (this.def.dashlet) {
            return;
        }
        if (!(this.model instanceof Backbone.Model)) {
            return;
        }

        var el = this.getTextArea();
        var self = this;

        el.on('change', function() {
            var value = self.unformat(el.val());

            if (!self._newEntryModel) {
                var collectionField = self.model.get('commentlog');

                if (!collectionField) {
                    self.model.set(self.name, []);
                    collectionField = self.model.get('commentlog');
                }

                self._newEntryModel = app.data.createRelatedBean(self.model, null, 'commentlog_link', {
                    entry: value,
                    _link: 'commentlog_link',
                });

                collectionField.add(self._newEntryModel, {silent: true});
            }
            self._newEntryModel.set('entry', value);
        });
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.model) {
            var collectionField = this.model.get(this.name);
            if (collectionField) {
                this.listenTo(collectionField, 'reset', function() {
                    this.newValue = this._newEntryModel = null;
                });
            }
            this.model.on('change:' + this.name, function(model, value) {
                if (this.action !== 'edit') {
                    this.newValue = this._newEntryModel = null;
                }
                this.render();
            }, this);
        }

        if (this.def.dashlet) {
            var collection = this.getCollection();
            if (collection) {
                collection.on('sync', function() {
                    if (this.disposed) {
                        return;
                    }
                    this.render();
                }, this);
            }
        }
    }
}) },
"stage2_image": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Stage2_image Field (base) 

    extendsFrom: 'ImageField',

    /**
     * Format value
     *
     * @param {string} value
     * @return {string}
     */
    format: function(value) {
        return value;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this.model.fileField = this.name;
        app.view.Field.prototype._render.call(this);

        if (!_.isEqual(this.view.name, 'record') &&
            !_.isEqual(this.view.name, 'list') &&
            !_.isEqual(this.view.name, 'create')) {
            //Define default sizes
            this.width = 42;
            this.height = 42;

            if (_.isEqual(this.name, 'hint_account_logo')) {
                this.width = this.def.width / 2;
                this.height = 50;
            }
            if (_.isEqual(this.value, '')) {
                template = app.template.getField(this.type, 'module-icon', this._getModuleName());
                if (template) {
                    this.$('.image_field').replaceWith(template({
                        module: this.name === 'hint_account_logo' ? 'Accounts' : this._getModuleName(),
                        labelSizeClass: 'label-module-lg',
                        tooltipPlacement: app.lang.direction === 'ltr' ? 'right' : 'left'
                    }));
                }
            } else {
                //Resize widget before the image is loaded
                this.resizeWidth(this.width);
                this.resizeHeight(this.height);
                this.$('.image_field').removeClass('hide');
                //Resize widget once the image is loaded
                this.$('img').addClass('hide').on('load', $.proxy(this.resizeWidget, this));
            }
            return this;

        } else {
            this.$el.parent().addClass('hidden');
            return this;
        }
    },

    /**
     * Gets the record's module name.
     *
     * FIXME: This isn't the right way to do it. The
     * {@link View.Views.Base.HistorySummaryView} view should use a true
     * {@link Data.MixedBeanCollection} so we don't have to do this.
     *
     * @return {string} The module name.
     * @protected
     */
    _getModuleName: function() {
        if (this.view.name === 'history-summary') {
            return this.model.get('_module');
        }
        return this.module;
    },

}) },
"stage2_preficon": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Stage2_preficonField
 * @alias SUGAR.App.view.fields.BaseStage2_preficonField
 * @extends View.Fields.Base.BoolField
 */
({
	// Stage2_preficon Field (base) 

    extendsFrom: 'BoolField'
}) },
"password": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.PasswordField
 * @alias SUGAR.App.view.fields.BasePasswordField
 * @extends View.Fields.Base.BaseField
 */
({
	// Password Field (base) 

    direction: 'ltr'
}) },
"image-url": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ImageUrl
 * @alias SUGAR.App.view.fields.BaseImageUrl
 * @extends View.Fields.Base.UrlField
 */
({
	// Image-url Field (base) 

    extendsFrom: 'UrlField',

    preview: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        app.error.errorName2Keys.url = 'ERROR_URL';

        this.setPreview();

        this.model.on('change:' + this.name, function() {
            this.setPreview();
            this.render();
        }, this);

        this.model.addValidationTask('image_url_' + this.cid, _.bind(this._doValidateUrl, this));
    },

    /**
     * URL validation.
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * */
    _doValidateUrl: function(fields, errors, callback) {
        var value = this.model.get(this.name);

        if (value && !/^(https?|ftp):\/\/[^\s\/$.?#]+\.[^\s]+$/.test(this.format(value))) {
            errors[this.name] = errors[this.name] || {};
            errors[this.name].url = true;
        }

        callback(null, fields, errors);
    },

    /*
     * Set preview value
     */
    setPreview: function() {
        this.preview = this.model.get(this.name) || '';

        if (!this.preview && this.def.default) {
            this.preview = this.def.default + '?v=' + app.config.versionMark;
        }
    },

    /**
     * Remove validation on the model.
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('image_url_' + this.cid);
        this._super('_dispose');
    },
}) },
"formula-builder": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FormulaBuilderField
 * @alias SUGAR.App.view.fields.BaseFormulaBuilderField
 * @extends View.Fields.Base.BaseField
 */
({
	// Formula-builder Field (base) 

    events: {
        'click a[data-action=add-related]': 'addRelatedField',
        'click a[data-action=add-rollup]': 'addRollupField',
        'change textarea.formula-editor': 'formulaChanged',
        'click a[data-action=related]': 'showRelatedControllers',
        'click a[data-action=rollup]': 'showRollupControllers',
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._beforeInit(options);

        this._super('initialize', [options]);
    },

    /**
     * Quick initialization of field properties
     *
     * @param {Object} options
     *
     */
    _beforeInit: function(options) {
        this._module = options.targetModule;
        this._formula = options.formula ? options.formula : '';
        this._callback = options.callback;
        this._returnType = options.returnType;
        this._matchField = options.matchField;

        // metadata of all the select2s needed
        this._dropdowns = [{
            selector: 'a[data-select=functions]',
            func: _.bind(this._addFunction, this),
            query: '_queryFunctions',
            label: 'LBL_ACTIONBUTTON_FUNCTIONS',
            skipValue: true,
            format: '_formatFunctionOptions'
        }, {
            selector: 'a[data-select=fields]',
            func: _.bind(this._addField, this),
            query: '_queryFields',
            label: 'LBL_ACTIONBUTTON_FIELDS',
            skipValue: true,
        }, {
            selector: 'a[data-select=related-module]',
            func: _.bind(this._changeRelatedModule, this),
            query: '_queryRelatedModule',
            label: 'LBL_ACTIONBUTTON_R_MODULE',
        }, {
            selector: 'a[data-select=related-fields]',
            query: '_queryRelatedFields',
            label: 'LBL_ACTIONBUTTON_R_FIELDS',
        }, {
            selector: 'a[data-select=rollup-module]',
            func: _.bind(this._changeRollupModule, this),
            query: '_queryRollupModule',
            label: 'LBL_ACTIONBUTTON_ROLL_MODULE',
        }, {
            selector: 'a[data-select=rollup-fields]',
            query: '_queryRollupFields',
            label: 'LBL_ACTIONBUTTON_ROLL_FIELDS',
        }, {
            selector: 'a[data-select=rollup-function]',
            query: '_queryRollupType',
            label: 'LBL_ACTIONBUTTON_ROLL_TYPE',
        }];

        this._functions = this._getFunctions();

        this._rollupFunctions = {
            rollupMin: app.lang.get('LBL_ACTIONBUTTON_MINIMUM'),
            rollupMax: app.lang.get('LBL_ACTIONBUTTON_MAXIMUM'),
            rollupAve: app.lang.get('LBL_ACTIONBUTTON_AVERAGE'),
            rollupSum: app.lang.get('LBL_ACTIONBUTTON_SUM'),
        };

        this._currentRelatedFields = {};
        this._relatedFields = {};
        this._rollupModules = {};
        this._relatedModules = {};
        this._currentRollupFields = {};
        this._rollupFields = {};
        this._functionsHelp = {};
        this._fields = {};
        this._fieldsType = {};

        this._getMeta();
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._cachedElements = new Map();

        this._super('_render');

        _.each(this._dropdowns, function __createSelect2(dropdownData) {
            this._createSelect2(
                dropdownData.selector,
                dropdownData.func,
                dropdownData.query,
                dropdownData.label,
                dropdownData.skipValue,
                dropdownData.format
            );
        }, this);
    },

    /**
     * Finds DOM elements and caches them for later usage
     *
     * @param {string} selector
     *
     * @return {jQuery}
     */
    find: function(selector) {
        var $el = selector && this._cachedElements.has(selector) && this._cachedElements.get(selector);

        if ($el) {
            return $el;
        }

        $el = this.$(selector);

        if (selector && $el.length > 0) {
            this._cachedElements.set(selector, $el);
        }

        return $el;
    },

    /**
     * Return current formula
     *
     * @return {string}
     */
    getFormula: function() {
        return this._formula;
    },

    /**
     * Validates current formula
     *
     * @return {bool}
     */
    isValid: function() {
        if (Object.keys(this._fieldsType).length < 1) {
            return true;
        }

        var isValid = SUGAR.expressions.validateExpressionSidecar(
            this._formula,
            this._fieldsType,
            this._module,
            this._returnType
        );

        var children = this.$el.children();

        children.toggleClass('formula-invalid', !isValid);

        return isValid;
    },

    /**
     * Event handler for whenever the formula changes.
     *
     * @param {UIEvent} e
     *
     */
    formulaChanged: function(e) {
        this._formula = e.currentTarget.value;

        let $el = $(e.currentTarget);
        let $parent = $el.parent();

        if ($parent.hasClass('formula-invalid')) {
            $parent.toggleClass('formula-invalid', false);
        }

        if (this._callback) {
            this._callback(this._formula);
        }
    },

    /**
     * Show UI controls for related field selection
     *
     * @param {UIEvent} e
     *
     */
    showRelatedControllers: function(e) {
        var $button = $(e.currentTarget);
        var $bar = this.find('div.related-action-bar');

        var isActive = $button.hasClass('active');

        $bar.toggleClass('hidden', isActive);
        $button.toggleClass('active', !isActive);
    },

    /**
     * Show UI controls for rollup function selection
     *
     * @param {UIEvent} e
     *
     */
    showRollupControllers: function(e) {
        var $button = $(e.currentTarget);
        var $bar = this.find('div.rollup-action-bar');

        var isActive = $button.hasClass('active');

        $bar.toggleClass('hidden', isActive);
        $button.toggleClass('active', !isActive);
    },

    /**
     * Handle related field addition
     *
     * @param {UIEvent} e
     *
     */
    addRelatedField: function(e) {
        var link = this.find('a[data-select=related-module]').val();
        var field = this.find('a[data-select=related-fields]').val();

        // build the related field and add it to the existing formula
        this._formula = this._formula + 'related($' + link + ', "' + field + '")';
        this.find('textarea.formula-editor').val(this._formula);

        if (this._callback) {
            this._callback(this._formula);
        }
    },

    /**
     * Handle rollup function addition
     *
     * @param {UIEvent} e
     *
     */
    addRollupField: function(e) {
        var link = this.find('a[data-select=rollup-module]').val();
        var field = this.find('a[data-select=rollup-fields]').val();
        var func = this.find('a[data-select=rollup-function]').val();

        // build the rollup field and add it to the existing formula
        this._formula = this._formula + func + '($' + link + ',"' + field + '")';
        this.find('textarea.formula-editor').val(this._formula);

        if (this._callback) {
            this._callback(this._formula);
        }
    },

    /**
     * Handle adding a generic formula function
     *
     * @param {Object} data
     *
     */
    _addFunction: function(data) {
        // adds the function to the already existing formula
        this._formula = this._formula + data.text + '(';
        this.find('textarea.formula-editor').val(this._formula);

        if (this._callback) {
            this._callback(this._formula);
        }
    },

    /**
     * Handle adding a field
     *
     * @param {Object} data
     *
     */
    _addField: function(data) {
        // adds the field to the already existing formula
        this._formula = this._formula + '$' + data.text;
        this.find('textarea.formula-editor').val(this._formula);

        if (this._callback) {
            this._callback(this._formula);
        }
    },

    /**
     * Handle changing the relate module in the relate field UI bar
     *
     * @param {Object} data
     *
     */
    _changeRelatedModule: function(data) {
        // whenever we change the related module we have to change the related fields as well
        this._currentRelatedFields = this._relatedFields[data.text];
    },

    /**
     * Handle changing the rollup module in the rollup function UI bar
     *
     * @param {Object} data
     *
     */
    _changeRollupModule: function(data) {
        // whenever we change the rollup module we have to change the rollup fields as well
        this._currentRollupFields = this._rollupFields[data.text];
    },

    /**
     * Create a generic Select2 control
     *
     * @param {string} id
     * @param {Function} callback
     * @param {string} queryFunction
     * @param {string} label
     * @param {bool} skipValue
     * @param {string} formatOptions
     *
     */
    _createSelect2: function(selector, callback, queryFunction, label, skipValue, formatOptions) {
        var el = this.find(selector)
            .select2(this._getSelect2Options(queryFunction, label, formatOptions))
            .data('select2');

        el.onSelect = (function select(fn) {
            return function returnCallback(data, options) {
                if (callback) {
                    callback(data);
                }

                // we have to reset the select2 display after each select
                if (arguments && skipValue) {
                    arguments[0] = {
                        id: 'select',
                        text: app.lang.get(label)
                    };
                }

                return fn.apply(this, arguments);
            };
        })(el.onSelect);
    },

    /**
     * Create a generic wrapper around a querying function used by the Select2 component to build up the options list
     *
     * @param {string} queryFunction
     * @param {string} label
     * @param {string} formatOptions
     *
     * @return {Object}
     */
    _getSelect2Options: function(queryFunction, label, formatOptions) {
        var select2Options = {};

        select2Options.placeholder = app.lang.get(label);
        select2Options.query = _.bind(this[queryFunction], this);
        select2Options.dropdownAutoWidth = true;

        if (formatOptions) {
            select2Options.formatResult = _.bind(this[formatOptions], this);
        }

        return select2Options;
    },

    /**
     * Return custom Select2 item formatted option, in order to add the item tooltip
     *
     * @param {Object} option
     *
     * @return {string}
     */
    _formatFunctionOptions: function(option) {
        // adds the help for each function as a tooltip
        var text = option.text;
        var help = this._functionsHelp[text] ?
            this._functionsHelp[text] :
            app.lang.get('LBL_ACTIONBUTTON_HELP_NOT_AVAILABLE');
        return '<div data-toggle=\'tooltip\' data-html=\'true\' rel=\'tooltip\' ' +
            ' data-placement=\'right\' title=\'' + _.escape(help) + '\'>' + _.escape(text) + '</div>';
    },

    /**
     * Wrapper for querying functions for select2 components
     *
     * @param {Function} query
     *
     */
    _queryFunctions: function(query) {
        this._query(query, '_functions');
    },

    /**
     * Wrapper for querying fields for select2 components
     *
     * @param {Function} query
     *
     */
    _queryFields: function(query) {
        this._query(query, '_fields');
    },

    /**
     * Wrapper for querying related modules for select2 components
     *
     * @param {Function} query
     *
     */
    _queryRelatedModule: function(query) {
        this._query(query, '_relatedModules');
    },

    /**
     * Wrapper for querying rollup modules for select2 components
     *
     * @param {Function} query
     *
     */
    _queryRollupModule: function(query) {
        this._query(query, '_rollupModules');
    },

    /**
     * Wrapper for querying related fields for select2 components
     *
     * @param {Function} query
     *
     */
    _queryRelatedFields: function(query) {
        this._query(query, '_currentRelatedFields');
    },

    /**
     * Wrapper for querying rollup fields for select2 components
     *
     * @param {Function} query
     *
     */
    _queryRollupFields: function(query) {
        this._query(query, '_currentRollupFields');
    },

    /**
     * Wrapper for querying rollup types for select2 components
     *
     * @param {Function} query
     *
     */
    _queryRollupType: function(query) {
        this._query(query, '_rollupFunctions');
    },

    /**
     * Generic implementation of select2 query method
     *
     * @param {Function} query
     * @param {Object} options
     *
     */
    _query: function(query, options) {
        var listElements = this[options];
        var data = {
            results: [],
            more: false
        };

        // return only the options that match the input query
        if (_.isObject(listElements)) {
            _.each(listElements, function pushValidResults(element, index) {
                if (query.matcher(query.term, element)) {
                    data.results.push({id: index, text: element});
                }
            });
        } else {
            listElements = null;
        }

        query.callback(data);
    },

    /**
     * Return function list
     *
     * @return {Object}
     */
    _getFunctions: function() {
        var typeMap = SUGAR.expressions.Expression.TYPE_MAP;
        var funcMap = SUGAR.FunctionMap;
        var funcList = {};

        for (var functionName in funcMap) {
            if (_.isFunction(funcMap[functionName]) && funcMap[functionName].prototype) {
                for (var functionReturnType in typeMap) {
                    if (funcMap[functionName].prototype instanceof typeMap[functionReturnType]) {
                        funcList[functionName] = functionName;
                        break;
                    }
                }
            }
        }
        return funcList;
    },

    /**
     * Retrieve FormulaBuilder metadata from server
     *
     */
    _getMeta: function() {
        app.api.call(
            'create',
            app.api.buildURL('formulaBuilder/meta'),
            {
                module: this._module
            },
            null,
            {
                success: _.bind(function callback(data) {
                    this._fields = data.fields;
                    this._relatedFields = data.relateFields;
                    this._relatedModules = data.relateModules;
                    this._functionsHelp = data.help;
                    this._rollupFields = data.rollupFields;
                    this._fieldsType = this._getFieldsType(data);

                    if (this._matchField && !this._returnType) {
                        this._returnType = this._getMatchFieldType();
                    }

                    this._calculateRollupModules();
                }, this)
            }
        );
    },

    /**
     * Because of Defect 67228, formula builder doesn't recognize email1 as a valid field,
     * so we're not allowed to use it in our calculations, however for actions such as Compose Email in
     * ActionButtons, it is preferable to also have email1 in order to build the recipient list.
     *
     * This adds the field for any module that has email address support.
     *
     * @param {Object} data
     *
     * @return {Object}
     */
    _getFieldsType: function(data) {
        let fieldsTypes = data.fieldsTypes;

        if (_.has(fieldsTypes, 'email_addresses')) {
            fieldsTypes.email1 = ['email1', 'string'];
        }

        return fieldsTypes;
    },

    /**
     * Get matched field type
     *
     * @return {string}
     */
    _getMatchFieldType: function() {
        var _fieldType = 'string';

        _.each(this._fieldsType, function getType(data) {
            if (data[0] === this._matchField) {
                _fieldType = data[1];
            }
        }, this);

        return _fieldType;
    },

    /**
     * Filter down related modules with rollupable fields and save them
     *
     */
    _calculateRollupModules: function() {
        this._rollupModules = {};
        // build a list of rollup modules from all the valid rollup fields we have
        _.each(this._rollupFields, function getModules(fields, moduleName) {
            if (fields.length > 0 || Object.keys(fields).length > 0) {
                var linkName = '';

                _.each(this._relatedModules, function getLink(relModuleName, relLink) {
                    if (relModuleName === moduleName) {
                        linkName = relLink;
                    }
                });

                this._rollupModules[linkName] = moduleName;
            }
        }, this);
    },
}) },
"tag": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TagField
 * @alias SUGAR.App.view.fields.BaseTagField
 * @extends View.Fields.Base.BaseField
 */
({
	// Tag Field (base) 

    /**
     * HTML tag of the append tag checkbox.
     *
     * @property {String}
     */
    appendTagInput: 'input[name=append_tag]',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // init bean collection used for type aheads
        this.filterResults = app.data.createBeanCollection('Tags');

        // Set appendTagValue for mass update
        if (_.isUndefined(this.model.get('tag_type'))) {
            this.model.setDefault('tag_type', '1');
            this.appendTagValue = true;
        } else {
            this.appendTagValue = this.model.get('tag_type') === '1';
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this.setTagList();

        this._super('_render');

        this.initializeSelect2();
        this.$select2.on('change', _.bind(this.storeValues, this));
        this.$select2.on('select2-selecting', this.handleNewSelection);
    },

    /**
     * Set up tagList variable for use in the list view
     */
    setTagList: function() {
        var self = this;
        this.value = this.getFormattedValue();
        this.tagList = [];
        if (this.value) {
            _.each(this.value, function(tag){
                if (_.isString(tag)) {
                    self.tagList.push(tag);
                } else {
                    self.tagList.push(tag.name);
                }
            })
            this.tagList = this.tagList.join(', ');
        }
    },

    /**
     * @inheritdoc
     */
    format: function(value) {
        return _.map(value, function(tag){
            return _.extend(tag, {encodedValue: encodeURIComponent(tag.name)});
        });
    },

    /**
     * Overrides select2 function. For more details, check out select2's documentation
     *
     * @param term
     * @param results
     * @return {Mixed}
     * @private
     */
    _createSearchChoice: function(term, results) {
        // If tag is for filter, don't allow new choices to be selected
        if (this.view.action === 'filter-rows') {
            return false;
        }

        // Trim up the term for sanity sake
        term = term.trim();

        // Check previously found results to see tag exists with different casing
        if (results && results.length) {
            if (_.find(results, function(tag) {
                return tag.text.toLowerCase() === term.toLowerCase();
            })) {
                return false;
            }
        }
        
        // Check if input is empty after trim
        if (term === '') {
            return false;
        }

        // Check for existence amongst tags that exist but haven't been saved yet
        if (this.checkExistingTags(term)) {
            return false;
        }

        return {
            id: term,
            text: term + ' ' + app.lang.get('LBL_TAG_NEW_TAG'),
            locked: false,
            newTag: true
        };
    },

    /**
     * Check tag select2's currently selected tags for term to see if it already exists (case insensitive)
     * @param term term to be checked
     * @return {boolean} `true` if tag exists already, `false` otherwise
     */
    checkExistingTags: function(term) {
        if (this.$select2 && _.isFunction(this.$select2.val)) {
            var currentSelections = this.$select2.val().split(',');
        }
        if (currentSelections && currentSelections.length) {
            if (_.find(currentSelections, function(tag) {
                return tag.toLowerCase() === term.toLowerCase();
            })) {
                return true;
            }
        }

        return false;
    },

    /**
     * Overrides select2 function. For more details, check out select2's documentation
     * @param query
     * @private
     */
    _query: function(query) {
        var self = this,
            shortlist = {results: []};

        // Trim the query term right up front since it needs to be clean
        query.term = query.term.trim();

        this.filterResults.filterDef = {
            'filter': [{
                'name_lower': { '$starts': query.term.toLowerCase() }
            }]
        };

        // Tags should always be available because it's public
        this.filterResults.module = 'Tags';
        this.filterResults.fetch({
            success: function(data) {
                shortlist.results = self.parseRecords(data.models);

                //Format results so that already existing records don't show up
                shortlist.results = _.reject(shortlist.results, function(result) {
                    return self.checkExistingTags(result.text)
                });

                query.callback(shortlist);
            },
            error: function() {
                app.alert.show('collections_error', {
                    level: 'error',
                    messages: 'LBL_TAG_FETCH_ERROR'
                });
            }
        });
    },

    /**
     * Upon selection of a tag, if it's a new tag, get rid of the text indicating new tag
     * @param {event} e
     */
    handleNewSelection: function(e) {
        // For new tags, look for New Tag indicator and remove it if it's there
        if (e.object.newTag) {
            var newTagIdx = e.object.text.lastIndexOf(' ' + app.lang.get('LBL_TAG_NEW_TAG'));
            e.object.text = e.object.text.substr(0, newTagIdx);
        }
    },

    /**
     * Initialize select2 jquery widget
     */
    initializeSelect2: function() {
        var self = this,
            escapeChars = '!\"#$%&\'()*+,./:;<=>?@[\\]^`{|}~';

        this.$select2 = this.$('.select2field').select2({
            placeholder: '',
            minimumResultsForSearch: 5,
            minimumInputLength: 1,
            tags: true,
            multiple: true,
            closeOnSelect: true,
            width: '100%',
            containerCssClass: 'select2-choices-pills-close',
            tokenSeparators: [','],

            initSelection: function(element, callback) {
                var data = self.parseRecords(self.value);
                callback(data);
            },

            createSearchChoice: _.bind(this._createSearchChoice, this),
            query: _.debounce(_.bind(this._query, this), 300),

            sortResults: function(results, container, query) {
                results = _.sortBy(results, 'text');
                return results;
            }
        });

        this.setSelect2Records();

        // Workaround to make select2 treat enter the same as it would a comma (INT-668)
        this.$('.select2-search-field > input.select2-input').on('keyup', function(e) {
            if (e.keyCode === 13) {
                var val = self.$('input.select2-input').val();

                // Trim the tag
                val = val.trim();

                // Prevent blank tags
                if (val === '') {
                    return;
                }

                // Sanitize input
                if (escapeChars.indexOf(val.charAt(0)) >= 0) {
                    val = '\\\\' + val;
                }

                var tags = self.$select2.select2('data');

                // If the current input already exists as a tag (case insensitive), just exit
                var exists = _.find(tags, function(tag) {
                    return tag.id.toLowerCase() === val.toLowerCase();
                });
                if (exists) {
                    // Close the search box and return
                    self.$select2.select2('close');
                    // Re-opens the search box with the default message
                    // (this is to maintain consistency with select2's OOB tokenizer)
                    self.$select2.select2('open');
                    return;
                }

                // Otherwise, create a tag out of current input
                tags.push({id: val, text: val, locked: false});
                self.$select2.select2('data', tags, true);
                e.preventDefault();

                // Close the search box
                self.$select2.select2('close');
            }
        });
    },

    /**
     * Format related records in select2 format
     * @param {array} list of objects/beans
     */
    parseRecords: function(list) {
        var results = [];

        _.each(list, function(item) {
            var record = item;

            // we may have a bean from a collection
            if (_.isFunction(record.toJSON)) {
                record = record.toJSON();
            }
            if (_.isString(record)) {
                results.push({id: record, text: record});
            } else {
                results.push({id: record.name, text: record.name});
            }
        });

        return results;
    },

    /**
     * Store selected/removed values on our field which is put to the server
     * @param {event} e - event data
     */
    storeValues: function(e) {
        this.value = app.utils.deepCopy(this.value) || [];
        if (e.added) {
            app.analytics.trackEvent('click', 'tag_pill_added');
            // Check if added is an array or a single object
            if (_.isArray(e.added)) {
                // Even if it is an array, only one object gets added at a time,
                // so we just need it to be the first element
                e.added = e.added[0];
            }

            // Check to see if the tag we're adding has already been added.
            var valFound = _.find(this.value, function(vals) {
                return vals.name === e.added.text;
            });

            if (!valFound) {
                this.value.push(e.added.text);
            }
        } else if (e.removed) {
            app.analytics.trackEvent('click', 'tag_pill_removed');
            // Remove the tag
            this.value = _.reject(this.value, function(record) {
                if (_.isString(record)) {
                    return record === e.removed.text;
                } else {
                    return record.name === e.removed.text;
                }
            });
        }
        this.model.set('tag', this.value);
    },

    /**
     * Sanitize the tags and set the select2
     */
    setSelect2Records: function() {
        var escapeChars = '!\"#$%&\'()*+,./:;<=>?@[\\]^`{|}~';
        var records = _.map(this.value, function(record) {
            if (_.isString(record)) {
                // If a special character is the first character of a tag, it breaks select2 and jquery and everything
                // So escape that character if it's the first char
                if (escapeChars.indexOf(record.charAt(0)) >= 0) {
                    return '\\\\' + record;
                }
                return record;
            }
            if (escapeChars.indexOf(record.name.charAt(0)) >= 0) {
                return '\\\\' + record.name;
            }
            return record.name;
        });

        this.$select2.select2('val', records);

    },

    /**
     * Avoid rendering process on Select2 change in order to keep focus
     * @override
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:' + this.name, function() {
                if (!_.isEmpty(this.$select2.data('select2'))) {
                    this.setTagList();
                    this.setSelect2Records();
                } else {
                    this.render();
                }
            }, this);
        }
    },

    /**
     * Override to remove default DOM change listener, we use Select2 events instead
     * @override
     */
    bindDomChange: function() {
        // Borrowed from team set
        var $el = this.$(this.appendTagInput);
        if ($el.length) {
            $el.on('change', _.bind(function() {
                this.appendTagValue = $el.prop('checked');
                this.model.set('tag_type', this.appendTagValue ? '1' : '0');
            }, this));
        }
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        // This line is likewise borrowed from team set
        this.$(this.appendTagInput).off();
        this.$('.select2field').select2('destroy');
        this._super('unbindDom');
    }

}) },
"record-decor": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This field is a container for a field that renders on record view.
 * It's designed to update the style of the label based off the state of the
 * actual field.
 *
 * @class View.Fields.Base.RecordDecorField
 * @alias SUGAR.App.view.fields.BaseRecordDecorField
 * @extends View.Fields.Base.BaseField
 */
({
	// Record-decor Field (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.fields = [];
        this.actualFieldsMeta = [this.def.field];
        this.disabled = false;
        this.context.on('field:disabled', this._setDisabled, this);
    },

    /**
     * Set the disable property and redecorate.
     * @private
     */
    _setDisabled: function(fieldName) {
        var field = this.getActualField();
        if (!field || !field.name) {
            return;
        }
        if (field.name == fieldName) {
            this.disabled = true;
            this.redecorate(field);

        }
    },

    /**
     * Always load the record-decor.hbs template
     * @private
     */
    _loadTemplate: function() {
        this.template = app.template.getField(this.type, 'record-decor', this.module, false);
    },

    /**
     * Render the container first and then render the actual field
     * @return {SUGAR.App.view.fields.RecordDecorField}
     * @private
     */
    _render: function() {
        this._super('_render');
        this.wrapSetMode();
        this._renderFields(this.fields);
        this.bindChange();
        return this;
    },

    /**
     * Renders all the fields inside the record-decor field
     *
     * @param {Array} List of field instances
     * @private
     */
    _renderFields: function(fields) {
        var fieldElems = {};
        this.$('span[sfuuid]').each(function() {
            var $this = $(this);
            var sfId = $this.attr('sfuuid');
            fieldElems[sfId] = $this;
        });
        _.each(fields, function(field) {
            field.setElement(fieldElems[field.sfId]);
            if (field.view.action !== 'create') {
                // Ensures the subfield is given the correct action and renders it
                field.setMode(this.action);
            } else {
                field.render();
            }

            this.redecorate(field);
        }, this);
    },

    /**
     * Gets the field that we are showing on record view. Currently we only
     * have 1 field per container so default to getting the field at the 0 index
     *
     * @return {View.Field}
     */
    getActualField: function() {
        return this.fields[0];
    },

    /**
     * Gets the record cell and caches it for future retrieves
     *
     * @return {jQuery}
     */
    getRecordCell: function() {
        if (this.recordCellDom) {
            return this.recordCellDom;
        }
        return this.recordCellDom = this.$el.parents('.record-cell');
    },

    /**
     * Sets or removes class on the record cell
     * @param style
     */
    setCellStyle: function(style) {
        var $cell = this.getRecordCell();
        if ($cell.length === 0) {
            return;
        }
        if (style === 'pill') {
            $cell.addClass('label-pill');
        } else {
            $cell.removeClass('label-pill');
        }
    },

    /**
     * Set up an event listener on the actual field's model
     * change so that we know to update the look of the rest of the
     * container
     */
    bindChange: function() {
        var field = this.getActualField();
        if (!field || !field.name) {
            return;
        }

        if (_.isArray(field.fields)) {
            _.each(field.fields, function(subField) {
                field.model.on('change:' + subField.name, function() {
                    this.redecorate(field);
                }, this);
            }, this);
        } else {
            field.model.on('change:' + field.name, function() {
                this.redecorate(field);
            }, this);
        }
    },

    /**
     * SetMode is used to toggle a field between detail and edit mode.
     * We wrap it so that we also update our label when setMode is called
     */
    wrapSetMode: function() {
        var field = this.getActualField();
        if (!field || !field.name) {
            return;
        }
        field.setMode = _.wrap(field.setMode, _.bind(function(setMode, args) {
            this.redecorate(field, args);
            setMode.call(field, args);
        }, this));
    },

    /**
     * Change how the contents surrounding the actual field look like
     *
     * @param {View.Field} field The actual field to show/hide based off of state
     * @param {string} toTemplate The action the field will switch to
     */
    redecorate: function(field, toTemplate) {
        // Make sure the field element exists
        if (!field.$el) {
            return;
        }

        // Allow fields to prevent their design to be controlled by record-decor
        if (this.fieldDecorationDisabled(field)) {
            return;
        }

        // Do not redecorate readonly fields
        if (app.utils.isFieldAlwaysReadOnly(field.def, field.viewDefs)) {
            return;
        }

        // First check if we are switching templates (setMode will have the new template)
        // Then check if the field is just re-rendering and use its action
        // Render based off the view's action if the field's action is unknown
        var actionToCheck = toTemplate || field.action || this.view.action || 'detail';
        // In detail mode, we have to show a pill for the label if the field is empty
        if (actionToCheck == 'detail') {
            const editAccess = app.acl.hasAccessToModel('edit', this.model, field.name);

            if (field.isFieldEmpty() && editAccess && !this.disabled &&
                !(this.view && _.contains(this.view.noEditFields, field.name))) {
                this.setCellStyle('pill');
                field.hide();
            } else {
                this.setCellStyle('none');
                field.show();
            }
        } else {
            this.setCellStyle('none');
            field.show();
        }

        if (!field.def.labelsOnTop) {
            this.relocatePencil();
        }
    },

    /**
     * Check the field to see if disableDecoration is set to true for the field,
     * or for a fieldset for its components.
     *
     * @param field
     * @return {boolean}
     */
    fieldDecorationDisabled: function(field) {
        if (field.disableDecoration) {
            return true;
        } else if (field.type === 'fieldset' && _.some(field.fields, function(field) {
            return field.disableDecoration;
        })) {
            return true;
        }
        return false;
    },

    /**
     * In labelsOnSide view, the pencil icon needs to be moved to the left
     * so it hovers near the text
     */
    relocatePencil: function() {
        var field = this.getActualField();

        var cell = this.getRecordCell();
        let isCellHidden = cell.parent().hasClass('hide');

        // if cell is hidden, display it to get non-zero width values
        if (isCellHidden) {
            this.toggleRecordCellDisplay(cell);
        }

        var pencil = cell.find('.sicon-edit');
        var wrapper = cell.find('.record-label-wrapper');
        var label = cell.find('.record-label');
        var wrapperWidth = wrapper.outerWidth();
        var labelWidth = label.outerWidth();

        // if cell was originally hidden, re-hide the cell
        if (isCellHidden) {
            this.toggleRecordCellDisplay(cell);
        }

        var offset = wrapperWidth - labelWidth - 6;
        let css = {};

        // change offset if it's showed children's label instead of label of field
        if (field && field.type === 'fieldset' && field.def.show_child_labels) {
            offset += 26;
        }

        if (field && !field.def.show_child_labels) {
            css = {top: '6px'};
        }

        var direction = app.lang.direction === 'ltr' ? 'left' : 'right';
        css[direction] = offset + 'px';

        pencil.css(css);
    },

    /**
     * Displays or hides the record cell by toggling the parent div's 'hide' class
     *
     * @param {jquery} $cell the record cell
     */
    toggleRecordCellDisplay: function($cell) {
        $cell.parent().toggleClass('hide');
    },

    /**
     * Dispose the child fields
     *
     * @override
     */
    _dispose: function() {
        _.each(this.fields, function(field) {
            field.dispose();
        });
        this._super('_dispose');
    }
}) }
}}
,
"views": {
"base": {
"customCustomViewOne": {"controller": ({
	// CustomCustomViewOne View (base) 

	initialize: function (options) {
        this._super('initialize', [options]);
        //add listener for custom button
        this.context.on('button:alertBtn:click', this.alertDrawer, this);
        this.context.on('button:cancelBtn:click', this.cancelDrawer, this);
    },

	alertDrawer: function()
	{
		App.alert.show('button-fine', {
			level: 'success',
			messages: 'Short Preview Success',
			autoClose: false,
		});
	},

	cancelDrawer: function()
	{
		var linkName = "tasks";
		console.log('before fetching subpanel');
		var subPanelCollection = this.context.parent.getRelatedCollection(linkName);
		console.log('fetched');
		if(subPanelCollection)
		{
			subPanelCollection.fetch({relate: true});
			console.log('refreshed');

		}
		

		App.drawer.close();
	},

})





// temp : Backbone.View.extend({

// 	className: 'view1',
  
// 	events: {
// 	  'click .alertBtn': 'alertDrawer',
// 	  'click .cancelBtn': 'cancelDrawer'
// 	},
  
// 	template: _.template($('#myButtons').html()),
  
// 	initialize: function() {
// 	  this.listenTo(this.model, "change", this.render);
// 	},
  
// 	render: function() {
// 	  this.$el.html(this.template(this.model.attributes));
// 	  return this;
// 	},
  
// 	alertDrawer: function(e) {
// 	  e.preventDefault();
// 	  App.alert.show('button-fine', {
// 			level: 'success',
// 			messages: 'Short Preview Success',
// 			autoClose: false,
// 		});
// 	},
  
// 	cancelDrawer: function(e) {
// 	  e.preventDefault();
// 	  App.drawer.close();
// 	}
  
//   }),








// ({	
// 	className: 'view1',

// 	buttonBinding : function()
// 	{
// 		var BlahView = Backbone.View.extend({
// 			events: {
// 				"click .alertBtn": "alertDrawer",
// 				"click .cancelBtn": "cancelDrawer",
// 			},
		
// 			alertDrawer: function()
// 			{
// 				App.alert.show('button-fine', {
// 				  level: 'success',
// 				  messages: 'Short Preview Success',
// 				  autoClose: false,
// 				});
// 			},
		
// 			cancelDrawer: function()
// 			{
// 				App.drawer.close();
// 			},
// 		});
		
// 		var blahView = new BlahView({ el: $('#myButtons') });
// 	}


// })



	//className: 'view1',


	/*alertDrawer: function()
	{
	    App.alert.show('button-fine', {
	      level: 'success',
	      messages: 'Short Preview Success',
	      autoClose: false,
	    });
	},
	
	cancelDrawer: function()
	{
		App.drawer.close();
	},*/ },
"activitystream": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivitystreamView
 * @alias SUGAR.App.view.views.BaseActivitystreamView
 * @extends View.View
 */
({
	// Activitystream View (base) 

    events: {
        'change div[data-placeholder]': 'checkPlaceholder',
        'keydown div[data-placeholder]': 'checkPlaceholder',
        'keypress div[data-placeholder]': 'checkPlaceholder',
        'input div[data-placeholder]': 'checkPlaceholder',
        'click .reply': 'showAddComment',
        'click .reply-btn': 'addComment',
        'click .preview-btn:not(.disabled)': 'previewRecord',
        'click .comment-btn': 'toggleReplyBar',
        'click .more': 'fetchComments'
    },

    tagName: "li",
    className: "activitystream-posts-comments-container",
    plugins: ['RelativeTime', 'FileDragoff', 'Taggable'],
    cacheNamePrefix: "user:avatars:",
    cacheNameExpire: ":expiry",
    expiryTime: 36000000,   //1 hour in milliseconds
    thresholdRelativeTime: 2, //Show relative time for 2 days and then date time after

    _unformattedPost: null,
    _unformattedComments: {},

    // Based on regular expression from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
    // It is the JavaScript regular expression version of the one in LinkEmbed.php
    urlRegExp: /\b((?:https?:\/\/|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:\'".,<>?]))/ig,

    _attachImageSelector: 'img[data-note-id]',

    /**
     * Modules placed in this array will have links to the module removed from the display
     * e.g. Quotas isn't a real module, has no record view, shouldn't have a link
     */
    blacklistModules: [
        'Quotas'
    ],

    initialize: function(options) {
        this.readonly = !!options.readonly;
        this.nopreview = !!options.nopreview;

        app.view.View.prototype.initialize.call(this, options);

        var lastComment = this.model.get("last_comment");
        this.commentsCollection = app.data.createRelatedCollection(this.model, "comments");

        if (lastComment && !_.isUndefined(lastComment.id)) {
            this.commentsCollection.reset([lastComment]);
        }

        this.model.set("comments", this.commentsCollection);

        // If comment_count is 0, we don't want to decrement the count by 1 since -1 is truthy.
        var count = parseInt(this.model.get('comment_count'), 10);
        this.remaining_comments = 0;
        this.more_tpl = "TPL_MORE_COMMENT";
        if (count) {
            this.remaining_comments = count - 1;

            // Pluralize the comment count label
            if (count > 2) {
                this.more_tpl += "S";
            }
        }

        this.preview = this.getPreviewData();
        var data = this.model.get('data');
        var activityType = this.model.get('activity_type');

        this.tpl = 'TPL_ACTIVITY_' + activityType.toUpperCase();

        if (data.object && !_.isUndefined(data.object.name) && data.object.name === 'LBL_VALUE_ERASED') {
            data.object.name = app.lang.get('LBL_VALUE_ERASED', activityType);
        }
        if (data.subject && !_.isUndefined(data.subject.name) && data.subject.name === 'LBL_VALUE_ERASED') {
            data.subject.name = app.lang.get('LBL_VALUE_ERASED', activityType);
        }

        switch (activityType) {
            case 'post':
                if (!data.value) {
                    this.tpl = null;
                }
                break;
            case 'update':
                data.updateStr = this.processUpdateActivityTypeMessage(data.changes);
                this.model.set('data', data);
                break;
            case 'attach':
                var url,
                    urlAttributes = {
                    module: 'Notes',
                    id: data.noteId,
                    field: 'filename'
                };

                if (data.mimetype && data.mimetype.indexOf("image/") === 0) {
                    url = app.api.buildFileURL(urlAttributes, {
                        htmlJsonFormat: false,
                        passOAuthToken: false,
                        cleanCache: true,
                        forceDownload: false
                    });

                    data.embeds = [{
                        type: "image",
                        src: url,
                        noteId: data.noteId
                    }];
                } else {
                    url = app.api.buildFileURL(urlAttributes);
                }

                data.url = url;
                this.$el.data(data);
                this.model.set('data', data);
                this.model.set('display_parent_type', 'Files');
                break;
        }

        this.processEmbed();
        this.toggleSubmitButton = _.debounce(this.toggleSubmitButton, 200);

        // specify the record that the tags are associated with
        this.setTaggableRecord(this.model.get('parent_type'), this.model.get('parent_id'));
    },

     /**
     * Creates the update message for the activity stream based on the fields changed.
     * @param {object} changes Object containing the changes for the fields of an update activity message
     * @return {string} The formatted message for the update
     */
     processUpdateActivityTypeMessage: function (changes) {
         var updateTpl = Handlebars.compile(app.lang.get('TPL_ACTIVITY_UPDATE_FIELD', 'Activities')),
             parentType = this.model.get("parent_type"),
             fields = app.metadata.getModule(parentType).fields,
             self = this,
             updateStr;

         updateStr = _.reduce(changes, function (memo, changeObj) {
             var fieldMeta = fields[changeObj.field_name],
                 field = app.view.createField({
                     def: fieldMeta,
                     view: self,
                     model: self.model,
                     viewName: 'detail'
                 });

             if (changeObj.before === 'LBL_VALUE_ERASED') {
                 changeObj.before = app.lang.get('LBL_VALUE_ERASED', parentType);
             } else {
                 changeObj.before = field.format(changeObj.before);
             }
             if (changeObj.after === 'LBL_VALUE_ERASED') {
                 changeObj.after = app.lang.get('LBL_VALUE_ERASED', parentType);
             } else {
                 changeObj.after = field.format(changeObj.after);
             }

             changeObj.field_label = app.lang.get(fields[changeObj.field_name].vname, parentType);

             if (memo) {
                 return updateTpl(changeObj) + ', ' + memo;
             }
             return updateTpl(changeObj);
         }, '');

         return updateStr;
     },

    /**
     * Get embed templates to be processed on render
     */
    processEmbed: function() {
        var data = this.model.get('data');

        if (!_.isEmpty(data.embeds)) {
            this.embeds = [];
            _.each(data.embeds, function(embed) {
                var typeParts = embed.type.split('.'),
                    type = typeParts.shift(),
                    embedTpl;

                _.each(typeParts, function(part) {
                    type = type + part.charAt(0).toUpperCase() + part.substr(1);
                });

                embedTpl = app.template.get(this.name + '.' + type + 'Embed');
                if (embedTpl) {
                    this.embeds.push(embedTpl(embed));
                }
            }, this);
        }
    },

    fetchComments: function() {
        var self = this;
        this.commentsCollection.fetch({
            //Don't show alerts for this request
            showAlerts: false,
            relate: true,
            success: function(collection) {
                self.remaining_comments = 0;
                self.render();
            }
        });
    },

    /**
     * Event handler for clicking comment button -- shows a post's comment box.
     * @param  {Event} e
     */
    showAddComment: function(e) {
        var currentTarget = this.$(e.currentTarget);

        currentTarget.closest('li').find('.activitystream-comment').toggle();
        currentTarget.closest('li').find('.activitystream-comment').find('.sayit').focus();

        e.preventDefault();
    },

    /**
     * Creates a new comment on a post.
     * @param {Event} event
     */
    addComment: function (event) {
        var self = this,
            parentId = this.model.id,
            payload = {
                parent_id: parentId,
                data: {}
            },
            bean;

        payload.data = this.getComment();

        if (payload.data.value && (payload.data.value.length > 0)) {
            bean = app.data.createRelatedBean(this.model, null, 'comments');
            bean.save(payload, {
                relate: true,
                success: _.bind(self.addCommentCallback, self)
            });
        }
    },

    /**
     * Callback for rendering a newly added comment into the activity stream view
     * @param  {Object} model
     */
    addCommentCallback: function (model) {
        var template, data;

        this.$('div.reply').empty().trigger('change');
        this.commentsCollection.add(model);
        this.toggleReplyBar();

        template = app.template.getView('activitystream.comment');

        data = model.get('data');
        data.value = this.formatTags(data.value);
        data.value = this.formatLinks(data.value);

        this.processAvatars();
        this.$('.comments').prepend(template(model.attributes));
        this.context.trigger('activitystream:post:prepend', this.model);
    },

    /**
     * Handler for previewing a record listed on the activity stream.
     * @param  {Event} event
     */
    previewRecord: function(event) {
        var el = this.$(event.currentTarget),
            data = el.data(),
            module = data.module,
            id = data.id;

        // Remove highlighted styling from all activities
        this.layout.clearRowDecorations();

        // If module/id data attributes don't exist, this user
        // doesn't have access to that record due to team security.
        if (module && id) {
            var model = app.data.createBean(module),
                collection = this.context.get("collection");

            model.set("id", id);
            this.decorateRow();
            app.events.trigger("preview:module:update", this.context.get("module"));
            app.events.trigger("preview:render", model, collection, true, this.cid);
        }

        event.preventDefault();
    },

    /**
     * Handles highlighting of current activity item and active state of preview button.
     */
    decorateRow: function() {
        this.$el.addClass('highlighted');
        this.$('.preview-btn')
            .addClass('active')
            .attr('aria-pressed', true);
    },

    _renderHtml: function(model) {
        // Save state of the reply bar before rendering
        var isReplyBarOpen = this.$(".comment-btn").hasClass("active") && this.$(".comment-btn").is(":visible"),
            replyVal = this.$(".reply").html();

        this.processAvatars();
        this.formatAllTagsAndLinks();

        this._setRelativeTimeAvailable();

        app.view.View.prototype._renderHtml.call(this);

        // If the reply bar was previously open, keep it open (render hides it by default)
        if (isReplyBarOpen) {
            this.toggleReplyBar();
            this.$(".reply").html(replyVal);
        }

        this._addBrokenImageHandler();
    },

    /**
     * Add a listener for when activity has a broken image for attach type posts
     * Remove the broken image and remove link to broken image
     *
     * @private
     */
    _addBrokenImageHandler: function() {
        this.$(this._attachImageSelector).on('error', _.bind(function(event) {
            var $brokenImg = $(event.currentTarget),
                linkSelector = 'a[data-note-id="' + $brokenImg.data('note-id') + '"]';

            //first remove the link to the image which will also be broken
            //FIXME: this is hacky, but temporary until we fix how attachment posts are displayed in MAR-780
            this.$(linkSelector).contents().unwrap();
            //then remove the broken image
            $brokenImg.closest('div[class="embed"]').remove();
        }, this));
    },

    /**
     * Sets property on activity to show date created as a relative time or as date time.
     *
     * @private
     */
    _setRelativeTimeAvailable: function() {
        var diffInDays = app.date().diff(this.model.get('date_entered'), 'days', true);
        this.useRelativeTime = (diffInDays <= this.thresholdRelativeTime);
    },

    /**
     * Format all tags and link in post and comments.
     */
    formatAllTagsAndLinks: function() {
        var post = this.model.get('data');

        // Check to see if the post's module is in the blacklist, if so, delete
        // the module property from the object so it will not create a link to the record
        if (post.object && post.object.module && _.contains(this.blacklistModules, post.object.module)) {
            delete post.object.module;
        }

        this.unformatAllTagsAndLinks();

        if (post) {
            this._unformattedPost = post.value;
            post.value = this.formatLinks(post.value);
            post.value = this.formatTags(post.value);
        }

        this.commentsCollection.each(function(model) {
            var data = model.get('data');
            this._unformattedComments[model.get('id')] = data.value;
            data.value = this.formatLinks(data.value);
            data.value = this.formatTags(data.value);
        }, this);
    },

    /**
     * Revert back to the unformatted version of tags and links
     */
    unformatAllTagsAndLinks: function() {
        var post = this.model.get('data');
        if (post) {
            post.value = this._unformattedPost || post.value;
        }

        this.commentsCollection.each(function(model) {
            var data = model.get('data');
            data.value = this._unformattedComments[model.get('id')] || data.value;
        }, this);
    },

    /**
     * Searches the post to identify links and make them as actual links
     *
     * @param {String} post
     * @return {string}
     */
    formatLinks: function(post) {
        var formattedPost = '';

        if (post && (post.length > 0)) {
            formattedPost = post.replace(this.urlRegExp, function(url) {
                var href = url;
                if ((url.indexOf('http://') !== 0) && (url.indexOf('https://') !== 0)) {
                    href = 'http://' + url;
                }
                let a = document.createElement('a');
                a.href = href;
                a.innerText = url;
                a.target = '_blank';

                return a.outerHTML;
            });
        }

        return formattedPost;
    },

    /**
     * Sets the profile picture for activities based on the created by user.
     */
    processAvatars: function () {
        var comments = this.model.get('comments'),
            postPictureUrl;

        if (this.model.get('activity_type') === 'post' && !this.model.get('picture_url')) {
            postPictureUrl = this.getAvatarUrlForUser(this.model, 'post');
            this.model.set('picture_url', postPictureUrl);
        }

        if (comments) {
            comments.each(function (comment) {
                var commentPictureUrl = this.getAvatarUrlForUser(comment, 'comment');
                comment.set('picture_url', commentPictureUrl);
            }, this);
        }
    },

    /**
     * Builds and returns the url for the user's profile picture based on fetching from cache
     * @param model
     * @param activityType
     * @return {string}
     */
    getAvatarUrlForUser: function (model, activityType){
        var createdBy = model.get('created_by'),
            hasPicture = this.checkUserHasPicture(model, activityType);

        return hasPicture ? this.buildAvatarUrl(createdBy) : '';
    },

    /**
     * Checks cache to see if user has a picture, calls API if needed
     *
     * @param model The User
     * @param activityType
     * @return {boolean} whether user has a picture
     */
    checkUserHasPicture: function (model, activityType) {
        var createdBy = model.get('created_by'),
            hasPicture;

        // If processing the current user's avatar, no need to fetch
        if (createdBy === app.user.get('id')) {
            hasPicture = !_.isEmpty(app.user.get('picture'));
        } else {
            // Check cache
            hasPicture = this.getUserPictureStatus(createdBy);
        }

        // If not current user or cached, call api to check if user has a picture
        if (_.isUndefined(hasPicture)) {
            this.fetchUserPicture(model, activityType);
            hasPicture = false; // Use placeholder until api call finishes
        }

        return hasPicture;
    },

    /**
     * Retrieves a user and caches the results of whether the user has a profile picture.
     * Replaces the default icon with an image tag of the profile picture.
     *
     * @param model
     * @param activityType
     */
    fetchUserPicture: function(model, activityType) {
        var self = this,
            createdBy = model.get('created_by'),
            user = app.data.createBean('Users', {id: createdBy});

        user.fetch({
            fields: ["picture"],
            success: function () {
                var pictureUrl = self.buildAvatarUrl(createdBy),
                    hasPicture = !_.isEmpty(user.get('picture'));

                self.setUserPictureStatus(createdBy, hasPicture);

                // If picture exists, replace the activity image with the user's profile picture
                if (hasPicture) {
                    self.$('#avatar-' + activityType + '-' + model.get('id')).html("<img src='" + pictureUrl + "' alt='" + model.get('created_by_name') + "'>");
                }
            },
            error: function () {
                // Problem retrieving picture, use placeholder
                self.setUserPictureStatus(createdBy, false);
            }
        });
    },

    /**
     * Retrieve from the app cache whether user has a picture
     * Respects cache TTL, returns undefined if expired
     *
     * @param userId
     * @return {boolean|undefined} whether user has picture or `undefined` if cache not set or expired
     * @private
     */
    getUserPictureStatus: function(userId) {
        var hasPicture = app.cache.get(this.cacheNamePrefix + userId),
            cachedTTL = app.cache.get(this.cacheNamePrefix + userId + this.cacheNameExpire);

        return (cachedTTL < $.now()) ? undefined : hasPicture;
    },

    /**
     * Cache whether the user has a picture or not
     *
     * @param userId
     * @param hasPicture
     * @private
     */
    setUserPictureStatus: function(userId, hasPicture) {
        app.cache.set(this.cacheNamePrefix + userId, hasPicture);
        app.cache.set(this.cacheNamePrefix + userId + this.cacheNameExpire, $.now() + this.expiryTime);
    },

    /**
     * Build the file url for the given user's avatar
     *
     * @param userId
     * @return {string} The avatar url
     * @private
     */
    buildAvatarUrl: function(userId) {
        return app.api.buildFileURL({
            module: 'Users',
            id: userId,
            field: 'picture'
        });
    },

    toggleReplyBar: function() {
        var isHidden = this.$('.reply-area').hasClass('hide');
        this.$('.reply-area').toggleClass('hide', !isHidden);
        this.$('.comment-btn')
            .toggleClass('active', isHidden)
            .attr('aria-pressed', isHidden);
    },

    /**
     * Retrieve comment entered inside content editable and translate any tags into text format
     * so that it can be saved in the database as JSON string.
     *
     * @return {string}
     */
    getComment: function() {
        return this.unformatTags(this.$('div.reply'));
    },

    /**
     * Determines the status and label for the preview button.
     *
     * @return {Object}
     * @return {Boolean} return.enabled Whether the preview is enabled.
     * @return {String} return.label The label to display in the preview button
     *   tooltip.
     */
    getPreviewData: function () {
        var parentModel,
            preview = {
                enabled: true,
                label: 'LBL_PREVIEW'
            },
            isBwcEnabled,
            module = this.model.get('display_parent_type');

        if (module) {
            // assume modules without metadata are BWC by default.
            isBwcEnabled = true;
            var moduleMetadata = app.metadata.getModule(module);
            if (moduleMetadata && _.has(moduleMetadata, 'isBwcEnabled')) {
                isBwcEnabled = moduleMetadata.isBwcEnabled;
            }
        } else {
            isBwcEnabled = false;
        }

        if (isBwcEnabled) {
            preview.enabled = false;
            preview.label = 'LBL_PREVIEW_BWC_TOOLTIP';
        } else if (this.model.get("activity_type") === 'attach') { //no preview for attachments
            preview.enabled = false;
            preview.label = 'LBL_PREVIEW_DISABLED_ATTACHMENT';
        } else if (_.isEmpty(this.model.get('display_parent_id')) || _.isEmpty(this.model.get('display_parent_type'))) {  //no related record
            preview.enabled = false;
            preview.label = 'LBL_PREVIEW_DISABLED_NO_RECORD';
        } else if (!app.acl.hasAccess("view", this.model.get('display_parent_type'))) { //no access to related record
            preview.enabled = false;
            preview.label = 'LBL_PREVIEW_DISABLED_NO_ACCESS';
        } else if (this.model.get('preview_enabled') === false) { //deleted or no team access to related record
            preview.enabled = false;
            preview.label = this.model.get('preview_disabled_reason');
        } else {
            parentModel = this._getParentModel('record', this.context);
            // Check if the bean to be previewed is the same as the context.
            if (parentModel && parentModel.module == this.model.get('display_parent_type') && parentModel.id === this.model.get('display_parent_id')) {
                preview.enabled = false;
                preview.label = 'LBL_PREVIEW_DISABLED_SAME_RECORD';
            }
        }

        return preview;
    },

    /**
     * Traverse up the context hierarchy and look for given layout, retrieve the model from the layout's context
     *
     * @param layoutName to look for up the context hierarchy
     * @param context start of context hierarchy
     * @return {Mixed}
     * @private
     */
    _getParentModel: function(layoutName, context) {
        if (context) {
            if (context.get('layout') === layoutName) {
                return context.get('model');
            } else {
                return this._getParentModel(layoutName, context.parent);
            }
        } else {
            return null;
        }
    },

    /**
     * Toggle the Submit button disabled/enabled state.
     */
    toggleSubmitButton: function(enable) {
        if (!enable) {
            this.disableSubmitButton();
        } else {
            this.enableSubmitButton();
        }
    },

    /**
     * Enable Submit button
     */
    enableSubmitButton: function() {
        this.$('.reply-btn')
            .removeClass('disabled')
            .attr('aria-disabled', false)
            .attr('tabindex', 0);
    },

    /**
     * Disable Submit button
     */
    disableSubmitButton: function() {
        this.$('.reply-btn')
            .addClass('disabled')
            .attr('aria-disabled', true)
            .attr('tabindex', -1);
    },

    /**
     * If the reply area has content, remove placeholder and
     * enable the reply button
     */
    checkPlaceholder: function(e) {
        // We can't use any of the jQuery methods or use the dataset property to
        // set this attribute because they don't seem to work in IE 10. Dataset
        // isn't supported in IE 10 at all.
        var el = e.currentTarget;
        if (el.textContent) {
            el.setAttribute('data-hide-placeholder', 'true');
            this.toggleSubmitButton(true);
        } else {
            el.removeAttribute('data-hide-placeholder');
            this.toggleSubmitButton(false);
        }
    },

    /**
     * Data change event.
     */
    bindDataChange: function () {
        if (this.commentsCollection) {
            this.commentsCollection.on("add", function () {
                this.model.set('comment_count', this.model.get('comment_count') + 1);
            }, this);
        }
        app.view.View.prototype.bindDataChange.call(this);
    },

    unbindData: function() {
        if (this.commentsCollection) {
            this.commentsCollection.off();
        }
        app.view.View.prototype.unbindData.call(this);
    },

    _dispose: function() {
        $(window).off('resize.' + this.cid);
        this.$(this._attachImageSelector).off('error');
        app.view.View.prototype._dispose.call(this);
        this.commentsCollection = null;
    }
}) },
"dashletselect": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * "Add a dashlet" view.
 * Displays a list of dashlets filtered according to current module and layout.
 *
 * @class View.Views.Base.DashletselectView
 * @alias SUGAR.App.view.views.DashletselectView
 * @extends View.Views.Base.FilteredListView
 */
({
	// Dashletselect View (base) 

    extendsFrom: 'FilteredListView',

    /**
     * @inheritdoc
     *
     * Displays a filtered list of dashlets.
     * Uses client-generated collection with disabled load state, custom
     * preview and select actions.
     */
    initialize: function(options) {
        var meta = app.metadata.getView(null, 'dashletselect') || {};
        options.meta = _.extend({}, meta, options.meta || {});

        this._super('initialize', [options]);

        // To avoid reset while sorting.
        this.context = _.extend(_.clone(this.context), {
            resetLoadFlag: function() {
                return;
            }
        });

        this.context.on('dashletlist:select-and-edit', function(model) {
            this.selectDashlet(model.get('metadata'));
        }, this);

        this.context.on('dashletlist:preview:fire', function(model) {
            let currentElem = this.$('tr[data-type=' + model.get('type') + '] a.rowaction.btn');

            this.$('a.rowaction.btn').removeClass('active');
            currentElem.addClass('active');

            this.previewDashlet(model.get('metadata'));
        }, this);
    },

    /**
     * Load dashlet preview by passing preview metadata
     *
     * @param {Object} metadata Preview metadata.
     */
    previewDashlet: function(metadata) {
        var layout = this.layout,
            previewLayout;
        while (layout) {
            if (layout.getComponent('preview-pane')) {
                previewLayout = layout.getComponent('preview-pane').getComponent('dashlet-preview');
                previewLayout.showPreviewPanel();
                break;
            }
            layout = layout.layout;
        }

        if (previewLayout) {
            // If there is no preview property, use the config property
            if (!metadata.preview) {
                metadata.preview = metadata.config;
            }
            var previousComponent = _.last(previewLayout._components);
            if (previousComponent.name !== 'dashlet-preview') {
                var index = previewLayout._components.length - 1;
                previewLayout._components[index].dispose();
                previewLayout.removeComponent(index);
            }

            if (app.controller.context.get('layout') == 'portaltheme-config' && app.metadata.portalModules) {
                metadata.preview.module = app.metadata.portalModules[0];
            }

            var contextDef,
                component = {
                    label: app.lang.get(metadata.label, metadata.preview.module),
                    type: metadata.type,
                    preview: true
                };
            if (metadata.preview.module || metadata.preview.link) {
                contextDef = {
                    skipFetch: false,
                    forceNew: true,
                    module: metadata.preview.module,
                    link: metadata.preview.link
                };
            } else if (metadata.module) {
                contextDef = {
                    module: metadata.module
                };
            }

            component.view = _.extend({module: metadata.module}, metadata.preview, component);
            if (contextDef) {
                component.context = contextDef;
            }

            previewLayout.initComponents([
                {
                    layout: {
                        type: 'dashlet-grid-wrapper',
                        label: app.lang.get(metadata.preview.label || metadata.label, metadata.preview.module),
                        preview: true,
                        components: [
                            component
                        ]
                    }
                }
            ], this.context);
            previewLayout.loadData();
            previewLayout.render();
        }
    },

    /**
     * Load dashlet configuration view by passing configuration metadata
     *
     * @param {Object} metadata Configuration metadata.
     */
    selectDashlet: function(metadata) {
        var model = new app.Bean();

        // On the multi-line list and focus view, side drawer/focus drawer the dashlets need
        // the correct module context, which is set here.
        var contextModule;
        var contextModel = this.context.get('model');
        if (contextModel && _.contains(['multi-line', 'focus'], contextModel.get('view_name'))) {
            contextModule = contextModel.get('dashboard_module');
        }
        // Set module for SugarLive console
        if (contextModel && contextModel.get('view_name') === 'omnichannel' && this.context.parent) {
            contextModule = this.context.parent.get('module');
        }
        var dashletConfigModule = metadata.config.module || metadata.module || contextModule;

        app.drawer.load({
            layout: {
                type: 'dashletconfiguration',
                components: [
                    {
                        view: _.extend({}, metadata.config, {
                            label: app.lang.get(metadata.label, metadata.config.module),
                            type: metadata.type,
                            config: true,
                            module: dashletConfigModule
                        })
                    }
                ]
            },
            context: {
                module: dashletConfigModule,
                model: model,
                forceNew: true,
                skipFetch: true
            }
        });
    },

    /**
     * Filtering the available dashlets with the current page's module and
     * layout view.
     *
     * @param {Array} dashlets A list of dashlet components.
     * @return {Array} A list of filtered dashlet set.
     */
    getFilteredList: function(dashlets) {
        var alwaysRecordViewDashboards = ['multi-line', 'focus', 'omnichannel'];
        var useRecordViewDashlets = this.context && this.context.parent &&
            _.contains(alwaysRecordViewDashboards, this.context.parent.get('layout'));

        var parentContext = useRecordViewDashlets ? this.context.parent : app.controller.context;
        var parentModule = parentContext.get('module');

        // always show record view dashlets for certain dashboards
        var parentView = useRecordViewDashlets ? 'record' : parentContext.get('layout');
        var externalAppDashlet;
        var filteredDashlets = _.chain(dashlets)
            .filter(function(dashlet) {
                var filter = dashlet.filter;
                // if there is no filter for this dashlet, include it
                if (_.isUndefined(filter)) {
                    return true;
                }

                if (dashlet.type === 'external-app-dashlet') {
                    // save a reference to the external-app-dashlet def
                    // since we're already looping over them
                    externalAppDashlet = dashlet;
                    // don't include external-app-dashlet in the list of dashlets yet
                    return false;
                }

                var filterModules = filter.module || [parentModule];
                var filterViews = filter.view || [parentView];
                let filterLicenses = filter.licenseType ? filter.licenseType : app.user.get('licenses');

                if (_.isString(filterModules)) {
                    filterModules = [filterModules];
                }
                if (_.isString(filterViews)) {
                    filterViews = [filterViews];
                }

                if (_.isString(filterLicenses)) {
                    filterLicenses = [filterLicenses];
                }

                // if the filter is matched, then this will be true
                var inModuleAndView = _.contains(filterModules, parentModule) && _.contains(filterViews, parentView);

                // check if we got the right license
                let hasValidLicense = filterLicenses ? app.user.hasLicense(filterLicenses) : true;

                // also allow blacklisting in addition to whitelisting
                var blacklisted = false;
                if (filter.blacklist) {
                    filterModules = filter.blacklist.module || [];
                    if (_.isString(filterModules)) {
                        filterModules = [filterModules];
                    }
                    filterViews = filter.blacklist.view || [];
                    if (_.isString(filterViews)) {
                        filterViews = [filterViews];
                    }

                    blacklisted = _.contains(filterModules, parentModule) || _.contains(filterViews, parentView);
                }

                return inModuleAndView && hasValidLicense && !blacklisted;
            })
            .value();

        if (app.config.catalogEnabled) {
            // only do this check if Catalog is enabled
            var dashletView = parentView === 'records' ? 'list-dashlet' : 'record-dashlet';
            var dashletMeta = app.metadata.getLayout(parentModule, dashletView);
            if (dashletMeta) {
                // loop through components to see if any of them call for
                // customConfig true -- convert those to dashlet view metadata
                _.each(dashletMeta.components, function(comp) {
                    if (comp.view.customConfig) {
                        filteredDashlets = filteredDashlets.concat(app.utils.convertCompToDashletView(comp));
                    }
                }, this);
                // if there is a Sugar App already set to load in this module's list or record dashlet spot
                // add the external-app-dashlet def to the filteredDashlets
                filteredDashlets.push(externalAppDashlet);
            }
        }
        return filteredDashlets;
    },

    /**
     * Iterates dashlets metadata and extract the dashlet components among them.
     *
     * @param {String} type The component type (layout|view).
     * @param {String} name The component name.
     * @param {String} module The module name.
     * @param {Object} meta The metadata.
     * @return {Array} list of available dashlets.
     * @private
     */
    _getDashlets: function(type, name, module, meta) {
        var dashlets = [],
            hadDashlet = meta && meta.dashlets &&
                app.view.componentHasPlugin({
                    type: type,
                    name: name,
                    module: module,
                    plugin: 'Dashlet'
                });
        if (!hadDashlet) {
            return dashlets;
        }
        _.each(meta.dashlets, function(dashlet) {
            if (!dashlet.config) {
                return;
            }
            var description = app.lang.get(dashlet.description, dashlet.config.module);
            if (!app.acl.hasAccess('access', module || dashlet.config.module)) {
                return;
            }
            dashlets.push({
                type: name,
                filter: dashlet.filter,
                metadata: _.extend({
                    component: name,
                    module: module,
                    type: name
                }, dashlet),
                title: app.lang.get(dashlet.label, dashlet.config.module),
                description: description
            });
        }, this);
        return dashlets;
    },

    /**
     * Retrieves all base view's metadata.
     *
     * @return {Array} All base view's metadata.
     * @private
     */
    _addBaseViews: function() {
        var components = [];
        _.each(app.metadata.getView(), function(view, name) {
            var dashlets = this._getDashlets('view', name, null, view.meta);
            if (!_.isEmpty(dashlets)) {
                components = _.union(components, dashlets);
            }
        }, this);
        return components;
    },

    /**
     * Retrieves all module view's metadata.
     *
     * @return {Array} The module view's metadata.
     * @private
     */
    _addModuleViews: function() {
        var components = [];
        _.each(app.metadata.getModuleNames({filter: 'visible'}), function(module) {
            _.each(app.metadata.getView(module), function(view, name) {
                var dashlets = this._getDashlets('view', name, module, view.meta);
                if (!_.isEmpty(dashlets)) {
                    components = _.union(components, dashlets);
                }
            }, this);
        }, this);
        return components;
    },

    /**
     * @inheritdoc
     *
     * Instead of fetching context, it will retrieve all dashable components
     * based on metadata. Sorts the components by `title` alphabetically.
     */
    loadData: function() {
        if (this.collection.length) {
            this.filteredCollection = this.collection.models;
            return;
        }

        var dashletCollection = _.union(this._addBaseViews(), this._addModuleViews()),
            filteredDashletCollection = this.getFilteredList(dashletCollection);

        this.collection.comparator = function(model) {
            return model.get('title');
        };

        this.collection.add(filteredDashletCollection);
        this.collection.dataFetched = true;
        this._renderData();
    },

    /**
     * @inheritdoc
     *
     * DashletSelect isn't a read module, no need to compare fields with defs.
     */
    getFields: function() {
        return _.flatten(_.pluck(this.meta.panels, 'fields'));
    }

}) },
"omnichannel-search-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * List view for the {@link View.Layouts.Base.SearchLayout
 * Search layout}.
 *
 * @class View.Views.Base.OmnichannelSearchFilterView
 * @alias SUGAR.App.view.views.BaseOmnichannelSearchFilterView
 * @extends View.View
 */
({
	// Omnichannel-search-filter View (base) 

    className: 'omnichannel-search-filter-wrapper',

    events: {
        'click .omnichannel-search-facet-select': 'facetClicked'
    },

    /**
     * The collection facets/filters currently applied by the user
     */
    selectedFacets: {},

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // Share the same collection as other views in the parent layout
        this.collection = this.layout.collection;
        this.collection.on('sync', this.render, this);

        this.selectedFacets = {};

        // Pull previously selected facets on search
        var dashboard = this._getOmnichannelDashboard();
        if (dashboard && dashboard.searchSelectedFacets) {
            this.selectedFacets = dashboard.searchSelectedFacets;
        }

        app.events.on('omnichannelsearch:bar:search:started', this._handleBarSearchStarted, this);
        app.events.on('omnichannelsearch:bar:search:complete', this._handleBarSearchComplete, this);
    },

    /**
     * Handles when a search from the search bar is completed
     *
     * @private
     */
    _handleBarSearchComplete: function() {
        this._initializeSelectedFacets();
        this.render();
    },

    /**
     * Handles when pagination is initiated in the search list results
     *
     * @private
     */
    _handleBarSearchStarted: function() {
        this.collection.dataFetched = false;
        this.render();
    },

    /**
     * Get the omnichannel-dashboard component
     * @return {Data.Layout}
     * @private
     */
    _getOmnichannelDashboard: function() {
        return this.closestComponent('omnichannel-dashboard');
    },
    /**
     * Builds the selected facets object to be sent to the server when fetching
     *
     * @private
     */
    _initializeSelectedFacets: function() {
        var facets = this.collection.xmod_aggs;
        _.each(facets, function(facet, key) {
            if (key === 'modules') {
                this.selectedFacets[key] = [];
            } else {
                this.selectedFacets[key] = false;
            }
        }, this);

        this.context.set('selectedFacets', this.selectedFacets);

        var dashboard = this._getOmnichannelDashboard();
        if (dashboard) {
            dashboard.searchSelectedFacets = this.selectedFacets;
        }
    },

    /**
     * @inheritdoc
     *
     * Builds the facets objects for the template to display the module and
     * property facets correctly
     */
    _render: function() {
        this._initModuleFacets();
        this._initPropertyFacets();

        var dashboard = this._getOmnichannelDashboard();
        if (dashboard) {
            dashboard.searchModuleFacets = this.moduleFacets;
            dashboard.searchPropertyFacets = this.propertyFacets;
        }
        this._super('_render');
    },

    /**
     * Builds the module facets objects for the template
     *
     * @private
     */
    _initModuleFacets: function() {
        var moduleFacets = [];

        // The xmod_aggs collection property stores information about how many
        // records from each module facet are in the results
        var aggs = this.collection.xmod_aggs || {};
        var moduleResults = aggs && aggs.modules && aggs.modules.results;
        if (!_.isEmpty(moduleResults)) {
            _.each(moduleResults, function(count, moduleName) {
                moduleFacets.push({
                    facetId: 'modules',
                    facetCriteriaId: moduleName,
                    label: app.lang.getModuleName(moduleName, {plural: true}),
                    count: count,
                    selected: _.contains(this.selectedFacets.modules, moduleName)
                });
            }, this);
        }

        this.moduleFacets = moduleFacets;
    },

    /**
     * Builds the property facets objects for the template (Assigned to me,
     * Created by me, etc.)
     *
     * @private
     */
    _initPropertyFacets: function() {
        var propertyFacets = [];

        // The xmod_aggs collection property stores information about how many
        // records from each property facet are in the results
        var aggs = this.collection.xmod_aggs || {};
        var facetMeta = this.meta && this.meta.facets;
        _.each(facetMeta, function(facet) {
            var aggData = aggs[facet.facet_id];
            var count = aggData && aggData.results && aggData.results.count || 0;
            propertyFacets.push({
                facetId: facet.facet_id,
                facetCriteriaId: facet.facet_id,
                label: app.lang.get(facet.label),
                count: count,
                selected: this.selectedFacets[facet.facet_id] || false
            });
        }, this);

        this.propertyFacets = propertyFacets;
    },

    /**
     * Handles when a facet is selected/deselected by the user
     *
     * @param {Event} event the click event
     */
    facetClicked: function(event) {
        // Update the selected facets
        var currentTarget = this.$(event.currentTarget);
        var facetEl = currentTarget.closest('[data-facet-id]');
        var facetId = facetEl.data('facet-id');
        var facetCriteriaId = facetEl.data('facet-criteria-id');
        this._updateSelectedFacets(facetId, facetCriteriaId, facetId !== 'modules');

        // Refetch the collection with the updated list of selected facets
        var options = {
            apiOptions: {
                data: {
                    agg_filters: this.selectedFacets
                },
                fetchWithPost: true,
                useNewApi: true
            }
        };
        this.layout.trigger('omnichannelsearch:filtering:started');
        this.collection.fetch(options);
    },

    /**
     * Updates {@link #selectedFacets} with the facet change.
     *
     * @param {string} facetId The facet type
     * @param {string} facetCriteriaId The id of the facet criteria
     * @param {boolean} isSingleItem `true` if it's a single item facet
     * @private
     */
    _updateSelectedFacets: function(facetId, facetCriteriaId, isSingleItem) {
        if (isSingleItem) {
            this.selectedFacets[facetId] = !this.selectedFacets[facetId];
        } else {
            var index;
            if (this.selectedFacets[facetId]) {
                index = this.selectedFacets[facetId].indexOf(facetCriteriaId);
            } else {
                this.selectedFacets[facetId] = [];
            }
            if (_.isUndefined(index) || index === -1) {
                this.selectedFacets[facetId].splice(0, 0, facetCriteriaId);
            } else {
                this.selectedFacets[facetId].splice(index, 1);
                if (this.selectedFacets[facetId].length === 0) {
                    delete this.selectedFacets[facetId];
                }
            }
        }

        this.context.set('selectedFacets', this.selectedFacets);
        var dashboard = this._getOmnichannelDashboard();
        if (dashboard) {
            dashboard.searchSelectedFacets = this.selectedFacets;
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.collection.off('sync', this.render, this);
        app.events.off('omnichannelsearch:bar:search:started', this._handleBarSearchStarted, this);
        app.events.off('omnichannelsearch:bar:search:complete', this._handleBarSearchComplete, this);
    }
}) },
"editmodal": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.EditmodalView
 * @alias SUGAR.App.view.views.BaseEditmodalView
 * @extends View.Views.Base.BaseeditmodalView
 */
({
	// Editmodal View (base) 

    extendsFrom:'BaseeditmodalView',
    fallbackFieldTemplate: 'edit',
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        if (this.layout) {
            this.layout.on('app:view:activity:editmodal', function() {
                this.context.set('createModel',
                    app.data.createRelatedBean(app.controller.context.get('model'), null, 'notes', {})
                );
                this.render();
                this.$('.modal').modal({backdrop: 'static'});
                this.$('.modal').modal('show');
                app.$contentEl.attr('aria-hidden', true);
                $('.modal-backdrop').insertAfter($('.modal'));
                this.context.get('createModel').on('error:validation', function() {
                    this.disableButtons(false);
                }, this);
            }, this);
        }
        this.bindDataChange();
    },
    cancelButton: function() {
        this._super('cancelButton');
        app.$contentEl.removeAttr('aria-hidden');
    },
    saveComplete: function() {
        this._super('saveComplete');
        app.$contentEl.removeAttr('aria-hidden');
    }
  }) },
"inactive-tasks": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Inactive tasks dashlet takes advantage of the tabbed dashlet abstraction by
 * using its metadata driven capabilities to configure its tabs in order to
 * display information about tasks module.
 *
 * @class View.Views.Base.InactiveTasksView
 * @alias SUGAR.App.view.views.BaseInactiveTasksView
 * @extends View.Views.BaseTabbedDashletView
 */
({
	// Inactive-tasks View (base) 

    extendsFrom: 'TabbedDashletView',

    /**
     * @inheritdoc
     *
     * @property {Object} _defaultSettings
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        limit: 10,
        visibility: 'user'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        options.meta.template = 'tabbed-dashlet';

        this.plugins = _.union(this.plugins, [
            'LinkedModel'
        ]);
        this.tbodyTag = 'ul[data-action="pagination-body"]';

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    _initEvents: function() {
        this._super('_initEvents');
        this.on('linked-model:create', this.loadData, this);
        return this;
    },

    /**
     * Create new record.
     *
     * @param {Event} event Click event.
     * @param {Object} params
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    createRecord: function(event, params) {
        if (this.module !== 'Home') {
            this.createRelatedRecord(params.module, params.link);
        } else {
            var self = this;
            app.drawer.open({
                layout: 'create',
                context: {
                    create: true,
                    module: params.module
                }
            }, function(context, model) {
                if (!model) {
                    return;
                }
                self.context.resetLoadFlag();
                self.context.set('skipFetch', false);
                if (_.isFunction(self.loadData)) {
                    self.loadData();
                } else {
                    self.context.loadData();
                }
            });
        }
    },

    /**
     * New model related properties are injected into each model.
     * Update the picture url's property for model's assigned user.
     *
     * @param {Bean} model Appended new model.
     */
    bindCollectionAdd: function(model) {
        var pictureUrl = app.api.buildFileURL({
            module: 'Users',
            id: model.get('assigned_user_id'),
            field: 'picture'
        });
        model.set('picture_url', pictureUrl);
        this._super('bindCollectionAdd', [model]);
    }
}) },
"stage2-news-preferences-key": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Stage2-news-preferences-key View (base) 

    extendsFrom: 'BaseView',

    plugins: ['Stage2CssLoader'],

    /**
     * Set keys
     */
    setKeys: function() {
        this.keys = [{
            icon: 'newspaper-o',
            title: app.lang.get('LBL_NOTIFICATIONS_KEY_TITLE_DASHLET')
        }, {
            icon: 'bell',
            title: app.lang.get('LBL_NOTIFICATIONS_KEY_TITLE_BROWSER'),
            details: app.lang.get('LBL_NOTIFICATIONS_KEY_DESCR_BROWSER')
        }, {
            icon: 'bell-slash',
            disabledClass: 'icon-disabled',
            details: app.lang.get('LBL_NOTIFICATIONS_KEY_DESCR_BROWSER_DISABLED')
        }, {
            icon: 'envelope',
            title: app.lang.get('LBL_NOTIFICATIONS_KEY_TITLE_EMAIL')
        }, {
            icon: 'calendar-o',
            title: app.lang.get('LBL_NOTIFICATIONS_KEY_TITLE_DAILY'),
            iconStack: '1'
        }, {
            icon: 'calendar-o',
            title: app.lang.get('LBL_NOTIFICATIONS_KEY_TITLE_WEEKLY'),
            iconStack: '7'
        }];
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this.setKeys();
        this._super('_render');
    }
}) },
"filter-module-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for the module dropdown.
 *
 * Part of {@link View.Layouts.Base.FilterLayout}.
 *
 * @class View.Views.Base.FilterModuleDropdownView
 * @alias SUGAR.App.view.views.BaseFilterModuleDropdownView
 * @extends View.View
 */
({
	// Filter-module-dropdown View (base) 

    //Override default Backbone tagName
    tagName: "span",
    className: "table-cell",

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //Load partials
        this._select2formatSelectionTemplate = app.template.get("filter-module-dropdown.selection-partial");
        this._select2formatResultTemplate = app.template.get("filter-module-dropdown.result-partial");

        this.listenTo(this.layout, "filter:change:module", this.handleChange);
        this.listenTo(this.layout, "filter:render:module", this._render);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this._renderDropdown();
    },

    /**
     * Render select2 dropdown
     * @private
     */
    _renderDropdown: function() {
        var self = this;

        this.filterList = this.getFilterList();

        // Hide the dropdown if filterList has not been specified.
        if (!this.filterList) {
            this.$el.hide();
            return;
        }

        this.filterNode = this.$(".related-filter");

        this.filterNode.select2({
            data: this.filterList,
            multiple: false,
            minimumResultsForSearch: 7,
            formatSelection: _.bind(this.formatSelection, this),
            formatResult: _.bind(this.formatResult, this),
            dropdownCss: {width: 'auto'},
            dropdownCssClass: 'search-related-dropdown',
            initSelection: _.bind(this.initSelection, this),
            escapeMarkup: function(m) {
                return m;
            },
            width: 'off'
        });

        // Disable the module filter dropdown.
        if (this.shouldDisableFilter()) {
            this.filterNode.select2("disable");
        }

        this.filterNode.off("change");
        this.filterNode.on("change", function(e) {
            /**
             * Called when the user selects a module in the dropdown
             * Triggers filter:change:module on filter layout
             * @param {Event} e
             */
            var linkModule = e.val;
            if (self.layout.layoutType === "record" && linkModule !== "all_modules") {
                linkModule = app.data.getRelatedModule(self.module, linkModule);
            }
            self.layout.trigger("filter:change:module", linkModule, e.val);
        });
    },

    /**
     * Get the list for filter module dropdown.
     * @return {Object}
     */
    getFilterList: function() {
        var filterList;

        if (this.layout.showingActivities) {
            filterList = this.getModuleListForActivities();
        } else if (this.layout.layoutType === "record") {
            filterList = this.getModuleListForSubpanels();
        }

        return filterList;
    },

    /**
     * Should the filter be disabled?
     * @return {boolean}
     */
    shouldDisableFilter: function() {
        return (this.layout.layoutType !== "record" || this.layout.showingActivities);
    },

    /**
     * Trigger events when a change happens
     * @param {String} linkModuleName
     * @param {String} linkName
     * @param {Boolean} silent
     */
    handleChange: function(linkModuleName, linkName, silent) {
        if (linkName === "all_modules") {
            this.layout.trigger("subpanel:change");
        } else if (linkName) {
            this.layout.trigger("subpanel:change", linkName);
        }

        // It is important to reset the `currentFilterId` in order to retrieve
        // the last filter from cache later.
        if (this.context) {
            this.context.set('currentFilterId', null);
        }

        if (this.filterNode) {
            this.filterNode.select2("val", linkName || linkModuleName);
        }
        if (!silent) {
            this.layout.layout.trigger("filter:change", linkModuleName, linkName);
            this.layout.trigger('filter:get', linkModuleName, linkName);
            //Clear the search input and apply filter
            this.layout.trigger('filter:clear:quicksearch');
        }
    },

    /**
     * For record layout,
     * Populate the module dropdown by reading the subpanel relationships
     */
    getModuleListForSubpanels: function() {
        var filters = [];
        filters.push({id: "all_modules", text: app.lang.get("LBL_MODULE_ALL")});

        var subpanels = this.pullSubpanelRelationships();
        subpanels = this._pruneHiddenModules(subpanels);
        if (subpanels) {
            _.each(subpanels, function(value, key) {
                var module = app.data.getRelatedModule(this.module, value);
                if (app.acl.hasAccess("list", module)) {
                    filters.push({id: value, text: app.lang.get(key, this.module)});
                }
            }, this);
        }
        return filters;
    },

    /**
     * For Activity Stream,
     * Populate the module dropdown with a single item
     */
    getModuleListForActivities: function() {
        var filters = [], label;
        if (this.module == "Activities") {
            label = app.lang.get("LBL_MODULE_ALL");
        } else {
            label = app.lang.getModuleName(this.module, {plural: true});
        }
        filters.push({id: 'Activities', text: label});
        return filters;
    },

    /**
     * Pull the list of related modules from the subpanel metadata
     * @return {Object}
     */
    pullSubpanelRelationships: function() {
        // Subpanels are retrieved from the global module and not the
        // subpanel module, therefore we use this.module instead of
        // this.currentModule.
        return app.utils.getSubpanelList(this.module);
    },

    /**
     * Prunes hidden modules from related dropdown list
     * @param {Object} subpanels List of candidate subpanels to display
     * @return {Object} pruned list of subpanels
     * @private
     */
    _pruneHiddenModules: function(subpanels){
        var hiddenSubpanels = _.map(app.metadata.getHiddenSubpanels(), function(subpanel) {
            return subpanel.toLowerCase();
        });
        var pruned = _.reduce(subpanels, function(obj, value, key) {
            var relatedModule = app.data.getRelatedModule(this.module, value);
            if (relatedModule && !_.contains(hiddenSubpanels, relatedModule.toLowerCase())) {
                obj[key] = value;
            }
            return obj;
        }, {}, this);
        return pruned;
    },

    /**
     * Get the dropdown labels for the module dropdown
     * @param {Object} el
     * @param {Function} callback
     */
    initSelection: function(el, callback) {
        var selection, label;
        if (el.val() === "all_modules") {
            label = (this.layout.layoutType === "record") ? app.lang.get("LBL_MODULE_ALL") : app.lang.getModuleName(this.module, {plural: true});
            selection = {id: "all_modules", text: label};
        } else if (_.findWhere(this.filterList, {id: el.val()})) {
            selection = _.findWhere(this.filterList, {id: el.val()});
        } else if(this.filterList && this.filterList.length > 0)  {
            selection = this.filterList[0];
        }
        callback(selection);
    },

    /**
     * Returns the label for the dropdown.
     *
     * @return {string}
     */
    getSelectionLabel: function() {
        var selectionLabel;

        if (this.shouldDisableFilter()) {
            selectionLabel = app.lang.get("LBL_MODULE");
        } else {
            selectionLabel = app.lang.get('LBL_RELATED') + '<i class="sicon sicon-chevron-down"></i>';
        }

        return selectionLabel;
    },

    /**
     * Update the text for the selected module and returns template
     *
     * @param {Object} item
     * @return {string}
     */
    formatSelection: function(item) {
        var safeString;

        //Escape string to prevent XSS injection
        safeString = Handlebars.Utils.escapeExpression(item.text);
        // Update the text for the selected module.
        this.$('.choice-filter-label').html(safeString);

        return this._select2formatSelectionTemplate(this.getSelectionLabel());
    },

    /**
     * Returns template
     * @param {Object} option
     * @return {string}
     */
    formatResult: function(option) {
        // TODO: Determine whether active filters should be highlighted in bold in this menu.
        return this._select2formatResultTemplate(option.text);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (!_.isEmpty(this.filterNode)) {
            this.filterNode.select2('destroy');
        }
        this._super('_dispose');
    }
}) },
"extended-fab": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ExtendedFabView
 * @alias SUGAR.App.view.views.BaseExtendedFabView
 * @extends View.View
 */
({
	// Extended-fab View (base) 

    className: 'extended-fab',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.setOptions(options);
    },

    /**
     * Set options.
     * @param {Object} options
     */
    setOptions: function(options) {
        options = options || {};
        this.icon = options.icon || '';
        this.label = app.lang.get(options.label || '');
        if (this.style) {
            // remove existing style
            this.$el.removeClass(this.style);
        }
        this.style = options.style || '';
        if (this.style) {
            this.$el.addClass(this.style);
        }
        if (this.action && this.events) {
            this.events = _.omit(this.events, 'click [data-action=' + this.action + ']');
        }
        this.action = options.action || '';
        if (this.action) {
            this.events = _.extend({}, this.events);
            this.events['click [data-action=' + this.action + ']'] =  _.bind(function() {
                this.context.trigger(this.action + ':clicked');
            }, this);
        }
    }
}) },
"dashlet-cell-empty": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletCellEmptyView
 * @alias SUGAR.App.view.views.BaseDashletCellEmptyView
 * @extends View.View
 */
({
	// Dashlet-cell-empty View (base) 

    events: {
        'click .dashlet.empty' : 'addClicked'
    },
    originalTemplate: null,
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        //use the dashboard model rather than the current page's
        this.model = this.layout.context.get("model");

        this.model.on("setMode", this.setMode, this);
        this.originalTemplate = this.template;
        this.setMode(this.model.mode);
    },
    addClicked: function(evt) {
        var self = this;
        app.drawer.open({
            layout: 'dashletselect',
            context: this.layout.context
        }, function(model) {
            if(!model) return;
            var conf = model.toJSON(),
                dash = {
                    context: {
                        module: model.get("module"),
                        link: model.get("link")
                    }
                },
                type = conf.componentType;
            delete conf.config;
            delete conf.componentType;
            if(_.isEmpty(dash.context.module) && _.isEmpty(dash.context.link)) {
                delete dash.context;
            }
            dash[type] = conf;
            self.layout.addDashlet(dash);
        });
    },
    setMode: function(type) {
        if(type === 'edit') {
            this.template = this.originalTemplate;
        } else if(type === 'drag') {
            this.template = app.template.getView(this.name + '.drop') || this.originalTemplate;
        } else {
            this.template = app.template.getView(this.name + '.empty') || app.template.empty;
        }
        this.render();
    },
    _dispose: function() {
        this.model.off("setMode", null, this);
        app.view.View.prototype._dispose.call(this);
    }
}) },
"calendar-scheduler-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.CalendarSchedulerDashletView
 * @alias SUGAR.App.view.views.BaseCalendarSchedulerDashletView
 * @extends View.Views.Base.View
 */
 ({
	// Calendar-scheduler-dashlet View (base) 

    plugins: ['Dashlet'],

    /**
     * @inheritdoc
     */
    events: {
        'click span[name=addCalendar]': '_addCalendar'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.listenTo(this.model, 'change:availableViews', _.bind(this.changeAvailableViewsEvent, this));
    },

    /**
     * Initialize the dashlet
     */
    initDashlet: function() {
        if (this.meta.config) {

            this.layout.before('dashletconfig:save', _.bind(function() {
                if (this.validateFields() === false) {
                    return false;
                }
            },this));

            let fields = this.dashletConfig.panels[0].fields;
            let availableViewsField = _.find(fields, function findAvailableViewsField(field) {
                return field.name === 'availableViews';
            });
            let defaultViewField = _.find(fields, function findDefaultViewField(field) {
                return field.name === 'defaultView';
            });

            if (availableViewsField && defaultViewField) {
                let currentlySelectedAvailableViewsKeys = this.settings.get('availableViews');
                defaultViewField.options = {};

                let availableList = app.lang.getAppListStrings(availableViewsField.options);
                _.each(currentlySelectedAvailableViewsKeys, function selectedViewsIterator(keyAvailable) {
                    defaultViewField.options[keyAvailable] = availableList[keyAvailable];
                });
            }
        } else {
            let myConfigurations = this.settings.get('myCalendars') || [];
            myConfigurations = _.map(myConfigurations, function(configuration) {
                configuration.userId = 'current_user';
                return configuration;
            });
            let otherConfigurations = this.settings.get('otherCalendars') || [];

            let otherCalendarsSelected = _.filter(otherConfigurations, function(calendar) {
                return calendar.selected === true;
            });

            let calendars = myConfigurations.concat(otherCalendarsSelected);
            let availableViews = _.clone(this.settings.get('availableViews'));
            if (!availableViews) {
                availableViews = [];
            }

            let defaultView = this.settings.get('defaultView');
            if (!defaultView) {
                defaultView = '';
            }

            let calendarContext = this.context.getChildContext();
            calendarContext.set({
                skipFetch: true,
                module: 'Calendar',
                calendars: calendars,
                availableViews: availableViews,
                defaultView: defaultView,
                visibleRelationsInContextList: this.settings.get('contextMenu'),
                location: 'dashboard',
                customKendoOptions: {
                    listExportButtons: false,
                }
            });

            this.listenTo(calendarContext, 'calendar:loaded', _.bind(function childCalendarWasLoaded() {
                if (this.disposed) {
                    return;
                }
                let dashletToolbar = this.layout.getComponent('dashlet-toolbar');
                let $el = dashletToolbar.$('[data-action=loading]');
                $el.removeClass(dashletToolbar.cssIconRefresh).addClass(dashletToolbar.cssIconDefault);
            }, this));

            this.schedulerView = app.view.createView({
                name: 'scheduler',
                type: 'scheduler',
                context: calendarContext,
                parentView: this
            });

            this.layout.$el.off('resizestop.updateEvents');

            this.layout.$el.on('resizestop.updateEvents', _.debounce(_.bind(function() {
                this.schedulerView.scheduler.resize();
            }, this), 200));
        }
    },

    /**
     * Only used for refresh dashlet button.
     * In rest, the calendar is loaded internally (schedulerView)
     *
     * @method
     * @param  {Object} options At the moment only interesting parameter is complete callback
     */
    loadData: function(options) {
        if (this.meta.config) {
            return;
        }

        if (this.schedulerView instanceof app.view.View === false || this.schedulerView.disposed === true) {
            app.alert.show('error-no-scheduler', {
                level: 'error',
                messages: app.lang.getModString('LBL_CALENDAR_NO_SCHEDULER_VIEW', 'Calendar'),
                autoClose: false
            });
            return;
        }

        if (typeof options !== 'undefined' && typeof options.complete !== 'undefined') {
            this.schedulerView.trigger('calendar:reload');
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        //load calendar data
        this.listenTo(this.schedulerView, 'calendar:initialized', _.bind(this.loadCalendarData, this));
        //this class helps in resizing calendar dashlet to fit calendar component
        this.$el
            .parent()
            .parent()
            .addClass('calendar');

        //we need to add scheduler html element to dom before initializing the scheduler (Scheduler view->render)
        this._super('_render');

        if (this.meta.config) {
            //add addCalendar button
            const addCalendarButton =
                '<span name=\'addCalendar\'><i class=\'sicon sicon-plus\' title=\'Add calendars\'></i></span>';

            this.$('[data-type=calendars][data-name=otherCalendars] > .record-label').append(addCalendarButton);

            this.$el.addClass('mediumDots');
        } else {
            if (this.schedulerView instanceof app.view.View === true &&
                typeof this.schedulerView.disposed === 'undefined') {

                this.$('[data-content=scheduler]').html(this.schedulerView.$el);

                this.schedulerView.render();
            } else {
                app.alert.show('error-no-scheduler', {
                    level: 'error',
                    messages: app.lang.getModString('LBL_CALENDAR_NO_SCHEDULER_VIEW', 'Calendar'),
                    autoClose: false
                });
                return;
            }
        }
    },

    /**
     *
     * Change available views event
     */
    changeAvailableViewsEvent: function() {
        let fields = this.fields;
        let availableViewsField = _.find(fields, function findAvailableViewsField(field) {
            return field.name === 'availableViews';
        });
        let defaultViewField = _.find(fields, function findDefaultViewField(field) {
            return field.name === 'defaultView';
        });

        if (availableViewsField && defaultViewField) {
            let currentlySelectedAvailableViewsKeys = this.settings.get('availableViews');
            defaultViewField.def.options = {};

            let availableList = app.lang.getAppListStrings(availableViewsField.def.options);

            _.each(currentlySelectedAvailableViewsKeys, function availableViewsIterator(keyAvailable) {
                defaultViewField.def.options[keyAvailable] = availableList[keyAvailable];
            });

            defaultViewField.items = defaultViewField.def.options;

            if (currentlySelectedAvailableViewsKeys.indexOf(this.settings.get('defaultView')) === -1) {
                if (currentlySelectedAvailableViewsKeys.length >= 1) {
                    defaultViewField.value = [currentlySelectedAvailableViewsKeys[0]];
                    this.settings.set('defaultView', currentlySelectedAvailableViewsKeys[0]);
                } else {
                    defaultViewField.value = [''];
                    this.settings.set('defaultView', '');
                }
            }

            defaultViewField.render();
        }
    },

    /**
     * Reconfigure calendar
     */
    loadCalendarData: function() {
        this.schedulerView._reconfigureCalendar();
    },

    /**
     *
     * @inheritdoc
     */
    _dispose: function() {
        if (this.schedulerView instanceof app.view.View) {
            this.schedulerView.dispose();
        }

        delete this.schedulerView;

        this._super('_dispose');
    },

    /**
     * Validates dashlet fields marked as required
     *
     * @return {boolean}
     */
    validateFields: function() {
        let _validModel = true;

        _.each(this.fields, _.bind(function checkRequired(field) {
            if (field.def.required === true && _.isEmptyValue(this.dashModel.get(field.name))) {

                field.model.trigger('error:validation:' + field.name, {
                    'required': true
                });

                _validModel = false;
            }
        },this));

        return _validModel;
    },

    /**
     * Add calendar option
     */
    _addCalendar: function() {
        app.drawer.open(
            {
                layout: 'add-calendar',
                context: {
                    module: 'Calendar',
                    mixed: true,
                    dashletSource: true
                }
            },
            _.bind(function close(calendar) {
                if (typeof calendar === 'undefined') {
                    return;
                }

                let otherCalendars = this.settings.get('otherCalendars') || [];
                otherCalendars = app.utils.deepCopy(otherCalendars);

                let calendarAlreadyAdded = false;
                _.each(otherCalendars, function searchCalendar(otherCalendar) {
                    if (otherCalendar.calendarId === calendar.calendarId &&
                        (_.isEmpty(otherCalendar.userId) || otherCalendar.userId === calendar.userId) &&
                        (_.isEmpty(otherCalendar.teamId) || otherCalendar.teamId === calendar.teamId)
                    ) {
                        calendarAlreadyAdded = true;
                    }
                });

                if (calendarAlreadyAdded === true) {
                    app.alert.show('calendar-already-added', {
                        level: 'info',
                        messages: app.lang.get('LBL_CALENDAR_CALENDAR_ALREADY_ADDED', 'Calendar'),
                        autoClose: true
                    });
                    return;
                } else {
                    otherCalendars.push(_.extend(calendar, {selected: true}));
                }

                this.settings.set('otherCalendars', otherCalendars);

                this.getField('otherCalendars').render();

            }, this)
        );
    }
}) },
"profileactions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ProfileactionsView
 * @alias SUGAR.App.view.views.BaseProfileactionsView
 * @extends View.View
 */
({
	// Profileactions View (base) 

    plugins: ['Dropdown'],

    events: {
        'click .profileactions-reset-mfa': 'resetMultifactorAuthentication'
    },

    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        app.events.on("app:sync:complete", this.render, this);
        app.events.on("bwc:avatar:removed", this.bwcAvatarRemoved, this);
        app.user.on("change:picture", this.setCurrentUserData, this);
    },

    /**
     * Render profile actions dropdown menu
     * @private
     */
    _renderHtml: function() {
        // FIXME check why the router is not loaded before all the other components are rendered
        if (!app.router || !app.api.isAuthenticated() || app.config.appStatus === 'offline') {
            return;
        }

        if (!_.isEmpty(this.meta)) {
            this.menulist = this.filterAvailableMenu(app.utils.deepCopy(this.meta));
        }
        this._super('_renderHtml');
    },

    /**
     * Filters menu metadata
     * @param Array menuMeta
     * @return {Array}
     */
    filterAvailableMenu: function(menuMeta){
        var result = [];
        var impersonationMode = !_.isEmpty(app.cache.get('ImpersonationFor'));
        _.each(menuMeta,function(item) {
            item = this.filterMenuProperties(item);
            if (!_.isEmpty(item.acl_module) &&
                !app.acl.hasAccess(item.acl_action, item.acl_module)) {
                return;
            }

            // if current user is neither a developer nor allowed to access admin actions,
            // but the action is reserved for admin, skip this action
            if (!app.acl.hasAccessToAny('developer') &&
                !app.acl.hasAccess('admin', 'Administration') &&
                item.acl_action === 'admin') {
                return;
            }


            // in impersonation mode default logout replaced by finish impersonation strategy
            // and also disabled possibility change password
            if (impersonationMode) {
                if (item.label === 'LBL_LOGOUT' || item.label === 'LBL_CHANGE_PASSWORD') {
                    return;
                }
            } else {
                if (item.label === 'LBL_FINISH_IMPERSONATING') {
                    return;
                }
            }

            result.push(item);
        },this);
        return result;
    },

    /**
     * Filters single menu data
     * @param Array menu data
     * @return {Array}
     */
    filterMenuProperties:function(singleItem){
        if(singleItem['label'] === 'LBL_PROFILE'){
            singleItem['img_url'] = this.pictureUrl;
        } else if (singleItem.label === 'LBL_CHANGE_PASSWORD') {
            singleItem.route += '?user_hint=' + encodeURIComponent(app.utils.createUserSrn(app.user.id));
        }
        return singleItem;
    },

    //TODO: Remove once bwc is completely pruned out of the product
    bwcProfileEntered: function() {
        //Refetch latest user data (since bwc updated avatar); reset
        var self = this;
        app.user.load(function() {
            self.setCurrentUserData();
        });
    },
    //This will get called when avatar is removed from bwc User profile edit (SP-1949)
    //TODO: Remove once bwc is completely pruned out of the product
    bwcAvatarRemoved: function() {
        app.user.set("picture", '');//so `this.pictureUrl` is falsy and default avatar kicks in on .hbs template
        this.setCurrentUserData();
    },
    /**
     * Sets the current user's information like full name, user name, avatar, etc.
     * @protected
     */
    setCurrentUserData: function() {
        this.fullName = app.user.get("full_name");
        this.userName = app.user.get("user_name");
        this.userId = app.user.get('id');
        var picture = app.user.get("picture");

        this.pictureUrl = picture ? app.api.buildFileURL({
            module: "Users",
            id: this.userId,
            field: "picture"
        }, {
            cleanCache: true
        }) : '';

        this.render();
    },
    _dispose: function() {
        if (app.user) app.user.off(null, null, this);
        app.view.View.prototype._dispose.call(this);
    },
    resetMultifactorAuthentication: function() {
        let mfaBlockContent = {
            linkToDocumentation: app.help.getDocumentationUrl('ResettingMFA')
        };
        app.alert.show('mfa_reset_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_MFA_RESET_CONFIRMATION', null, mfaBlockContent),
            confirm: {
                label: app.lang.get('LBL_MFA_RESET_CONFIRMATION_BTN'),
            },
            onConfirm: function() {
                app.api.call('update', app.api.buildURL('mfa/reset'), null, {
                    success: function(data) {
                        app.router.navigate('#logout/?clear=1', {trigger: true});
                    },
                    error: function(err) {
                        app.alert.show('mfa_reset_error', {
                            level: 'error',
                            messages: app.lang.get('EXCEPTION_FATAL_ERROR_DESC'),
                        });
                    }
                });
            }
        });
        return false;
    }
}) },
"omnichannel-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The layout for the Omnichannel console.
 *
 * @class View.Layouts.Base.OmnichannelHeaderView
 * @alias SUGAR.App.view.layouts.BaseOmnichannelHeaderView
 * @extends View.View
 */
({
	// Omnichannel-header View (base) 

    className: 'omni-header',

    toggleModeButtonSettings: {
        compact: {
            iconClass: 'sicon sicon-full-screen',
            tooltip: 'LBL_OMNICHANNEL_FULL_VIEW'
        },
        full: {
            iconClass: 'sicon sicon-full-screen-exit',
            tooltip: 'LBL_OMNICHANNEL_COMPACT_VIEW'
        }
    },

    /**
     * @inheritdoc
     *
     * Updates the toggle mode button when the console mode changes
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.layout.on('omniconsole:mode:set', this.updateToggleModeButton, this);
        this.layout.on('omniconsole:activeCall', this.updateShowHideToggleModeButton, this);
    },

    /**
     * Toggles the Compact/Full view button if a call is active or not
     *
     * @param isCallActive
     */
    updateShowHideToggleModeButton: function(isCallActive) {
        this.$('[data-action=toggleMode]').toggleClass('hidden', !isCallActive);
    },

    /**
     * Updates the styling of the "toggle mode" button in the Omnichannel header
     * based on the current mode that the console is in
     *
     * @param {string} currentMode the current mode of the console
     */
    updateToggleModeButton: function(currentMode) {
        // Get the button and button icon elements
        var toggleModeButton = this.$('[data-action=toggleMode]');
        var toggleModeButtonIcon = toggleModeButton.find('i');

        // If button settings are defined for the given mode, apply the correct
        // styling for the mode and show the button. Otherwise, hide it
        var modeSettings = null;
        switch (currentMode) {
            case this.layout.modes.COMPACT:
                modeSettings = this.toggleModeButtonSettings.compact;
                break;
            case this.layout.modes.FULL:
                modeSettings = this.toggleModeButtonSettings.full;
        }

        if (modeSettings && modeSettings.iconClass && modeSettings.tooltip) {
            toggleModeButtonIcon.removeClass().addClass(modeSettings.iconClass);
            toggleModeButton.attr('data-original-title', app.lang.get(modeSettings.tooltip));
            toggleModeButton.show();
        } else {
            toggleModeButton.hide();
        }
    }
}) },
"dashablerecord": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * Dashablerecord is a dashlet representation of a module record view. Users
 * can build dashlets of this type for any accessible and approved module.
 *
 * The specific record is not configured in advance. Rather, only the
 * module to which the record belongs is. Records are loaded into the
 * dashlet via the `change:model` event.
 *
 * @class View.Views.Base.DashablerecordView
 * @alias SUGAR.App.view.views.BaseDashablerecordView
 * @extends View.Views.Base.RecordView
 */
({
	// Dashablerecord View (base) 

    extendsFrom: 'RecordView',

    /**
     * The plugins used by this view.
     *
     * This list is the same as that of the normal record view, with the
     * following exceptions:
     *
     * * Dashlet plugin added (because this is a dashlet)
     * * Pii removed (no PII drawer)
     * * Audit removed (no Audit Log drawer)
     * * FindDuplicates removed (no find-duplicate button)
     * * Pagination added (used by the list view tabs)
     */
    plugins: [
        'SugarLogic',
        'ErrorDecoration',
        'GridBuilder',
        'Editable',
        'ToggleMoreLess',
        'Dashlet',
        'Pagination',
        'ConfigDrivenList',
        'ActionButton',
    ],

    /**
     * We want to load field `record` templates
     */
    fallbackFieldTemplate: 'record',

    /**
     * Modules that are permanently blacklisted so users cannot configure a
     * dashlet for these modules.
     *
     * @property {string[]}
     */
    moduleBlacklist: [
        'Campaigns',
        'Home',
        'Forecasts',
        'Project',
        'ProjectTask',
        'UserSignatures',
        'OutboundEmail',
    ],

    /**
     * Extra modules that we need to check for user access
     *
     * @property {string[]}
     */
    extraModules: [
        'ProductCategories',
        'ProductTypes',
        'Manufacturers',
        'ContractTypes',
        'Shippers',
        'ShiftExceptions',
    ],

    /**
     * List of modules that should not be available as tabs
     *
     * @property {string[]}
     */
    tabBlacklist: [
        'Tags',
    ],

    /**
     * Flag indicates if a module is available for display.
     *
     * @property {boolean}
     */
    moduleIsAvailable: true,

    /**
     * Cache of the modules a user is allowed to see.
     *
     * The keys are the module names and the values are the module names after
     * resolving them against module and/or app strings. The cache logic can be
     * seen in {@link BaseDashablerecordView#_getAvailableModules}.
     *
     * @property {Object}
     */
    _availableModules: {},

    /**
     * The default settings for a record view dashlet.
     *
     * @property {Object}
     */
    _defaultSettings: {
        freeze_first_column: true,
        limit: 5, // for tabs with list view
    },

    /**
     * Denotes the mode of operation for the dashlet:
     * 'main' during normal use, 'config' during configuration.
     *
     * @property {string}
     */
    _mode: 'main',

    /**
     * List of fields we wish to banish from the header.
     *
     * @property {string[]}
     */
    _noshowFields: ['favorite', 'follow', 'badge', 'status'],

    /**
     * Size of avatars within the dashlet toolbar.
     *
     * @property {number}
     */
    _avatarSize: 28,

    /**
     * Ensures we only bind event listeners once.
     *
     * @property {boolean}
     */
    _hasDelegated: false,

    /**
     * Cap on the maximum number of tabs allowed.
     *
     * @property {Object}
     */
    _tabLimit: {
        number: 6,
        label: 'LBL_SIX'
    },

    /**
     * The tabs in the view
     *
     * @property {Array}
     */
    tabs: [],

    /**
     * The pseudo dashlet component that is the live preview on the config view
     *
     * @property {View}
     */
    _pseudoDashlet: null,

    dataView: 'recorddashlet',

    /**
     * Are we in a config drawer layout?
     */
    configLayout: false,

    /**
     * Turn off headerpane
     */
    enableHeaderPane: true,

    /**
     * Defines the scroll container jQuery element
     */
    scrollContainer: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        if (options.meta.pseudo) {
            this.plugins = _.without(this.plugins, 'Pagination');
        }
        // bolt record view metadata for the given module onto the dashlet
        this._defaultBaseMeta = options.meta;
        options.meta = this._extendMeta({module: options.meta.module, type: 'record'});

        this._super('initialize', [options]);

        this._noAccessTemplate = app.template.get(this.name + '.noaccess');
        this._noTabsAvailableTemplate = app.template.get(`${this.name}.no-tabs-available`);
        this._recordsTemplate = app.template.get(this.name + '.records');
        this._recordTemplate = app.template.get(this.name + '.record');
        this._tabsTemplate = app.template.get(this.name + '.tabs');
        this._configListTemplate = app.template.get(this.name + '.list-config');

        // listen to tab events
        this.events = _.extend(this.events || {}, {
            'click [class*="orderBy"]': 'setOrderBy',
            'click [data-action=tab-switcher]': 'tabSwitcher'
        });

        /**
         * Events to listen to on the dashlet toolbar's context.
         *
         * @property {Object}
         */
        this._toolbarContextEvents = {
            'button:edit_button:click': this.editRecord,
            'button:save_button:click': this.saveClicked,
            'button:cancel_button:click': this.cancelClicked,
        };

        this.configLayout = this._inConfigLayout();
        this.context.on('focusRow', this.focusRow, this);
        this.context.on('unfocusRow', this.unhighlightRows, this);
    },

    /**
     * @inheritdoc
     */
    saveClicked: function() {
        // Disable the action buttons.
        this.toggleButtons(false);
        var allFields = this.getFields(this.module, this.model);
        var fieldsToValidate = {};
        var erasedFields = this.model.get('_erased_fields');
        for (var fieldKey in allFields) {
            if (app.acl.hasAccessToModel('edit', this.model, fieldKey) &&
                (!_.contains(erasedFields, fieldKey) || this.model.get(fieldKey) || allFields[fieldKey].id_name)) {
                _.extend(fieldsToValidate, _.pick(allFields, fieldKey));
            }
        }

        // name field is not defined in metadata, inject it here to be validated
        var $recordCells = this._getRecordCells();
        var nameField = this._getNameFieldFromRecordCells($recordCells);
        var nameFieldName = $(nameField).find('.index').attr('data-fieldname');
        var nameFieldDef = app.metadata.getField({module: this.module, name: nameFieldName});
        if (!_.isEmpty(nameFieldDef)) {
            if (!_.contains(fieldsToValidate, nameFieldName)) {
                fieldsToValidate[nameFieldName] = nameFieldDef;
            }
            // field group such as fullname
            if (fieldsToValidate[nameFieldName].fields) {
                _.each(fieldsToValidate[nameFieldName].fields, function(field) {
                    var fieldDef = app.metadata.getField({module: this.module, name: field});
                    if (!_.isEmpty(fieldDef) && fieldDef.required && !_.contains(fieldsToValidate, field)) {
                        fieldsToValidate[field] = fieldDef;
                    }
                }, this);
            }
        }
        this.model.doValidate(fieldsToValidate, _.bind(this.validationComplete, this));
    },

    /**
     * Extend this dashlet's metadata with that of the record view
     * (or, if available, its recorddashlet view) metadata.
     * Also mutate the panel metadata to handle its headerpane.
     *
     * @param {Object} tab Target tab.
     * @return {Object} The extended metadata.
     * @private
     */
    _extendMeta: function(tab) {
        var desiredMeta;
        if (tab.type === 'record') {
            desiredMeta = app.metadata.getView(tab.module, 'recorddashlet') || this._getRecordMeta(tab.module);
        } else {
            desiredMeta = app.metadata.getView(tab.module, 'list');
        }
        var newMeta = _.extend(
            {},
            this._defaultBaseMeta,
            desiredMeta,
            tab.meta
        );

        // Make sure we start with all the buttons. These get filtered out next,
        // but we need the full list and not the already filtered ones.
        newMeta.buttons = desiredMeta.buttons;

        // split out the headerpane if necessary, and remove unwanted fields
        // we need to inject these into the toolbar
        if (newMeta.panels) {
            this._prepareHeader(newMeta.panels, newMeta.buttons, tab);
        }

        return newMeta;
    },

    /**
     * Must implement this method as a part of the contract with the Dashlet
     * plugin. Kicks off the various paths associated with a dashlet:
     * Configuration, preview, and display.
     *
     * @param {string} viewName The name of the view as defined by the `oninit`
     *   callback in {@link DashletView#onAttach}.
     */
    initDashlet: function(viewName) {
        this._mode = viewName;
        this._initializeSettings();

        // always save the host dashboard's module
        // (this might be different from the "base record type")
        this._baseModule = this.settings.get('base_module') ||
            this.settings.get('module') ||
            this.model.module ||
            this.model.get('module');

        if (this._mode === 'config') {
            this._configureDashlet();
        } else if (this.meta.pseudo) {
            // re-render the pseudo-dashlet in the configuration whenever the set of selected tabs or its order changes
            this.layout.context.on('dashablerecord:config:tablist:change', function(newTabs = [], resetActiveTab) {
                var oldTabsLength = this.tabs.length;

                this._initTabs(newTabs);

                // Show no tabs available template, since there are no tabs in the config screen
                if (_.size(newTabs) === 0) {
                    return this._noTabsAvailable();
                }

                // if we removed a tab, lets reset back to the first tab
                if (resetActiveTab || newTabs.length !== oldTabsLength) {
                    this.setActiveTab(0);
                }

                this._updateViewToCurrentTab();
                this.render();
                this.settings.set('tabs', this.tabs);
            }, this);

            this.layout.context.trigger('dashablerecord:config:tablist:change', this.meta.tabs, true);
        } else {
            this._initTabs();
            this.setActiveTab(0);
            this._updateViewToCurrentTab();
        }

        this.before('render', function() {
            // ACL check
            if (!this.moduleIsAvailable || !this.model) {
                this._showHideListBottom(null, true);
                return this._noAccess();
            }

            var activeTab = this._getActiveTab();
            if (!activeTab) {
                return;
            }

            if (
                this._mode === 'main' &&
                this.model &&
                this.model.module === this.module
            ) {
                // ensure the header is populated with the relevant data if we already have it
                this._prepareHeader(this.meta.panels, this.meta.buttons, activeTab);
            }
        });
    },

    /**
     * Initialize the SugarLogic plugin for the current model. As the dashlet is initialized,
     * the current model is a config model which is swapped later to the actual record model.
     * In case there are multiple tabs containing different records, we have to initialize
     * the plugin for each model (there are 3 critical plugin inputs - the model, the collection
     * and the fields displayed).
     */
    initTabSugarLogic: function() {
        // ensure that the SugarLogic listeners are attached only once
        if (!this.disposed && !this.model.hasSugarLogicEvents) {
            // we may lack a collection, so we create one to be able to trigger onLoad logics
            if (!this.collection) {
                if (this.model.collection) {
                    this.collection = this.model.collection;
                } else {
                    this.collection = app.data.createBeanCollection(this.model.module, [this.model]);
                }
            }

            this._slCtx = this.initSugarLogic();
            this.context.addFields(this._getDepFields());
            this.collection.trigger('sync', this.collection, this.collection.models);
            this.model.hasSugarLogicEvents = true;
        }
    },

    /**
     * Prevent shortcuts from dashablerecord overriding the shortcuts set by the main view
     * @override
     */
    registerShortcuts: _.noop,

    /**
     * Gets the currently active tab object.
     *
     * @return {Object|undefined} The currently active tab object, or the
     *   first configured tab if it exists, or else `undefined`.
     * @private
     */
    _getActiveTab: function() {
        if (this.settings.get('activeTab')) {
            return this.settings.get('activeTab');
        }

        if (this.tabs && this.tabs.length) {
            var activeTabIndex = this.settings.get('activeTabIndex') || 0;
            return this.tabs[activeTabIndex];
        }

        if (this.settings.has('tabs')) {
            var tab = this.settings.get('tabs')[0];
            if (_.isString(tab)) {
                return {
                    link: tab,
                    module: this._getRelatedModule(tab),
                    type: this._getTabType(tab)
                };
            }
            return tab;
        }
    },

    /**
     * Set a tab as the active tab and save both the tab and the index
     *
     * @param {number} newActiveTabIndex The index of this.tabs to make the active tab
     */
    setActiveTab: function(newActiveTabIndex) {
        if (this.tabs.length < newActiveTabIndex) {
            this.settings.set('activeTabIndex', null);
            this.settings.set('activeTab', null);
        } else {
            this.settings.set('activeTabIndex', newActiveTabIndex);
            this.settings.set('activeTab', this.tabs[newActiveTabIndex]);
        }
    },

    /**
     * Checks if the passed in tab is the active tab by comparing the link name
     *
     * @param {Object} tab The tab to check
     * @return {boolean}
     * @private
     */
    _isActiveTab: function(tab) {
        return tab.link === this._getActiveTab().link;
    },

    /**
     * Fetches relate fields depending on tabs for the contextual model
     *
     * @private
     */
    _loadContextModel: function() {
        var model = this._getContextModel();
        var fields = this._getRelateFieldsForContextModel();
        model.setOption('fields', fields);
        model.fetch({
            showAlerts: true,
            success: _.bind(function(model) {
                if (this.disposed) {
                    return;
                }
                this._syncIdsToModels(model);
                this.render();
            }, this)
        });
    },

    /**
     * Set ids for related models to the correct models in side the tabs
     *
     * @param {Data.Bean} model The fetched model that contains relate field data
     * @private
     */
    _syncIdsToModels: function(model) {
        _.each(this.tabs, function(tab) {
            if (tab.type !== 'record') {
                return;
            }

            var link = tab.link;
            var relateField = model.get(link);
            if (relateField && relateField.records) {
                relateField = relateField.records[0];
            }
            if (relateField && relateField.id) {
                if (tab.model) {
                    tab.model.dispose();
                }
                tab.model = app.data.createRelatedBean(this._getContextModel(), relateField.id, link);
                this._setDataView(tab.model);
                if (this._isActiveTab(tab)) {
                    this._updateViewToCurrentTab();
                    this._loadDataForTabs([tab]);
                }
            }
        }, this);
    },

    /**
     * Set the dataView for the model to tell the server what fields to load
     * Depending on if recorddashlet metadata is defined, dataView will be recorddashlet
     * or record
     *
     * @param {Data.Bean} model The model to set the dataView on
     * @private
     */
    _setDataView: function(model) {
        var dataView = app.metadata.getView(model.module, 'recorddashlet') ? this.dataView : 'record';
        model.setOption('view', dataView);
    },

    /**
     * Gets relate field names for the context model for each record tab
     * Used to force relate fields onto the context model's fetch so that we get
     * an id for the related record
     *
     * @return {Array} List of relate field names
     * @private
     */
    _getRelateFieldsForContextModel: function() {
        var contextModel = this._getContextModel();
        var tabs = this.settings.get('tabs');
        var fields = [];
        var moduleFields = _.values(app.metadata.getModule(contextModel.module, 'fields'));
        _.each(tabs, function(tab) {
            if (tab.type !== 'record') {
                return;
            }
            var link = tab.link;
            var field = _.find(moduleFields, function(mField) {
                return mField.link === link ||
                    (mField.name === 'parent_type' && contextModel.get('parent_type').toLowerCase() === link);
            });
            if (field) {
                if (field.name === 'parent_type') {
                    fields.push(contextModel.get(field.name).toLowerCase());
                } else {
                    fields.push(field.name);
                }
            }
        }, this);

        return fields;
    },

    /**
     * Returns true if the name of the given link should be interpreted as a
     * "link" to the base record.
     *
     * @param {string} link Name of the link to check.
     * @return {boolean} `true` if this link refers to the base record type.
     * @private
     */
    _isLinkToBaseRecord: function(link) {
        return link === '' || link === this._baseModule;
    },

    /**
     * Inject the pseudo dashlet (a configuration pane) into the
     * dashletconfiguration layout.
     *
     * @private
     */
    _addPseudoDashlet: function() {
        var pseudoDashlet = this.layout.getComponent('dashlet');
        if (pseudoDashlet && pseudoDashlet.meta && pseudoDashlet.meta.pseudo) {
            return;
        }

        var metadata = {
            component: this.type,
            name: this.type,
            type: this.type,
            module: this._baseModule,
            config: [],
            preview: []
        };

        var newContext = this.context.getChildContext();
        newContext.prepare(); // try to avoid the pagination plugin complaining about collection not being defined
        var component = {
            name: metadata.component,
            type: metadata.type,
            preview: true,
            context: newContext,
            module: metadata.module,
            custom_toolbar: 'no'
        };
        component.view = _.extend({module: metadata.module}, metadata.preview, component);
        component.view.tabs = [];
        component.view.pseudo = true;

        var settingsTabs = this.settings.get('tabs');
        component.view.tabs = settingsTabs;
        var layout = {
            type: 'dashlet',
            css_class: 'dashlets',
            config: false,
            preview: false,
            module: metadata.module,
            context: this.context,
            components: [
                component
            ],
            pseudo: true
        };
        var pseudoLayout = this.layout.initComponents([{layout: layout}], this.context);
        this._cachePseudoComponent(pseudoLayout);
    },

    /**
     * Save the pseudo dashlet so we can reference it anytime
     *
     * @param {Array} layouts An array of created layouts
     * @private
     */
    _cachePseudoComponent: function(layouts) {
        var layout = layouts[0];
        this._pseudoDashlet = layout.getComponent('dashablerecord');
    },

    /**
     * Event handler for tab switcher.
     *
     * @param {Event} event Click event.
     */
    tabSwitcher: function(event) {
        // don't switch tabs if you are editing
        if (this.action == 'edit') {
            return; // maybe we should show a message?
        }
        var index = this.$(event.currentTarget).data('index');

        if (index === this.settings.get('activeTabIndex')) {
            return;
        }

        this.setActiveTab(index);

        if (this._mode === 'config') {
            this.render();
        } else if (this.meta.pseudo) {
            this._updateViewToCurrentTab();
            this.render();

            if (_.has(this.settings.get('activeTab'), 'type') &&
              this.settings.get('activeTab').type === 'list' &&
              !this.model.get('fields')
            ) {
                this._updateDisplayColumns();
            }
        } else {
            var tab = this.tabs[index];
            this.collection = this.tabs[index].collection || null;
            this._updateViewToCurrentTab();
            this.context.set('collection', this.collection);
            tab.skipFetch = false;

            if (this.collection && !this.collection.dataFetched && !tab.skipFetch && !this.meta.pseudo) {
                this._loadDataForTabs([tab]);
            } else if (tab.type === 'record' && !tab.model.dataFetched) {
                this._loadDataForTabs([tab]);
            }
            this.render();
        }
    },

    /**
     * Update the view with tab data at the view level so that the
     * templates can reference the correct meta, model and module
     *
     * @private
     */
    _updateViewToCurrentTab: function() {
        var tab = this.settings.get('activeTab');

        if (!tab) {
            return;
        }

        this.model = tab.model;
        this.module = tab.module;
        this.context.set('module', this.module);
        this.meta = this._extendMeta(tab);
        this._initDropdownBasedViews();
        this.modulePlural = app.lang.getAppListStrings('moduleList')[this.module] || this.module;
        this.moduleSingular = app.lang.getAppListStrings('moduleListSingular')[this.module] || this.modulePlural;
        this.action = tab.type === 'list' ? 'list' : 'detail';
        // From ConfigDrivenList Plugin
        this.filterConfigFieldsForDashlet();
        this._buildGridsFromPanelsMetadata();
        this.collection = tab.collection || null;
        this.context.set('model', this.model, {silent: true});
        this._prepareHeader(this.meta.panels, this.meta.buttons, tab);
    },

    /**
     * @override
     * Override getLabelPlacement from record.js to always return true since
     * we always want dashlet record labels on top
     *
     * @return {boolean} true
     */
    getLabelPlacement: function() {
        return true;
    },

    /**
     * Set order by on collection.
     * The event is canceled if an element being dragged is found.
     *
     * @param {Event} event jQuery event object.
     */
    setOrderBy: function(event) {
        var $target = $(event.currentTarget);

        if ($target.find('ui-draggable-dragging').length) {
            return;
        }

        var tab = this.settings.get('activeTab');
        var collection = tab.collection;
        // first check if alternate orderby is set for column
        var orderBy = $target.data('orderby');
        // if no alternate orderby, use the field name
        if (!orderBy) {
            orderBy = $target.data('fieldname');
        }
        if (!_.isEmpty(orderBy) && !app.acl.hasAccess('read', tab.module, app.user.get('id'), orderBy)) {
            // no read access to the orderBy field, don't bother to reload data
            return;
        }
        // if same field just flip
        if (orderBy === tab.order_by.field) {
            tab.order_by.direction = tab.order_by.direction === 'desc' ? 'asc' : 'desc';
        } else {
            tab.order_by.field = orderBy;
            tab.order_by.direction = 'desc';
        }

        collection.orderBy = tab.order_by;
        collection.resetPagination();
        this._loadDataForTabs([tab]);
    },

    /**
     * Create collection based on tab properties and current context.
     *
     * @param {Object} tab Tab properties.
     * @return {Data.BeanCollection|null} A new instance of bean collection or `null`
     *   if we cannot access module metadata.
     * @private
     */
    _createCollection: function(tab) {
        // on the multi-line list view, the first time the collections are created this.model is from Home
        // (i.e. it's the dashboard model). This causes fetching to complain.
        var modelToUse = this._getContextModel() || this.model;
        return app.data.createRelatedCollection(modelToUse, tab.link);
    },

    /**
     * Get the row model from row-model-data.
     *
     * @return {Data.Bean|undefined} The rowModel, if it exists.
     * @private
     */
    _getRowModel: function() {
        return this.context.parent.parent.get('rowModel');
    },

    /**
     * Get the contextual model for the dashlet
     *
     * @return {Data.Bean}
     * @private
     */
    _getContextModel: function() {
        let contextModel = null;

        if (this._contextModel) {
            contextModel = this._contextModel;
        } else if (this._hasRowModel()) {
            contextModel = this._cloneModel(this._getRowModel());
        } else {
            var context = this.context;

            // search upward for the first context that has the correct record model
            while (context) {
                var model = context.get('model');

                if (model && model.has('id')) {
                    var module = context.get('module');

                    if (module === this._baseModule) {
                        contextModel = model;
                        break;
                    }
                }

                context = context.parent;
            }

            contextModel = this._cloneModel(contextModel || app.controller.context.get('model'));
        }

        return this._contextModel = contextModel;
    },

    /**
     * Create a new model with the same attributes as the passed in model.
     * Also copies the id
     *
     * @param {Data.Bean} model The model to copy
     * @return {Data.Bean}
     * @private
     */
    _cloneModel: function(model) {
        var clonedModel = app.data.createBean(model.module);
        clonedModel.copy(model);
        clonedModel.set('id', model.get('id'));
        return clonedModel;
    },

    /**
     * Determine if we have a rowModel or not.
     *
     * @return {boolean} `true` if we have a rowModel. `false` otherwise.
     * @private
     */
    _hasRowModel: function() {
        return this.context &&
            this.context.parent &&
            this.context.parent.parent &&
            this.context.parent.parent.has('rowModel');
    },

    /**
     * Retrieve collection options for a specific tab.
     *
     * @param {Object} tab The tab.
     * @return {Object} Collection options.
     * @return {number} return.limit The number of records to retrieve.
     * @return {Object} return.params Additional parameters to the API call.
     * @return {Object|null} return.fields Specifies the fields on each
     * requested model.
     * @private
     */
    _getCollectionOptions: function(tab) {
        return {
            limit: tab.limit || this.settings.get('limit'),
            relate: true,
            params: {
                order_by: !_.isEmpty(tab.order_by) ? tab.order_by.field + ':' + tab.order_by.direction : null,
                include_child_items: tab.include_child_items || null
            },
            fields: this._addRelateFields(tab.module, tab.fields)
        };
    },

    /**
     * Add relates and actual id fields to the field list.
     *
     * @param {string} module The module name
     * @param {Array} fields The field list
     * @return {Array} The expanded field list
     */
    _addRelateFields: function(module, fields) {
        fields = fields || [];
        var vardefFieldMetadata = app.metadata.getModule(module, 'fields') || {};

        // The columns of a dashablerecord can handle fields defined in a module's
        // list view defs, including 'fieldset' type fields that aren't defined
        // in the module's vardefs. This means we need to include the related
        // fields necessary for those in the fetch as well.
        var listViewFieldMetadata = {};
        _.each(this._getFieldMetaForView(app.metadata.getView(module, 'list')) || [], function(field) {
            listViewFieldMetadata[field.name] = field;
        });

        if (vardefFieldMetadata !== {} || listViewFieldMetadata !== {}) {
            // we need to find the relates and add the actual id fields
            var relates = [];
            _.each(fields, function(name) {
                // If the field definition is not found in the vardefs, look in
                // the list view defs
                var meta = vardefFieldMetadata[name] || listViewFieldMetadata[name];
                if (!meta) {
                    return;
                }
                if (meta.type == 'relate') {
                    relates.push(meta.id_name);
                } else if (meta.type == 'parent') {
                    relates.push(meta.id_name);
                    relates.push(meta.type_name);
                }
                if (_.isArray(meta.related_fields)) {
                    relates = relates.concat(meta.related_fields);
                }
            });

            fields = _.union(fields, relates);
        }

        return fields;
    },

    /**
     * Retrieve pagination options for current tab. Called by 'Pagination' plugin.
     *
     * @return {Object} Pagination options.
     */
    getPaginationOptions: function() {
        return this._getCollectionOptions(this.settings.get('activeTab'));
    },

    /**
     * Fetch data for tabs.
     *
     * @param {Object} [options={}] Options that are passed to collection/model's
     *   fetch method.
     */
    loadData: function(options) {
        if (this.disposed || this._mode === 'config' || this._mode === 'preview' || this.meta.pseudo) {
            return;
        }
        if (this._contextModel) {
            this._contextModel = undefined;
        }
        this._loadContextModel();
        this._super('loadData', [options]);
        this._loadDataForTabs(this.tabs, options);
    },

    /**
     * @inheritdoc
     */
    _renderField: function(field, $fieldEl) {
        // Make sure that we render the subfields of the non-editable fieldsets in 'detail' mode
        if (!_.contains(this.editableFields, field) && field.fields && _.isArray(field.fields)) {
            field.setElement($fieldEl || this.$(`span[sfuuid=${field.sfId}]`));
            field.setMode('detail');
        } else {
            this._super('_renderField', [field, $fieldEl]);
        }
    },

    /**
     * @inheritdoc
     */
    _getDropdownBasedViewName: function() {
        return this._mode === 'main' ? 'recorddashlet' : null;
    },

    /**
     * Load data for passed set of tabs.
     *
     * @param {Object[]} tabs Set of tabs to update.
     * @param {Object} [options={}] load options.
     * @private
     */
    _loadDataForTabs: function(tabs, options) {
        // don't load data on the pseudo config  or preview dashlet
        if (this.meta.pseudo || this._mode === 'preview' || this.configLayout) {
            return;
        }

        options = options || {};
        var self = this;
        var loadDataRequests = [];
        var shouldNotMakeRequest = function(tab) {
            if (!tab) {
                return true;
            }
            if (tab.type === 'list') {
                return !tab.collection ||
                    tab.skipFetch ||
                    (
                        tab.collection.link &&
                        tab.collection.link.bean &&
                        tab.collection.link.bean.has('view_name')
                    );
            } else if (tab.type === 'record') {
                return !tab.model ||
                    tab.skipFetch ||
                    tab.model.dataFetched ||
                    _.isEmpty(tab.model.get('id'));
            }
        };
        _.each(tabs, function(tab, index) {
            if (shouldNotMakeRequest(tab)) {
                return;
            }
            loadDataRequests.push(function(callback) {
                if (tab.type === 'list') {
                    tab.collection.setOption(self._getCollectionOptions(tab));
                    tab.collection.fetch({
                        complete: function() {
                            tab.collection.dataFetched = true;
                            callback(null);
                        }
                    });
                } else if (tab.type === 'record') {
                    tab.model.fetch({
                        showAlerts: true,
                        success: _.bind(function(model) {
                            if (self._isActiveTab(tab)) {

                                // Check the metadata again. On the first switch to the tab,
                                // some of the fields we need for the header buttons might
                                // not be available
                                self.meta = self._extendMeta(tab);
                                self._initDropdownBasedViews();

                                self.render();
                                // init SugarLogic only after fields have been rendered
                                self.initTabSugarLogic();
                            }
                        }, this)
                    });
                }
            });
        }, this);
        if (!_.isEmpty(loadDataRequests)) {
            async.parallel(loadDataRequests, function() {
                if (self.disposed) {
                    return;
                }
                self.collection = self.settings.get('activeTab').collection;
                self.context.set('collection', self.collection);

                self.render();

                if (_.isFunction(options.complete)) {
                    options.complete.call(self);
                }
            });
        }
    },

    /**
     * Util method to determine if we are in a config layout. Used to allow
     * dashlet to render an empty record view for config displays
     *
     * @return {boolean} Whether we are in a config layout
     * @private
     */
    _inConfigLayout: function() {
        var context = this.context;
        while (context) {
            if (context.get('config-layout')) {
                return true;
            }
            context = context.parent;
        }
        return false;
    },

    /**
     * Get the fields metadata for a tab.
     *
     * @param {Object} tab The tab.
     * @return {Object[]} The fields metadata or an empty array.
     * @private
     */
    _getFieldMetaForTab: function(tab) {
        // FIXME: this function needs to be renamed as it only applies to list view tabs
        var meta = app.metadata.getView(tab.module, 'list') || {};
        return this._getFieldMetaForView(meta);
    },

    /**
     * Get the columns to display for a tab.
     *
     * @param tab {Object} Tab to display.
     * @return {Object[]} Array of objects defining the field metadata for
     *   each column.
     * @private
     */
    _getColumnsForTab: function(tab) {
        var columns = [];
        var fields = this._getFieldMetaForTab(tab);
        var moduleMeta = app.metadata.getModule(tab.module);

        _.each(tab.fields, function(name) {
            var field = _.find(fields, function(field) {
                return field.name === name;
            }, this);

            // field may not be in module's list view metadata
            field = field || app.metadata._patchFields(tab.module, moduleMeta, [name]);

            // handle setting of the sortable flag on the list
            // this will not always be true
            var sortableFlag;
            var fieldDef = moduleMeta.fields[field.name];

            // if the module's field def says nothing about the sortability, then
            // assume it's ok to sort
            if (_.isUndefined(fieldDef) || _.isUndefined(fieldDef.sortable)) {
                sortableFlag = true;
            } else {
                // Get what the field def says it is supposed to do
                sortableFlag = !!fieldDef.sortable;
            }

            var column = _.extend({sortable: sortableFlag}, field);
            columns.push(column);
        }, this);

        return columns;
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        // Flag to show the tabs in the tabs.hbs template
        this.showTabs = this.tabs && this.tabs.length > 1;

        this.tabsHtml = this._tabsTemplate(this);

        var tab = this.settings.get('activeTab');

        var tabType = tab && tab.type;

        if (tabType === 'record') {
            this._setRecordState();
            this._setReadonlyFields();
        }

        this.tabContentHtml = this._getTabContentTemplate(tabType)(this);

        // Link to studio if showing a single record
        if (this._shouldShowStudioText(tab)) {
            this.showStudioText = true;
            this.linkToStudio = '#bwc/index.php?module=ModuleBuilder&action=index&type=studio';
        } else {
            this.showStudioText = false;
        }
        this._showHideListBottom(tab);

        this._super('_renderHtml');

        // Only show the SugarLive record link button if we're on an record tab that has an actual record in it
        if (tabType === 'record' && this.model.get('id')) {
            this.createSugarLiveLinkButton();
        } else if (this.sugarLiveLinkButton) {
            this._destroySugarLiveLinkButton();
        }
    },

    /**
     * Ensure at most one button exists at a time for the dashlet, for the current
     * active record view tab only
     * @inheritdoc
     */
    createSugarLiveLinkButton: function() {
        if (this.sugarLiveLinkButton) {
            this._destroySugarLiveLinkButton();
        }

        this._getCurrentSugarLiveContact();
        this._super('createSugarLiveLinkButton');
    },

    /**
     * @inheritdoc
     */
    _toggleSugarLiveButtonVisibility: function(isEdit) {
        let toolbar = this._getToolbar();
        if (toolbar && toolbar.$) {
            if (this.showSugarLiveLinkButton && !isEdit && this.model.get('id')) {
                toolbar.$('.omni-record-link').removeClass('hide');
            } else {
                toolbar.$('.omni-record-link').addClass('hide');
            }

            toolbar.adjustHeaderPaneTitle();
        }
    },

    /**
     * @inheritdoc
     */
    _insertSugarLiveButton: function(linkButton) {
        let toolbar = this._getToolbar();
        if (toolbar && toolbar.$) {
            let actionButtons = toolbar.$('.fieldset.actions.dashlet-toolbar').first();
            actionButtons.before(linkButton.$el);
        }
    },

    /**
     * Helper method to determine if we should show the edit in studio message
     *
     * @param {Object} tab The tab
     * @return {boolean} `true` to show the message
     * @private
     */
    _shouldShowStudioText: function(tab) {
        if (!tab || !tab.type || !tab.module) {
            return false;
        }
        return this.meta.pseudo && tab.type === 'record' &&
            app.acl.hasAccess('developer', tab.module) &&
            !_.isNull(app.metadata.getView(tab.module, 'recorddashlet'));
    },

    /**
     * Set the state of the current record view tab
     *
     * @private
     */
    _setRecordState: function() {
        var tab = this._getActiveTab();
        var contextModel = this._getContextModel();
        if (tab.model.dataFetched || this.meta.pseudo || this.configLayout) {
            this.recordState = 'READY';
        } else if (contextModel.dataFetched && _.isEmpty(tab.model.get('id'))) {
            this.recordState = 'NODATA';
        } else {
            this.recordState = 'LOADING';
        }
    },

    /**
     * Sets all model fields in `extraNoEditFields` array if we are in a config
     * layout, since the dashlet is for display purposes only and does not
     * represent a record.
     *
     * @private
     */
    _setReadonlyFields: function() {
        if (this.configLayout) {
            var tab = this._getActiveTab();
            var noEditFields = this.extraNoEditFields || [];
            noEditFields.push(_.keys(tab.model.fields));
            noEditFields = _.uniq(noEditFields);
            this.extraNoEditFields = noEditFields;
        }
    },

    /**
     * Get the correct content template based off of tab type and view type
     *
     * @param {string} tabType Either `record` or `list`
     * @return {*}
     * @private
     */
    _getTabContentTemplate: function(tabType) {
        if (this.meta.pseudo) {
            return tabType === 'list' ? this._configListTemplate : this._recordTemplate;
        }

        if (this._mode === 'main') {
            return tabType === 'list' ? this._recordsTemplate : this._recordTemplate;
        }
    },

    /**
     * @override
     *
     * Listen to change:model event to populate this dashlet with a new bean.
     */
    bindDataChange: function() {
        this.context.on('change:model', function(ctx, model) {
            this.switchModel(model);
            this._injectRecordHeader(model);
            this.render();
        }, this);
    },

    /**
     * @override
     *
     * The buttons are actually on the dashlet-toolbar component, so we have to
     * listen there rather than on the record view dashlet context.
     */
    delegateButtonEvents: function() {
        if (this._hasDelegated) {
            return;
        }

        var toolbar = this._getToolbar();
        if (!toolbar) {
            return;
        }

        var context = toolbar.context;
        this._hasDelegated = true;
        _.each(this._toolbarContextEvents, function(value, key) {
            context.on(key, value, this);
        }, this);
    },

    /**
     * @override
     */
    editClicked: function() {
        // the dashlet toolbar is triggering record view's editClicked, so override it here
        this._getToolbar().editClicked();
    },

    /**
     * Edit the underlying record (rather than the dashlet itself).
     */
    editRecord: function() {
        this._super('editClicked', arguments);
    },

    /**
     * @override
     *
     * Propagate button state requests to the dashlet toolbar.
     */
    setButtonStates: function(state) {
        var toolbar = this._getToolbar();
        toolbar && toolbar.setButtonStates(state);
    },

    /**
     * @override
     *
     * Do nothing. Dashlets should not affect the route.
     */
    setRoute: _.noop,

    /**
     * Get the dashlet toolbar component.
     *
     * @return {View.Layout}
     * @private
     */
    _getToolbar: function() {
        return this.layout && this.layout.getComponent('dashlet-toolbar');
    },

    /**
     * Use the given model to render this dashlet.
     * This transfers any events from the existing model to the new one.
     *
     * @param {Data.Bean} model Model to render.
     */
    switchModel: function(model) {
        this.model && this.model.abortFetchRequest();
        this.stopListening(this.model);
        this.model = model;
        if (this.module !== this.model.module) {
            this.module = this.model.module;
            this.meta = this._extendMeta({type: 'record', module: this.module});
            this._initDropdownBasedViews();
        }
        this._initTabs();
    },

    /**
     * Certain dashlet settings can be defaulted.
     *
     * Builds the available module cache by way of the
     * {@link BaseDashablerecordView#_setDefaultModule} call.
     *
     * @private
     */
    _initializeSettings: function() {
        var settings = _.extend(
            {},
            this._defaultSettings,
            this.settings.attributes
        );
        this.settings.set(settings);
        this._setDefaultModule();
        if (!this.settings.get('label')) {
            this.settings.set('label', 'LBL_MODULE_NAME');
        }
        if (!this.settings.has('tabs') && this.meta.tabs) {
            this.settings.set('tabs', this.meta.tabs);
        }
    },

    /**
     * Filters the list of extra modules to return only those the user has access to
     * @return {string[]}
     * @private
     */
    _getVisibleExtraModules: function() {
        return this.extraModules.filter(moduleName => app.acl.hasAccess('view', moduleName));
    },

    /**
     * Sets the default module when a module isn't defined in this dashlet's
     * view definition.
     *
     * If the module was defined but it is not in the list of available modules
     * in config mode, then the view's module will be used.
     *
     * @private
     */
    _setDefaultModule: function() {
        var availableModules = this._getAvailableModules();
        var metadata = app.metadata.getModule(this.model.module);
        var fields = metadata && metadata.fields;
        var module = this.settings.get('module') || this.context.get('module');

        // note: the module in the settings might actually be the name of a link field
        if (fields && this._isALink(module, fields)) {
            // FIXME: I might actually have to call _getModuleFromLink or whatever here
            module = fields[module].module;
        }

        if (module in availableModules) {
            this.settings.set('module', module);
        } else if (this._mode === 'config') {
            module = this.context.parent.get('module');
            if (_.contains(this.moduleBlacklist, module)) {
                module = _.first(_.keys(availableModules));
                // On 'initialize' model is set to context's model - that model can have no access at all
                // and we'll result in 'no-access' template after render. So we change it to default model.
                this.model = app.data.createBean(module);
            }
            this.settings.set('module', module);
        } else {
            this.moduleIsAvailable = false;
        }
    },

    /**
     * Perform any necessary setup before the user can configure the dashlet.
     *
     * Modifies the dashlet configuration panel metadata to allow it to be
     * dynamically primed prior to rendering.
     *
     * @private
     */
    _configureDashlet: function() {
        var availableModules = this._getAvailableModules();
        var validTabs = this._getValidTabs(_.keys(availableModules));

        _.each(this._getFieldMetaForView(this.meta), function(field) {
            if (field.name === 'module' || field.name === 'tab_list') {
                // load the list of available modules into the metadata
                field.options = validTabs;
                field.default = this.module;
            }
        }, this);

        this.listenTo(this.layout, 'init', this._addPseudoDashlet);

        // load the previously selected tabs by default
        var initialTabs = this.settings.get('tab_list');
        // in case this is the initial setup, load in the current module as the tab
        if (_.isUndefined(initialTabs)) {
            initialTabs = [this.settings.get('module')];
            var configTabs = this._generateConfigTabs(initialTabs);
            this.settings.set('tabs', configTabs);
        }
        this.settings.set('templateEdit', 'detail');
        this.settings.set('tab_list', initialTabs);
        this.settings.set('label', 'LBL_DASHLET_RECORDVIEW_NAME');

        this._bindSettingsEvents();
        this._bindSaveEvents();
    },

    /**
     * Gets all of the modules the current user can see.
     *
     * This is used for populating the module select field.
     * Filters out any modules that are blacklisted.
     *
     * @return {Object} {@link BaseDashablerecordView#_availableModules}
     * @private
     */
    _getAvailableModules: function() {
        if (_.isEmpty(this._availableModules) || !_.isObject(this._availableModules)) {
            this._availableModules = {};
            var visibleModules = app.metadata.getModuleNames({filter: 'visible', access: 'read'});
            visibleModules = visibleModules.concat(this._getVisibleExtraModules());
            var allowedModules = _.difference(visibleModules, this.moduleBlacklist);

            _.each(allowedModules, function(module) {
                var recordMeta = this._getRecordMeta(module);
                var hasRecordView = !_.isEmpty(this._getFieldMetaForView(recordMeta));
                if (hasRecordView) {
                    this._availableModules[module] = app.lang.getModuleName(module, {plural: true});
                }
            }, this);
        }
        return this._availableModules;
    },

    /**
     * Gets the fields metadata from a particular view's metadata.
     *
     * @param {Object} meta The view's metadata.
     * @return {Object[]} The fields metadata or an empty array.
     * @private
     */
    _getFieldMetaForView: function(meta) {
        meta = _.isObject(meta) ? meta : {};
        return _.compact(!_.isUndefined(meta.panels) ? _.flatten(_.pluck(meta.panels, 'fields')) : []);
    },

    /**
     * Gets the correct record view metadata.
     *
     * @param {string} module
     * @return {Object} The correct module record metadata.
     * @private
     */
    _getRecordMeta: function(module) {
        return app.metadata.getView(module, 'record');
    },

    /**
     * Renders the no-access template, then aborts further rendering.
     *
     * @return {boolean} Always returns `false`.
     * @private
     */
    _noAccess: function() {
        this.$el.html(this._noAccessTemplate());
        return false;
    },

    /**
     * Renders the no-tabs-available template, then aborts further rendering.
     *
     * @return {boolean} Always returns `false`.
     * @private
     */
    _noTabsAvailable: function() {
        this.$el.html(this._noTabsAvailableTemplate());
        return false;
    },

    /**
     * Prepare the header fields from the given panels and buttons.
     *
     * @param {Object[]} panels Record view panel metadata.
     * @param {Object[]} buttons Record view button metadata.
     * @param {Object[]} activeTab Active/current tab.
     * @private
     */
    _prepareHeader: function(panels, buttons, activeTab) {
        this._headerFields = this._headerFields || [];
        this._headerButtons = this._headerButtons || [];
        var model = activeTab ? activeTab.model : null;
        var tabType = activeTab ? activeTab.type : null;

        // find which (if any) of the panels is for the header
        var headerIndex = _.findIndex(panels, function(panel) {
            return panel.header === true;
        });

        if (headerIndex !== -1) {
            // get all the fields we want to show in the header and shrink them down if necessary
            var header = panels[headerIndex];
            var fields = _.filter(header.fields, _.bind(function(field) {
                return !field.type || !_.includes(this._noshowFields, field.type);
            }, this));

            // shrink certain header fields down for the toolbar
            _.each(fields, function(field) {
                if (field.size) {
                    field.size = 'button';
                }
                if (field.type === 'avatar') {
                    field.height = field.height ? Math.min(field.height, this._avatarSize) : this._avatarSize;
                    field.width = field.width ? Math.min(field.width, this._avatarSize) : this._avatarSize;
                }
            }, this);

            // tweak the buttons as necessary
            var desiredButtons = this._getHeaderButtons(buttons, activeTab);
        } else if (tabType === 'list') {
            this._headerFields = this._getHeaderFieldsForListTab();
        }
        this._headerFields = fields || this._headerFields;
        this._headerButtons = desiredButtons || this._headerButtons;

        this._initButtons();
        this._injectRecordHeader(model);

        if (_.isFunction(this.insertActionButtonsRows)) {
            this.insertActionButtonsRows();
        }
    },

    /**
     * Adjust the given button definitions for appropriate use in the dashlet
     * toolbar.
     *
     * @param {Object[]} buttons List of button fielddefs from metadata.
     * @param {Object[]} tab Current tab
     * @return {Object[]} The list of button definitions tweaked for the
     *   dashlet toolbar.
     * @private
     */
    _getHeaderButtons: function(buttons, tab) {
        var desiredButtons = [];
        // If we're rendering this dashlet in a console config layout, we do NOT
        // want edit, save, or cancel buttons on our empty dashlet
        // Also don't display the buttons if there's no related record
        if (this.configLayout || !this.model || !this.model.get('id')) {
            return desiredButtons;
        }

        var self = this;
        _.each(buttons, function(button) {
            if (button.buttons) { // dropdown
                // remove all dividers
                button.buttons = _.filter(button.buttons, function(subButton) {
                    return subButton.type !== 'divider';
                });

                // Mark dropdowns as needing to be filtered
                _.each(button.buttons, function(button) {
                    button.filterForRecordDashlet = true;
                });
            }
            var desiredButtonNames = [
                'save_button',
                'cancel_button',
                'edit_button',
                'dashlet_save_button',
                'dashlet_cancel_button',
                'dashlet_edit_button',
            ];
            if (_.includes(desiredButtonNames, button.name) || button.type === 'actiondropdown') {
                if (!button.name.includes('dashlet_')) {
                    button.name = 'dashlet_' + button.name;
                }
                desiredButtons.push(button); // note, save the original button, not the subbutton
            }
        });

        return desiredButtons;
    },

    /**
     * Re-fetch the model and update the metadata after an action has finished
     * @private
     */
    _updateAllowedButtons: function() {
        var tab = this.settings.get('activeTab');

        if (!tab) {
            return;
        }

        var self = this;
        tab.model.fetch({
            showAlerts: true,
            success: function(model) {
                if (self._isActiveTab(tab)) {
                    self.meta = self._extendMeta(tab);
                    self.render();
                }
            }
        });
    },

    /**
     * Send header fielddefs and model data to the dashlet toolbar.
     *
     * @param {Data.Bean} [model] Model to send to the toolbar. If undefined,
     *   the header fielddefs will be sent to the toolbar but the model data
     *   will not.
     * @private
     */
    _injectRecordHeader: function(model) {
        if (this.meta && this.meta.pseudo) {
            return;
        }
        // inject header content into dashlet toolbar
        var dashletToolbar = this._getToolbar();
        if (dashletToolbar) {
            var buttonsToSend = [];
            var activeTab = this._getActiveTab() || {};
            if (app.acl.hasAccessToModel('edit', model) && activeTab.type === 'record') {
                buttonsToSend = this._headerButtons;
            }

            var toolbarCtx = dashletToolbar.context;
            toolbarCtx.trigger('dashlet:toolbar:change', this._headerFields, buttonsToSend, model, this);
            this.delegateButtonEvents();
        }
    },

    /**
     * Build the header fields array object for list type tab
     *
     * @return {Array}
     * @private
     */
    _getHeaderFieldsForListTab: function() {
        var labelValue = app.lang.get('LBL_RELATED_RECORDS', null, {
            module: app.lang.getModuleName(this.module, {plural: true})
        });
        return [
            {
                dismiss_label: true,
                height: this._avatarSize,
                label: 'LBL_PICTURE_FILE',
                name: 'picture',
                size: 'button',
                type: 'avatar',
                width: this._avatarSize,
                readonly: true,
            },
            {
                type: 'label',
                formatted_value: labelValue,
                readonly: true,
            },
        ];
    },

    /**
     * Set the proper widths of the dashlet-toolbar fields
     */
    adjustHeaderpaneFields: function() {
        this._super('adjustHeaderpaneFields');
        var toolbar = this._getToolbar();
        if (!toolbar) {
            return;
        }
        var $recordCells = this._getRecordCells();
        var nameField = this._getNameFieldFromRecordCells($recordCells);
        var $nameField = $(nameField);
        if ($nameField.hasClass('edit')) {
            // We need to calculate how much available space there is for the name field
            var fieldsWidth = 0;
            var toolbarWidth = toolbar.$el.outerWidth();
            var btnsWidth = toolbar.$('.btn-toolbar').outerWidth();
            _.each(toolbar.$('.table-cell-wrapper'), function(cell) {
                var $cell = $(cell);
                var parentType = $cell.parent().data('type');
                // ignore the name field since we are going to change its width anyways
                if (parentType === 'name' || parentType === 'fullname') {
                    return;
                }
                fieldsWidth += $cell.outerWidth();
            });

            // subtracting additional 20px to avoid the name field overlapping button
            var nameFieldWidth = toolbarWidth - btnsWidth - fieldsWidth - 20;
            $nameField.find('.table-cell-wrapper').css({width: nameFieldWidth + 'px'});
        } else {
            $nameField.find('.table-cell-wrapper').css({width: ''});
        }

        // Make sure the header fields use the correct templates
        if (this.action === 'detail') {
            let nameFields = _.filter(this.editableFields, function(field) {
                return _.contains(['name', 'fullname'], field.type);
            });
            _.each(nameFields, function(field) {
                if (field.$el) {
                    field.setMode('dashlet-header');
                }
            });
        }

        toolbar.adjustHeaderPaneTitle();
    },

    /**
     * Get the name field a list of record-cells
     * @param {Array} $cells Array of jQuery elements
     * @return {jQuery}
     * @private
     */
    _getNameFieldFromRecordCells: function($cells) {
        var nameFields = ['name', 'fullname'];
        return _.find($cells, function(cell) {
            return _.contains(nameFields, $(cell).data('type'));
        });
    },

    /**
     * dashablerecord has fields on this view and on the dashlet-toolbar view. We need both
     * @inheritdoc
     */
    _getNonButtonFields: function() {
        var viewFields = this._filterButtonsFromFields(this.fields);
        var toolbarFields = [];
        var toolbar = this._getToolbar();
        if (toolbar) {
            toolbarFields = this._filterButtonsFromFields(toolbar.fields);
        }

        return _.union(toolbarFields, viewFields);
    },

    /**
     * Filter out dashletaction fields
     * @inheritdoc
     */
    _filterButtonsFromFields: function(fields) {
        fields = this._super('_filterButtonsFromFields', [fields]);
        return _.filter(fields, function(field) {
            if (field.type === 'dashletaction') {
                return false;
            }
            return true;
        });
    },

    /**
     * Set up buttons from the header instead of from record meta. Assume this._headerButtons is set up already
     * @override
     */
    _initButtons: function() {
        this.buttons = [];
        _.each(this._headerButtons, function(button) {
            this.registerFieldAsButton(button.name);
        }, this);
    },

    /**
     * Get button field instances from the toolbar instead of from this view.
     * @override
     */
    registerFieldAsButton: function(buttonName) {
        var toolbar = this._getToolbar();
        if (toolbar) {
            var button = toolbar.getField(buttonName);
            if (button) {
                this.buttons[buttonName] = button;
            }
        }
    },

    /**
     * Gets the dashletconfiguration layout.
     *
     * @return {View.Layout} The dashletconfiguration layout.
     * @private
     */
    _getDashletConfiguration: function() {
        return this.closestComponent('dashletconfiguration');
    },

    /**
     * Turn the dashlet configuration save button on or off.
     *
     * @param {bool} enabled true to enable and false to disable.
     * @private
     */
    _toggleDashletSaveButton: function(enabled) {
        this._getDashletConfiguration().trigger('dashletconfig:save:toggle', enabled);
    },

    /**
     * Initialize tabs.
     *
     * @param {Object[]} [newTabs] List of new tabs.
     * @private
     */
    _initTabs: function(newTabs) {
        this.tabs = [];

        var dashletTabs;
        if (this._mode === 'config') {
            dashletTabs = this.meta.tabs || [];
        } else if (this.meta.pseudo) {
            dashletTabs = this._patchTabsFromSettings(newTabs);
        } else {
            dashletTabs = newTabs || this._getTabsFromSettings() || this.meta.tabs || [];
        }

        _.each(dashletTabs, function(tab, index) {
            if (!app.acl.hasAccess('view', tab.module)) {
                return;
            }
            if (tab.active) {
                this.settings.set('activeTabIndex', index);
                this.settings.set('activeTab', tab);
            }
            tab.type = tab.type || this._getTabType(tab.link);
            var module;
            if (tab.type === 'list') {
                var collection = this._createCollection(tab);
                if (_.isNull(collection)) {
                    return;
                }
                module = tab.module;
                tab.model = app.data.createBean(module);
                if (tab.fields) {
                    tab.model.set('fields', tab.fields, {silent: true});
                }
                if (tab.limit) {
                    tab.model.set('limit', tab.limit, {silent: true});
                }
                if (tab.auto_refresh) {
                    tab.model.set('auto_refresh', tab.auto_refresh, {silent: true});
                }
                if (!_.isUndefined(tab.freeze_first_column)) {
                    tab.model.set('freeze_first_column', tab.freeze_first_column, {silent: true});
                }
                tab.collection = collection;
                tab.relate = _.isObject(collection.link);
                tab.include_child_items = tab.include_child_items || false;
                tab.collection.display_columns = [{
                    fields: this._getColumnsForTab(tab),
                    module: module
                }];
                tab.collection.orderBy = tab.order_by || {};
                if (this.meta.pseudo) {
                    tab.meta = app.metadata.getView(null, this.name).listsettings;
                    _.each(this._getFieldMetaForView(tab.meta), function(field) {
                        if (field.name === 'fields') {
                            // load the list of available modules into the metadata
                            field.options = this._getAvailableColumns(tab);
                            field.default = tab.module;
                        }
                    }, this);
                } else {
                    tab.meta = this._getFieldMetaForTab(tab);
                }
            } else if (tab.type === 'record') {
                // Single record (record view tab)
                module = tab.module;
                tab.meta = app.metadata.getView(module, 'recorddashlet') || app.metadata.getView(module, 'record');
                var contextModel = this._getContextModel() || app.data.createBean(module);
                if (this.meta.pseudo) {
                    tab.model = app.data.createBean(module);
                } else if (tab.link === tab.module || tab.link === '') {
                    // Record view for the context model
                    tab.model = this._cloneModel(this._getContextModel());
                } else {
                    // related 1 side record view
                    var id = null;
                    var relationship = contextModel.get(tab.link);
                    if (relationship) {
                        id = relationship.id || null;
                    }
                    tab.model = app.data.createRelatedBean(contextModel, id, tab.link);
                }
                if (this.configLayout) {
                    _.each(tab.meta.panels, function(panel) {
                        _.each(panel.fields, function(field) {
                            field.readonly = true;
                        });
                    });
                }
                this._setDataView(tab.model);
            }
            this.tabs[index] = tab;
        }, this);

        // Set this to false if we pruned out all the tabs
        this.moduleIsAvailable = !((this.tabs.length === 0) && (dashletTabs.length > 0));
    },

    /**
     * Sets up tabs by pulling any saved tab info from setting and merging
     * with any new tabs to be created
     *
     * @param {Array} newTabs Tabs to shown
     * @return {Array} Tabs that have picked up any saved settings
     */
    _patchTabsFromSettings: function(newTabs) {
        var settings = this.settings.get('tabs');
        var tabs = [];

        _.each(newTabs, function(t) {
            var foundTab = _.find(settings, function(s) {
                return s.link == t.link;
            });
            if (foundTab) {
                tabs.push(_.extend(t, foundTab));
            } else {
                tabs.push(t);
            }

        });
        return tabs;
    },

    /**
     * Given a list of tab names (either base module or a link field name),
     * return a list of tabs suitable for rendering.
     *
     * @param {string[]} tablist List of tabs (base module or link name).
     * @param {Object} [options] Additional tab options (to be applied to every
     *   tab.)
     * @return {Object[]} The list of tab objects.
     * @private
     */
    _generateConfigTabs: function(tablist, options) {
        if (_.isEmpty(tablist)) {
            return [];
        }

        options = options || {};

        return _.map(tablist, function(tab) {
            var link = tab;
            if (_.isObject(tab)) {
                link = tab.link || tab.module;
            }

            var tabType = this._getTabType(link);
            var relatedModule = this._getRelatedModule(link);

            var baseOptions = {
                type: tabType,
                label: this._getLinkLabel(link),
                module: relatedModule,
                link: link
            };

            // FIXME CS-63: we'll probably want to do this differently later
            if (tabType === 'list') {
                baseOptions.fields = _.pluck(app.metadata.getView(relatedModule, 'list').panels[0].fields, 'name');
                baseOptions.limit = this._defaultSettings.limit;
                baseOptions.freeze_first_column = this._defaultSettings.freeze_first_column;
                baseOptions.skipFetch = true;
            }

            return _.extend(baseOptions, options);
        }, this);
    },

    /**
     * Determine whether a tab for the given link name is a list type or a
     * record type.
     *
     * @param {string} linkName The link name.
     * @return {string} "list" if this tab should be a list view and "record"
     *   otherwise.
     * @private
     */
    _getTabType: function(linkName) {
        return app.data.canHaveMany(this._baseModule, linkName) ? 'list' : 'record';
    },

    /**
     * Get the link label for the given link field name.
     *
     * @param {string} linkName Name of the link field.
     * @return {string}
     * @private
     */
    _getLinkLabel: function(linkName) {
        if (this._isLinkToBaseRecord(linkName)) {
            return this._getBaseRecordLabel();
        }

        var fields = this._getBaseModuleFields();
        var linkField = fields[linkName];
        var module = this._getModuleFromLinkField(linkField);

        return app.lang.get(
            linkField.vname,
            [this._baseModule, module]
        );
    },

    /**
     * Get the related module name given a link name,
     * relative to the base module.
     *
     * If given the base module, just return that.
     *
     * @param {string} linkName Link field name.
     * @return {string} Name of the related module.
     * @private
     */
    _getRelatedModule: function(linkName) {
        if (this._isLinkToBaseRecord(linkName)) {
            return this._baseModule;
        }

        return this._getModuleFromLinkField(this._getBaseModuleFields()[linkName]);
    },

    /**
     * Get the module from a link field.
     *
     * @param {Object} linkField The link field vardef.
     * @return {string} The name of the module.
     * @private
     */
    _getModuleFromLinkField: function(linkField) {
        if (!linkField || !linkField.name) {
            return '';
        }

        if (linkField.module) {
            return linkField.module;
        }

        // a lot of link fields don't actually have a module on them (look at the Accounts vardef for proof)
        // in that case, determine the module from the relationship rather than the link
        return app.data.getRelatedModule(this._baseModule, linkField.name);
    },

    /**
     * For the dashlet, get a list of tabs to show from the config
     * settings.
     *
     * @return {Object[]} List of dashlet tabs as retrieved from settings.
     * @private
     */
    _getTabsFromSettings: function() {
        return this.settings.get('tabs');
    },

    /**
     * Check if the given string corresponds to a link field.
     *
     * @param {string} str The name to check.
     * @param {Object} fields The fielddefs for the module to check.
     * @return {boolean} true if the given name corresponds to a link field,
     *   false otherwise.
     * @private
     */
    _isALink: function(str, fields) {
        return !!(fields[str] && fields[str].type === 'link');
    },

    /**
     * Get a translated label of the form "This <module>"
     * for the base module.
     *
     * @return {string}
     * @private
     */
    _getBaseRecordLabel: function() {
        return app.lang.get(
            'TPL_DASHLET_RECORDVIEW_THIS_RECORD_TYPE',
            null,
            {moduleSingular: app.lang.getModuleName(this._baseModule)}
        );
    },

    /**
     * Get the list of acceptable tabs filtered across available modules,
     * which are related to the base module.
     *
     * @param {string[]} availableModules The list of available modules.
     * @return {Object} A mapping of link field names to display link labels.
     * @private
     */
    _getValidTabs: function(availableModules) {
        var baseRecordTypes = {};

        // get the "This Account" label
        baseRecordTypes[this._baseModule] = this._getBaseRecordLabel();

        // find the related module for each link field and make sure we can use it
        var linkFields = this._getBaseModuleLinks();
        _.each(linkFields, function(linkField) {
            var relatedModule = app.data.getRelatedModule(this._baseModule, linkField.name);

            if (!_.contains(availableModules, relatedModule) || _.contains(this.tabBlacklist, relatedModule)) {
                return;
            }

            baseRecordTypes[linkField.name] = this._getLinkLabel(linkField.name);
        }, this);

        return baseRecordTypes;
    },

    /**
     * In config mode, bind events that occur when the configuration options
     * are (about to be) saved.
     *
     * @private
     */
    _bindSaveEvents: function() {
        this.layout.before('dashletconfig:save', function() {
            // save the dashlet tabs settings in full, not the strings-only version
            var tabs = this._pseudoDashlet.settings.get('tabs');
            var settings = {
                base_module: this._baseModule,
                label: this.settings.get('label'),
                tabs: this._getTabsToSave(tabs),
                //tab_list: this.settings.get('tab_list'), // not sure if we need this, uncomment if we find a bug
            };

            // don't save unwanted record view metadata into the dashlet. Just whitelist what we need.
            this.settings.clear({silent: true});

            this.settings.set(settings, {silent: true});
            this.dashModel.set(settings, {silent: true});
        }, this);
    },

    /**
     * Sanitize and only save properties of tabs that matter in DB
     * @param {Array} tabs List of tabs to save
     * @return {Array} Tabs that have been sanitized
     */
    _getTabsToSave: function(tabs) {
        var returnTabs = [];
        _.each(tabs, function(tab) {
            var tabToSave = {
                type: tab.type,
                module: tab.module,
                label: tab.label,
                link: tab.link
            };
            if (tab.type === 'list') {
                var listOptions = {
                    fields: tab.model.get('fields') || [],
                    limit: tab.model.get('limit'),
                    auto_refresh: tab.model.get('auto_refresh'),
                    freeze_first_column: tab.model.get('freeze_first_column'),
                };
                tabToSave = _.extend(tabToSave, listOptions);
            }
            returnTabs.push(tabToSave);
        });
        return returnTabs;
    },

    /**
     * In config mode, bind events that occur when the configuration options
     * change.
     *
     * @private
     */
    _bindSettingsEvents: function() {
        // Commenting this out until we support 2 level relationships
        // this.settings.on('change:module', function(model, moduleName) {
        //     this.dashModel.set('module', moduleName);
        //
        //     // clear out any previously selected tabs, except for the new base record type
        //     this._resetConfigTabs();
        //     this.settings.set('tabs', [moduleName]);
        // }, this);

        this.settings.on('change:tab_list', function(model, tabs) {
            // show warning message if too many tabs
            if (tabs && tabs.length > this._tabLimit.number) {
                this._showTooManyTabsWarning();
            }

            // disable save button on both 0 and too many tabs
            var enableSaveButton = tabs && tabs.length && tabs.length <= this._tabLimit.number;
            this._toggleDashletSaveButton(enableSaveButton);

            // for rendering the tabs in the config
            var configTabs = this._generateConfigTabs(tabs || [], {skipFetch: true});
            model.set('tabs', configTabs, {silent: true});
            var configDashletLayout = this.layout.getComponent('dashlet');
            configDashletLayout.context.trigger('dashablerecord:config:tablist:change', configTabs);
        }, this);
    },

    /**
     * Show a warning that there are too many tabs selected.
     *
     * @private
     */
    _showTooManyTabsWarning: function() {
        app.alert.show('too_many_tabs', {
            level: 'warning',
            messages: app.lang.get(
                'TPL_DASHLET_RECORDVIEW_TOO_MANY_TABS',
                null,
                {num: this._tabLimit.number, numWord: app.lang.get(this._tabLimit.label)}
            )
        });
    },

    /**
     * Return the fielddefs from the base module.
     *
     * @return {Object} Fielddefs from the base module.
     * @private
     */
    _getBaseModuleFields: function() {
        if (this._baseModuleFields) {
            return this._baseModuleFields;
        }

        this._baseModuleFields = app.metadata.getModule(this._baseModule).fields;
        return this._baseModuleFields;
    },

    /**
     * Get all fields of type link from the base module.
     *
     * @return {Object[]} List of base module fields of type link.
     * @private
     */
    _getBaseModuleLinks: function() {
        return _.filter(this._getBaseModuleFields(), function(field) {
            return field.type && field.type === 'link';
        });
    },

    /**
     * Show or hide the list-bottom component depending on the tab type.
     *
     * @param {Object} tab Tab to be shown.
     * @param {boolean} forceHide Force the list-bottom component to hide
     * @private
     */
    _showHideListBottom: function(tab, forceHide) {
        var listBottom = this.layout.getComponent('list-bottom');
        if (!listBottom) {
            return;
        }
        if (forceHide) {
            listBottom.hide();
        } else {
            tab && tab.type === 'list' ? listBottom.show() : listBottom.hide();
        }
    },

    /**
     * Get the collection of record-cell elements in the header.
     *
     * @return {jQuery|undefined} The collection of record-cell and btn-toolbar
     *   elements from the toolbar, or `undefined` if the toolbar is not
     *   available.
     * @private
     */
    _getRecordCells: function() {
        var toolbar = this._getToolbar();
        if (!toolbar) {
            return;
        }
        return toolbar.$('h4.record-toolbar').children('.record-cell, .btn-toolbar');
    },

    /**
     * @override
     *
     * Get the available width for fields in the header.
     * From the full width of the container we need to subtract
     * the paddings and reserve some space for custom buttons.
     * The super method relies on functionality that is not present
     * in the context this component is used in. (`layout.getPaneWidth`)
     *
     * @return {number} Returns the numeric width value to be assgined to the title field.
     */
    getContainerWidth: function() {
        var containerWidth = 0;
        var titleRightIndent = 10;
        var defaultRecommendedWidth = 230;
        var btnBar = this.layout.$el.find('.btn-toolbar');
        var titleBar = this.layout.$el.find('.dashlet-title');
        // we need to use header bar as we are subtracting other widths from this to get title width
        var headerBar = this.layout.$el.find('.dashlet-header');

        if (titleBar.length && headerBar) {
            var titleBarChildMargins = 0;
            _.each(titleBar.children(), function(child) {
                titleBarChildMargins += parseInt($(child).css('marginLeft'), 10) || 0;
                titleBarChildMargins += parseInt($(child).css('marginRight'), 10) || 0;
            });
            containerWidth = headerBar.width() - titleBarChildMargins - titleRightIndent;

            if (btnBar.length) {
                var buttonsWidth = 0;
                _.each(btnBar.children(), function(button) {
                    var $button = $(button);
                    if ($button.css('display') !== 'none') {
                        buttonsWidth += $button.outerWidth(true);
                    }
                });

                var btnBarLeftMargin = parseInt(btnBar.css('marginLeft'), 10) || 0;
                if (buttonsWidth > btnBarLeftMargin) {
                    containerWidth -= (buttonsWidth - btnBarLeftMargin);
                }
            }
        }

        return (containerWidth > 0) ? containerWidth : defaultRecommendedWidth;
    },

    /**
     * Gets a list of columns for a list view tab regardless of any saved settings.
     * Updates the fields enum field
     * @private
     */
    _updateDisplayColumns: function() {
        var tab = this.settings.get('activeTab');
        if (!tab) {
            return;
        }
        // need to check if we already have columns saved in tabs and pull that instead if it is set
        var availableColumns = this._getAvailableColumns(tab);
        var columnsFieldName = 'fields';
        var columnsField = this.getField(columnsFieldName);
        if (columnsField) {
            columnsField.items = availableColumns;
        }
        this.model.set(columnsFieldName, _.keys(availableColumns));
        columnsField.render();
    },

    /**
     * Gets all columns for a list view tab
     *
     * @param {Object} tab
     * @return {Array} A list of columns
     * @private
     */
    _getAvailableColumns: function(tab) {
        var columns = {};
        var module = tab.module;
        if (!module) {
            return columns;
        }

        _.each(this._getFieldMetaForTab(tab), function(field) {
            columns[field.name] = app.lang.get(field.label || field.name, module);
        });

        return columns;
    },

    /**
     * Focus a row in the list
     * @param {string} id The id of the record to focus on
     */
    focusRow: function(id) {
        var $row = this.getRowDomForModelId(id);
        this.highlightRow($row);
        this.makeRowVisible($row);
    },

    /**
     * Highlights a row by making the row blue. Also removes the highlight from
     * any other row.
     * @param {jQuery} $el The element for the row to highlight
     */
    highlightRow: function($el) {
        this.unhighlightRows();
        if ($el.length) {
            $el.addClass('current highlighted');
        }
    },

    /**
     * Un-highlight all currently selected rows.
     */
    unhighlightRows: function() {
        let highlightedRows = this.$('tr.current.highlighted');
        if (highlightedRows.length) {
            highlightedRows.removeClass('current highlighted');
        }
    },

    /**
     * Get the DOM for the row that represents a model.
     * @param {string} id The model id
     * @return {jQuery}
     */
    getRowDomForModelId: function(id) {
        return this.$(`tr[data-id="${id}"]`);
    },

    /**
     * Scroll the list so the selected row is visible
     * @param $selected
     */
    makeRowVisible: function($selected) {
        if (!$selected) {
            this.$el.scrollTop();
            return;
        }

        let rowTop = $selected.position().top;
        let rowHeight = $selected.height();
        let rowBottom = rowTop + rowHeight;
        let dashletTop = this.$el.scrollTop();
        let dashletHeight = this.$el.height();
        let dashletBottom = dashletTop + dashletHeight;

        if (rowBottom >= dashletBottom || rowTop <= dashletTop) {
            this.$el.scrollTop(rowTop);
        }
    },

    /**
     * @inheritdoc
     * @private
     */
    _render: function() {
        this._super('_render');
        this.scrollContainer = this.$el.find('.dashablerecord .tab-content');
    },
}) },
"dashletconfiguration-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletconfigurationHeaderpaneView
 * @alias SUGAR.App.view.views.BaseDashletconfigurationHeaderpaneView
 * @extends View.View
 */
({
	// Dashletconfiguration-headerpane View (base) 

    plugins: ['Editable', 'ErrorDecoration'],

    events: {
        "click a[name=cancel_button]": "close",
        "click a[name=save_button]":   "save"
    },

    /**
     * Store the translated i18n label.
     * @type {String} Translated dashlet's title label.
     * @private
     */
    _translatedLabel: null,

    /**
     * @inheritdoc
     * Binds the listener for the before `save` event.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.before('save', function(model) {
            return this.layout.triggerBefore('dashletconfig:save', model);
        }, this);

        //shortcut keys
        app.shortcuts.register({
            id: 'Dashlet:Config:Cancel',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $cancelButton = this.$('a[name=cancel_button]');
                if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                    $cancelButton.click();
                }
            }
        });
        app.shortcuts.register({
            id: 'Dashlet:Config:Save',
            keys: ['mod+s','mod+alt+a'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_SAVE',
            callOnFocus: true,
            handler: function() {
                var $saveButton = this.$('a[name=save_button]');
                if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                    $saveButton.click();
                }
            }
        });

        // allow explicitly enabling and disabling the save button
        var dashletConfig = this.closestComponent('dashletconfiguration');
        this.listenTo(dashletConfig, 'dashletconfig:save:toggle', function(enabled) {
            var saveButton = this.getField('save_button');
            saveButton.setDisabled(!enabled);
        });
    },

    /**
     * @inheritdoc
     * Compare with the previous attributes and translated dashlet's label
     * in order to warn unsaved changes.
     *
     * @return {Boolean} true if the dashlet setting contains changes.
     */
    hasUnsavedChanges: function() {
        var previousAttributes = _.extend(this.model.previousAttributes(), {
            label: this._translatedLabel
        });
        return !_.isEmpty(this.model.changedAttributes(previousAttributes));
    },

    /**
     * Triggers a `save` event before `app.drawer.close()` is called, in case
     * any processing needs to be done on the model before it is saved.
     *
     * @return {Boolean} `false` if the `dashletconfig:save` event returns false.
     */
    save: function() {
        if (this.triggerBefore('save', this.model) === false) {
            return false;
        }

        var fields = {};
        _.each(this.meta.panels[0].fields, function(field) {
            fields[field.name] = field;
        });

        this.model.doValidate(fields, _.bind(function(isValid) {
            if (isValid) {
                app.drawer.close(this.model);
            }
        }, this));
    },

    /**
     * Closes the containing drawer.
     */
    close: function() {
        app.drawer.close();
    },

    /**
     * @inheritdoc
     *
     * Translate model label before render using model attributes.
     */
    _renderHtml: function() {
        var label;
        this.model = this.context.get('model');
        label = app.lang.get(
            this.model.get('label'),
            this.model.get('module') || this.module,
            this.model.attributes
        );
        this._translatedLabel = label;
        if (this.model.get('templateEdit') !== 'detail') {
            this.model.set('templateEdit', 'edit');
        }
        this.model.set('label', label, {silent: true});
        app.view.View.prototype._renderHtml.call(this);
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.CreateView
 * @alias SUGAR.App.view.views.CreateView
 * @extends View.Views.Base.RecordView
 */
({
	// Create View (base) 

    extendsFrom: 'RecordView',
    editAllMode: false,

    enableDuplicateCheck: false,
    dupecheckList: null, //duplicate list layout

    saveButtonName: 'save_button',
    cancelButtonName: 'cancel_button',
    restoreButtonName: 'restore_button',

    /**
     * If this create view has subpanel models to save
     */
    hasSubpanelModels: false,

    /*
     * Pre-population from Omnichanel
     */
    omniPopulation: false,

    /**
     * A collection of alert messages to be used in this view. The alert methods
     * should be invoked by Function.prototype.call(), passing in an instance of
     * a sidecar view. For example:
     *
     *     // ...
     *     this.alerts.showInvalidModel.call(this);
     *     // ...
     *
     * FIXME: SC-3451 will refactor this `alerts` structure.
     * @property {Object}
     */
    alerts: {
        showInvalidModel: function() {
            if (!this instanceof app.view.View) {
                app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                return;
            }
            var name = 'invalid-data';
            this._viewAlerts.push(name);
            app.alert.show(name, {
                level: 'error',
                messages: 'ERR_RESOLVE_ERRORS'
            });
        },
        showServerError: function() {
            if (!this instanceof app.view.View) {
                app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                return;
            }
            var name = 'server-error';
            this._viewAlerts.push(name);
            app.alert.show(name, {
                level: 'error',
                messages: 'ERR_GENERIC_SERVER_ERROR'
            });
        },
        showSuccessButDeniedAccess: function() {
            if (!this instanceof app.view.View) {
                app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                return;
            }
            var name = 'invalid-data';
            this._viewAlerts.push(name);
            app.alert.show(name, {
                level: 'warning',
                messages: 'LBL_RECORD_SAVED_ACCESS_DENIED',
                autoClose: true,
                autoCloseDelay: 9000
            });
        }
    },

    /**
     * Initialize the view and prepare the model with default button metadata
     * for the current layout.
     */
    initialize: function (options) {
        this.plugins = _.union(this.plugins || [], [
            'FindDuplicates'
        ]);

        //add states for create view
        this.STATE = _.extend({}, this.STATE, {
            CREATE: 'create',
            SELECT: 'select',
            DUPLICATE: 'duplicate'
        });

        //inherit base create metadata for purpose of initialization
        options.meta = _.extend({}, app.metadata.getView(null, 'create'), options.meta);

        this._super("initialize", [options]);

        // FIXME: SC-3451 will refactor this `alerts` structure.
        this.alerts = _.extend({}, this.alerts, {
            showServerError: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                var name = 'server-error';
                this._viewAlerts.push(name);
                app.alert.show(name, {
                    level: 'error',
                    messages: 'ERR_GENERIC_SERVER_ERROR'
                });
            },
            showNoAccessError: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                var name = 'server-error';
                this._viewAlerts.push(name);
                this.cancel();
                app.alert.show(name, {
                    level: 'error',
                    messages: 'ERR_HTTP_404_TEXT_LINE1'
                });
            },
            showSuccessButDeniedAccess: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                var name = 'invalid-data';
                this._viewAlerts.push(name);
                app.alert.show(name, {
                    level: 'warning',
                    messages: 'LBL_RECORD_SAVED_ACCESS_DENIED',
                    autoClose: true,
                    autoCloseDelay: 9000
                });
            }
        });

        this.model.off("change", null, this);

        //keep track of what post-save action was chosen in case user chooses to ignore dupes
        this.context.lastSaveAction = null;

        //listen for the select and edit button
        this.context.on('list:dupecheck-list-select-edit:fire', this.editExisting, this);

        //enable buttons if there is an error
        this.model.on('error:validation', this.enableButtons, this);

        //extend the record view definition
        this.meta = _.extend({}, app.metadata.getView(this.module, 'record'), this.meta);

        //enable or disable duplicate check?
        var moduleMetadata = app.metadata.getModule(this.module);
        this.enableDuplicateCheck = (moduleMetadata && moduleMetadata.dupCheckEnabled) || false;

        // If user has no list acl it doesn't make sense to enable dupecheck
        if (!app.acl.hasAccess('list', this.module)) {
            this.enableDuplicateCheck = false;
        }

        var fields = (moduleMetadata && moduleMetadata.fields) ? moduleMetadata.fields : {};

        this.model.relatedAttributes = this.model.relatedAttributes || {};

        this.populateFromOmnichanel();

        var assignedUserField = _.find(fields, function(field) {
            return field.type === 'relate' &&
                (field.name === 'assigned_user_id' || field.id_name === 'assigned_user_id');
        });
        if (assignedUserField) {
            // set the default assigned user as current user, unless we are copying another record
            var isDuplicate = this.model.has('assigned_user_id') && this.model.has('assigned_user_name');
            if (!isDuplicate) {
                this.model.setDefault({
                    'assigned_user_id': app.user.id,
                    'assigned_user_name': app.user.get('full_name')
                });
            }
            this.model.relatedAttributes.assigned_user_id = app.user.id;
            this.model.relatedAttributes.assigned_user_name = app.user.get('full_name');
        }

        // need to reset the default attributes because the plugin may have
        // calculated default values.
        this.on('sugarlogic:initialize', function() {
            this.model.setDefault(this.model.attributes);
        }, this);
    },

    /**
     * @inheritdoc
     */
    _getDropdownBasedViewName: function() {
        return 'record';
    },

    /**
     * Extends in order to set the {@link #action} to `create` while the fields
     * are rendering.
     *
     * This is a temporary fix that will be reviewed in 7.8. The action should
     * be `create` at all times but doing the proper fix may have bad impacts on
     * ACLs/non editable fields. Follow up in SC-4511.
     *
     * @inheritdoc
     */
    _renderFields: function() {
        var current = this.action;
        this.action = 'create';
        this._super('_renderFields');
        this.action = current;
    },

    /**
     * @inheritdoc
     */
    /**
     * Check unsaved changes.
     * This method is called by {@link app.plugins.Editable}.
     *
     * @return {Boolean} `true` if current model contains unsaved changes,
     *  `false` otherwise.
     */
    hasUnsavedChanges: function() {
        var defaults,
            nonDefaultedAttributesChanged,
            defaultedAttributesChanged;

        if (this.resavingAfterMetadataSync) {
            return false;
        }

        defaults = this.model.getDefault() || {};
        nonDefaultedAttributesChanged = !_.isEqual(_.keys(defaults), _.keys(this.model.attributes));
        defaultedAttributesChanged = !_.isEmpty(this.model.changedAttributes(defaults));

        return (this.model.isNew() && (nonDefaultedAttributesChanged || defaultedAttributesChanged));
    },

    /**
     * @inheritdoc
     *
     * Wires up the save buttons.
     */
    delegateButtonEvents: function() {
        this.context.on('button:' + this.saveButtonName + ':click', this.save, this);
        this.context.on('button:' + this.cancelButtonName + ':click', this.cancel, this);
        this.context.on('button:' + this.restoreButtonName + ':click', this.restoreModel, this);
    },

    _render: function () {
        this._super("_render");

        this.setButtonStates(this.STATE.CREATE);

        // Don't need to add dupecheck layout if dupecheck disabled
        if (this.enableDuplicateCheck) {
            this.renderDupeCheckList();
        }

        //SP-1502: Broadcast model changes so quickcreate field can keep track of unsaved changes
        app.events.trigger('create:model:changed', false);
        this.model.on('change', function() {
            app.events.trigger('create:model:changed', this.hasUnsavedChanges());
        }, this);
    },

    /*
     * Pre-populate the record if Omnichannel is opened
     */
    populateFromOmnichanel: function() {
        if (app.omniConsole && app.omniConsole.isOpen() && this.omniPopulation) {
            var prepopulateValues = app.omniConsole.getModelPrepopulateData(this.module);
            if (!_.isEmpty(prepopulateValues)) {
                this.model.set(prepopulateValues);
            }
        }
    },

    /**
     * Defaults to {@link #saveAndClose}.
     */
    save: function() {
        this.saveAndClose();
    },

    /**
     * Save and close drawer
     */
    saveAndClose: function () {
        this.initiateSave(_.bind(function () {
            if (this.closestComponent('drawer')) {
                app.drawer.close(this.context, this.model);
            } else {
                app.navigate(this.context, this.model);
            }
        }, this));
    },

    /**
     * Handle click on the cancel link
     */
    cancel: function () {
        app.alert.dismiss('cancel-dropdown-view-change');

        //Clear unsaved changes on cancel.
        app.events.trigger('create:model:changed', false);
        this.$el.off();
        if (app.drawer.count()) {
            app.drawer.close(this.context);
            this._dismissAllAlerts();
        } else {
            app.router.navigate(this.module, {trigger: true});
        }
    },

    /**
     * Cancels the create view when the user cancels a dropdown view change
     * @private
     */
    _cancelDropdownViewChange: function() {
        this.cancel();
    },

    /**
     * Handle click on restore to original link
     */
    restoreModel: function () {
        this.model.clear();
        if (this._origAttributes) {
            this.model.set(this._origAttributes);
            this.model.isCopied = true;
        }

        // reset subpanels
        if (this.hasSubpanelModels) {
            // loop through subpanels and call resetCollection on create subpanels
            _.each(this.context.children, function(child) {
                if (child.get('isCreateSubpanel')) {
                    this.context.trigger('subpanel:resetCollection:' + child.get('link'), true);
                }
            }, this);

            // reset the hasSubpanelModels flag
            this.hasSubpanelModels = false;
        }
        
        this.createMode = true;
        if (!this.disposed) {
            this.render();
        }
        this.setButtonStates(this.STATE.CREATE);
    },

    /**
     * Check for possible duplicates before creating a new record
     * @param callback
     */
    initiateSave: function (callback) {
        this.disableButtons();
        async.waterfall([
            _.bind(this.validateSubpanelModelsWaterfall, this),
            _.bind(this.validateModelWaterfall, this),
            _.bind(this.dupeCheckWaterfall, this),
            _.bind(this.createRecordWaterfall, this)
        ], _.bind(function (error) {
            this.enableButtons();
            if (error && error.status == 412 && !error.request.metadataRetry) {
                this.handleMetadataSyncError(error);
            } else if (!error && !this.disposed) {
                this.context.lastSaveAction = null;
                callback();
            }
        }, this));
    },
    /**
     * Check to see if all fields are valid
     * @param callback
     */
    validateModelWaterfall: function(callback) {
        this.model.doValidate(this.getFields(this.module), function(isValid) {
            callback(!isValid);
        });
    },

    /**
     * Check to see if there are subpanel create models on this view
     * And trigger an event to tell the subpanel to validate itself
     *
     * @param callback
     * @return {Mixed}
     */
    validateSubpanelModelsWaterfall: function(callback) {
        this.hasSubpanelModels = false;
        _.each(this.context.children, function(child) {
            if (child.get('isCreateSubpanel')) {
                this.hasSubpanelModels = true;
                this.context.trigger('subpanel:validateCollection:' + child.get('link'), callback, true);
            }
        }, this);

        // If there are no subpanel models, callback false so the waterfall can continue
        if (!this.hasSubpanelModels) {
            return callback(false);
        }
    },

    /**
     * Check for possible duplicate records
     * @param callback
     */
    dupeCheckWaterfall: function (callback) {
        var success = _.bind(function (collection) {
                if (this.disposed) {
                    callback(true);
                }
                if (collection.models.length > 0) {
                    this.handleDuplicateFound(collection);
                    callback(true);
                } else {
                    this.resetDuplicateState();
                    this.disableButtons();
                    callback(false);
                }
            }, this),
            error = _.bind(function(model, e) {
                if (e.status == 412 && !e.request.metadataRetry) {
                    this.handleMetadataSyncError(e);
                } else {
                    callback(true);
                }
            }, this);

        if (this.skipDupeCheck() || !this.enableDuplicateCheck) {
            callback(false);
        } else {
            this.checkForDuplicate(success, error);
        }
    },

    /**
     * Create new record
     * @param callback
     */
    createRecordWaterfall: function (callback) {
        var success = _.bind(function () {
                var acls = this.model.get('_acl');
                if (!_.isEmpty(acls) && acls.access === 'no' && acls.view === 'no') {
                    //This happens when the user creates a record he won't have access to.
                    //In this case the POST request returns a 200 code with empty response and acls set to no.
                    this.alerts.showSuccessButDeniedAccess.call(this);
                    callback(false);
                } else {
                    this._dismissAllAlerts();
                    app.alert.show('create-success', {
                        level: 'success',
                        messages: this.buildSuccessMessage(this.model),
                        autoClose: true,
                        autoCloseDelay: 10000,
                        onLinkClick: function() {
                            app.alert.dismiss('create-success');
                        }
                    });
                    callback(false);
                }
                app.events.trigger('list:create:success');
            }, this),
            error = _.bind(function(model, e) {
                if (e.status == 412 && !e.request.metadataRetry) {
                    this.handleMetadataSyncError(e);
                } else {
                    if (e.status == 403) {
                        this.alerts.showNoAccessError.call(this);
                    }
                    callback(true);
                }
            }, this);

        this.saveModel(success, error);
    },

    /**
     * Check the server to see if there are possible duplicate records.
     * @param success
     * @param error
     */
    checkForDuplicate: function (success, error) {
        var options = {
            //Show alerts for this request
            showAlerts: true,
            success: success,
            error: error
        };

        this.context.trigger("dupecheck:fetch:fire", this.model, options);
    },

    /**
     * Duplicate found: display duplicates and change buttons
     */
    handleDuplicateFound: function () {
        this.setButtonStates(this.STATE.DUPLICATE);
        this.dupecheckList.show();
    },

    /**
     * Clear out all things related to duplicate checks
     */
    resetDuplicateState: function () {
        this.setButtonStates(this.STATE.CREATE);
        this.hideDuplicates();
    },

    /**
     * Called when current record is being saved to allow customization of options and params
     * during save
     *
     * Override to return set of custom options
     *
     * @param {Object} options The current set of options that is going to be used.  This is hand for extending
     */
    getCustomSaveOptions: function (options) {
        return {};
    },

    /**
     * Create a new record
     * @param success
     * @param error
     */
    saveModel: function (success, error) {
        var self = this,
            options;
        options = {
            success: success,
            error: error,
            viewed: true,
            relate: (self.model.link) ? true : null,
            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': false,
                'error': false //error callback implements its own error handler
            },
            lastSaveAction: this.context.lastSaveAction
        };
        this.applyAfterCreateOptions(options);

        // Check if this has subpanel create models
        this.addSubpanelCreateModels();

        options = _.extend({}, options, self.getCustomSaveOptions(options));
        self.model.save(null, options);
    },

    /**
     * Sets the link field(s) on the parent model so that on save, the subpanel-create models will
     * be created as related records through those links
     */
    addSubpanelCreateModels: function() {
        if (this.hasSubpanelModels) {
            _.each(this.context.children, function(child) {
                if (child.get('isCreateSubpanel') && child.get('collection').models.length) {
                    // create the child collection JSON structure to save
                    var childCollection = {
                            create: []
                        },
                        linkName = child.get('link');
                    if (this.model.has(linkName)) {
                        // the model already has the link name, there must be rollup formulas
                        // on the create form between the model and the subpanel
                        childCollection = this.model.get(linkName);
                        // make sure there is a create key on the childCollection
                        if (!_.has(childCollection, 'create')) {
                            childCollection['create'] = [];
                        }
                    }
                    // loop through the models in the collection and push each model's JSON
                    // data to the 'create' array
                    _.each(child.get('collection').models, function(model) {
                        childCollection.create.push(model.toJSON());
                    }, this);

                    // set the child JSON collection data to the model
                    this.model.set(linkName, childCollection);
                }
            }, this);
        }
    },

    /**
     * Apply after_create parameters to the URL to specify operations to execute after creating a record.
     * @param options
     */
    applyAfterCreateOptions: function(options) {
        var copiedFromModelId = this.context.get('copiedFromModelId');

        if (copiedFromModelId && this.model.isCopy()) {
            options.params = options.params || {};
            options.params.after_create = {
                copy_rel_from: copiedFromModelId
            };
        }
    },

    /**
     * Using the model returned from the API call, build the success message
     * @param model
     * @return {string}
     */
    buildSuccessMessage: function(model) {
        var modelAttributes,
            successLabel = 'LBL_RECORD_SAVED_SUCCESS',
            successMessageContext;

        //if we have model attributes, use them to build the message, otherwise use a generic message
        if (model && model.attributes) {
            modelAttributes = model.attributes;

            if (model.get('no_success_label_link')) {
                successLabel = 'LBL_RECORD_SAVED_SUCCESS_NO_LINK';
            }
        } else {
            modelAttributes = {};
            successLabel = 'LBL_RECORD_SAVED';
        }

        //use the model attributes combined with data from the view to build the success message context
        successMessageContext = _.extend({
            module: this.module,
            moduleSingularLower: app.lang.getModuleName(this.module).toLowerCase()
        }, modelAttributes);

        return app.lang.get(successLabel, this.module, successMessageContext);
    },

    /**
     * Check to see if we should skip duplicate check.
     *
     * Duplicate check should be skipped if we are displaying duplicates or user
     * has switched over to editing an existing duplicate record.
     *
     * @return {boolean}
     */
    skipDupeCheck: function () {
        var skipStates = [this.STATE.DUPLICATE, this.STATE.SELECT];
        return (_.contains(skipStates, this.getCurrentButtonState()));
    },

    /**
     * Clears out field values
     */
    clear: function () {
        this.model.clear();
        if (!this.disposed) {
            this.render();
        }
    },

    /**
     * Make the specified record as the data to be edited, and merge the existing data.
     * @param model
     */
    editExisting: function (model) {
        var origAttributes = this.saveFormData();

        this.model.clear();
        this.model.set(this.extendModel(model, origAttributes));

        if (this.model.link) {
            this.model.link.isNew = false;
        }

        this.createMode = false;
        if (!this.disposed) {
            this.render();
        }
        this.toggleEdit(true);

        this.hideDuplicates();
        this.setButtonStates(this.STATE.SELECT);
    },

    /**
     * Merge the selected record with the data entered in the form
     * @param newModel
     * @param origAttributes
     * @return {Object}
     */
    extendModel: function (newModel, origAttributes) {
        var modelAttributes = _.clone(newModel.attributes);

        _.each(modelAttributes, function (value, key) {
            if (_.isUndefined(value) || _.isNull(value) ||
                ((_.isObject(value) || _.isArray(value) || _.isString(value)) && _.isEmpty(value))) {
                delete modelAttributes[key];
            }
        });

        return _.extend({}, origAttributes, modelAttributes);
    },

    /**
     * Save the data entered in the form
     * @return {Object}
     */
    saveFormData: function () {
        this._origAttributes = _.clone(this.model.attributes);
        return this._origAttributes;
    },

    /**
     * Sets the dupecheck list type
     *
     * @param {String} type view to load
     */
    setDupeCheckType: function(type) {
        this.context.set('dupelisttype', type);
    },

    /**
     * Render duplicate check list table
     */
    renderDupeCheckList: function () {
        this.setDupeCheckType('dupecheck-list-edit');
        this.context.set('collection', this.createDuplicateCollection(this.model));

        if (_.isNull(this.dupecheckList)) {
            this.dupecheckList = app.view.createLayout({
                context: this.context,
                name: 'create-dupecheck',
                module: this.module
            });
            this.dupecheckList.initComponents();
            this.addToLayoutComponents(this.dupecheckList);
        }

        this.$('.headerpane').after(this.dupecheckList.$el);
        this.dupecheckList.hide();
        this.dupecheckList.render();
    },

    /**
     * Add component to layout's component list so it gets cleaned up properly on dispose
     *
     * FIXME: SC-6041 should handle deprecating this method.
     *
     * @param component
     */
    addToLayoutComponents: function (component) {
        this.layout._components.push(component);
    },

    /**
     * If initialized (depends on this.enableDuplicateCheck flag) hides the
     * duplicate list.
     */
    hideDuplicates: function () {
        if (this.dupecheckList) {
            this.dupecheckList.hide();
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.dupecheckList) {
            this.dupecheckList.dispose();
        }
        this._super('_dispose');
    },

    /**
     * Disable buttons
     */
    disableButtons: function () {
        this.toggleButtons(false);
    },

    /**
     * Enable buttons
     */
    enableButtons: function () {
        this.toggleButtons(true);
    },

    registerShortcuts: function() {
        this._super('registerShortcuts');

        app.shortcuts.register({
            id: 'Create:Save',
            keys: ['mod+s','mod+alt+a'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_SAVE',
            callOnFocus: true,
            handler: function() {
                var $saveButton = this.$('a[name=' + this.saveButtonName + ']');
                if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                    $saveButton.get(0).click();
                }
            }
        });

        app.shortcuts.register({
            id: 'Create:Cancel',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $cancelButton = this.$('a[name=' + this.cancelButtonName + ']');
                if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                    $cancelButton.get(0).click();
                }
            }
        });
    },

    /**
     * We don't want the locked fields warning on create
     * @override
     */
    warnLockedFields: _.noop
}) },
"create-nodupecheck": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.CreateNodupecheckView
 * @alias SUGAR.App.view.views.BaseCreateNodupecheckView
 * @extends View.Views.Base.CreateView
 */
({
	// Create-nodupecheck View (base) 

    extendsFrom: 'CreateView',

    initialize: function(options) {
        this._super("initialize", [options]);
        this.enableDuplicateCheck = false;
    }
}) },
"forecast-pareto": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Dashlet that displays a chart.
 *
 * @class View.Views.Base.ForecastParetoView
 * @alias SUGAR.App.view.views.BaseForecastParetoView
 * @extends View.View
 */
({
	// Forecast-pareto View (base) 

    plugins: ['Dashlet'],

    className: 'forecasts-chart-wrapper',

    /**
     * Should we display the timeperiod Pivot options
     */
    displayTimeperiodPivot: true,

    /**
     * Track if they are a manager
     */
    isManager: false,

    /**
     * Track if the user is a top-level manager
     */
    isTopLevelManager: false,

    /**
     * When on a Record view this are fields we should listen to changes in
     */
    validChangedFields: ['amount', 'likely_case', 'best_case', 'worst_case', 'assigned_user_id',
        'date_closed', 'date_closed_timestamp', 'probability', 'commit_stage', 'sales_stage'],

    /**
     * Hold the initOptions if we have to call the Forecast/init end point cause we are not on Forecasts
     */
    initOptions: null,

    /**
     * Holds the forecast isn't set up message if Forecasts hasn't been set up yet
     */
    forecastsNotSetUpMsg: undefined,

    /**
     * Holds the Forecast Module Config
     */
    forecastConfig: undefined,

    /**
     * Are we using Opportunities with RevenueLineItems?
     */
    opportunitiesWithRevenueLineItems: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.isManager = app.user.get('is_manager');
        this._initPlugins();

        // if the user is a manager, check if they're toplevel or not
        if (this.isManager) {
            this.isTopLevelManager = app.user.get('is_top_level_manager');
        }

        // if the parent exists, use it, otherwise use the main context
        this.initOptions = options;
        this.forecastConfig = app.metadata.getModule('Forecasts', 'config');
        this.isForecastSetup = this.forecastConfig.is_setup;
        this.forecastsConfigOK = app.utils.checkForecastConfig();

        var oppConfig = app.metadata.getModule('Opportunities', 'config');
        if (oppConfig && oppConfig['opps_view_by'] === 'RevenueLineItems') {
            this.opportunitiesWithRevenueLineItems = true;
        } else {
            this.opportunitiesWithRevenueLineItems = false;
        }

        if (this.isForecastSetup && this.forecastsConfigOK) {
            delete this.initOptions.meta.template;
            if (!options.meta.config) {
                // we only want to call this if forecast is setup and configured
                // and this is not the dashlet config screen
                app.api.call('GET', app.api.buildURL('Forecasts/init'), null, {
                    success: _.bind(this.forecastInitCallback, this),
                    complete: this.initOptions ? this.initOptions.complete : null
                });
            }

            this.displayTimeperiodPivot = (options.context.get('module') === 'Home');
        } else {
            // set the no access template
            this.initOptions.meta.template = 'forecast-pareto.no-access';
            var isAdmin = _.isUndefined(app.user.getAcls()['Forecasts'].admin);
            this.forecastsNotSetUpMsg = app.utils.getForecastNotSetUpMessage(isAdmin);
        }

        this._super('initialize', [this.initOptions]);
    },

    /**
     * @inheritdoc
     */
    getLabel: function() {
        return app.lang.get(this.meta.label);
    },

    /**
     * @inheritdoc
     */
    initDashlet: function() {
        if (!this.isManager && this.meta.config) {
            // FIXME: Dashlet's config page is rendered from meta.panels directly.
            // See the "dashletconfiguration-edit.hbs" file.
            this.meta.panels = _.chain(this.meta.panels).filter(function(panel) {
                panel.fields = _.without(panel.fields, _.findWhere(panel.fields, {name: 'visibility'}));
                return panel;
            }).value();
        }
        if (this.isForecastSetup && this.forecastsConfigOK) {
            this.settings.module = 'Forecasts';
        }
        var fieldOptions = app.lang.getAppListStrings(this.dashletConfig.dataset.options),
            cfg = app.metadata.getModule('Forecasts', 'config');
        this.dashletConfig.dataset.options = {};

        if (cfg.show_worksheet_worst &&
            app.acl.hasAccess('view', 'ForecastWorksheets', app.user.get('id'), 'worst_case')) {
            this.dashletConfig.dataset.options['worst'] = fieldOptions['worst'];
        }

        if (cfg.show_worksheet_likely) {
            this.dashletConfig.dataset.options['likely'] = fieldOptions['likely'];
        }

        if (cfg.show_worksheet_best &&
            app.acl.hasAccess('view', 'ForecastWorksheets', app.user.get('id'), 'best_case')) {
            this.dashletConfig.dataset.options['best'] = fieldOptions['best'];
        }

        // Hide dataset drop-down if there is only one option.
        this.dashletConfig.show_dataset = true;
        if (_.size(this.dashletConfig.dataset.options) <= 1) {
            this.dashletConfig.show_dataset = false;
        }
    },

    /**
     * Callback function for Forecasts/init success
     */
    forecastInitCallback: function(initData) {
        if (this.disposed) {
            return;
        }
        var defaultOptions = {
            user_id: app.user.get('id'),
            // Default to 'user' view for reps, and 'group' view for managers.
            display_manager: this.isDisplayManager(),
            show_target_quota: (this.isManager && !this.isTopLevelManager),
            selectedTimePeriod: initData.defaultSelections.timeperiod_id.id,
            timeperiod_id: initData.defaultSelections.timeperiod_id.id,
            timeperiod_label: initData.defaultSelections.timeperiod_id.label,
            dataset: initData.defaultSelections.dataset,
            group_by: initData.defaultSelections.group_by,
            ranges: _.keys(app.lang.getAppListStrings(this.forecastConfig.buckets_dom))
        };

        var model = this._getNonForecastModel();

        if (model && !this.displayTimeperiodPivot && model.has('date_closed_timestamp') &&
            model.get('date_closed_timestamp') != 0) {
            // if we have a timestamp, use it, otherwise just default to the current time period
            defaultOptions.timeperiod_id = model.get('date_closed_timestamp');
        } else {
            this.layout.setTitle(this.getLabel() + ' ' + defaultOptions.timeperiod_label);
        }
        this.settings.set(defaultOptions);
    },

    /**
     * Overwrite loadData so the default behavior doesn't happen
     *
     * @override
     */
    loadData: function(options) {
        if (options && _.isFunction(options.complete)) {
            options.complete();
        }
    },

    _render: function() {
        this.settings.set('display_manager', this.isDisplayManager());
        this.spanSize = this.displayTimeperiodPivot && this.dashletConfig.show_dataset ? 'span4' : 'span6';
        this._super('_render');

        var chartField = this.getField('paretoChart');

        if (!_.isUndefined(chartField)) {
            chartField.renderChart();
            chartField.once('chart:pareto:rendered', function() {
                if (this.opportunitiesWithRevenueLineItems &&
                    this.context.get('module') == 'RevenueLineItems') {
                    this.addRowToChart();
                } else {
                    this.addRowToChart();
                }
            }, this);
        }
    },

    /**
     * Called after _render
     */
    toggleRepOptionsVisibility: function() {
        var mgrToggleOffset;
        if (this.settings.get('display_manager') === true) {
            mgrToggleOffset = 6;
            this.$el.find('div.groupByOptions').addClass('hide');
        } else {
            mgrToggleOffset = 3;
            this.$el.find('div.groupByOptions').removeClass('hide');
        }

        if (this.displayTimeperiodPivot) {
            mgrToggleOffset = mgrToggleOffset - 3;
        }

        if (this.isManager) {
            var el = this.$el.find('#' + this.cid + '-mgr-toggle');
            if (el.length > 0) {
                var classes = el.attr('class').split(' ').filter(function(item) {
                    return item.indexOf('offset') === -1 ? item : '';
                });
                if (mgrToggleOffset != 0) {
                    classes.push('offset' + mgrToggleOffset);
                }
                el.attr('class', classes.join(' '));
            }
        }
    },

    /**
     * @inheritdoc
     *
     * Additional logic on switch visibility event.
     */
    visibilitySwitcher: function(event) {
        var activeVisibility;
        this.settings.set({
            display_manager: this.isDisplayManager(),
            show_target_quota: (this.isDisplayManager() && !this.isTopLevelManager)
        });
        if (!this.isManager) {
            return;
        }
        activeVisibility = this.getVisibility();
        this.$el.find('[data-action=visibility-switcher]')
            .attr('aria-pressed', function() {
                return $(this).val() === activeVisibility;
            });
    },

    /**
     * Calculates "display_manager" option according to visibility.
     *
     * @return {Boolean}
     */
    isDisplayManager: function() {
        return this.isManager ? (this.getVisibility() === 'group') : false;
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        // on the off chance that the init has not run yet.
        var meta = this.meta || this.initOptions.meta;
        if (meta.config) {
            return;
        }

        // if we don't have a context, this shouldn't run yet.
        if (_.isUndefined(this.context)) {
            return;
        }

        if (this.isForecastSetup && this.forecastsConfigOK) {
            this.on('render', function() {
                var chartField = this.getField('paretoChart'),
                    dashletToolbar = this.layout.getComponent('dashlet-toolbar');

                // if we have a dashlet-toolbar, then make it do the refresh icon
                // while the chart is loading from the server
                if (chartField && dashletToolbar) {
                    chartField.before('chart:pareto:render', function() {
                        this.$('[data-action=loading]').removeClass(this.cssIconDefault).addClass(this.cssIconRefresh);
                    }, dashletToolbar);
                    chartField.on('chart:pareto:rendered', function() {
                        this.$('[data-action=loading]').removeClass(this.cssIconRefresh).addClass(this.cssIconDefault);
                    }, dashletToolbar);
                }
            }, this);

            this.settings.on('change:title', function(model, title) {
                this.layout.setTitle(this.getLabel() + title);
            }, this);

            this.settings.on('change:display_manager', this.toggleRepOptionsVisibility, this);

            if (!this.displayTimeperiodPivot) {
                this.findModelToListen();
                this.listenModel.on('change', this.handleDataChange, this);
            } else {
                this.settings.on('change:selectedTimePeriod', function(context, timeperiod) {
                    this.settings.set({timeperiod_id: timeperiod});
                }, this);
            }
        }
    },

    findModelToListen: function() {
        this.listenModel = this._getNonForecastModel();
        if (this.opportunitiesWithRevenueLineItems) {
            // now that this context is set to the forecast module, we should use the parent context if it exists
            // if it doesn't then we use the context on this dashlet
            var context = this.context.parent || this.context;
            if (context.get('module') == 'Opportunities') {
                // we need to watch for when the date changes time periods on the opportunity to re-render the chart
                this._getNonForecastModel().on('change:date_closed_timestamp', function(model, changed) {
                    this.settings.set('timeperiod_id', changed);
                }, this);
                // since we are forecasting by RLI but on the Opp Module, we need to find the subpanel for RLI to watch
                // for the changes there
                var ctx = _.find(context.children, function(child) {
                    return (child.get('module') == 'RevenueLineItems');
                });
                if (ctx && ctx.has('collection')) {
                    this.listenModel = ctx.get('collection');
                }
            }
        }
    },

    /**
     * Utility Method to find the proper model to use, if this.model.module is forecasts, go up to the parent context
     * and use the model that's attached to it otherwise return this.model
     *
     * @return {Backbone.Model|Data.Bean}
     * @private
     */
    _getNonForecastModel: function() {
        if (this.model.module == 'Forecasts') {
            return this.context.parent.get('model');
        }

        return this.model;
    },

    /**
     * Handler for when the model changes
     * @param {Object} [model]      The model that changed, if not provided, it will use this.model
     */
    handleDataChange: function(model) {
        model = model || this._getNonForecastModel();
        var changed = model.changed,
            changedField = _.keys(changed),
            validChangedFields = _.intersection(this.validChangedFields, _.keys(changed)),
            changedCurrencyFields = _.intersection(
                ['amount', 'best_case', 'likely_case', 'worst_case'],
                validChangedFields
            ),
            assigned_user = model.get('assigned_user_id');

        // lets make sure that the values actually changed on the currencies,
        // this is needed because the server will send back the values with out .00 on the end and the model has .00
        // so it looks like it changed, when in fact it didn't so don't worry about this change
        if (!_.isEmpty(changedCurrencyFields)) {
            _.each(changedCurrencyFields, function(field) {
                if (parseFloat(model.get(field)) == parseFloat(model.previous(field))) {
                    validChangedFields = _.without(validChangedFields, field);
                }
            });
        }

        // dump out if it's not a field we are watching
        if (_.isEmpty(validChangedFields)) {
            return;
        }

        if (this.settings.get('display_manager') === false && assigned_user == app.user.get('id')) {
            // we can update this chart
            // get what we are currently filtered by
            // find the item in the serverData
            var field = this.getField('paretoChart'),
                serverData = field.getServerData();

            if (!field.hasServerData()) {
                // if the field does not have server data, that means it's re-rendering the chart already,
                // just bail out
                return;
            }

            // if we only have one changed field and it's the date_closed, lets map it to a timestamp.
            // this happens on the Opp -> RLI Subpanel since we don't have SugarLogic Support in ListViews
            if (changedField.length == 1 && changedField[0] == 'date_closed') {
                // convert this into the timestamp
                changedField.push('date_closed_timestamp');
                changed.date_closed_timestamp = Math.round(+app.date.parse(changed.date_closed).getTime() / 1000);
                model.set('date_closed_timestamp', changed.date_closed_timestamp, {silent: true});
            }

            // before we do anything, lets make sure that if the date_changed, make sure it's still in this range,
            // if it's not force the chart to update to the new timeperiod that is valid for this row, then add this
            // row to the new timeperiod
            if (_.contains(changedField, 'date_closed_timestamp')) {
                if (!(model.get('date_closed_timestamp') >= _.first(serverData['x-axis']).start_timestamp &&
                    model.get('date_closed_timestamp') <= _.last(serverData['x-axis']).end_timestamp)) {

                    // lets check to see, if we have a collection as the listenModel, then just remove the row if there
                    // is more than one record in the collection
                    if (this.listenModel instanceof Backbone.Collection) {
                        if (this.listenModel.length > 1) {
                            this.removeRowFromChart(model);
                            return;
                        }
                    }
                    // we just have a model, so lets just update it
                    field.once('chart:pareto:rendered', function() {
                        this[0].addRowToChart(this[1]);
                    }, [this, model]);
                    this.settings.set('timeperiod_id', model.get('date_closed_timestamp'));
                    return;
                }
            }

            // Amount on Opportunity maps to likely in the data set
            if (_.contains(changedField, 'amount')) {
                changed.likely = this._convertCurrencyValue(changed.amount, model.get('base_rate'));
                delete changed.amount;
            }
            // Likely Case in RLI
            if (_.contains(changedField, 'likely_case')) {
                changed.likely = this._convertCurrencyValue(changed.likely_case, model.get('base_rate'));
                delete changed.likely_case;
            }

            if (_.contains(changedField, 'best_case')) {
                changed.best = this._convertCurrencyValue(changed.best_case, model.get('base_rate'));
                delete changed.best_case;
            }
            if (_.contains(changedField, 'worst_case')) {
                changed.worst = this._convertCurrencyValue(changed.worst_case, model.get('base_rate'));
                delete changed.worst_case;
            }

            if (_.contains(changedField, 'commit_stage')) {
                changed.forecast = changed.commit_stage;
                delete changed.commit_stage;
            }

            var record = _.find(serverData.data, function(record, i, list) {
                if (model.get('id') == record.record_id) {
                    list[i] = _.extend({}, record, changed);
                    return true;
                }
                return false;
            });

            // the row was not found, lets add it
            if (_.isEmpty(record)) {
                this.addRowToChart(model);
            } else {
                field.setServerData(serverData, _.contains(changedField, 'probability'));
            }
        } else if (_.contains(changedField, 'assigned_user_id')) {
            if (assigned_user === app.user.get('id')) {
                this.addRowToChart(model);
            } else {
                this.removeRowFromChart(model);
            }
        }
    },

    /**
     * Add the model to the pareto chart
     * @param {Object} [model]      The Model to add, if not passed in, it will use this.model
     */
    addRowToChart: function(model) {
        model = model || this._getNonForecastModel();
        if (model.get('assigned_user_id') == app.user.get('id') && !this.settings.get('display_manager')) {
            var field = this.getField('paretoChart'),
                serverData = field.getServerData(),
            // make sure it doesn't exist in the serverdata
                found = _.find(serverData.data, function(record) {
                    return (record.record_id == model.get('id'));
                }),
                base_rate = model.get('base_rate'),
                likely_field = model.has('amount') ? model.get('amount') : model.get('likely_case');

            if (_.isEmpty(found)) {
                serverData.data.push({
                    best: this._convertCurrencyValue(model.get('best_case'), base_rate),
                    likely: this._convertCurrencyValue(likely_field, base_rate),
                    worst: this._convertCurrencyValue(model.get('worst_case'), base_rate),
                    record_id: model.get('id'),
                    date_closed_timestamp: model.get('date_closed_timestamp'),
                    probability: model.get('probability'),
                    sales_stage: model.get('sales_stage'),
                    forecast: model.get('commit_stage')
                });
                field.setServerData(serverData, true);
            }
        }
    },

    /**
     * Utility Method to convert to base rate
     * @param {Number} value
     * @param {Number} base_rate
     * @return {Number}
     * @protected
     */
    _convertCurrencyValue: function(value, base_rate) {
        return app.currency.convertWithRate(value, base_rate);
    },

    /**
     * Get the server data from the ParetoField and if the model exists in the data, remove it
     *
     * @param {Object} [model]      The Model to add, if not passed in, it will use this.model
     */
    removeRowFromChart: function(model) {
        model = model || this._getNonForecastModel();
        var field = this.getField('paretoChart'),
            serverData = field.getServerData();

        if (!serverData || !serverData.data) {
            return;
        }

        _.find(serverData.data, function(record, i, list) {
            if (model.get('id') === record.record_id) {
                list.splice(i, 1);
                return true;
            }
            return false;
        });

        field.setServerData(serverData, true);
    },

    /**
     * @inheritdoc
     * Clean up!
     */
    unbindData: function() {
        var ctx = this.context.parent;
        if (ctx) {
            ctx.off(null, null, this);
        }
        if (this.listenModel) this.listenModel.off(null, null, this);
        if (this.context) this.context.off(null, null, this);
        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * Initialize plugins.
     * Only manager can toggle visibility.
     *
     * @return {BaseForecastParetoView} Instance of this view.
     * @protected
     */
    _initPlugins: function() {
        if (this.isManager) {
            this.plugins = _.union(this.plugins, [
                'ToggleVisibility'
            ]);
        }
        return this;
    }
}) },
"setup-complete-wizard-page": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Setup Complete wizard page for the FirstLoginWizard.
 *
 * @class View.Views.Base.SetupCompleteWizardPageView
 * @alias SUGAR.App.view.views.BaseSetupCompleteWizardPageView
 * @extends View.Views.Base.WizardPageView
 */
({
	// Setup-complete-wizard-page View (base) 

    extendsFrom: "WizardPageView",
    /**
     * Name of wizard being displayed
     */
    wizardName : "",
    /**
     * Set flag for admin or user wizard so we can render the correct template
     * @override
     * @param options
     */
    initialize: function(options){
        //Extend default events to add listener for click events on links
        //FIXME: events should be data action driven instead of tied to css
        //TY-573 will address this problem
        this.events = _.extend({}, this.events, {
            "click a.thumbnail": "linkClicked",
            "click [name=start_sugar_button]:not(.disabled)": "next"
        });
        this._super("initialize", [options]);
        this.wizardName = this.context.get("wizardName") || "user";
    },
    /**
     * @override
     * @return {boolean}
     */
    isPageComplete: function(){
        return true;
    },
    /**
     * Event handler whenever a link is clicked that makes sure wizard is finished
     * We need to use app router for Sugar app links on complete page.
     * External links should always open onto new pages.
     *
     * @param ev
     */
    //FIXME: Each link should have its own handler. Will be addressed in TY-573
    linkClicked: function(ev){
        var href, redirectUrl,
            target = this.$(ev.currentTarget);
        if(this.$(target).attr("target") !== "_blank") {
            app.user.unset('show_wizard');
            ev.preventDefault();
            //Show the header bar since it is likely hidden
            $("#header").show();
            href = this.$(target).attr("href");
            // Check if bwc link; if so, we need to do bwc.login first
            if (href.indexOf('#bwc/') === 0) {
                redirectUrl = href.split('#bwc/')[1];
                app.bwc.login(redirectUrl);
            } else {
                // Not bwc, so use router navigate instead
                app.router.navigate($(ev.currentTarget).attr("href"), {trigger: true});
            }
        }
    },

    /**
     * @inheritdoc
     *
     * When the setup complete page is disposed, we can update user object since
     * the user setup is complete, to prevent routing to the setup wizard.
     */
    _dispose: function() {
        this._super('_dispose');
        app.user.unset('show_wizard');
    }
}) },
"shortcuts-help-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Headerpane for keyboard shortcuts help
 *
 * @class View.Views.Base.ShortcutsHelpHeaderpaneView
 * @alias SUGAR.App.view.views.BaseShortcutsHelpHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Shortcuts-help-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    configureButtonName: 'configure_button',

    /**
     * Handle cancel and configure buttons.
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.context.on('button:cancel_button:click', function() {
            app.drawer.close();
        }, this);

        this.context.on('button:configure_button:click', this.configure, this);
    },

    /**
     * Load template for headerpane.
     * @inheritdoc
     */
    _loadTemplate: function(options) {
        var name = this.name;
        this.name = 'headerpane';
        this._super('_loadTemplate', [options]);
        this.name = name;
    },

    /**
     * Disable configure button if there are no contextual shortcuts to configure.
     * @inheritdoc
     */
    _renderHtml: function() {
        var shouldEnableConfigButton = this._shouldEnableConfigureButton();

        if (shouldEnableConfigButton) {
            this._setTooltipForConfigureButton('LBL_DASHLET_CONFIGURE');
        } else {
            this._setTooltipForConfigureButton('LBL_SHORTCUT_CONFIG_DISABLED');
        }

        this._super('_renderHtml');

        if (!shouldEnableConfigButton) {
            this._disableConfigureButton();
        }
    },

    /**
     * Should configure button be enabled?
     * @return {boolean}
     * @private
     */
    _shouldEnableConfigureButton: function() {
        var lastShortcutSession = app.shortcuts.getLastSavedSession();
        return lastShortcutSession && !_.isEmpty(lastShortcutSession.getRegisteredShortcuts());
    },

    /**
     * Set tooltip label for the configure button.
     * @param {string} tooltip tooltip label to be displayed
     * @private
     */
    _setTooltipForConfigureButton: function(tooltip) {
        var configureButtonViewDef = _.find(this.meta.buttons, function(button) {
            return (button.name === this.configureButtonName);
        }, this);

        if (configureButtonViewDef) {
            configureButtonViewDef.tooltip = tooltip;
        }
    },

    /**
     * Disable configure button.
     * @private
     */
    _disableConfigureButton: function() {
        var configureButton = this.getField(this.configureButtonName);
        if (configureButton) {
            configureButton.setDisabled(true);
        }
    },

    /**
     * Open the drawer to configure shortcut keys.
     */
    configure: function() {
        var self = this;

        app.drawer.open({
            layout: 'shortcuts-config',
            context: {
                shortcutSession: app.shortcuts.getLastSavedSession()
            }
        }, function(shouldRefresh) {
            if (shouldRefresh) {
                self.context.trigger('shortcuts:help:render');
            }
        });
    }
}) },
"dupecheck-list-select": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckListSelectView
 * @alias SUGAR.App.view.views.BaseDupecheckListSelectView
 * @extends View.Views.Base.DupecheckListView
 */
({
	// Dupecheck-list-select View (base) 

    extendsFrom: 'DupecheckListView',
    additionalTableClasses: 'duplicates-singleselect'
}) },
"sweetspot-results": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SweetspotResultsView
 * @alias SUGAR.App.view.views.BaseSweetspotResultsView
 * @extends View.View
 */
({
	// Sweetspot-results View (base) 

    className: 'sweetspot-results',
    tagName: 'ul',

    events: {
        'click li[data-sweetaction] > a': 'triggerAction',
    },

    /**
     * @inheritdoc
     *
     * - Listens to `sweetspot:results` on the layout to update the results.
     * - Listens to `keydown` on `window` to highlight an item.
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of layout.collection.
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        /**
         * The list of results returned by Sweet Spot, split by category.
         *
         * It serves as a helper for the navigation within the results.
         * Includes:
         *
         *  - {@link #actions}
         *  - {@link #keywords}
         *  - {@link #records}
         *
         * @property {Array}
         */
        this.results = [];

        /**
         * The list of results returned by Sweet Spot, split by category.
         *
         * @property {Array}
         */
        this.records = [];

        /**
         * The list of results returned by Sweet Spot, split by category.
         *
         * @property {Array}
         */
        this.actions = [];

        /**
         * The list of results returned by Sweet Spot, split by category.
         *
         * @property {Array}
         */
        this.keywords = [];

        /**
         * Partial template for rendering a result row.
         *
         * @property {Function}
         */
        this._resultPartial = app.template.get(this.name + '.result');

        /**
         * Template for rendering the show more link.
         *
         * @property {Function}
         */
        this._showMoreTpl = app.template.get(this.name + '.showmore');

        /**
         * Stores the index of the currently highlighted list element.
         * This is used for keyboard navigation.
         *
         * @property {number}
         */
        this.activeIndex = null;

        // Listens to new set of results and updates the different sections.
        this.layout.on('sweetspot:results', function(results) {
            // We want to highlight the same item that was highlighted before,
            // so first we get the result that was highlighted.
            var oldHighlighted = this.results[this.activeIndex];
            var options = _.pick(results, 'showMore', 'term');

            // Rendering different sections
            this.renderSection('actions', this._formatResults(results.actions));
            this.renderSection('records', this._formatResults(results.records), options);
            this.renderSection('keywords', this._formatResults(results.keywords));

            if (options.showMore) {
                // This is so we get the moveForward/moveBackward working
                // properly.
                this.records.push(options);
            }

            // Update with the new list of records.
            this.results = this.keywords.concat(this.actions).concat(this.records);

            var newActiveIndex;
            if (oldHighlighted) {
                // Try to find the old highlighted result in the new data set.
                _.find(this.results, function(result, index) {
                    var test;
                    if (oldHighlighted.id) {
                        test = oldHighlighted.id === result.id;
                    }
                    if (oldHighlighted.route) {
                        test = oldHighlighted.route === result.route;
                    }
                    if (test) {
                        // Once we found it, we actually want its new index.
                        newActiveIndex = index;
                        return true;
                    }
                });
            }
            // Sets the item that will be highlighted.
            this.activeIndex = newActiveIndex || 0;
            if (this.results.length) {
                this._highlightActive();
                this.layout.trigger('sweetspot:calc:resultsHeight');
            }
        }, this);

        // Listens to when sweet spot is opened to bind keydown event
        this.layout.on('show', function() {
            this.results = this.actions = this.records = this.keywords = [];
            $(window).on('keydown.' + this.cid, _.bind(this.keydownHandler, this));
            this.render();
        }, this);

        // Listens to when sweet spot is opened to unbind keydown event
        this.layout.on('hide', function() {
            $(window).off('keydown.' + this.cid);
        }, this);

        this.layout.on('sweetspot:results:adjustMaxHeight', this.setMaxHeight, this);
    },

    /**
     * Sets the max-height of the element.
     *
     * @param {number} maxHeight The max-height value.
     */
    setMaxHeight: function(maxHeight) {
        if (this.results.length) {
            this.$el.css('maxHeight', maxHeight);
        }
    },

    /**
     * Renders a specific section.
     *
     * - Only if the list of records for that section has changed.
     * - Shows the section if there is at least a record
     * - Hides the section if there are no records.
     *
     * @param {string} section The section name (can be `actions`, `keywords`
     *   or `records`).
     * @param {Array} results The list of results for that section.
     * @param {Object} [options] Custom rendering options per section.
     */
    renderSection: function(section, results, options) {
        options = options || {};
        var allowed = ['actions', 'keywords', 'records'];
        if (!_.contains(allowed, section)) {
            return;
        }
        if (_.isEqual(this[section], results)) {
            return;
        }
        var $section = this.$('[data-section="' + section + '"]');
        var $list = $section.find('ul');
        $list.empty();
        this[section] = results;
        if (results.length === 0) {
            $section.addClass('hide');
            $list.empty();
        } else {
            $section.removeClass('hide');
            _.each(results, function(result) {
                $list.append(this._resultPartial(result));
            }, this);
            if (options.showMore) {
                options.searchRoute = '#search/' + options.term + '?';
                $list.append(this._showMoreTpl(options));
            }
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this.activeIndex = 0;
        if (this.results.length) {
            this._highlightActive();
        }
    },

    /**
     * Formatter function for the list of results.
     *
     * @param {Array} results The list of actions/commands.
     * @return {Array} The formatted list of actions/commands.
     */
    _formatResults: function(results) {
        if (_.isEmpty(results)) {
            return [];
        }

        return results;
    },

    /**
     * Handle the keydown events.
     * @param {event} e The `keydown` event.
     */
    keydownHandler: function(e) {
        switch (e.keyCode) {
            case 13: // enter
                this.triggerAction();
                break;
            case 40: // down arrow
                this.moveForward();
                e.preventDefault();
                break;
            case 38: // up arrow
                this.moveBackward();
                e.preventDefault();
                break;
        }
    },

    /**
     * Hides the {@link View.Layouts.Base.SweetspotLayout sweet spot layout}.
     */
    triggerHide: function() {
        this.layout.hide();
    },

    /**
     * Triggers the action linked to the active element.
     *
     * Navigates to the view or calls the callback method.
     *
     * @param {Event} [evt] The `click` event.
     */
    triggerAction: function(evt) {
        if (_.isEmpty(this.results)) {
            return;
        }

        this.triggerHide();

        var $action;
        if (evt) {
            evt.preventDefault();
            // When the user clicks on an action, we need to select that action
            // instead of the active one.
            $action = this.$(evt.currentTarget);
        } else {
            $action = this.$('.active > a');
        }

        var route = $action.data('route');
        if (route) {
            var openwindow = $action.data('openwindow');
            if (openwindow) {
                // If the there is an `openwindow` property configured on the action
                // metadata, open this action in a new browser window.
                window.open(route, '_blank');
                return;
            }

            app.router.navigate(route, {trigger: true});
        }

        var callback = $action.data('callback');
        if (callback) {
            this.layout.triggerSystemAction(callback);
        }
    },

    /**
     * Highlight the active element and unhighlight the rest of the elements.
     */
    _highlightActive: function() {
        this.$('.active').removeClass('active');
        var nth = this.activeIndex;
        var $active = this.$('[data-sweetaction=true]:nth(' + nth + ')');
        $active.addClass('active');
        $active.find('a').focus();
        this.$el.prev().find('input').focus();
    },

    /**
     * Moves to the next the active element.
     */
    moveForward: function() {
        // check to make sure we will be in bounds.
        this.activeIndex++;
        if (this.activeIndex < this.results.length) {
            // We're in bounds, just go to the next element in this view.
            this._highlightActive();
        } else {
            this.activeIndex = 0;
            this._highlightActive();
        }
    },

    /**
     * Moves to the previous the active element.
     */
    moveBackward: function() {
        // check to make sure we will be in bounds.
        if (this.activeIndex > 0) {
            // We're in bounds, just go to the previous element in this view
            this.activeIndex--;
            this._highlightActive();
        } else {
            this.activeIndex = this.results.length - 1;
            this._highlightActive();
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        $(window).off('keydown.' + this.cid);
        this._super('_dispose');
    }
}) },
"access-denied": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.AccessDeniedView
 * @alias SUGAR.App.view.views.BaseAccessDeniedView
 * @extends View.View
 */
({
	// Access-denied View (base) 

    className: 'error-page',

    cubeOptions: {spin: false},

    events: {
        'click .sugar-cube': 'spinCube'
    },

    spinCube: function() {
        this.cubeOptions.spin = !this.cubeOptions.spin;
        this.render();
    }
}) },
"login": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Login form view.
 *
 * @class View.Views.Base.LoginView
 * @alias SUGAR.App.view.views.BaseLoginView
 * @extends View.View
 */
({
	// Login View (base) 

    /**
     * @inheritdoc
     */
    plugins: ['ErrorDecoration'],

    /**
     * @inheritdoc
     */
    fallbackFieldTemplate: 'edit',

    /**
     * @inheritdoc
     */
    events: {
        'click [name=login_button]': 'login',
        'keypress': 'handleKeypress',
        "click [name=external_login_button]": "external_login",
        "click [name=login_form_button]": "login_form"
    },

    /**
     * An object containing the keys of the alerts that may be displayed in this
     * view.
     *
     * @type {Object}
     */
    _alertKeys: {
        adminOnly: 'admin_only',
        invalidGrant: 'invalid_grant_error',
        login: 'login',
        needLogin: 'needs_login_error',
        offsetProblem: 'offset_problem',
        loading: 'loading'
    },

    /**
     * Flag to indicate if the link to reset the password should be displayed.
     *
     * @type {Boolean}
     */
    showPasswordReset: false,

    /**
     * The company logo url.
     *
     * @type {String}
     */
    logoUrl: null,

    /**
     * Is external login in progress?
     *
     * @type {boolean}
     */
    isExternalLoginInProgress: false,

    /**
     * Save login popup handler
     */
    childLoginPopup: null,

    /**
     * Process login on key `Enter`.
     *
     * @param {Event} event The `keypress` event.
     */
    handleKeypress: function(event) {
        if (event.keyCode === 13) {
            this.$('input').trigger('blur');
            this.login();
        }
    },

    /**
     * Get the fields metadata from panels and declare a Bean with the metadata
     * attached.
     *
     * Fields metadata needs to be converted to {@link Data.Bean#declareModel}
     * format.
     *
     *     @example
     *      {
     *        "username": { "name": "username", ... },
     *        "password": { "name": "password", ... },
     *        ...
     *      }
     *
     * @param {Object} meta The view metadata.
     * @private
     */
    _declareModel: function(meta) {
        meta = meta || {};

        var fields = {};
        _.each(_.flatten(_.pluck(meta.panels, 'fields')), function(field) {
            fields[field.name] = field;
        });
        app.data.declareModel('Login', {fields: fields});
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        if (app.progress) {
            app.progress.hide();
        }
        // Declare a Bean so we can process field validation
        this._declareModel(options.meta);

        // Reprepare the context because it was initially prepared without metadata
        options.context.prepare(true);

        this._super('initialize', [options]);

        var config = app.metadata.getConfig();
        if (config && app.config.forgotpasswordON === true) {
            this.showPasswordReset = true;
        }

        /**
         * Set window open handler to save popup handler
         */
        app.api.setExternalLoginUICallback(_.bind(function(url, name, params) {
            this.closeLoginPopup();
            this.childLoginPopup = window.open(url, name, params);
        }, this));

        if ((config &&
            app.config.externalLogin === true && 
            app.config.externalLoginSameWindow === true) || app.config.idmModeEnabled
        ) {
            this.externalLoginForm = true;
            this.externalLoginUrl = app.config.externalLoginUrl;
            app.api.setExternalLoginUICallback(_.bind(function(url) {
                this.externalLoginUrl = app.config.externalLoginUrl = url;
                if (this.isExternalLoginInProgress || app.config.idmModeEnabled) {
                    this.isExternalLoginInProgress = false;
                    app.api.setRefreshingToken(true);
                    window.location.replace(this.externalLoginUrl);
                } else {
                    this.render();
                }
            }, this));
        }

        // Set the page title to 'SugarCRM' while on the login screen
        $(document).attr('title', 'SugarCRM');
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (app.config.idmModeEnabled) {
            app.alert.show(this._alertKeys.loading, {
                level: 'process',
                title: app.lang.get('LBL_LOADING'),
                autoClose: false
            });
            return;
        }
        this.logoUrl = this.getLogoImage();
        //It's possible for errors to prevent the postLogin from triggering so contentEl may be hidden.
        app.$contentEl.show();

        this._super('_render');

        this.refreshAdditionalComponents();

        var config = app.metadata.getConfig(),
            level = config.system_status && config.system_status.level;

        if (level === 'maintenance' || level === 'admin_only') {
            app.alert.show(this._alertKeys.adminOnly, {
                level: 'warning',
                title: '',
                messages: [
                    '',
                    app.lang.get(config.system_status.message)
                ]
            });
        }
        app.alert.dismiss(this._alertKeys.offsetProblem);
        return this;
    },

    /**
     * Gets the logo image for sugar and portal
     */
    getLogoImage: function() {
        // Fallback to Sugar logo for portal
        return app.metadata.getLogoUrl(app.utils.isDarkMode());
    },

    /**
     * Refresh additional components
     */
    refreshAdditionalComponents: function() {
        _.each(app.additionalComponents, function(component) {
            component.render();
        });
    },

    /**
     * Process login.
     *
     * We have to manually set `username` and `password` to the model because
     * browser autocomplete does not always trigger DOM change events that would
     * propagate changes into the model.
     */
    login: function() {
        //FIXME: Login fields should trigger model change (SC-3106)
        this.model.set({
            password: this.$('input[name=password]').val(),
            username: this.$('input[name=username]').val()
        });

        // Prepare local auth variables if user chooses local auth
        if (app.api.isExternalLogin() &&
            app.config.externalLogin === true &&
            !_.isNull(app.config.externalLoginSameWindow) &&
            app.config.externalLoginSameWindow === false
        ) {
            app.config.externalLogin = false;
            app.config.externalLoginUrl = undefined;
            app.api.setExternalLogin(false);
            this.closeLoginPopup();
        }

        this.model.doValidate(null,
            _.bind(function(isValid) {
                if (isValid) {
                    app.$contentEl.hide();

                    app.alert.show(this._alertKeys.login, {
                        level: 'process',
                        title: app.lang.get('LBL_LOADING'),
                        autoClose: false
                    });

                    var args = {
                        password: this.model.get('password'),
                        username: this.model.get('username')
                    };

                    app.login(args, null, {
                        error: _.bind(function(error) {
                            this.showSugarLoginForm(error);
                        }, this),
                        success: _.bind(function() {
                            app.logger.debug('logged in successfully!');
                            app.alert.dismiss(this._alertKeys.invalidGrant);
                            app.alert.dismiss(this._alertKeys.needLogin);
                            app.alert.dismiss(this._alertKeys.login);
                            //External login URL should be cleaned up if the login form was successfully used instead.
                            app.config.externalLoginUrl = undefined;

                            app.events.on('app:sync:complete', function() {
                                app.events.trigger('data:sync:complete', 'login', null, {
                                    'showAlerts': {'process': true}
                                });
                                app.api.setRefreshingToken(false);
                                app.logger.debug('sync in successfully!');
                                _.defer(_.bind(this.postLogin, this));
                            }, this);
                        }, this),
                        complete: _.bind(function(request) {
                            if (request.xhr.status == 401) {
                                this.showSugarLoginForm();
                            }
                        }, this)
                    });
                }
            }, this)
        );

        app.alert.dismiss('offset_problem');
    },

    /**
     * When SAML enabled app login error callback will be run only when _refreshToken = true and
     * app login complete callback will be run when _refreshToken = false
     * So to avoid form disappearance after second incorrect login we need to run the same code into to two callbacks
     */
    showSugarLoginForm: function(error) {
        if (error !== undefined && error.code == 'license_seats_needed') {
            app.alert.show(this._alertKeys.adminOnly, {
                level: 'error',
                title: '',
                messages: [
                    '',
                    error.message
                ]
            });
            app.logger.debug('Number of seats exceeded license limit.');
        }
        app.alert.dismiss(this._alertKeys.login);
        app.api.setExternalLogin(false);
        app.config.externalLoginUrl = undefined;
        app.$contentEl.show();
        app.logger.debug('login failed!');
    },

    /**
     * close log in popup
     */
    closeLoginPopup: function() {
        if (!_.isNull(this.childLoginPopup)) {
            this.childLoginPopup.close();
            this.childLoginPopup = null;
        }
    },

    /**
     * After login and app:sync:complete, we need to see if there's any post
     * login setup we need to do prior to rendering the rest of the Sugar app.
     */
    postLogin: function() {
        if (!app.user.get('show_wizard') && !app.user.get('is_password_expired') && app.user.get('cookie_consent')) {

            this.refreshAdditionalComponents();

            if (new Date().getTimezoneOffset() != (app.user.getPreference('tz_offset_sec') / -60)) {
                var link = new Handlebars.SafeString('<a href="#' +
                    app.router.buildRoute('Users', app.user.id, 'edit') + '">' +
                    app.lang.get('LBL_TIMEZONE_DIFFERENT_LINK') + '</a>');

                var message = app.lang.get('TPL_TIMEZONE_DIFFERENT', null, {link: link});

                app.alert.show(this._alertKeys.offsetProblem, {
                    messages: message,
                    closeable: true,
                    level: 'warning'
                });
            }
        }
        app.$contentEl.show();
    },

    /**
     * Process Login
     */
    external_login: function() {
        this.isExternalLoginInProgress = true;
        app.api.setRefreshingToken(false);
        app.api.ping(null, {});
    },
    
    /**
     * Show Login form
     */
    login_form: function() {
        app.config.externalLogin = false;
        app.api.setExternalLogin(false);
        app.controller.loadView({
            module: "Login",
            layout: "login",
            create: true
        });
    }
}) },
"maps-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.BaseMapsDashletView
 * @alias SUGAR.App.view.views.BaseMapsDashletView
 * @extends View.View
 */
({
	// Maps-dashlet View (base) 

    extendsFrom: 'ListMapView',
    plugins: ['Dashlet'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this._initProperties(options);
        this._registerEvents();
    },

    /**
     * @inheritdoc
     */
    _initProperties: function(options) {
        this._super('_initProperties', [options]);

        this._noAccessTemplate = app.template.get(this.name + '.noaccess');
        this._isDashlet = true;
        this._showExpandButton = false;
        this._showCloseButton = false;
        this._showMapToPdfButton = true;
        this._showMapShareButton = true;
        this._defaultZoom = 15;
        this._mapsEnabled = true;
    },

    /**
     * Listening to external events
     *
     */
    _registerEvents: function() {
        this.listenTo(app.controller.context.get('collection'), 'data:sync:complete', this.refreshClicked, this);
    },

    /**
     * @inheritdoc
     */
    initDashlet: function(viewName) {
        this._mode = viewName;

        if (!this.settings.get('maps_display_zoom')) {
            this.settings.set('maps_display_zoom', this._defaultZoom);
        }

        this.before('render', function() {
            if (!this.model || !this._hasMapAccess()) {
                return this._noAccess();
            }
        });
    },

    /**
     * Renders the no-access template, then aborts further rendering.
     *
     * @return {boolean} Always returns `false`.
     * @private
     */
    _noAccess: function() {
        this.$el.html(this._noAccessTemplate());

        return false;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this._createAndShowMap();
    },

    /**
     * Called when Map is loaded
     */
    onMapReady: function() {
        const mapsDisplayType = this.settings.get('maps_display_type');
        const zoomLevel = this.settings.get('maps_display_zoom');

        const mapViewOptions = {
            mapTypeId: mapsDisplayType ? mapsDisplayType : this._getDefaultMapType(),
            zoom: zoomLevel ? zoomLevel : this._defaultZoom
        };

        this._createLocation();
        this._mapController.centerMap(mapViewOptions);
    },

    /**
     * Create the map and display it
     */
    _createAndShowMap: function() {
        if (!app.user.hasMapsLicense()) {
            this._mapsEnabled = false;

            this._noAccess();

            return;
        }

        const collection = this.context.get('collection');

        if (!collection || !this._hasMapAccess() || !this.$el) {
            return;
        }

        let records = _.extend({}, this.context.get('collection').models);

        if (this.context.parent && _.isEmpty(records)) {
            records = [this.context.parent.get('model')];
        }

        if (_.isEmpty(records)) {
            this.$('[data-container=map-no-geocoded-records]').show();
            this.$('[data-widget=list-map-loading]').hide();
        } else {
            this.$('[data-container=map-no-geocoded-records]').hide();
            this.createMap(records);
        }
    },

    /**
     * Refresh the map
     */
    refreshClicked: function() {
        this._createAndShowMap();
    },

    /**
      * Check if the current module has access to the Maps
      *
      * @return {boolean}
      */
    _hasMapAccess: function() {
        if (!_.has(app.config, 'maps')) {
            return false;
        }

        if (!_.has(app.config.maps, 'enabled_modules')) {
            return false;
        }

        const enabledModulesKey = 'enabled_modules';

        const allowedModules = app.config.maps[enabledModulesKey];

        if (allowedModules.indexOf(this.module) > -1) {
            return true;
        }

        return false;
    },

    /**
     * Get default value for MapType
     *
     * @return {string}
     */
    _getDefaultMapType: function() {
        const mapTypeDropdown = app.lang.getAppListStrings('maps_display_type_list');
        const defaultValue = _.first(_.keys(mapTypeDropdown));

        return defaultValue;
    },
}) },
"sweetspot-searchbar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SweetspotSearchbarView
 * @alias SUGAR.App.view.views.BaseSweetspotSearchbarView
 * @extends View.View
 */
({
	// Sweetspot-searchbar View (base) 

    className: 'sweetspot-searchbar',
    events: {
        'keyup input': 'keyUpHandler',
        'click [data-action=configure]': 'initConfig'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of layout.collection.
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        app.events.on('app:sync:complete sweetspot:reset', this.initLibrary, this);
        this.lastTerm = '';

        this.layout.on('hide', function() {
            this.lastTerm = '';
        }, this);
    },

    initConfig: function(evt) {
        this.layout.toggle();
        this.layout.trigger('sweetspot:config');
    },

    /**
     * Initializes the libraries.
     *
     * - Adds all the mega menu actions to {@link #internalLibrary}.
     */
    initLibrary: function() {
        /**
         * Static library.
         *
         * Contains mega menu actions and system commands.
         *
         * @type {Array}
         */
        this.internalLibrary = [];

        /**
         * Temporary library.
         *
         * Contains records from the search API, but these are only kept for
         * 5 minutes (for better user experience).
         *
         * @type {Object}
         */
        this.temporaryLibrary = {};

        this.addToInternalLibrary(this.getSweetspotActions());

        this.internalLibrary = this._formatInternalLib();
    },

    /**
     * Formats the {@link #internalLibrary internal library} by parsing it to
     * remove duplicate results.
     *
     * @return {Array} The formatted library of actions/commands.
     */
    _formatInternalLib: function() {
        var lib = _.chain(this.internalLibrary)
            .map(function(item) {
                return JSON.stringify(item);
            })
            .uniq()
            .map(function(item) {
                return JSON.parse(item)
            })
            .value();

        return lib;
    },

    getSweetspotActions: function() {
        var actionsById = app.metadata.getSweetspotActions();
        var prefs = app.user.getPreference('sweetspot');
        var data = prefs && prefs.hotkeys;

        _.each(data, function(customSetting) {
            if (!actionsById[customSetting.action]) {
                return;
            }
            actionsById[customSetting.action].keyword = customSetting.keyword;
        });
        return _.toArray(actionsById);
    },

    /**
     * Adds some items to the {@link #internalLibrary}.
     *
     * @param {Array} items Items to add.
     */
    addToInternalLibrary: function(items) {
        this.internalLibrary = this.internalLibrary.concat(items);
    },

    /**
     * Adds some records to the {@link #temporaryLibrary}
     *
     * @param {Array} items Records to add.
     */
    addToTemporaryLibrary: function(items) {
        _.each(items, function(item) {
            this.temporaryLibrary[item.id] = item;
        }, this);
    },

    /**
     * Gets the records from the {@link #temporaryLibrary}.
     *
     * Records that are here for more than 5 minutes are removed.
     *
     * @return {Array} The list of records.
     */
    getTemporaryLibrary: function() {
        var now = new Date().getTime();
        var tooOld = now - 300000;
        var updatedLibrary = {};
        var recordList = [];
        _.each(this.temporaryLibrary, function(item) {
            if (item.timestamp > tooOld) {
                updatedLibrary[item.id] = item;
                recordList.push(item);
            }
        });
        this.temporaryLibrary = updatedLibrary;
        return recordList;
    },

    /**
     * Gets the library to perform the search.
     *
     * Concats {@link #internalLibrary} and {@link #temporaryLibrary}.
     *
     * @return {Array} The list of items to perform the search.
     */
    getLibrary: function() {
        return this.internalLibrary.concat(this.getTemporaryLibrary());
    },



    /**
     * Triggers the search and send results.
     *
     * @param {boolean} later `true` if triggered from the search API callback.
     */
    applyQuickSearch: function(later) {
        var term = this.$('input').val();
        if (!later && term === this.lastTerm) {
            return;
        }
        var results = {};
        if (!later && !_.isEmpty(term)) {
            this.fireSearchRequest(term);
        }
        if (!_.isEmpty(term)) {
            results = this.doSearch(term);
        }
        this.sendResults(results);
        this.lastTerm = term;
    },

    /**
     * Performs the actual search in the library.
     *
     * @param {string} term The term to search
     * @return {Array} Hopefully a list of results.
     */
    doSearch: function(term) {
        var options = {
            keys: ['module', 'name'],
            threshold: '0.3',
            includeScore: true
        };
        var keywordFuse = new Fuse(this.internalLibrary, {keys: ['keyword'], threshold: '0.0'});
        var keywords = keywordFuse.search(term);
        keywords = keywords.slice(0, 5);

        var actionsFuse = new Fuse(_.difference(this.internalLibrary, keywords), options);
        var actions = actionsFuse.search(term);
        actions = _.sortBy(actions, function(obj) {
            return [obj.score, obj.item.weight];
        });
        actions = actions.slice(0, 6);

        var recordsFuse = new Fuse(_.toArray(this.temporaryLibrary), options);
        var records = recordsFuse.search(term);
        var showMore = records.length > 3;

        records = records.slice(0, 3);
        return {
            actions: _.compact(_.pluck(actions, 'item')),
            keywords: keywords,
            records: _.compact(_.pluck(records, 'item')),
            showMore: showMore,
            term: term
        };
    },

    /**
     * Triggers `sweetspot:results` with the results of the search.
     *
     * @param {Array} Hopefully a list of results.
     */
    sendResults: function(results) {
        this.layout.trigger('sweetspot:results', results);
    },

    /**
     * Handles the keyup events.
     *
     * @param {event} evt The `keyup` event.
     */
    keyUpHandler: function(evt) {
        if (!this.layout.isVisible()) {
            return;
        }
        this.debouncedSearch(evt);
    },

    /**
     * Calls {@link #applyQuickSearch} with a debounce of 200ms.
     */
    debouncedSearch: _.debounce(function(event) {
        this.applyQuickSearch();
    }, 200),

    /**
     * Makes a request to the search API to find records.
     *
     * On success it calls {@link #addToTemporaryLibrary} to add the records
     * to the temporary library and calls {@link #applyQuickSearch} to re-apply
     * the search.
     *
     * @param {string} term The search term.
     */
    fireSearchRequest: function(term) {
        var self = this;
        this.collection.query = term;
        this.collection.fetch({
            query: term,
            fields: ['name', 'id'],
            module_list: [],
            limit: 4,
            success: function(collection) {
                var now = new Date().getTime();
                var formattedRecords = [];
                _.each(collection.toJSON(), function(record) {
                    if (!record.id) {
                        return; // Elastic Search may return records without id and record names.
                    }
                    var formattedRecord = {
                        id: record.id,
                        name: record.name || app.utils.formatNameModel(record._module, record),
                        module: record._module,
                        label: app.lang.getModuleIconLabel(record._module),
                        route: '#' + app.router.buildRoute(record._module, record.id),
                        timestamp: now,
                        weight: 40
                    };

                    formattedRecords.push(formattedRecord);
                });
                self.addToTemporaryLibrary(formattedRecords);
                self.applyQuickSearch(true);
            }
        });
    }

}) },
"activity-card-content": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivityCardContentView
 * @alias SUGAR.App.view.views.BaseActivityCardContentView
 * @extends View.Views.Base.ActivityCardView
 */
({
	// Activity-card-content View (base) 

    extendsFrom: 'ActivityCardView',

    className: 'activity-card-content',

    attachmentFieldNames: [
        'attachment_list',
        'attachments_collection'
    ],

    events: {
        'click .activity-card-show-more': 'expandCollapse',
        'click .activity-card-show-less': 'expandCollapse'

    },

    /**
     * @inheritdoc
     * @param options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.toggleShowMore = _.debounce(this.toggleShowMore, 10);
        this.initDateDetails();
    },

    /**
     * Initializes hbs date variables with date_modified
     */
    initDateDetails: function() {
        if (!this.activity) {
            return;
        }
        let dateEntered = app.date(this.activity.get('date_entered'));
        let dateModified = app.date(this.activity.get('date_modified'));

        if (dateEntered.isValid() && dateModified.isValid()) {
            dateEntered = dateEntered.formatUser();
            dateModified = dateModified.formatUser();

            if (dateEntered !== dateModified) {
                this.dateModified = dateModified;
            }
        }
    },

    /**
     * @inheritdoc
     * @private
     */
    _render: function() {
        this._super('_render');
        this.toggleShowMore();
    },

    /**
     * show/hide More/Less buttons
     */
    toggleShowMore: function() {
        var curHeight = this.$('.activity-card-content-body').height();
        if (curHeight == 300) {
            this.$('.activity-card-show-more').show();
            this.$('.activity-card-show-less').hide();
        }else if (curHeight < 300) {
            this.$('.activity-card-show-more').hide();
            this.$('.activity-card-show-less').hide();
        } else {
            this.$('.activity-card-show-more').hide();
            this.$('.activity-card-show-less').show();
        }
    },

    /**
     * adds/removes class to expand/collapse cards
     * @param event
     */
    expandCollapse: function(event) {
        var shouldShowMore = $(event.currentTarget).hasClass('activity-card-show-more');
        if (shouldShowMore) {
            this.$('.activity-card-content-body').removeClass('collapsed-timeline').addClass('expanded-timeline');
        } else {
            this.$('.activity-card-content-body').removeClass('expanded-timeline').addClass('collapsed-timeline');
        }
        this.toggleShowMore();
    },

    /**
     * Adds HTML <br> tags for line breaks in the text
     * @param text the string to be formatted
     * @return {string}
     */
    formatContent: function(text) {
        return text ? text.replace(/\n/g, '<br />') : '';
    },

    /**
     * Set the required details for the attachments to be shown in the activity card
     * This method can be used by child classes to initialize attachment fields
     *
     * @param {string} attachmentFieldName Name of the attachment field like, 'attachment_list'
     */
    initAttachmentDetails: function(attachmentFieldName) {
        if (this.activity && this.attachmentFieldNames.includes(attachmentFieldName)) {
            var cardAttachments = this.activity.get(attachmentFieldName);
            this.attachments = cardAttachments.length > 0 ? cardAttachments : null;
            if (this.attachments) {
                this.model = app.data.createBean(this.module, {id: this.activity.get('id')});
                this.model.set(attachmentFieldName, this.attachments);
            }
        }
    }
}) },
"audit-footer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.AuditFooterView
 * @alias SUGAR.App.view.views.BaseAuditFooterView
 * @extends View.View
 */
({
	// Audit-footer View (base) 

    /**
     * @inheritdoc
     * Initialize the audited fields on the parent model.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        if (this.context.parent) {
            var baseModule = this.context.parent.get('module');
            this.auditedFields = this._getAuditedFields(baseModule);
            this.hasCurrencyFields = this._hasCurrencyFields(baseModule);
        }
    },

    /**
     * Parse the parent module metadata and determine audited fields.
     *
     * @param {String} baseModule Name of parent module.
     * @return {Array} List of audited field's name.
     * @protected
     */
    _getAuditedFields: function(baseModule) {
        return _.chain(app.metadata.getModule(baseModule, 'fields'))
            .filter(function(o) {return o.audited;})
            .map(function(o) {return app.lang.get(o.vname, baseModule);})
            .value();
    },

    /**
     *  Look to see if the baseModule has any currency fields
     *
     *  @return {boolean}
     *  @protected
     */
    _hasCurrencyFields: function(baseModule) {
        return _.some(app.metadata.getModule(baseModule, 'fields'), function(field) {
           return field.audited && field.type && field.type == 'currency';
        });
    }
}) },
"omnichannel-search-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.OmnichannelSearchButtonView
 * @alias SUGAR.App.view.views.BaseOmnichannelSearchButtonView
 * @extends View.Views.Base.QuicksearchButtonView
 */
({
	// Omnichannel-search-button View (base) 

    extendsFrom: 'QuicksearchButtonView',
    className: 'table-cell omnichannel-search-button-wrapper',

    events: {
        'click [data-action=search_icon]': 'searchIconClickHandler'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.layout.on('omnichannelsearch:close', function() {
            if (!this.context.get('search')) {
                this.toggleSearchIcon(true);
            }
        }, this);

        /**
         * Used for indicating the state of the button icon.
         *
         * @property {boolean}
         * - `true` means magnifying glass.
         * - `false` means X icon.
         */
        this.searchButtonIcon = true;
    },

    /**
     * Toggles the search icon between the magnifying glass and x.
     *
     * @param {boolean} searchButtonIcon Indicates the state of the search button icon
     * - `true` means magnifying glass.
     * - `false` means X icon.
     */
    toggleSearchIcon: function(searchButtonIcon) {
        if (this.searchButtonIcon === searchButtonIcon) {
            return;
        }
        var iconEl = this.$('[data-action=search_icon] .sicon').first();
        this.searchButtonIcon = searchButtonIcon;
        if (searchButtonIcon) {
            iconEl.removeClass('sicon-close');
            iconEl.addClass('sicon-search');
        } else {
            iconEl.removeClass('sicon-search');
            iconEl.addClass('sicon-close');
        }
    },

    /**
     * Handler for clicks on the search icon (or x, depending on state).
     */
    searchIconClickHandler: function() {
        if (this.searchButtonIcon) {
            app.events.trigger('omnichannelsearch:bar:search:term');
        } else {
            this.layout.trigger('omnichannelsearch:bar:clear:term');
            this.layout.trigger('omnichannelsearch:close');
        }
    }
}) },
"base": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The Base View that all Views should extend from before extending
 * {@link #View.View}.
 *
 * Use this controller to specify your customizations for the Base platform.
 * This should contain any special override that only applies to Base platform
 * and not to Sidecar's library.
 *
 * Any View in a module can skip the default fallback and extend this one
 * directly. In your `BaseModuleMyView` component that lives in the file
 * `modules/<module>/clients/base/views/my-view/my-view.js`, you can
 * directly extend the `BaseView` skipping the normal extend flow which will
 * extend automatically from `BaseMyView` that might live in
 * `clients/base/views/my-view/my-view.js`. Simply define your controller
 * with:
 *
 * ```
 * ({
	// Base View (base) 

 *     extendsFrom: 'BaseView',
 *     // ...
 * })
 * ```
 *
 * This controller exists to force the component to be created and not fallback
 * to the default flow (which happens when the component isn't found).
 *
 * @class View.Views.Base.BaseView
 * @alias SUGAR.App.view.views.BaseBaseView
 * @extends View.View
 */
({
    /**
     * The Base View will always clear any tooltips after `render`.
     */
    initialize: function() {
        this._super('initialize', arguments);
        if (app.tooltip) {
            this.on('render', app.tooltip.clear);
        }
    }
}) },
"omnichannel-search-modulelist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.OmnichannelSearchModulelistView
 * @alias SUGAR.App.view.views.BaseOmnichannelSearchModulelistView
 * @extends View.Views.Base.QuicksearchModuleListView
 */
({
	// Omnichannel-search-modulelist View (base) 

    extendsFrom: 'QuicksearchModuleListView',
    className: 'table-cell omnichannel-search-modulelist-wrapper',

    events: {
        'click [data-action=select-all]': 'selectAllModules',
        'click [data-action=select-module]': 'selectModule',
        'click [data-toggle=dropdown]': 'moduleDropdownClick'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        /**
         * A collection of the available modules.
         *
         * @type {Backbone.Collection}
         */
        this.searchModuleFilter = new Backbone.Collection(null, {
            //adds models in alphabetical order of model's id's module name translation
            comparator: function(model) {
                return app.lang.getModuleName(model.id, {plural: true});
            }
        });

        /**
         * The lastState key for local storage.
         *
         */
        this.stateKey = app.user.lastState.buildKey('omnisearch', 'modulelist', this.name);

        /**
         * Template for the module icons in the search bar.
         * @type {Handlebars.Template}
         *
         * @private
         */
        this._moduleIconTemplate = app.template.getView(this.name + '.module-avatar');

        app.events.on('omnichannel:modulelist:open', function() {
            this.populateModules();
            // If there is a module preference stored in local storage,
            // default selection to those modules.
            var previousModuleSelection = app.user.lastState.get(this.stateKey);
            if (_.isEmpty(previousModuleSelection) || _.isUndefined(previousModuleSelection[0])) {
                this.searchModuleFilter.allSelected = true;
            } else {
                _.each(previousModuleSelection, function(module) {
                    this.searchModuleFilter.get(module).set('selected', true);
                }, this);
            }
            this._setSelectedModules();
            // Prepare the module icons for display
            var moduleIconObj = this._buildModuleIconList();
            this.moduleIcons = {icon: moduleIconObj};
            this.render();
        }, this);
    },

    /**
     * @override
     */
    bindDataChange: function() {
        // If the layout has `omnichannel:modulelist:close` or `omnichannel:results:close` called on it,
        // we need to hide modulelist
        this.layout.on('quicksearch:close omnichannel:modulelist:close omnichannel:results:close', this.close);
    },

    /**
     * Populate `this.searchModuleFilter` with the searchable modules, using
     * acls and the metadata attribute `checkGlobalSearchEnabled`.
     */
    populateModules: function() {
        if (this.disposed) {
            return;
        }

        this.searchModuleFilter.reset();
        var modules = app.metadata.getModules() || {};

        var metaTabs = this._getMetaTabs();
        if (metaTabs) {
            // filter the module names out based on omnichannel modules,
            // global search enabled, has access to acl, and is not a blacklisted module
            _.each(modules, function(meta, module) {
                var validModule = _.find(metaTabs, function(tab) {
                    if (tab.icon && tab.icon.module) {
                        return tab.icon.module === module;
                    }
                    return false;
                });
                if (meta.globalSearchEnabled &&
                    app.acl.hasAccess.call(app.acl, 'view', module) &&
                    !_.contains(this.blacklistModules, module) &&
                    validModule
                ) {
                    var moduleModel = new Backbone.Model({id: module, selected: false});
                    this.searchModuleFilter.add(moduleModel);
                }
            }, this);
        }
    },

    /**
     * Gets metadata tabs.
     */
    _getMetaTabs: function() {
        var metadata = this.model.get('metadata');
        return metadata.tabs || {};
    },

    /**
     * Handle module 'select/unselect' event.
     *
     * @param {Event} event
     */
    selectModule: function(event) {
        // We need to stop propagation for two reasons:
        // 1) Stop scrolling when using the spacebar.
        // 2) Prevent collapse of the `omnichannel-search` layout. The module list is
        // considered inside the dropdown plugin, and not in the layout. Clicks
        // outside the layout normally collapse the layout.
        event.stopImmediatePropagation();
        var $li = $(event.currentTarget);
        var module = $li.data('module');
        var moduleModel = this.searchModuleFilter.get(module);

        // If all the modules were selected, we unselect all of them first.
        if (this.searchModuleFilter.allSelected) {
            this.$('[data-action=select-all]').removeClass('selected', false);
            this.searchModuleFilter.allSelected = false;
        }

        // Then we select the clicked module.
        var checkModule = !moduleModel.get('selected');
        moduleModel.set('selected', checkModule);
        $li.toggleClass('selected', checkModule);

        // Check to see if all the modules are now all selected or unselected.
        var selectedLength = this.searchModuleFilter.where({'selected': true}).length;

        // All modules are selected, set them all to unselected.
        if (selectedLength === this.searchModuleFilter.length) {
            this.searchModuleFilter.invoke('set', {selected: false});
            selectedLength = 0;
        }

        // If all modules are now unselected, update checkboxes and set the
        // `allSelected` property of the filter.
        if (selectedLength === 0) {
            this.searchModuleFilter.allSelected = true;
            this.$('[data-action=select-all]').addClass('selected');
            this.$('[data-action=select-module]').removeClass('selected');
        }

        this._setSelectedModules();
        this._updateModuleIcons();

        // Trigger full search
        this.layout.trigger('omnichannelsearch:quicksearch:viewallresults');
    },

    /**
     * Handle clicks on the "Search all" list item.
     *
     * @param {event} event
     */
    selectAllModules: function(event) {
        // We need to stop propagation for two reasons:
        // 1) Stop scrolling when using the spacebar.
        // 2) Prevent collapse of the `omnichannel-search` layout. The module list is
        // considered inside the dropdown plugin, and not in the layout. Clicks
        // outside the layout normally collapse the layout.
        event.stopImmediatePropagation();

        // Selects all modules.
        this.$('[data-action=select-all]').addClass('selected');
        this.$('[data-action=select-module]').removeClass('selected');
        this.searchModuleFilter.invoke('set', {selected: false});
        this.searchModuleFilter.allSelected = true;

        this._setSelectedModules();
        this._updateModuleIcons();

        // Trigger full search
        this.layout.trigger('omnichannelsearch:quicksearch:viewallresults');
    },

    /**
     * Open it when the module dropdown is clicked.
     */
    moduleDropdownClick: function() {
        this.open();
    },

    /**
     * Show the modulelist dropdown
     */
    open: function() {
        this.$('.dropdown-menu').show();
    },

    /**
     * Hide the modulelist dropdown
     */
    close: function() {
        this.$('.dropdown-menu').hide();
    },

    /**
     * Updates the modules icons in the search bar, based on the currently
     * selected modules.
     *
     * @private
     */
    _updateModuleIcons: function() {
        // Update the module icons in the search bar.
        var $moduleIconContainer = this.$('[data-label=module-icons]');
        $moduleIconContainer.empty();
        var moduleIconObj = this._buildModuleIconList();

        $moduleIconContainer.append(this._moduleIconTemplate({icon: moduleIconObj}));
    },

    /**
     * Builds an array of objects for displaying the module icons.
     * @return {Array}
     *
     * @private
     */
    _buildModuleIconList: function() {
        var moduleIconObj = [];
        // If all modules are selected, display "all" icon.
        if (this.collection.selectedModules.length === 0) {
            moduleIconObj.push({});
            // If 3 or fewer selected, display the module icons that are selected.
        } else if (this.collection.selectedModules.length <= 3) {
            _.each(this.collection.selectedModules, function(module) {
                moduleIconObj.push({module: module});
            }, this);
            // If there are more than 3 modules selected, display the
            // "Multiple Modules" icon
        } else {
            moduleIconObj.push({multiple: true});
        }
        return moduleIconObj;
    },

    /**
     * Store the selected modules on the collection and in local storage.
     *
     * @private
     */
    _setSelectedModules: function() {
        var selectedModules = [];
        if (!this.searchModuleFilter.allSelected) {
            this.searchModuleFilter.each(function(model) {
                if (model.get('selected')) {
                    selectedModules.push(model.id);
                }
            });
        }

        this.collection.selectedModules = selectedModules;
        app.user.lastState.set(this.stateKey, this.collection.selectedModules);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.layout.off('quicksearch:close omnichannel:modulelist:close omnichannel:results:close', this.close);
        this._super('_dispose');
    }
}) },
"omnichannel-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * 'Omnichannel' button.
 *
 * @class View.Views.Base.OmnichannelButtonView
 * @alias SUGAR.App.view.views.BaseOmnichannelButtonView
 * @extends View.View
 */
({
	// Omnichannel-button View (base) 

    className: 'omni-button flex items-center',

    events: {
        'click [data-action=omnichannel]': 'openConsole',
        'click .config-menu .option-layout-open': 'openOptionLayout',
    },

    /**
     * Agent's current status.
     * @property {string}
     */
    status: 'logged-out',

    /**
     * List of browsers supported by AWS Connect CCP.
     * @property {Array}
     */
    supportedBrowsers: [
        'Chrome',
        'Firefox'
    ],

    /**
     * Opens console.
     */
    openConsole: function() {
        if (!this._checkBrowser()) {
            app.alert.show('omnichannel-unsupported-browser', {
                level: 'error',
                messages: app.lang.get('LBL_OMNICHANNEL_UNSUPPORTED_BROWSER')
            });
            return;
        }

        if (this._banOpenCcp()) {
            app.alert.show('finish_configuring', {
                level: 'warning',
                messages: app.lang.get('LBL_OMNICHANNEL_FINISH_CONFIGURING_BEFORE_OPENING_SUGARLIVE'),
            });
            return;
        }

        var console = this._getConsole();
        if (console) {
            console.open();
            console.$el.attr('data-ccp', true);
            this.$('.btn').removeClass('notification-pulse');
        }
    },

    /**
     * Opens Layout Configuration.
     */
    openOptionLayout: function() {
        var console = app.omniConsoleConfig;

        if (!console || !console.isOpen()) {
            console = this._getConfigConsole();
            if (console) {
                console.$el.attr('data-config', true);
                this.$('.config-menu').attr('data-mode', 'open');
                console.isConfigPaneExpanded = true;
                console.open();
            }
        }
    },

    /**
     * Sets button status.
     *
     * @param {string} status string: logged-out, logged-in, active-session
     */
    setStatus: function(status) {
        var currentStatus = this.status || 'logged-out';
        var button = this.$('.btn');
        button.removeClass(currentStatus);
        button.addClass(status);
        this.status = status;
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this.isAvailable = this._isAvailable();
        this.configAvailable = this._configAvailable();

        this._super('_renderHtml');
    },

    /**
     * Util to determine if SugarLive is available for this user
     *
     * @return {boolean} True if SugarLive should be available
     * @private
     */
    _isAvailable: function() {
        return app.api.isAuthenticated() &&
            app.user.hasSellServeLicense() &&
            app.user.isSetupCompleted() &&
            !!app.config.awsConnectInstanceName; // aws connect is configured
    },

    /**
     * Util to determine if SugarLive config should be available for the current user.
     *
     * @return {boolean} True if the user should be able to open SugarLive Config
     * @private
     */
    _configAvailable: function() {
        return app.user.get('type') === 'admin' && app.user.hasSellServeLicense();
    },

    /**
     * Checks if browser is supported by AWS Connect.
     * @return {boolean} True if its supported, false otherwise.
     */
    _checkBrowser: function() {
        var UA = navigator.userAgent;
        return !!_.find(this.supportedBrowsers, function(browserName) {
            return UA.indexOf(browserName) !== -1 &&
                // exclude Microsoft Edge ('Edg' for newer versions)
                UA.indexOf('Edg') === -1;
        });
    },

    /**
     * Checks if ban to open CCP-panel
     * @return {boolean}
     */
    _banOpenCcp: function() {
        var console = app.omniConsoleConfig;
        return (console && console.isConfigPaneExpanded);
    },

    /**
     * Creates omnichannel console if not yet.
     *
     * @return {View.Layout} The console
     * @private
     */
    _getConsole: function() {
        if (_.isUndefined(app.omniConsole)) {
            app.omniConsole = this._createConsole('omnichannel-console');
        } else if (this.status === 'logged-out') {
            var ccp = app.omniConsole.getComponent('omnichannel-ccp');
            ccp.loadCCP();
        }
        return app.omniConsole;
    },

    /**
     * Creates omnichannel console config drawer if not yet created.
     *
     * @return {View.Layout} The console
     * @private
     */
    _getConfigConsole: function() {
        if (_.isUndefined(app.omniConsoleConfig)) {
            app.omniConsoleConfig = this._createConsole(
                'omnichannel-console-config'
            );
        }
        return app.omniConsoleConfig;
    },

    /**
     * Create and initialize a new console of the given layout name, and bind
     * appropriate event listeners.
     *
     * @param layoutName name of layout to create
     * @return {View.Layout} newly created console
     * @private
     */
    _createConsole: function(layoutName) {
        var context = app.controller.context.getChildContext({forceNew: true, module: 'Dashboards'});
        // remove it from parent so that it won't get cleared when loading a new view
        app.controller.context.children.pop();
        var console = app.view.createLayout({
            type: layoutName,
            context: context
        });
        console.initComponents();
        console.loadData();
        console.render();
        this._bindConsoleListeners(console);
        $('#sidecar').append(console.$el);
        return console;
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this._unbindConsoleListeners(app.omniConsole);
        this._unbindConsoleListeners(app.omniConsoleConfig);
        this._super('_dispose');
    },

    /**
     * Util to unbind event listeners on active console
     * @param console
     * @private
     */
    _unbindConsoleListeners: function(console) {
        if (!_.isUndefined(console)) {
            console.context.off('omnichannel:auth');
            console.off('omnichannel:message');
            console.off('omniconsole:open');
        }
    },

    /**
     * Show user notification if the console is closed when a message comes in
     *
     * @private
     */
    _notifyUser: function() {
        var omniConsole = this._getConsole();
        if (!omniConsole.isOpen()) {
            this.$('.btn').addClass('notification-pulse');
        }
    },

    /**
     * Clear notifications
     *
     * @private
     */
    _clearNotifications: function() {
        this.$('.btn').removeClass('notification-pulse');
    },

    /**
     * Bind listeners to the omnichannel-console layout
     *
     * @param {Layout} console - Omnichannel Console layout
     * @private
     */
    _bindConsoleListeners: function(console) {
        console.on('omnichannel:message', this._notifyUser, this);
        console.on('omniconsole:open', this._clearNotifications, this);
        console.context.on('omnichannel:auth', function(status) {
            this.setStatus(status);
        }, this);
    }
}) },
"omnichannel-search-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.OmnichannelSearchHeaderpaneView
 * @alias SUGAR.App.view.views.BaseOmnichannelSearchHeaderpaneView
 * @extends View.Views.Base.SearchHeaderpaneView
 */
({
	// Omnichannel-search-headerpane View (base) 

    extendsFrom: 'SearchHeaderpaneView',

    className: 'omnichannel-search-headerpane-wrapper',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // Share the same collection as other views in the parent layout
        this.collection = this.layout.collection;
        this.collection.on('sync', this.render, this);
    },

    /**
     * @inheritdoc
     *
     * Updates the results count string to show in the header pane
     */
    _render: function() {
        this.countLabel = '';
        this.searchTerm = {
            term: this.collection.query
        };
        var context = {
            num: this.collection.next_offset < 0 ? this.collection.total : this.collection.next_offset,
            total: this.collection.total
        };
        if (context.num || context.total) {
            this.countLabel = new Handlebars.SafeString(app.lang.get('TPL_LIST_HEADER_COUNT_TOTAL',
                this.module, context));
        }
        this._super('_render');
    },

    /**
     * Adjusts the title's ellipsis max-width when browser is resized.
     */
    adjustTitle: function() {
        var $titleCell = this.$('[data-name=omni-title]');
        var headerWidth = $('.omnichannel-search-list').width() * 0.6 - $('.omni-search-header').width();
        var count = $titleCell.find('.count').length > 0 ? $titleCell.find('.count').width() : 0;
        $(window).resize(function() {
            headerWidth = $('.omnibar-search').width() * 0.6 - $('.omni-search-header').width();
            count = $titleCell.find('.count').length > 0 ? $titleCell.find('.count').width() : 0;
        });
        headerWidth = count > 0 ? headerWidth - count : headerWidth;
        if ($titleCell && $titleCell.length > 0 && headerWidth > 0) {
            var $ellipsisDiv = $titleCell.find('.ellipsis_inline');
            $ellipsisDiv.css({
                'max-width': headerWidth * 0.92
            });
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.collection.off('sync', this.render, this);
        this._super('_dispose');
    }
}) },
"omnichannel-search-bar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.OmnichannelSearchBarView
 * @alias SUGAR.App.view.views.BaseOmnichannelSearchBarView
 * @extends View.Views.Base.QuicksearchBarView
 */
({
	// Omnichannel-search-bar View (base) 

    extendsFrom: 'QuicksearchBarView',

    className: 'table-cell omnichannel-search-bar-wrapper',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // Set the number of maximum results to display. Defaults to 20, but can
        // be changed by adding a 'limit' property in the metadata
        this.limit = 20;
        if (this.meta && this.meta.limit) {
            this.limit = this.meta.limit;
        }

        // Sets a persistent option on the collection to always use the xmod_aggs
        // flag, which returns facet/filter count information along with each
        // collection fetch
        this.collection.setOption({
            params: {
                xmod_aggs: true
            }
        });

        // Remove unneeded event from the parent quicksearch bar view
        this.layout.off('quicksearch:close');

        app.events.on('omnichannelsearch:bar:search:term', this.fireSearch);
        this.layout.on('omnichannelsearch:bar:clear:term', this.clearSearchTerm, this);
        this.layout.on('omnichannelsearch:quicksearch:viewallresults', this.fireSearch, this);

        var dashboard = this.closestComponent('omnichannel-dashboard');
        if (dashboard) {
            this.searchTerm = dashboard.savedSearchTerm;
        }
    },

    /**
     * Fires the search based on the search term.
     * Waits & debounces for 0.5 seconds before firing a search.
     */
    fireSearch: _.debounce(function() {
        // When a search is triggered, show "Loading..."
        this.collection.dataFetched = false;
        this.collection.showMore = false;

        // When a search from the search bar completes, let other views know
        var options = this._getDefaultFetchOptions();
        options = _.extend(options, {
            success: _.bind(function() {
                app.events.trigger('omnichannelsearch:bar:search:complete');
                var dashboard = this.closestComponent('omnichannel-dashboard');
                if (dashboard) {
                    dashboard.savedSearchTerm = options.query;
                }
            }, this)
        });

        app.events.trigger('omnichannelsearch:bar:search:started');
        this.collection.query = options.query;
        this.collection.fetch(options);
    }, 500),

    /**
     * @inheritdoc
     *
     * Handles different key stroke cases, so that when the user hits enter the
     * full search fires instead of quicksearch
     */
    keyupHandler: function(event) {
        if (event.keyCode === 13) {
            // Enter pressed, cancel any open quick search and fire a full
            // search instead
            this.layout.trigger('omnichannel:results:close');
            this.fireQuickSearch.cancel();
            this.fireSearch();
        } else {
            // Any other key pressed, fire a quick search
            this.layout.trigger('omnichannel:modulelist:close');
            this.fireQuickSearch();
        }
    },

    /**
     * Delegates firing a quick search to the quick search results view, so that
     * it can use a separate collection to avoid interfering with this layout's
     * collection. Waits & debounces for 0.5 seconds before firing
     */
    fireQuickSearch: _.debounce(function() {
        var options = this._getDefaultFetchOptions();
        this.layout.trigger('omnichannelsearch:quicksearch:fire', options);
    }, 500),

    /**
     * Returns the default options used for collection fetches
     *
     * @return {Object} the set of default collection fetch options
     * @private
     */
    _getDefaultFetchOptions: function() {
        return {
            query: this._getSearchTerm(),
            module_list: this._getSearchSelectedModules(),
            limit: this._getSearchLimit(),
            apiOptions: {
                fetchWithPost: true,
                useNewApi: true
            }
        }
    },

    /**
     * Returns the search term currently entered in the search bar
     *
     * @return {string} the contents of the search bar
     * @private
     */
    _getSearchTerm: function() {
        return this.$input ? this.$input.val() : '';
    },

    /**
     * Returns the search modules currently selected by the user
     *
     * @return {Array} the list of selected search modules
     * @private
     */
    _getSearchSelectedModules: function() {
        var metadata = this.model.get('metadata');
        var selectedModules = [];
        if (metadata.tabs && this.collection.selectedModules.length === 0) {
            _.each(metadata.tabs, function(tab) {
                if (tab.icon && tab.icon.module &&
                    app.acl.hasAccess.call(app.acl, 'view', tab.icon.module)) {
                    selectedModules.push(tab.icon.module);
                }
            });
        } else {
            selectedModules = this.collection.selectedModules;
        }
        return selectedModules;
    },

    /**
     * Returns the default search result limit to use for collection fetches
     *
     * @return {number} the search result limit
     * @private
     */
    _getSearchLimit: function() {
        var limit = this.layout.v2 ? this.limit : 20;
        limit = app.config && app.config.maxSearchQueryResult || limit;
        return limit;
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        app.events.off('omnichannelsearch:bar:search:term', this.fireSearch);
        this.layout.off('omnichannelsearch:bar:clear:term', this.clearSearchTerm, this);
        this.layout.off('omnichannelsearch:quicksearch:viewallresults', this.fireSearch, this);
        this._super('_dispose');
    }
}) },
"searchbar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Views.Base.SearchbarView
 * @alias SUGAR.App.view.views.BaseSearchbarView
 * @extends View.View
 */
({
	// Searchbar View (base) 

    /**
     * the library to search
     */
    library: [],

    /**
     * the matched records
     */
    matches: null,

    /**
     * search tool
     */
    fuse: null,

    /**
     * @inheritdoc
     */
    events: {
        'click .search-group .sicon-close': 'closeIconClickHandler',
        'keyup [data-action="search"]': 'doSearch'
    },

    /**
     * Max number of records per page
     */
    maxNum: 7,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.searchDropdown = null;
        this.searchButtonIcon = 'search';

        this.context.on('page:clicked', this._search, this);

        this._initProperties();
    },

    /**
     * Handler for clicks on the close.
     */
    closeIconClickHandler: function() {
        this.$('input[data-action=search]').val('');
        this.toggleSearchIcon('search');
    },

    /**
     * Toggles the search icon between the magnifying glass and x.
     *
     * @param {string} searchButtonIcon Indicates the state of the search button icon
     * - `search` means magnifying glass.
     * - `close` means X icon.
     */
    toggleSearchIcon: function(searchButtonIcon) {
        if (this.searchButtonIcon === searchButtonIcon) {
            return;
        }
        var iconEl = this.$('input[data-action=search] + i').first();
        this.searchButtonIcon = searchButtonIcon;
        switch (searchButtonIcon) {
            case 'search':
                iconEl.removeClass('sicon-close');
                iconEl.addClass('sicon-search');
                break;
            case 'close':
                iconEl.removeClass('sicon-search');
                iconEl.addClass('sicon-close');
                break;
        }
    },

    /**
     * Handler when the library data is ready
     */
    sourceDataReady: function() {
        this._populateLibrary();
        this.initFuse();
    },

    /**
     * initialize some properties
     * This should be overridden by sub classes to define their own greeting, event, etc.
     *
     * @private
     */
    _initProperties: function() {
    },

    /**
     * This function populates the search library.
     * This should be overridden by sub classes to build the library for search.
     *
     * @private
     */
    _populateLibrary: function() {
    },

    /**
     * This function returns fuse options.
     * This can be overridden by sub classes to define their own options as needed
     */
    getFuseOptions: function() {
        return {
            // we don't need score
            includeScore: false,
            // Search only in the name and description attributes
            keys: ['name', 'description']
        };
    },

    /**
     * initialize fuse object
     */
    initFuse: function() {
        if (!this.fuse && this.library) {
            this.fuse = new Fuse(this.library, this.getFuseOptions());
        }
    },

    /**
     * Starts a new search and show the search results dropdown.
     */
    doSearch: _.debounce(function() {
        var $input = this.$('input[data-action=search]');
        var term = $input.val().trim();

        if (term === '') {
            if (this.searchDropdown) {
                this.searchDropdown.hide();
            }
            this.toggleSearchIcon('search');
            return;
        }

        this.toggleSearchIcon('close');

        if (_.isNull(this.searchDropdown)) {
            this.searchDropdown = app.view.createLayout({
                context: this.context,
                name: 'searchbar-dropdown',
                module: this.module
            });
            this.searchDropdown.initComponents();
            this.layout._components.push(this.searchDropdown);
            this.searchDropdown.render();

            var $searchGroup = this.$('.search-group');
            $searchGroup.after(this.searchDropdown.$el);
        }

        this.searchDropdown.hide();
        this.context.trigger('data:fetching');
        this.searchDropdown.show();

        // do fuse search, which supports fuzzy search
        if (this.fuse) {
            this.matches = this.fuse.search(term);
            this.totalRecords = this.matches.length;

            this._search();
        }
    }, 400),

    /**
     * @param {Object} options The search options
     * @private
     */
    _search: function(options) {
        var pageNumber = options && options.pageNum || 1;
        var offset = (pageNumber - 1) * this.maxNum;

        // looks up this.matches and gets the records we need and add them to data
        var data = {records: [], total: this.totalRecords, next_offset: offset + this.maxNum};
        for (var i = offset; i < offset + this.maxNum && i < this.totalRecords; i++) {
            data.records.push(this.matches[i]);
        }
        if (this.context) {
            var parsedData = this._parseData(data);
            this.context.trigger('data:fetched', parsedData);
        }
    },

    /**
     * Parses search results.
     *
     * @param {Object} result The search result
     * @return {Object} parsed data
     * @private
     */
    _parseData: function(result) {
        var totalPages = result.total > 0 ?
            Math.ceil(result.total / this.maxNum) : 0;
        var currentPage = result.next_offset > 0 ?
            result.next_offset / this.maxNum : totalPages;
        var records = _.map(result.records, function(record) {
            return {
                name: record.name,
                description: record.description,
                url: app.utils.buildUrl(record.href.replace(/^\/+/g, ''))
            };
        });
        return {
            currentPage: currentPage,
            records: records,
            totalPages: totalPages
        };
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.context) {
            this.context.off('page:clicked', null, this);
        }
        if (this.fuse) {
            delete this.fuse;
        }
    }
}) },
"activitystream-bottom": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivitystreamBottomView
 * @alias SUGAR.App.view.views.BaseActivitystreamBottomView
 * @extends View.View
 */
({
	// Activitystream-bottom View (base) 

    events: {
        'click [data-action=show-more]': 'paginate'
    },

    /**
     * Load list-bottom template.
     * @inheritdoc
     */
    _loadTemplate: function(options) {
        this.tplName = 'list-bottom';
        this.template = app.template.getView(this.tplName);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        if (!app.config.activityStreamsEnabled) {
            this.$el.addClass('hide');
        }

        return this;
    },

    /**
     * Display appropriate label depending on the state of activity stream collection.
     * @inheritdoc
     */
    _renderHtml: function() {
        if ((this.collection.next_offset === -1) && (this.collection.length > 0)) {
            this.$el.addClass('hide');
        } else {
            this.dataFetched = this.collection.dataFetched;
            this.showMoreLabel = app.lang.get('TPL_SHOW_MORE_MODULE', this.module);
            this.showLoadMsg = true;
            this._super('_renderHtml');
            this.$el.removeClass('hide');
        }
    },

    /**
     * Re-render when activity stream is fetched.
     * @inheritdoc
     */
    bindDataChange: function() {
        this.collection.on('reset add', this.render, this);
    },

    /**
     * Call to paginate activity stream.
     */
    paginate: function() {
        this.context.trigger('activitystream:paginate', true);
    }
}) },
"headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HeaderpaneView
 * @alias SUGAR.App.view.views.BaseHeaderpaneView
 * @extends View.View
 */
({
	// Headerpane View (base) 

    plugins: [
        'ErrorDecoration',
        'Editable'
    ],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.meta = _.extend({}, app.metadata.getView(null, 'headerpane'), this.meta);

        /**
         * The label used for the title. This is the raw label.
         *
         * @deprecated 7.5 and will be removed in 7.7. We recommend to set the
         * title by defining a `fields` array, containing a field named `title`,
         * in the metadata. You should not define the title with `meta.title`.
         * Note that you can extend {@link #formatTitle} if the string used is a
         * template and you wish to pass a context.
         *
         * @type {string}
         * @private
         */
        this._title = this.meta.title;
        this.buttons = {};

        this.context.on('headerpane:title', function(title) {
            this._title = title;
            if (!this.disposed) this.render();
        }, this);

        //shortcut keys
        app.shortcuts.register({
            id: 'Headerpane:Cancel',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $cancelButton = this.$('a[name=cancel_button]'),
                    $closeButton = this.$('a[name=close]');

                if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                    $cancelButton.click();
                } else if ($closeButton.is(':visible') && !$closeButton.hasClass('disabled')) {
                    $closeButton.click();
                }
            }
        });
        app.shortcuts.register({
            id: 'Headerpane:Save',
            keys: ['mod+s','mod+alt+a'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_SAVE',
            callOnFocus: true,
            handler: function() {
                var $saveButton = this.$('a[name=save_button]');
                if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                    $saveButton.click();
                }
            }
        });

        this.adjustHeaderpane = _.debounce(this.adjustHeaderpane, 50);
        _.bindAll(this, 'adjustHeaderpane');
        $(window).on('resize.headerpane.' + this.cid, this.adjustHeaderpane);
        this.layout.on('headerpane:adjust_fields', this.adjustTitle, this);
    },

    /**
     * Adjusts the title's ellipsis max-width to match the ancestor title cell.
     */
    adjustTitle: function() {
        var $titleCell = this.$el.find('[data-name=title]');
        if ($titleCell) {
            var $ellipsisDiv = $titleCell.find('.ellipsis_inline');
            var width = $titleCell.css('max-width');
            $ellipsisDiv.css({'max-width': width});
        }
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        /**
         * The title being rendered in the headerpane. This is the formatted
         * label.
         *
         * @deprecated 7.5 and will be removed in 7.7. We recommend to set the
         * title by defining a `fields` array, containing a field named `title`,
         * in the metadata. You should not define the title with `meta.title`.
         * Note that you can extend {@link #_formatTitle} if the string used is a
         * template and you wish to pass a context.
         *
         * @type {string}
         */
        this.title = !_.isUndefined(this._title) ? this._formatTitle(this._title) : this.title;
        // FIXME TY-1751 Move code that alters the metadata outside of _renderHtml
        this.meta.fields = _.map(this.meta.fields, function(field) {
            if (field.name === 'title') {
                field['formatted_value'] = this.title || this._formatTitle(field['default_value']);
            }
            return field;
        }, this);
        this._super('_renderHtml');
    },

    /**
     * Formats the title before being rendered.
     *
     * @param {string} title The unformatted title.
     * @return {string} The formatted title.
     * @protected
     */
    _formatTitle: function(title) {
        if (!title) {
            return '';
        }
        return app.lang.get(title, this.module);
    },

    /**
     * Adjust headerpane such that certain fields can be shown with ellipsis.
     */
    adjustHeaderpane: function() {
        this.setContainerWidth();
        this.adjustHeaderpaneFields();
    },

    /**
     * Adjust headerpane fields such that the first field is ellipsified and the last field
     * is set to 100% on view.  On edit, the first field is set to 100%.
     */
    adjustHeaderpaneFields: function() {
        var $ellipsisCell,
            ellipsisCellWidth,
            $recordCells;

        if (this.disposed) {
            return;
        }

        $recordCells = this.$('.headerpane h1').children('.record-cell, .btn-toolbar').get().reverse();

        if (($recordCells.length > 0) && (this.getContainerWidth() > 0)) {
            $ellipsisCell = $(this._getCellToEllipsify($recordCells));

            if ($ellipsisCell.length > 0) {
                if ($ellipsisCell.hasClass('edit')) {
                    // make the ellipsis cell widen to 100% on edit
                    $ellipsisCell.css({'width': '100%'});
                } else {
                    ellipsisCellWidth = this._calculateEllipsifiedCellWidth($recordCells, $ellipsisCell);
                    this._setMaxWidthForEllipsifiedCell($ellipsisCell, ellipsisCellWidth);
                }
            }
        }
        if (this.layout) {
            this.layout.trigger('headerpane:adjust_fields');
        }
    },

    /**
     * Adds the button corresponding to `buttonName` to the `buttons` object.
     *
     * @param {string} buttonName The name of the button.
     * @private
     */
    _registerFieldAsButton: function(buttonName) {
        var button = this.getField(buttonName);
        if (button) {
            this.buttons[buttonName] = button;
        }
    },

    /**
     * Returns a list of fields that are not button of the view.
     *
     * @private
     */
    _getNonButtonFields: function() {
        return _.filter(this.fields, _.bind(function(field) {
            if (field.name) {
                return !this.buttons[field.name];
            }

            return true;
        }, this));
    },

    /**
     * Uses {@link app.plugins.Editable} to
     *   set the internal property of {@link #editableFields}.
     */
    setEditableFields: function() {
        this.editableFields = this.getEditableFields(this._getNonButtonFields(), this.noEditFields || []);
    },

    /**
     * Registers fields as buttons as specified in the metadata.
     *
     * @protected
     */
    _setButtons: function() {
        if (this.meta && this.meta.buttons) {
            _.each(this.meta.buttons, function(button) {
                this._registerFieldAsButton(button.name);
            }, this);
        }
    },

    /**
     * Show/hide buttons depending on the state defined for each buttons in the
     * metadata.
     *
     * @param {string} state The {@link #STATE} of the current view.
     */
    setButtonStates: function(state) {
        this.currentState = state;

        _.each(this.buttons, function(field) {
            var showOn = field.def.showOn;
            if (_.isUndefined(showOn) || (showOn === state)) {
                field.show();
            } else {
                field.hide();
            }
        });

        this._toggleButtons(true);
    },

    /**
     * Enables or disables the action buttons that are currently shown on the
     * page. Toggles the `.disabled` class by default.
     *
     * @param {boolean} [enable=false] Whether to enable or disable the action
     *   buttons. Defaults to `false`.
     * @private
     */
    _toggleButtons: function(enable) {
        var state = !_.isUndefined(enable) ? !enable : false;

        _.each(this.buttons, function(button) {
            var showOn = button.def.showOn;
            if (_.isUndefined(showOn) || this.currentState === showOn) {
                button.setDisabled(state);
            }
        }, this);
    },

    /**
     * Get the width of the layout container
     */
    getContainerWidth: function() {
        return this._containerWidth;
    },

    /**
     * Set the width of the layout container
     */
    setContainerWidth: function() {
        this._containerWidth = this._getParentLayoutWidth(this.layout);
    },

    /**
     * Get the width of the parent layout that contains `getPaneWidth()`
     * method.
     *
     * @param {View.Layout} layout The parent layout.
     * @return {number} The parent layout width.
     * @private
     */
    _getParentLayoutWidth: function(layout) {
        if (!layout) {
            return window.innerWidth;
        } else if (_.isFunction(layout.getPaneWidth)) {
            return layout.getPaneWidth(this);
        }

        return this._getParentLayoutWidth(layout.layout);
    },

    /**
     * Get the first cell for the field that can be ellipsified.
     * @param {jQuery} $cells
     * @return {jQuery}
     * @private
     */
    _getCellToEllipsify: function($cells) {
        var fieldTypesToEllipsify = ['fullname', 'name', 'text', 'base', 'enum', 'url',
            'dashboardtitle', 'label', 'drillthrough-labels'];

        return _.find($cells, function(cell) {
            return (_.indexOf(fieldTypesToEllipsify, $(cell).data('type')) !== -1);
        });
    },

    /**
     * Calculate the width for the cell that needs to be ellipsified.
     * @param {jQuery} $cells
     * @param {jQuery} $ellipsisCell
     * @return {number}
     * @private
     */
    _calculateEllipsifiedCellWidth: function($cells, $ellipsisCell) {
        var width = this.getContainerWidth();

        _.each($cells, function(cell) {
            var $cell = $(cell);

            if ($cell.is($ellipsisCell)) {
                width -= (parseInt($ellipsisCell.css('padding-left'), 10) +
                parseInt($ellipsisCell.css('padding-right'), 10));
            } else if ($cell.is(':visible')) {
                $cell.css({'width': 'auto'});
                width -= $cell.outerWidth();
            }
            $cell.css({'width': ''});
        });

        return width;
    },

    /**
     * Set the max-width for the specified cell.
     * @param {jQuery} $ellipsisCell
     * @param {number} width
     * @private
     */
    _setMaxWidthForEllipsifiedCell: function($ellipsisCell, width) {
        var ellipsifiedCell,
            fieldType = $ellipsisCell.data('type');

        if (fieldType === 'fullname' || fieldType === 'dashboardtitle') {
            ellipsifiedCell = this.getField($ellipsisCell.data('name'));
            width -= ellipsifiedCell.getCellPadding();
            ellipsifiedCell.setMaxWidth(width);
        } else {
            $ellipsisCell.css({'max-width': width});
        }
    },

    /**
     * @inheritdoc
     */
    _renderFields: function() {
        this._super('_renderFields');
        this.adjustHeaderpane();
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this._super('unbind');
        $(window).off('resize.headerpane.' + this.cid);
        this.layout.off('headerpane:adjust_fields', this.adjustTitle);
    }
}) },
"multi-line-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * MultiLineList supports more than one line of data per Model row. User can group
 * relevant data into the same column of the data-table.
 *
 * The view metadata of each field columns uses subfields property to determine the
 * actual data being shown. Each subfields entry contains field data.
 *
 * Example:
 * array(
 *     'fields' => array(
 *         array(
 *             'user' => 'user',
 *             'label' => 'LBL_USER',
 *             'width' => 'xlarge',
 *             'subfields' => array(
 *                 array(
 *                     'name' => 'user_name',
 *                     'label' => 'LBL_USER_NAME',
 *                     'enable' => true,
 *                     'default' => true,
 *                 ),
 *                 array(
 *                     'name' => 'user_id',
 *                     'label' => 'LBL_USER_ID',
 *                     'enable' => true,
 *                     'default' => true,
 *                 ),
 *             ),
 *         ),
 *     ),
 * )
 *
 * @class View.Views.Base.MultiLineListView
 * @alias SUGAR.App.view.views.BaseMultiLineListView
 * @extends View.Views.Base.ListView
 */
({
	// Multi-line-list View (base) 

    extendsFrom: 'ListView',
    className: 'multi-line-list-view',
    drawerModelId: null,
    sideDrawer: null,
    plugins: ['ConfigDrivenList'],

    /**
     * Event handlers for left row actions.
     */
    contextEvents: {
        'list:openrow:fire': 'openClicked',
        'list:editrow:fire': 'editClicked',
        'list:copyrow:fire': 'copyClicked'
    },

    /**
     * @override
     */
    initialize: function(options) {
        var defaultMeta = app.metadata.getView(null, 'multi-line-list') || {};
        var listViewMeta = app.metadata.getView(options.module, 'multi-line-list') || {};
        options.meta = _.extend({}, defaultMeta, listViewMeta, options.meta || {});
        this._setConfig(options);
        this._setCollectionOption(options);

        this._super('initialize', [options]);

        this.hasModuleAccess = _.contains(
            app.metadata.getModuleNames(),
            this.module
        );

        // Set fields on context to forcefully load these fields
        var fields = this._extractFieldNames(this.meta);
        this.context.set('fields', fields);

        this.context.resetLoadFlag();
        this.context.set('skipFetch', false);

        this.leftColumns = [];
        this.addActions(this.meta);

        var leftColumnsEvents = {};
        //add an event delegate for left action dropdown buttons onclick events
        if (this.leftColumns.length) {
            leftColumnsEvents = {
                'hidden.bs.dropdown .actions': 'updateDropdownDirection',
                'shown.bs.dropdown .actions': 'updateDropdownDirection',
            };
        }
        this.events = _.extend({}, this.events, leftColumnsEvents, {
            'click .multi-line-row td:not(:first-child)': 'handleRowClick',
        });

        if (this.hasFrozenColumn) {
            this.$el.on('scroll', _.bind(this.toggleFrozenColumnBorder, this));
        }
        this.autoRefresh(true);
    },

    /**
     * Show/hide border when scrolling horizontally if the first column is frozen.
     */
    toggleFrozenColumnBorder: _.throttle(function() {
        if (!this.hasFrozenColumn) {
            return;
        }

        let $firstColumns = this.$('.table tbody tr td:nth-child(2), .table thead tr th:nth-child(2)');
        $firstColumns.toggleClass('column-border', this.$el[0].scrollLeft > 0);
    }, 100),

    /**
     * Get fields names from metadata
     *
     * @param {Object} meta Metadata containing fields on view
     * @return {Array} Array of fields
     * @private
     */
    _extractFieldNames: function(meta) {
        var fields = [];
        _.each(meta.panels, function(panel) {
            var panelFields = panel.fields;
            _.each(panelFields, function(fieldDefs) {
                var subFields = fieldDefs.subfields;
                var relatedFields = _.flatten(_.compact(_.pluck(subFields, 'related_fields')));
                fields = _.union(fields, _.pluck(subFields, 'name'), relatedFields);
            }, this);
        }, this);

        return fields;
    },

    /**
     * Set filter_def and order_by from config.
     *
     * @param {Object} options object for the view
     */
    _setConfig: function(options) {
        var configMeta = app.metadata.getModule('ConsoleConfiguration');

        if (configMeta && options.context && options.context.parent) {
            let config = configMeta.config;
            var module = options.context.get('module');
            var consoleId = options.context.parent.get('modelId');
            options.meta = options.meta || {};
            options.meta.filterDef = config.filter_def[consoleId][module] || [];
            var orderByPrimary = config.order_by_primary[consoleId][module] || '';
            var orderBySecondary = config.order_by_secondary[consoleId][module] || '';
            var orderBy = orderByPrimary.trim();
            if (orderBySecondary) {
                orderBy += ',' + orderBySecondary.trim();
            }
            options.meta.collectionOptions = options.meta.collectionOptions || {};
            options.meta.collectionOptions.params = options.meta.collectionOptions.params || {};
            options.meta.collectionOptions.params.order_by = orderBy;
            let freezeFirstColumn = config.freeze_first_column && config.freeze_first_column[consoleId] &&
                !_.isUndefined(config.freeze_first_column[consoleId][module]) ?
                config.freeze_first_column[consoleId][module] : true;
            this.hasFrozenColumn = app.config.allowFreezeFirstColumn && freezeFirstColumn;
        }
    },

    /**
     * Set collection option and filterDef
     *
     * @param {Object} options object for the view
     */
    _setCollectionOption: function(options) {
        var collection = options.context.get('collection');
        if (!collection) {
            collection = app.data.createBeanCollection(options.module);
            options.context.set({collection: collection});
        }
        var meta = options.meta || {};
        if (meta.collectionOptions) {
            collection.setOption(meta.collectionOptions);
        }
        this.setFilterDef(options);
    },

    /**
     * Set the filter for the collection
     *
     * @param {Object} options object for the view
     */
    setFilterDef: function(options) {
        var meta = options.meta || {};
        if (meta.filterDef) {
            // filterDef maybe altered by other methods like applyFilter()
            // but defaultFilterDef always maintains a copy of original default filters
            options.context.get('collection').defaultFilterDef = meta.filterDef;
            options.context.get('collection').filterDef = meta.filterDef;
        }
    },

    /**
     * @inheritdoc
     */
    focusRow: function(id) {
        this.drawerModelId = id;
        this._super('focusRow', [id]);
    },

    /**
     * @inheritdoc
     */
    getRowDomForModelId: function(id) {
        return this.$(`.multi-line-row[data-id="${id}"]`);
    },

    /**
     * Highlights a row on the list and removes highlight from
     * the previously highlighted row
     *
     * @param {jQuery} $el Element to find the row to highlight
     */
    highlightRow: function($el) {
        this.unhighlightRows();
        if ($el.length) {
            $el.addClass('current highlighted');
        }
    },

    /**
     * @inheritdoc
     */
    unhighlightRows: function() {
        let highlightedRows = this.$('.multi-line-row.current.highlighted');
        if (highlightedRows.length) {
            highlightedRows.removeClass('current highlighted');
        }
    },

    /**
     * Trigger action when a model row is clicked
     *
     * @param {Object} event Click event that triggers the function
     */
    handleRowClick: function(event) {
        var $el = this.$(event.target);

        // ignore event triggered by dropdown-toggle or any action dropdown is open
        if (this.isDropdownToggle($el) || this.isActionsDropdownOpen()) {
            return;
        }

        var modelId = $el.closest('.multi-line-row').data('id');
        var model = this.collection.get(modelId);
        if (app.sideDrawer && model) {
            const openDrawer = _.bind(function() {
                app.sideDrawer.open({
                    layout: 'row-model-data',
                    context: {
                        model: model,
                        module: model.get('_module'),
                        layout: 'multi-line',
                        modelId: model.id,
                        parentContext: this.context,
                        baseModelId: model.get('id'),
                        fieldDefs: this._getNameFieldDefs(model.get('_module'))
                    }
                });
                this.drawerModelId = modelId;
            }, this);

            if (app.sideDrawer.isOpen()) {
                // If the same row was selected again, don't re-open the drawer
                if (modelId === this.drawerModelId) {
                    return;
                }

                // If the decided to stay after the unsaved changes warning, don't open the drawer
                if (!app.sideDrawer.triggerBefore('side-drawer:content-changed', {callback: openDrawer})) {
                    return;
                }
            }

            openDrawer();
        }
    },

    /**
     * Gets the field defs for the given module's name field
     * @param module
     * @return {Object}
     * @private
     */
    _getNameFieldDefs: function(module) {
        return app.metadata.getModule(module, 'fields').name;
    },

    /**
     * Get side drawer.
     * @return {Object} The side drawer.
     * @private
     * @deprecated since 11.2.0, use app.sideDrawer instead
     */
    _getSideDrawer: function() {
        return app.sideDrawer;
    },

    /**
     * Open record view in edit mode when 'edit in new tab' is clicked.
     *
     * @param {Backbone.Model} model Selected row's model.
     */
    editClicked: function(model) {
        var route = app.router.buildRoute(model.module, model.id, 'edit');
        window.open('#' + route, '_blank');
    },

    /**
     * Open record view when 'open in new tab' is clicked.
     *
     * @param {Backbone.Model} model Selected row's model.
     */
    openClicked: function(model) {
        var route = app.router.buildRoute(model.module, model.id);
        window.open('#' + route, '_blank');
    },

    /**
     * Copy record url to clipboard when 'copy url' is clicked.
     *
     * This function is adaped from: https://gist.github.com/Chalarangelo/4ff1e8c0ec03d9294628efbae49216db
     * @param {Backbone.Model} model Selected row's model.
     */
    copyClicked: function(model) {
        var route = app.router.buildRoute(model.module, model.id);
        var el = document.createElement('textarea');
        el.value = app.utils.getSiteUrl() + '#' + route;
        el.setAttribute('readonly', '');
        el.style.position = 'absolute';
        el.style.left = '-9999px';
        document.body.appendChild(el);
        el.select();
        document.execCommand('copy');
        document.body.removeChild(el);
    },

    /**
     * Add rowactions to left column
     *
     * @param {Object} meta View metadata
     */
    addActions: function(meta) {
        if (meta && _.isObject(meta.rowactions)) {
            var _generateMeta = function(label, cssClass, buttons) {
                return {
                    'type': 'fieldset',
                    'css_class': 'overflow-visible',
                    'fields': [
                        {
                            'type': 'rowactions',
                            'no_default_action': true,
                            'label': label || '',
                            'css_class': cssClass,
                            'buttons': buttons || []
                        }
                    ],
                };
            };
            var def = meta.rowactions;
            this.leftColumns.push(_generateMeta(def.label, def.css_class, def.actions));
        }
    },

    /**
     * Check if any rowaction dropdown-menu is open
     *
     * @return {boolean} dropdown-menu open or not
     */
    isActionsDropdownOpen: function() {
        return !!this.$('.fieldset.actions.list.btn-group.open').length;
    },

    /**
     * Check if the event is triggered from dropdown-toggle
     *
     * @param {jQuery} $el element that trigger the event
     * @return {boolean} element is dropdown-toggle or not
     */
    isDropdownToggle: function($el) {
        return $el.hasClass('dropdown-toggle') || $el.parent().hasClass('dropdown-toggle');
    },

    /**
     * Update CSS class of dropdown-menu based on its vertical position
     *
     * @param {Event} event Shown/Hidden event
     */
    updateDropdownDirection: function(event) {
        var $buttonGroup = this.$(event.currentTarget).first();
        var windowHeight = $(window).height() - 65; // height of window less padding
        var menuHeight = $buttonGroup.height() + $buttonGroup.children('ul').first().height();
        if (windowHeight < $buttonGroup.offset().top + menuHeight) {
            $buttonGroup.toggleClass('dropup');
        }
    },

    /**
     * Auto refresh the list view every 5 minutes
     *
     * @param {boolean} start `true` to start the timer, `false` to stop it
     */
    autoRefresh: function(start) {
        if (start) {
            clearInterval(this._timerId);
            this._timerId = setInterval(_.bind(function() {
                this.refreshData();
            }, this), 5 * 1000 * 60); // 5 min default
        } else {
            clearInterval(this._timerId);
        }
    },

    /**
     * Reload the data
     */
    refreshData: function() {
        this.context.reloadData();
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this.$el.closest('.dashboard').css('overflow-y', 'hidden');
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.autoRefresh(false);
        if (this.hasFrozenColumn) {
            this.$el.off('scroll', _.bind(this.toggleFrozenColumnBorder, this));
        }
        this.$el.closest('.dashboard').css('overflow-y', 'auto');
        this._super('_dispose');
    }
}) },
"external-app-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This view allows users to add Sugar Apps (external-app) to a Dashboard
 *
 * @class View.Views.Base.ExternalAppDashletView
 * @alias SUGAR.App.view.views.BaseExternalAppDashletView
 * @extends View.Views.Base.ExternalAppView
 */
({
	// External-app-dashlet View (base) 

    extendsFrom: 'ExternalAppView',

    plugins: ['Dashlet'],

    className: 'external-app-dashlet',

    // wait for 20seconds for MFE to return
    scriptTimeoutTime: 20000,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        if (!options.meta.config) {
            this.allowApp = this._checkCatalogAccess(options);

            if (!this.allowApp) {
                // if the App is not allowed, set the Catalog Error code
                this.errorCode = 'CAT-404';
            }
        }
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.meta.config) {
            return;
        }

        if (!this.allowApp) {
            // only need to listen for the metadata update if we have not gotten the metadata yet
            app.events.on(`sugarApp:${this.module}:${this._getLayoutName()}:updated`, this._checkMeta, this);
            this.dashletSetTimeout = _.delay(this._failedToLoadScript.bind(this), this.scriptTimeoutTime);
        }
        this._super('bindDataChange');
    },

    /**
     * @inheritdoc
     */
    initDashlet: function() {
        if (this.meta.config && !this.meta.customConfig) {
            var fields = _.flatten(_.pluck(this.dashletConfig.panels, 'fields'));
            var appDataField = _.find(fields, function(f) {
                return f.name === 'src';
            });
            var options = {};
            this.servicesObj = {};
            _.each(this.services, function(s) {
                options[s.view.src] = s.view.name;
                this.servicesObj[s.view.src] = s.view;
            }, this);
            appDataField.options = options;

            this.settings.on('change', function(model) {
                if (model.changed.src) {
                    // if the service source changed,
                    // update the title and config options
                    this.setAppUrlTitle();
                }
            }, this);
        }
    },

    /**
     * @inheritdoc
     */
    render: function() {
        if (this.meta.config && !this.meta.customConfig) {
            // skip external-app's render and call View's render
            app.view.View.prototype.render.call(this);

            this.setAppUrlTitle();
        } else {
            if (this.allowApp) {
                // if the dashlet is allowed, go ahead and render
                this._super('render');
            } else {
                // else display error that the dashlet is not available
                this.displayError();
            }
        }
    },

    /**
     * Sets the Dashlet title when the URL changes or Dashlet config renders for the first time
     */
    setAppUrlTitle: function() {
        var url = this.settings.get('src');
        if (_.isArray(url)) {
            url = url[0];
        }

        if (url && (!this.currentService || this.currentService !== this.servicesObj[url])) {
            this.currentService = this.servicesObj[url];

            if (this.currentService) {
                // set the dashlet title
                this.settings.set({
                    label: this.currentService.name
                });

                this._render();
            }
        }
    },

    /**
     * @inheritdoc
     */
    loadData: function(callbacks) {
        if (!callbacks) {
            // on first load, no onComplete callback is used
            // so call parent loadData to continue operations
            this._super('loadData');
        } else if (!this.parcelApp) {
            // callbacks exists when user manually clicks "Refresh" button
            // if parcelApp doesn't exist for some reason, try to load it again
            this._onSugarAppLoad();
        } else if (callbacks && this.parcelApp) {
            // user has manually clicked Refresh on dashlet and the parcel
            // is already mounted, so unmount and remount
            this.parcelApp.unmount().then(function() {
                this.parcelApp.mount(this.parcelParams);
            }.bind(this));
        }

        if (callbacks && callbacks.complete) {
            // if complete() exists, call it
            callbacks.complete();
        }
    },

    /**
     * Returns the layout name from app.controller.context's layout
     *
     * @return {string}
     * @private
     */
    _getLayoutName: function() {
        var layoutName = app.controller.context.get('layout') === 'records' ? 'list' : 'record';

        return `${layoutName}-dashlet`;
    },

    /**
     * Checks the metadata for a given module, layout, and filename
     *
     * @private
     */
    _checkMeta: function() {
        // check to see if the MFE that was just added to metadata is this dashlet's src
        this.allowApp = this._checkCatalogAccess(this.options);
        if (this.allowApp) {
            if (this.dashletSetTimeout) {
                // stop the setTimeout if it exists
                clearTimeout(this.dashletSetTimeout);
                this.dashletSetTimeout = null;
            }
            // clear the element
            this.$el.empty();
            // load the src file from meta
            this._onSugarAppLoad();
            // rerender the dashlet
            this.render();
        }
    },

    /**
     * The MFE failed to load in time, remove Loading... and show the error
     * @private
     */
    _failedToLoadScript: function() {
        // remove the event listener waiting for MFE to load from endpoint
        // if it took too long, we dont want it
        app.events.off(`sugarApp:${this.module}:${this._getLayoutName()}:updated`, null, null);
        // hide the Loading... indicator
        this.$('.loading-label').addClass('hide');
        // show the error message
        this.$('.error-msg').removeClass('hide');
    },

    /**
     * Gets any available services that have been added to metadata
     *
     * @param options Init options
     * @return {Array} The array of components available to this view or an empty array
     * @private
     */
    _getAvailableServices: function(options) {
        var meta = app.metadata.getLayout(options.module, this._getLayoutName());

        return meta && meta.components ? meta.components : [];
    },

    /**
     * Checks metadata services to make sure Catalog sent over this service to be used
     *
     * @param options Init options
     * @return {boolean} True if the dashlet definition was found in services
     * @private
     */
    _checkCatalogAccess: function(options) {
        // update this.services with any of the latest metadata
        this.services = this._getAvailableServices(options);

        var dashletDef = _.find(this.services, function(svc) {
            // find the dashlet service with the same src
            return svc.view.src === options.meta.src;
        }, this);

        return !!dashletDef;
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.dashletSetTimeout) {
            // stop the setTimeout if it exists
            clearTimeout(this.dashletSetTimeout);
        }
        app.events.off(`sugarApp:${this.module}:${this._getLayoutName()}:updated`, null, null);

        this._super('_dispose');
    }
}) },
"tutorial": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TutorialView
 * @alias SUGAR.App.view.views.BaseTutorialView
 * @extends View.TutorialView
 */
({
	// Tutorial View (base) 

    /**
     * extendsFrom: This needs to be app.view.TutorialView since it's extending a Sidecar specific view class.  This is a
     * special case, as the normal method is for it to be a string.
     */
    extendsFrom: app.view.TutorialView,

    className: '', //override default class

    initialize: function(options) {
        this.resizeCallback = _.debounce(_.bind(function(){
            this.highlightItem(this.index);
        }, this), 400);
        $(window).on('resize', this.resizeCallback);
        this.keyupCallback = _.bind(this.processKeyCode, this);
        $(document).on('keyup', this.keyupCallback);
        app.view.TutorialView.prototype.initialize.call(this, options);
        app.events.on("cache:clean", function(callback) {
            callback(["tutorialPrefs"]);
        });
    },
    processKeyCode: function(e) {
        switch(e.which) {
            case 37: // left
                this.back(e);
                break;

            case 39: // right
            case 13: // Enter
                this.next(e);
                break;

            case 27: // exit
                this.hide(e);
                break;

            default: return; // exit this handler for other keys
        }
        e.preventDefault();
    },

    /**
     * removes the tour
     */
    remove: function() {
        $(window).off('resize', this.resizeCallback);
        $(document).off('keyup', this.keyupCallback);
        app.view.TutorialView.prototype.remove.call(this);
        var prefs = app.cache.get('tutorialPrefs') || {};
        if (prefs.showTooltip) {
            this.showTooltip();
            this.removeTooltip(3000);
        }
    },

    /**
     * shows tooltip on tour button
     */
    showTooltip: function() {
        $('[data-action=tour]')
            .tooltip({
                container: 'body',
                trigger: 'manual'
            })
            .tooltip('show');
    },

    /**
     * removes tooltip from tour button
     * @param {int} delayTime milliseconds.
     */
    removeTooltip: function(delayTime) {
        if (!delayTime) {
            $('[data-action=tour]').tooltip('hide');
        } else {
            _.delay(function() { $('[data-action=tour]').tooltip('hide'); }, delayTime);
        }
    }
}) },
"modal-confirm": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ModalConfirmView
 * @alias SUGAR.App.view.views.BaseModalConfirmView
 * @extends View.View
 */
({
	// Modal-confirm View (base) 

    events: {
        'click [name=close_button]' : 'close',
        'click [name=ok_button]' : 'ok'
    },
    initialize: function(options) {
        this.message = options.layout.confirmMessage;
        app.view.View.prototype.initialize.call(this, options);
    },
    close: function(evt) {
        this.layout.context.trigger("modal:close");
    },
    ok: function(evt) {
        this.layout.context.trigger("modal:callback");
    }
}) },
"consent-wizard-page": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ConsentWizardPageView
 * @alias SUGAR.App.view.views.BaseConsentWizardPageView
 * @extends View.Views.Base.WizardPageView
 */
({
	// Consent-wizard-page View (base) 

    extendsFrom: 'WizardPageView',

    events: {
        'click [name=continue_button]:not(.disabled)': 'continueConsent',
        'click [name=cancel_button]': 'cancelConsent'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.template = app.template.getView('consent-wizard-page');
        this._super('initialize', [options]);
        Handlebars.registerPartial('consent-wizard-page.header', app.template.get('consent-wizard-page.header'));
        this.href = 'https://www.sugarcrm.com/legal/privacy-policy/';
    },

    /**
     * Also set up event listener on the cookie_consent field to enable/disable the continue button
     * @private
     */
    _render: function() {
        this._super('_render');
        this._bindConsentField();
    },

    /**
     * Set up an event listener on the cookie_consent field to update the continue button
     * @private
     */
    _bindConsentField: function() {
        if (this._isBound) {
            return;
        }
        // this should be disabled by default
        this.getField('continue_button').setDisabled(true);
        this.model.on('change:cookie_consent',function() {
            this.getField('continue_button').setDisabled(!this.model.get('cookie_consent'));
        }, this);
        this._isBound = true;
    },

    /**
     * Event handler for clicking the continue button
     * Saves the user's cookie_consent
     */
    continueConsent: function() {
        var consent = this.model.get('cookie_consent');
        if (consent !== true) {
            return;
        }
        this.model.doValidate(this.fieldsToValidate,
            _.bind(function(isValid) {
                if (isValid) {
                    var payload = {cookie_consent: this.model.get('cookie_consent')};
                    app.alert.show('wizardprofile', {
                        level: 'process',
                        title: app.lang.get('LBL_LOADING'),
                        autoClose: false
                    });
                    app.user.updateProfile(payload, _.bind(function(err) {
                        app.alert.dismiss('wizardprofile');
                        if (!err) {
                            this.layout.finished();
                            app.router.navigate('#Home', {trigger: true});
                        }
                    }, this));
                }
            }, this)
        );
    },

    /**
     * Event handler for clicking the cancel button
     */
    cancelConsent: function() {
        app.router.logout();
    }
}) },
"hint-config-notifications-panel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HintConfigNotificationsPanelView
 * @alias SUGAR.App.view.views.BaseHintConfigPanelView
 * @extends View.Views.Base.ConfigPanelView
 */
({
	// Hint-config-notifications-panel View (base) 

    plugins: ['Stage2CssLoader'],

    extendsFrom: 'ConfigPanelView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        var url = app.api.buildURL('get/hint/configNotificationObject');
        app.api.call('read', url, null, {
            success: function(config) {
                // if no entry in table or the entry is set to disabled notifications
                if (_.isEmpty(config) || !config) {
                    $('#config_enable_hint_notifications').prop('checked',true);
                } else {
                    $('#config_disable_hint_notifications').prop('checked',true);
                }
            },
            error: function(err) {
                console.log('Error fetching configuration', err);
            }
        });

        this.name = app.lang.get('LBL_HINT_CONFIG_NOTIFICATIONS_HEADER');
        this.services = [
            {
                title: app.lang.get('LBL_HINT_CONFIG_ENABLE_NOTIFICATIONS'),
                name: 'config_hint_notifications',
                id: 'config_enable_hint_notifications',
                showWarning: false
            },
            {
                title: app.lang.get('LBL_HINT_CONFIG_DISABLE_NOTIFICATIONS'),
                name: 'config_hint_notifications',
                id: 'config_disable_hint_notifications',
                showWarning: false
            },
        ];
    },
}) },
"omnichannel-config": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The layout for the Omnichannel console.
 *
 * @class View.Layouts.Base.OmnichannelConfigView
 * @alias SUGAR.App.view.layouts.BaseOmnichannelConfigView
 * @extends View.View
 */
({
	// Omnichannel-config View (base) 

    className: 'omni-config',
}) },
"panel-top-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Header section for Subpanel layouts.
 *
 * @class View.Views.Base.PanelTopView
 * @alias SUGAR.App.view.views.BasePanelTopView
 * @extends View.View
 */
({
	// Panel-top-create View (base) 

    extendsFrom: 'PanelTopView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.context.set('collapsed', false);
    },

    /**
     * @inheritdoc
     *
     * Overrides the default related-record create to add the new item inline
     *
     * @override
     */
    createRelatedClicked: function(event) {},

    /**
     * @inheritdoc
     *
     * Overrides the parent togglePanel since we don't allow panel toggling in create
     *
     * @override
     */
    togglePanel: function() {}
}) },
"activity-timeline": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivityTimelineView
 * @alias SUGAR.App.view.views.BaseActivityTimelineView
 * @extends View.Views.Base.ActivityTimelineBaseView
 */
({
	// Activity-timeline View (base) 

    className: 'activity-timeline',

    extendsFrom: 'ActivityTimelineBaseView',

    plugins: ['EmailClientLaunch', 'LinkedModel', 'Dashlet'],

    /**
     * Rendered layout activities
     */
    additionalComponents: [],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.template = app.template.getView('activity-timeline-base');
        this.$el.addClass('dashlet-unordered-list');
        this.filter = {
            module: null
        };
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        this.context.on('filter:change:module', this.handleFilter, this);
    },

    /**
     * @inheritdoc
     *
     * Inject the singular module name.
     */
    _render: function() {
        this.disposeAdditionalComponents();

        this._super('_render');

        if (_.isFunction(this.layout.setTitle)) {
            var moduleSingular = app.lang.get(this.meta.label,
                this.module,
                {
                    moduleSingular: app.lang.getModuleName(this.module)
                }
            );
            this.layout.setTitle(moduleSingular);
        }

        this.initializeFilter();
    },

    /**
     * Create new filter layout and append it to the current view
     */
    initializeFilter: function() {
        var filter = app.view.createLayout({
            type: 'activity-filter',
            layout: this.layout,
            context: this.context,
        });

        filter.initComponents();
        filter.render();

        this.additionalComponents.push(filter);

        _.first(filter.$el).classList += ' bg-transparent';
        this.$('.activity-timeline-filter').append(filter.$el);
    },

    /**
     * Handle of filter change event
     *
     * @param {string} filterModule name of filtered module
     * @param {boolean} silent
     */
    handleFilter: function(filterModule, silent) {
        if (!silent || !this.filter.module) {
            var selectedModule = filterModule;
            if (selectedModule !== 'all_modules') {
                selectedModule = _.findKey(this.moduleLinkMapping, function(item) {
                    return item === selectedModule;
                });
            }

            var isModuleAvailable = app.metadata.getModule(selectedModule);
            this.filter.module = isModuleAvailable ? selectedModule : 'all_modules';
            this._setActivityModulesAndFields(this.baseModule);
            this.reloadData();
        }
    },

    /**
     * Must implement this method as a part of the contract with the Dashlet
     * plugin. Kicks off the various paths associated with a dashlet:
     * Configuration, preview, and display.
     *
     * @param {string} viewName The name of the view as defined by the `oninit`
     *   callback in {@link DashletView#onAttach}.
     */
    initDashlet: function(viewName) {
        this._mode = viewName;

        if (this._mode === 'config') {
            this.layout.before('dashletconfig:save', function() {
                // save the toolbar
                if (this.meta.custom_toolbar) {
                    this.settings.set('custom_toolbar', this.meta.custom_toolbar);
                }
            }, this);
        }
    },

    /**
     * @inheritdoc
     *
     * Get the activity-timeline dashlet metadata for the baseModule
     * @param {string} baseModule module name
     */
    getModulesMeta: function(baseModule) {
        return app.metadata.getView(baseModule, 'activity-timeline');
    },

    /**
     * Disposes additional components
     */
    disposeAdditionalComponents: function() {
        _.each(this.additionalComponents, function(component) {
            component.dispose();
        }, this);

        this.additionalComponents = [];
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.disposeAdditionalComponents();
        this._super('_dispose');
    }
}) },
"tabbed-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Tabbed dashlet is an abstraction that allows new tabbed dashlets to be
 * easily created based on a metadata driven configurable set of tabs, where
 * each new tab is created under a tabs array, where a specific set of
 * properties can be defined.
 *
 * Supported properties:
 *
 * - {Boolean} active If specific tab should be active by default.
 * - {String} filter_applied_to Date field to be used on date switcher, defaults
 *   to date_entered.
 * - {Array} filters Array of filters to be applied.
 * - {String} label Tab label.
 * - {Array} labels Array of labels (singular/plural) to be applied when
 *   LBL_MODULE_NAME_SINGULAR and LBL_MODULE_NAME aren't available or there's a
 *   need to use custom labels depending on the number of records available.
 * - {String} link Relationship link to be used if we're on a record view
 *   context, leading to only associated records being shown.
 * - {String} module Module from which the records are retrieved.
 * - {String} order_by Sort records by field.
 * - {String} record_date Date field to be used to print record date, defaults
 *   to 'date_entered' if none supplied.
 * - {Array} row_actions Row actions to be applied to each record.
 *
 * Example:
 * <pre><code>
 * // ...
 * 'tabs' => array(
 *     array(
 *         'filter_applied_to' => 'date_entered',
 *         'filters' => array(
 *             'type' => array('$equals' => 'out'),
 *         ),
 *         'labels' => array(
 *             'singular' => 'LBL_DASHLET_EMAIL_OUTBOUND_SINGULAR',
 *             'plural' => 'LBL_DASHLET_EMAIL_OUTBOUND_PLURAL',
 *         ),
 *         'link' => 'emails',
 *         'module' => 'Emails',
 *     ),
 *     //...
 * ),
 * //...
 * </code></pre>
 *
 * @class View.Views.Base.TabbedDashletView
 * @alias SUGAR.App.view.views.BaseTabbedDashletView
 * @extends View.View
 */
({
	// Tabbed-dashlet View (base) 

    plugins: ['Dashlet', 'RelativeTime', 'ToggleVisibility', 'Pagination'],

    events: {
        'click [data-action=show-more]': 'showMore',
        'click [data-action=tab-switcher]': 'tabSwitcher'
    },

    /**
     * Default settings used when none are provided via metadata.
     *
     * @template
     * @protected
     */
    _defaultSettings: {},

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        if (options.context) {
            if (options.context && options.context.parent && options.context.parent.get('layout') === 'omnichannel') {
                this.baseModule = options.context.parent.get('rowModel').get('_module');
                this.module = this.baseModule;
            } else {
                this.baseModule = options.context.get('module');
                this.module = this.baseModule;
            }
            this.baseRecord = this._getBaseModel(options);
        }

        this._super('initialize', [options]);
    },

    /**
     * Bind the separate context to avoid sharing context's handlers
     * between its extension dashlets.
     */
    initDashlet: function() {
        this._initSettings();
        if (this.meta.config) {
            return;
        }

        this.collection = app.data.createBeanCollection(this.module);
        this.context = this.context.getChildContext({
            forceNew: true,
            model: this.context.parent && this.context.parent.get('model'),
            collection: this.collection,
            //FIXME: name is temporary - special case for LinkedModel - SC-2550
            name: 'tabbed-dashlet',
            skipFetch: true
        });

        this.context.set('parentModule', this.module);

        this._initMaxHeightTarget();
        this._initEvents();
        this._initTabs();
        this._initTemplates();
    },

    /**
     * Initialize max height target element by overriding its value and
     * setting it to a specific tab inner element.
     *
     * @chainable
     * @template
     * @protected
     */
    _initMaxHeightTarget: function() {
        this.maxHeightTarget = this.meta.max_height_target || 'div.tab-content';

        return this;
    },

    /**
     * Initialize events.
     *
     * @chainable
     * @template
     * @protected
     */
    _initEvents: function() {
        this.settings.on('change:filter', this.loadData, this);
        this.on('tabbed-dashlet:unlink-record:fire', this.unlinkRecord, this);
        this.context.on('tabbed-dashlet:refresh', this.refreshTabsForModule, this);
        this.context.on('change:collection', this.onCollectionChange, this);

        return this;
    },

    /**
     * Initialize tabs.
     *
     * @chainable
     * @protected
     */
    _initTabs: function() {
        this.tabs = [];
        _.each(this.dashletConfig.tabs, function(tab, index) {
            if (tab.active) {
                this.settings.set('activeTab', index);
            }

            var collection = this._createCollection(tab);
            if (_.isNull(collection)) {
                return;
            }

            collection.on('add', this.bindCollectionAdd, this);
            collection.on('reset', this.bindCollectionReset, this);

            this.tabs[index] = tab;
            this.tabs[index].collection = collection;
            this.tabs[index].relate = _.isObject(collection.link);
            this.tabs[index].record_date = tab.record_date || 'date_entered';
            this.tabs[index].include_child_items = tab.include_child_items || false;
            this.tabs[index].tabFieldDefs = this._getTabFieldDefs(tab);
            this.tabs[index].row_actions = this._getTabRowActions(tab);
        }, this);

        return this;
    },

    /**
     * Gets the field defs for the fields defined on the given tab metadata
     *
     * @param {Object} tab the tab metadata
     * @return {Object} the field definitions for the fields on the tab
     * @private
     */
    _getTabFieldDefs: function(tab) {
        var moduleFields = app.metadata.getModule(tab.module, 'fields');
        var tabFieldDefs = {};
        _.each(tab.fields, function(field) {
            if (moduleFields[field]) {
                tabFieldDefs[field] = moduleFields[field];

                // For name fields, we want to set link to true so that we can
                // create a hyperlink and add the focus icon if available
                if (field === 'name') {
                    tabFieldDefs[field].link = true;
                }
            }
        }, this);
        return tabFieldDefs;
    },

    /**
     * Gets the row actions defined on the metadata for the tab. Filters out row
     * actions that are not valid for the given tab
     *
     * @param {Object} tab the tab metadata
     * @private
     */
    _getTabRowActions: function(tab) {
        return _.filter(tab.row_actions, function(rowAction) {
            // UI link/unlink actions are not supported for Emails
            if (_.contains(['link-action', 'unlink-action'], rowAction.type) &&
                _.contains(['Emails'], tab.module)) {
                return false;
            }
            return true;
        }, this);
    },

    /**
     * Initialize templates.
     *
     * This will get the templates from either the current module (since we
     * might want to customize it per module) or from core templates.
     *
     * Please define your templates on:
     *
     * - `custom/clients/{platform}/view/tabbed-dashlet/tabs.hbs`
     * - `custom/clients/{platform}/view/tabbed-dashlet/toolbar.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/tabbed-dashlet/tabs.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/tabbed-dashlet/toolbar.hbs`
     *
     * @chainable
     * @template
     * @protected
     */
    _initTemplates: function() {
        this._tabsTpl = app.template.getView(this.name + '.tabs', this.module) ||
            app.template.getView(this.name + '.tabs') ||
            app.template.getView('tabbed-dashlet.tabs', this.module) ||
            app.template.getView('tabbed-dashlet.tabs');

        this._toolbarTpl = app.template.getView(this.name + '.toolbar', this.module) ||
            app.template.getView(this.name + '.toolbar') ||
            app.template.getView('tabbed-dashlet.toolbar', this.module) ||
            app.template.getView('tabbed-dashlet.toolbar');

        return this;
    },

    /**
     * Sets up settings, starting with defaults.

     * @chainable
     * @protected
     */
    _initSettings: function() {
        var settings = _.extend({},
            this._defaultSettings,
            this.settings.attributes);

        this.settings.set(settings);

        return this;
    },

    /**
     * Get base model from parent context
     *
     * @param {Object} options
     * @return {Data.Bean} model the base model of the dashlet
     * @private
     */
    _getBaseModel: function(options) {
        var model;

        var currContext = options.context;
        while (currContext) {
            var contextModel = currContext.get('rowModel') || currContext.get('model');

            if (contextModel && contextModel.get('_module') === this.baseModule) {
                model = contextModel;

                var parentHasRowModel = currContext.parent && currContext.parent.has('rowModel');
                if (!parentHasRowModel) {
                    break;
                }
            }
            currContext = currContext.parent;
        }
        return model;
    },

    /**
     * Open create drawer to create new record.
     */
    openCreateDrawer: function(module, link) {
        var self = this;
        var link = link || this.context.get('link');
        var model = this.createLinkModel(this.baseRecord, link);

        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                module: module,
                model: model
            }
        }, function(context, model) {
            if (!model) {
                return;
            }
            self.trigger('linked-model:create', model);
        });
    },

    /**
     * New model related properties are injected into each model.
     * Update the record date associating by tab's record date value.
     *
     * @param {Data.Bean} model Appended new model.
     */
    bindCollectionAdd: function(model) {
        var tab = this._getTab(model.collection);
        model.set('record_date', model.get(tab.record_date));
    },

    /**
     * Bind event triggers for each updated models on collection reset.
     *
     * @param {Data.BeanCollection} collection Activated tab's collection.
     */
    bindCollectionReset: function(collection) {
        _.each(collection.models, this.bindCollectionAdd, this);
    },

    /**
     * Bind event listener for the updating collection count on the tab.
     */
    onCollectionChange: function() {
        var prevCollection = this.context.previous('collection');
        if (prevCollection) {
            prevCollection.off(null, this.updateCollectionCount, this);
        }
        this.collection = this.context.get('collection');
        this.collection.on('add remove reset', _.debounce(this.updateCollectionCount, 100), this);
    },

    /**
     * Update the collection's count on the active tab.
     */
    updateCollectionCount: function() {
        var tabIndex = this.settings.get('activeTab');
        var count = this.collection.length;

        if (this.collection.next_offset >= 0) {
            count += '+';
        }
        this.$('[data-action=tab-switcher][data-index=' + tabIndex + ']')
            .children('[data-action=count]')
            .text(count);
    },

    /**
     * Retrieve records template.
     *
     * This will get the template from either the active tab associated module,
     * from the current module (since we might want to customize it per module)
     * or from core templates.
     *
     * Please define your template on:
     *
     * - `custom/clients/{platform}/view/tabbed-dashlet/records.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/tabbed-dashlet/records.hbs`
     *
     * @param {String} module Module name.
     * @return {Function} Template function.
     * @protected
     */
    _getRecordsTemplate: function(module) {
        this._recordsTpl = this._recordsTpl || {};

        if (!this._recordsTpl[module]) {
            this._recordsTpl[module] = app.template.getView(this.name + '.records', module) ||
                app.template.getView(this.name + '.records', this.module) ||
                app.template.getView(this.name + '.records') ||
                app.template.getView('tabbed-dashlet.records', this.module) ||
                app.template.getView('tabbed-dashlet.records');
        }

        return this._recordsTpl[module];
    },

    /**
     * Create collection based on tab properties and current context,
     * furthermore if supplied tab has a valid 'link' property a related
     * collection will be created instead.
     *
     * @param {Object} tab Tab properties.
     * @return {Data.BeanCollection|null} A new instance of bean collection or `null`
     *   if we cannot access module metadata.
     * @protected
     */
    _createCollection: function(tab) {
        if (this.context.parent) {
            if (this.context.parent.parent) {
                var module = this.context.parent.parent.get('module');
            } else {
                var module = this.context.parent.get('module');
            }
        } else {
            var module = this.module;
        }

        var meta = app.metadata.getModule(module);
        if (_.isUndefined(meta)) {
            return null;
        }

        var options = {};
        if (meta.fields[tab.link] && meta.fields[tab.link].type === 'link') {
            options = {
                link: {
                    name: tab.link,
                    bean: this.model
                }
            };
        }

        var collection = app.data.createBeanCollection(tab.module, null, options);

        return collection;
    },

    /**
     * Retrieves collection options for a specific tab.
     *
     * @param {number} index Tab index.
     * @return {Object} Collection options.
     * @return {number} return.limit The number of records to retrieve.
     * @return {number} return.offset The offset for pagination.
     * @return {Object} return.params Additional parameters to the API call.
     * @return {Object|null} return.fields Specifies the fields on each
     * requested model.
     * @return {boolean|undefined} return.myItems Whether or not there is user
     * visibility when the module is not Meetings or Calls.
     * @protected
     */
    _getCollectionOptions: function(index) {
        var tab = this.tabs[index];
        var options = {
            limit: this.settings.get('limit'),
            offset: 0,
            params: {
                order_by: tab.order_by || null,
                include_child_items: tab.include_child_items || null
            },
            fields: tab.fields || null
        };

        if (tab.module != 'Meetings' && tab.module != 'Calls') {
            options.myItems = this.getVisibility() === 'user';
        }

        return options;
    },

    /**
     * Retrieves collection filters for a specific tab.
     *
     * @param {number} index Tab index.
     * @return {Array} Collection filters.
     * @protected
     */
    _getCollectionFilters: function(index) {
        var tab = this.tabs[index];
        var filters = [];

        _.each(tab.filters, function(condition, field) {
            var filter = {};
            filter[field] = condition;

            filters.push(filter);
        });

        if ((tab.module === 'Meetings' || tab.module === 'Calls')
            && this.getVisibility() === 'user') {
            filters.push({
                "$or":[{"assigned_user_id":app.user.id},
                       {"users.id":app.user.id}]
            });
        }

        return filters;
    },

    /**
     * Retrieves tab based on supplied collection.
     *
     * @param {Object} collection Collection of the desired tab.
     * @return {Object} Tab.
     * @private
     */
    _getTab: function(collection) {
        return _.find(this.tabs, function(tab) {
            return tab.collection === collection;
        }, this);
    },

    /**
     * Override this method to provide custom filters.
     *
     * @param {number} index Tab index.
     * @return {Array} Custom filters.
     * @template
     * @protected
     */
    _getFilters: function(index) {
        return [];
    },

    /**
     * Fetch data for view tabs based on selected options and filters.
     *
     * @param {Object} options Options that are passed to collection/model's
     *   fetch method.
     */
    loadData: function(options) {

        if (this.disposed || this.meta.config) {
            return;
        }
        this.loadDataForTabs(this.tabs, options);

    },

    /**
     * Refresh tabs for the given module
     * @param module {String} name of module needing refresh
     */
    refreshTabsForModule: function(module) {
        var toRefresh = [];
        _.each(this.tabs, function(tab) {
            if (tab.module === module) {
               toRefresh.push(tab);
            }
        });
        this.loadDataForTabs(toRefresh, {});
    },

    /**
     * Load data for passed set of tabs.
     * @param tabs {Array} Set of tabs to update.
     * @param options {Object} load options.
     */
    loadDataForTabs: function(tabs, options) {
        options = options || {};
        var self = this;
        var loadDataRequests = [];
        _.each(tabs, function(tab, index) {
            loadDataRequests.push(function(callback) {
                tab.collection.setOption(self._getCollectionOptions(index));

                tab.collection.filterDef = _.union(
                    self._getCollectionFilters(index),
                    self._getFilters(index)
                );
                if (self.context.parent && self.context.parent.parent &&
                    self.context.parent.parent.get('layout') === 'omnichannel' &&
                    tab.collection.link &&
                    self.context.parent.parent.get('rowModel')
                ) {
                    tab.collection.link.bean = self.context.parent.parent.get('rowModel');
                }
                tab.collection.fetch({
                    relate: tab.relate,
                    complete: function() {
                        tab.collection.dataFetched = true;
                        callback(null);
                    }
                });
            });
        }, this);
        if (!_.isEmpty(loadDataRequests)) {
            async.parallel(loadDataRequests, function() {
                if (self.disposed) {
                    return;
                }
                self.collection = self.tabs[self.settings.get('activeTab')].collection;
                self.context.set('collection', self.collection);

                self.render();

                if (_.isFunction(options.complete)) {
                    options.complete.call(self);
                }
            });
        }
    },

    /**
     * Convenience callback for updating this
     * and related dashlets once a model has been removed.
     * @return {Function} complete callback.
     * @private
     */
    _getRemoveModelCompleteCallback: function() {
        return _.bind(function(model) {
            if (this.disposed) {
                return;
            }
            this.collection.remove(model);
            this.render();
            this.context.trigger('tabbed-dashlet:refresh', model.module);
        }, this);
    },

    /**
     * Show more records for current collection.
     */
    showMore: function() {
        this.getNextPagination({
            showAlerts: true,
            limit: this.settings.get('limit')
        });
    },

    /**
     * Event handler for tab switcher.
     *
     * @param {Event} event Click event.
     */
    tabSwitcher: function(event) {
        var index = this.$(event.currentTarget).data('index');
        if (index === this.settings.get('activeTab')) {
            return;
        }

        this.settings.set('activeTab', index);
        this.collection = this.tabs[index].collection;
        this.context.set('collection', this.collection);
        this.render();
    },

    /**
     * Additional logic on switch visibility event.
     *
     * See {@link app.plugins.ToggleVisibility}.
     */
    visibilitySwitcher: function() {
        var activeVisibility;
        if (!this.isManager) {
            return;
        }
        activeVisibility = this.getVisibility();
        this.$el.find('[data-action=visibility-switcher]')
            .attr('aria-pressed', function() {
                return $(this).val() === activeVisibility;
            });
    },

    /**
     * Unlinks the selected record.
     *
     * Shows a confirmation alert and removes the model on confirm.
     *
     * @param {Data.Bean} model Selected model.
     */
    unlinkRecord: function(model) {
        var self = this;
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;
        app.alert.show(model.get('id') + ':unlink_confirmation', {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('NTC_UNLINK_CONFIRMATION_FORMATTED'), [context]),
            onConfirm: function() {
                model.destroy({
                    showAlerts: true,
                    relate: true,
                    success: self._getRemoveModelCompleteCallback()
                });
            }
        });
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        if (_.isEmpty(this.tabs)) {
            return;
        }

        var tab = this.tabs[this.settings.get('activeTab')];

        var recordsTpl = this._getRecordsTemplate(tab.module);

        this.toolbarHtml = this._toolbarTpl(this);
        this.tabsHtml = this._tabsTpl(this);

        // Get the HTML for the list of records in the tab. In order to build
        // certain fields correctly, make sure we use the right field defs for
        // the fields defined in the tabs
        this.tabFieldDefs = tab.tabFieldDefs;
        this.row_actions = tab.row_actions;
        this.recordsHtml = recordsTpl(this);

        this._super('_renderHtml');
    },

    /**
     *  Handle Avatar display, in case image doesn't exist.
     *
     *  FIXME: render avatar should happen when rendering each row, after pagination.(SC-2605)
     *  @private
     */
    _renderAvatars: function() {
        this.$('img.avatar')
            .on('load', function() {
                $(this).removeClass('hide');
            })
            .on('error', function() {
                $(this).parent().removeClass('avatar avatar-md')
                                .addClass('label label-module label-module-md label-Users');
                $(this).parent().find('span').removeClass('hide');
            });
        this.$('img.avatar').each(function() {
            var img = $(this);
            img.attr('src', img.data('src'));
        });
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        _.each(this.tabs, function(tab) {
            tab.collection.off(null, null, this);
        });

        this._super('_dispose');
    }
}) },
"audit": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.AuditView
 * @alias SUGAR.App.view.views.BaseAuditView
 * @extends View.Views.Base.FilteredListView
 */
({
	// Audit View (base) 

    extendsFrom: 'FilteredListView',

    fallbackFieldTemplate: 'list',

    /**
     * @inheritdoc
     * Assign base module and record id.
     * Override the new Audit collection
     * in order to fetch correct audit end-point.
     */
    initialize: function(options) {
        // in order to render the 'list' template on each field
        this.action = 'list';
        // populating metadata for audit module
        if (options.context.parent) {
            this.baseModule = options.context.parent.get('module');
            this.baseRecord = options.context.parent.get('modelId');
        }
        this._super('initialize', [options]);

       if (!this.collection) {
           this._initCollection();
       }
    },

    /**
     * Override the collection set up by new audit REST end-point.
     * @private
     */
    _initCollection: function() {
        var self = this;
        var AuditCollection = app.BeanCollection.extend({
            module: 'audit',
            baseModule: this.baseModule,
            baseRecordId: this.baseRecord,

            // FIXME PX-46: remove this function
            buildURL: function(params) {
                params = params || {};

                var parts = [],
                    url;
                parts.push(app.api.serverUrl);
                parts.push(this.baseModule);
                parts.push(this.baseRecordId);
                parts.push(this.module);
                url = parts.join('/');
                params = $.param(params);
                if (params.length > 0) {
                    url += '?' + params;
                }
                return url;
            },
            sync: function(method, model, options) {
                var auditedModel = self.context.get('model');
                var url = this.buildURL(options.params);
                var callbacks = app.data.getSyncCallbacks(method, model, options);
                var defaultSuccessCallback = app.data.getSyncSuccessCallback(method, model, options);
                callbacks.success = function(data, request) {
                    self._applyModelDataOnRecords(auditedModel, data.records);
                    return defaultSuccessCallback(data, request);
                };
                app.api.call(method, url, options.attributes, callbacks);
            }
        });
        this.collection = new AuditCollection();
    },

    /**
     * Filter the metadata in order to initiate the searchable fields.
     * @protected
     */
    _initFilter: function() {
        var filter = this._filter || _.chain(this.getFields())
            .filter(function(field) {
                return field.filter;
            })
            .map(function(field) {
                return {
                    name: field.name,
                    label: app.lang.get(field.label, this.module),
                    filter: field.filter,
                    type: field.type
                };
            }, this)
            .value();
        this.context.trigger('filteredlist:filter:set', _.pluck(filter, 'label'));

        if (_.isEmpty(filter)) {
            return;
        }
        this._filter = filter;
    },

    /**
     * Filtering collection that matches with search term.
     * In order to activate filtering on the field,
     * the filter term should be defined in the metadata.
     * There are three types of filter type (startsWith, contains, endsWith).
     */
    filterCollection: function() {
        var term = this.escapeRegExp(this.searchTerm);
        var filter = this._filter;
        var baseFields = this.model.fields;

        if (!_.isEmpty(term) && _.isString(term)) {
            this.filteredCollection = this.collection.filter(function(model) {
                return _.some(filter, function(params) {
                    var pattern = this._patternToReg[params.filter].replace('term', term);
                    var tester = new RegExp(pattern, 'i');
                    var fieldValue = '';
                    if (params.type === 'fieldtype') {
                        fieldValue = app.lang.get(baseFields[model.get(params.name)].vname, this.baseModule);
                    } else {
                        fieldValue = model.get(params.name);
                    }
                    if (_.isArray(fieldValue)) {
                        fieldValue = _.pluck(fieldValue, 'name').join(', ');
                    }
                    return tester.test(fieldValue);
                }, this);
            }, this);
        }
    },

    /**
     * Escape reserved chars of regular expression.
     *
     * @param {string} string Search term.
     */
    escapeRegExp: function(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
    },

    /**
     * Apply erased field information from the model to records.
     *
     * @private
     */
    _applyModelDataOnRecords: function(model, records) {
        var erasedFields = model.get('_erased_fields');
        _.each(erasedFields, function(erasedField) {
            // Apply erased fields only for records that are marked
            var erasedFieldName = erasedField.field_name || erasedField;

            var properties;
            var recordsRequiringErasedFields;
            if (erasedField.field_name) {
                // email and other non-scalar erased fields
                // check both the before and after fields
                // of each record to see if it matches up with
                // an erased email's ID, and if so mark that field as erased
                var fieldsToCheck = ['before', 'after'];
                _.each(fieldsToCheck, function(fieldToCheck) {
                    properties = {field_name: erasedFieldName};
                    properties[fieldToCheck] = erasedField.id;
                    recordsRequiringErasedFields = _.where(records, properties);
                    _.each(recordsRequiringErasedFields, function(record) {
                        record._erased_fields = record._erased_fields || [];
                        record._erased_fields.push(fieldToCheck);
                    });
                });
            } else {
                properties = {field_name: erasedFieldName};
                recordsRequiringErasedFields = _.where(records, properties);
                _.each(recordsRequiringErasedFields, function(record) {
                    record._erased_fields = ['before', 'after'];
                });
            }
        });
    },

    /**
     * @inheritdoc
     * Instead of fetching context, it fetches the collection directly.
     */
    loadData: function() {
        if (this.collection.dataFetched) {
            return;
        }
        this.collection.fetch();
    },

    /**
     * @inheritdoc
     *
     * Patch audit models `before` and `after` fields with information of
     * original field available within parent model, in order to render
     * properly.
     */
    _renderData: function() {
        var parentModule = this.context.parent.get('module');
        var fields = app.metadata.getModule(parentModule).fields;

        _.each(this.collection.models, function(model) {
            model.fields = app.utils.deepCopy(this.metaFields);

            var before = _.findWhere(model.fields, {name: 'before'});
            _.extend(before, fields[model.get('field_name')], {name: 'before'});

            var after = _.findWhere(model.fields, {name: 'after'});
            _.extend(after, fields[model.get('field_name')], {name: 'after'});

            // relate fields can be stored in the audit log as id, relate, or varchar.
            // Make sure they get rendered as relate.
            var baseField = fields[model.get('field_name')];
            if (baseField && _.contains(['id', 'relate'], baseField.type)) {
                before.type = 'relate';
                after.type = 'relate';
            }

            // FIXME: Temporary fix due to time constraints, proper fix will be addressed in TY-359
            // We can check just `before` since `before` and `after` refer to same field
            if (_.contains(['multienum', 'enum'], before['type']) && before['function']) {
                before['type'] = 'base';
                after['type'] = 'base';
            }

            // FIXME: This method should not be used as a public method (though
            // it's being used everywhere in the app) this should be reviewed
            // when SC-3607 gets in
            model.fields = app.metadata._patchFields(
                this.module,
                app.metadata.getModule(this.module),
                model.fields
            );
        }, this);

        this._super('_renderData');
    }
}) },
"omnichannel-search-results": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.OmnichannelSearchResultsView
 * @alias SUGAR.App.view.views.BaseOmnichannelSearchResultsView
 * @extends View.Views.Base.QuicksearchResultsView
 */
({
	// Omnichannel-search-results View (base) 

    extendsFrom: 'QuicksearchResultsView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // The mixed bean collection for executing cross-module searches
        this.collection = app.data.createMixedBeanCollection();

        // Set the number of maximum results to display. Defaults to 5, but can
        // be changed by adding a 'limit' property in the metadata
        this.limit = 5;
        if (this.meta && this.meta.limit) {
            this.limit = this.meta.limit;
        }
    },

    /**
     * Parses models when collection resets and renders the view.
     *
     * @override
     */
    bindDataChange: function() {
        // When signaled, perform a fetch
        this.layout.on('omnichannelsearch:quicksearch:fire', this.fireQuickSearch, this);

        // If the layout has `omnichannel:results:close` called on it, we
        // need to hide search backdrop
        this.layout.on('quicksearch:close omnichannel:close omnichannel:results:close', this.abortQuicksearch, this);

        // On a collection sync, format the search results and display
        this.collection.on('sync', this.displayResults, this);
    },

    /**
     * Aborts any collection fetch in progress and closes the quicksearch
     * results view
     */
    abortQuicksearch: function() {
        this.collection.abortFetchRequest();
        this.close();
        this.removeBackdrop();
    },

    /**
     * Formats and displays the current collection models
     */
    displayResults: function() {
        if (this.disposed) {
            return;
        }

        // Format the models to display correctly
        var gsUtils = app.utils.GlobalSearch;
        gsUtils.formatRecords(this.collection,false);

        _.each(this.collection.models, function(model) {
            model.viewAccess = app.acl.hasAccessToModel('view', model);

            var moduleMeta = this._fieldsMeta[model.module] ||
                gsUtils.getFieldsMeta(model.module, {linkablePrimary: false});
            this._fieldsMeta[model.module] = moduleMeta;
            model.primaryFields = gsUtils.highlightFields(model, moduleMeta.primaryFields);
            model.secondaryFields = gsUtils.highlightFields(model, {}, true);

            model.primaryFields = _.values(model.primaryFields);
            model.secondaryFields = _.values(model.secondaryFields).slice(0, 3);
        }, this);

        // Dynamically binds the click events
        this.$el.on('click', '.view-all-results', _.bind(this.viewAllResultsClicked, this));
        this.$el.on('click', '[data-action=rowClicked]', _.bind(this.rowClicked, this));

        // If the user has already closed the quicksearch results at this point,
        // do not reopen them
        if (this.isOpen()) {
            this._showQuickSearchPanel();
        }
    },

    /**
     * Fires a quicksearch using the current collection
     *
     * @param {Object} options the options to use for the collection fetch
     */
    fireQuickSearch: function(options) {
        if (_.isEmpty(options.query)) {
            return;
        }

        // Set the collection fetch limit option
        options = _.extend(options, {
            limit: this.limit
        });

        // Update the UI to show the search in progress
        this.collection.dataFetched = false;
        this.close();
        this.layout.expand();
        this._showQuickSearchPanel();

        this.collection.fetch(options);
    },

    /**
     * Opens and displays the quicksearch panel
     *
     * @private
     */
    _showQuickSearchPanel: function() {
        this.render();
        this.open();
        this.addBackdrop();
    },

    /**
     * Handler for row click event
     * Switches to relevant module tab
     *
     * @param {Event} evt row click event
     */
    rowClicked: function(evt) {
        var loadModel = [];
        var rowId = evt.currentTarget && $(evt.currentTarget).closest('li') ?
            $(evt.currentTarget).closest('li')[0].dataset.id : '';
        var collection = this.collection;
        var dashboard = this.closestComponent('omnichannel-dashboard') || {};
        if (!_.isEmpty(rowId) && collection) {
            loadModel = _.filter(collection.models, function(model) {
                if (model.id === rowId) {
                    return model;
                }
            }, this);
        }

        // set current row as model for the dashboard tab and switch tab based on module
        if (dashboard && loadModel.length !== 0) {
            app.alert.show('data-load', {
                level: 'process',
                title: app.lang.get('LBL_LOADING'),
            });
            loadModel[0].fetch({
                success: _.bind(function(model) {
                    app.alert.dismiss('data-load');
                    if (this.disposed) {
                        return;
                    }
                    dashboard.setModel(dashboard.moduleTabIndex[model.get('_module')], model);
                    dashboard.switchTab(dashboard.moduleTabIndex[model.get('_module')]);
                }, this)
            });
        }
    },

    /**
     * Show the quickresults dropdown
     */
    open: function() {
        this.$('.typeahead').show();
    },

    /**
     * Hide the quickresults dropdown
     */
    close: function() {
        this.collection.reset();
        this.$('.typeahead').hide();
        this.removeBackdrop();
        this.layout.trigger('omnichannel:modulelist:close');
    },

    /**
     * Adds the search result backdrop
     */
    addBackdrop: function() {
        $('.omnichannel-search-list').addClass('omnichannel-search-backdrop');
        $('.omnichannel-search-list').find('.omnibar-search').addClass('loading');
    },

    /**
     * Removes the search result backdrop
     */
    removeBackdrop: function() {
        $('.omnichannel-search-list').removeClass('omnichannel-search-backdrop');
        $('.omnichannel-search-list').find('.omnibar-search').removeClass('loading');
    },

    /**
     * Click event handler for the view all results link
     */
    viewAllResultsClicked: function() {
        // Close the quicksearch results panel and signal to the layout to
        // do a full search
        this.close();
        this.layout.trigger('omnichannelsearch:quicksearch:viewallresults');
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.$el.off('click');
        this.layout.off('omnichannelsearch:quicksearch:fire', this.fireQuickSearch, this);
        this.layout.off('omnichannel:close omnichannel:results:close', this.abortQuicksearch, this);
        this.collection.off('sync', this.displayResults, this);
        this._super('_dispose');
    }
}) },
"activity-card-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivityCardHeaderView
 * @alias SUGAR.App.view.views.BaseActivityCardHeaderView
 * @extends View.Views.Base.ActivityCardView
 */
({
	// Activity-card-header View (base) 

    extendsFrom: 'ActivityCardView',

    className: 'activity-card-header',

    /**
     * The panel_users panel metadata
     */
    usersPanel: null,

    /**
     * The panel_header panel metadata
     */
    headerPanel: null,

    /**
     * A list of user field definitions
     */
    userList: [],

    /**
     * Flag to store if the app is in RTL or not
     */
    isRtl: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.setUsersPanel();
        this.setHeaderPanel();

        this.isRtl = app.lang.direction === 'rtl';
    },

    /**
     * Set relevant metadata from the users panel
     */
    setUsersPanel: function() {
        this.setUsersTemplate();
        this.setUsersFields();
    },

    /**
     * Get and cache the users panel
     *
     * @return {Object}
     */
    getUsersPanel: function() {
        if (!this.usersPanel) {
            this.usersPanel = this.getMetaPanel('panel_users');
        }

        return this.usersPanel;
    },

    /**
     * Set the user template partial
     *
     * Defaults to 'user-single'
     */
    setUsersTemplate: function() {
        var panel = this.getUsersPanel();
        this.usersTemplate = panel && panel.template ? panel.template : 'user-single';
    },

    /**
     * Set user fields for hbs template
     */
    setUsersFields: function() {
        var panel = this.getUsersPanel();
        this.userField = _.find(panel.fields, function(field) {
            return field.name === 'created_by_name';
        });
        this.hasAvatarUser = !!this.userField;
    },

    /**
     * Set relevant metadata from the header panel
     *
     * The base card simply needs the panel itself
     */
    setHeaderPanel: function() {
        this.getHeaderPanel();
    },

    /**
     * Get and cache the header panel
     *
     * @return {Object}
     */
    getHeaderPanel: function() {
        if (!this.headerPanel) {
            this.headerPanel = this.getMetaPanel('panel_header');
        }

        return this.headerPanel;
    },

    /**
     * Get invitees user definitions
     */
    getInvitees: function() {
        var list = [];

        // if invitees is removed from preview/record layout, this will be empty
        var invitees = this.activity.get('invitees');

        if (invitees && invitees.models) {
            var panel = this.getUsersPanel();

            // as we are rendering each invitee avatar/name, we need the
            // singular name def from default fields metadata
            var def = _.find(panel.defaultFields, function(field) {
                return field.name === 'name';
            });

            if (!def) {
                return list;
            }

            _.each(invitees.models, _.bind(function(model) {
                var hasName = !!model.get('name');
                var userDef = {};

                if (hasName) {
                    userDef = {
                        userField: def,
                        userModel: model
                    };
                } else {
                    var email = model.get('email') ?
                        _.first(model.get('email')).email_address :
                        '';

                    if (email) {
                        userDef = {
                            userValue: email
                        };
                    }
                }

                if (userDef) {
                    list.push(userDef);
                }
            }, this));
        }

        return list;
    },

    /**
     * Determine if there are more invitees not fetched
     *
     * The activity model's invitees list is throttled by the max_num
     * system setting
     *
     * @return {boolean} true if there are more invitees, false otherwise
     */
    hasMoreInvitees: function() {
        var invitees = this.activity.get('invitees');
        var hasMore = false;

        if (invitees && invitees.offsets) {
            hasMore = _.some(invitees.offsets, function(offset) {
                return offset !== -1;
            });
        }

        return hasMore;
    },

    /**
     * Set invitees variables for hbs
     */
    setInvitees: function() {
        this.userList = this.getInvitees();
        this.hasMoreUsers = this.hasMoreInvitees();

        this.hasAvatarUser = !!this.userList;
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.userList.splice(0, this.userList.length);

        this._super('_dispose');
    }
}) },
"dashablelist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Dashablelist is a dashlet representation of a module list view. Users can
 * build dashlets of this type for any accessible and approved module with
 * their choice of columns from the list view for their chosen module.
 *
 * Options:
 * {String}  module             The module from which the records are
 *                              retrieved.
 * {String}  label              The string (i18n or hard-coded) representing
 *                              the dashlet name that the user sees.
 * {Array}   display_columns    The field names of the columns to include in
 *                              the list view.
 * {String}  filter_id          Filter to be applied, defaults to:
 *                              'assigned_to_me'.
 * {Integer} limit              The number of records to retrieve for the list
 *                              view.
 * {Integer} auto_refresh       How frequently (in minutes) that the dashlet
 *                              should refresh its data collection.
 *
 * Example:
 * <pre><code>
 * // ...
 * array(
 *     'module'          => 'Accounts',
 *     'label'           => 'LBL_MODULE_NAME',
 *     'display_columns' => array(
 *         'name',
 *         'phone_office',
 *         'billing_address_country',
 *     ),
 *     'filter_id'       => 'assigned_to_me',
 *     'limit'           => 15,
 *     'auto_refresh'    => 5,
 * ),
 * //...
 * </code></pre>
 *
 * Note that there are two concepts of "intelligence" for this dashlet.
 *
 * The intelligence property on the controller `this.intelligent` indicates
 * if the dashlet is allowed to link to a record.
 *
 * The intelligent setting retrieved by `this.settings.get('intelligent')` is
 * only relevant if the intelligence property `this.intelligent` is true. This
 * setting indicates if the dashlet is actively linking to a record.
 *
 * @class View.Views.Base.DashablelistView
 * @alias SUGAR.App.view.views.BaseDashablelistView
 * @extends View.Views.Base.ListView
 */
({
	// Dashablelist View (base) 

    extendsFrom: 'ListView',

    dataView: '',

    /**
     * The plugins used by this view.
     */
    plugins: ['Dashlet', 'Pagination', 'ConfigDrivenList'],

    /**
     * We want to load field `list` templates
     */
    fallbackFieldTemplate: 'list',

    /**
     * The default settings for a list view dashlet.
     *
     * @property {Object}
     */
    _defaultSettings: {
        limit: 5,
        freeze_first_column: true,
        filter_id: 'assigned_to_me',
        intelligent: '0'
    },

    /**
     * Modules that are permanently blacklisted so users cannot configure a
     * dashlet for these modules.
     *
     * @property {Array}
     */
    moduleBlacklist: [
        'Home',
        'Forecasts',
        'ProductCategories',
        'ProductTemplates',
        'ProductTypes',
        'UserSignatures',
        'OutboundEmail',
        'Administration'
    ],

    /**
     * Module Additions
     *
     * When a specific module is allowed, we should add these other modules that are
     * not first class modules.
     *
     * @property {Array}
     */
    additionalModules: {
        'Project': ['ProjectTask']
    },

    /**
     * Cache of the modules a user is allowed to see.
     *
     * The keys are the module names and the values are the module names after
     * resolving them against module and/or app strings. The cache logic can be
     * seen in {@link BaseDashablelistView#_getAvailableModules}.
     *
     * @property {Object}
     */
    _availableModules: {},

    /**
     * Cache of the fields found in each module's list view definition.
     *
     * This hash is multi-dimensional. The first set of keys are the module
     * names and the values are objects where the keys are the field names and
     * the values are the field names after resolving them against module
     * and/or app strings. The cache logic can be seen in
     * {@link BaseDashablelistView#_getAvailableColumns}.
     *
     * @property {Object}
     */
    _availableColumns: {},

    /**
     * Flag indicates if dashlet is intelligent.
     *
     * If the dashlet is intelligent, it can be linked to a record on the main
     * context, e.g. on the Record View.
     */
    intelligent: null,

    /**
     * Flag indicates if a module is available for display.
     */
    moduleIsAvailable: true,

    /**
     * Flag indicates if dashlet filter is accessible.
     */
    filterIsAccessible: true,

    /**
     * Defines the scroll container jQuery element
     */
    scrollContainer: null,

    /**
     * @inheritdoc
     *
     * Append lastStateID on metadata in order to active user cache.
     */
    initialize: function(options) {
        options.meta = _.extend({}, options.meta, {
            last_state: {
                id: 'dashable-list'
            }
        });
        this.checkIntelligence();
        this._super('initialize', [options]);
        this._noAccessTemplate = app.template.get(this.name + '.noaccess');

        this.context.set('isUsingListPagination', true);

        this.scrollContainer = this.$el;
    },

    /**
     * Prevent shortcuts from dashablelist overriding the shortcuts set by the main view
     * @override
     */
    registerShortcuts: _.noop,

    /**
     * Check if dashlet can be intelligent.
     *
     * A dashlet is considered intelligent when the data relates to the current
     * record.
     *
     * @return {String} Whether or not the dashlet can be intelligent.
     */
    checkIntelligence: function() {
        var isIntelligent = app.controller.context.get('layout') === 'record' &&
            !_.contains(this.moduleBlacklist, app.controller.context.get('module'));
        this.intelligent = isIntelligent ? '1' : '0';
        return this.intelligent;
    },

    /**
     * Show/hide `linked_fields` field.
     *
     * @param {String} visible '1' to show the field, '0' to hide it.
     * @param {String} [intelligent='1'] Whether the dashlet is in intelligent
     *   mode or not.
     */
    setLinkedFieldVisibility: function(visible, intelligent) {
        var field = this.getField('linked_fields');
        if (!field) {
            return;
        }
        intelligent = (intelligent === false || intelligent === '0') ? '0' : '1';
        var fieldEl = this.$('[data-name=linked_fields]');
        if (visible === '1' && intelligent === '1' && !_.isEmpty(field.items)) {
            fieldEl.show();
        } else {
            fieldEl.hide();
        }
    },

    /**
     * In case the filter for the dashlet has been retrieved successfully
     * a filter definition based dashlet setup will be triggered.
     *
     *  @param {Object} data object from specified filter request.
     */
    triggerDashletSetup: function(data) {
        this.filterIsAccessible = true;
        this._displayDashlet(data.filter_definition);
    },

    /**
     * Must implement this method as a part of the contract with the Dashlet
     * plugin. Kicks off the various paths associated with a dashlet:
     * Configuration, preview, and display.
     *
     * @param {String} view The name of the view as defined by the `oninit`
     *   callback in {@link DashletView#onAttach}.
     */
    initDashlet: function(view) {
        if (this.meta.config) {
            // keep the display_columns and label fields in sync with the selected module when configuring a dashlet
            this.settings.on('change:module', function(model, moduleName) {
                var label = (model.get('filter_id') === 'assigned_to_me') ? 'TPL_DASHLET_MY_MODULE' : 'LBL_MODULE_NAME';
                model.set('label', app.lang.get(label, moduleName, {
                    module: app.lang.getModuleName(moduleName, {plural: true})
                }));

                // Re-initialize the filterpanel with the new module.
                this.dashModel.set('module', moduleName);
                this.dashModel.set('filter_id', 'assigned_to_me');
                this.layout.trigger('dashlet:filter:reinitialize');

                this._updateDisplayColumns();
                this._hideUnselectedColumns();
                this.updateLinkedFields(moduleName);
            }, this);
            this.settings.on('change:intelligent', function(model, intelligent) {
                this.setLinkedFieldVisibility('1', intelligent);
            }, this);
            this.on('render', function() {
                var isVisible = !_.isEmpty(this.settings.get('linked_fields')) ? '1' : '0';
                this.setLinkedFieldVisibility(isVisible, this.settings.get('intelligent'));
            }, this);
        }
        this._initializeSettings();
        this.metaFields = this._getColumnsForDisplay();

        if (this.settings.get('intelligent') == '1') {

            var link = this.settings.get('linked_fields');
            var model = app.controller.context.get('model');
            var module = this.settings.get('module');
            var options = {
                link: {
                    name: link,
                    bean: model
                }
            };
            this.collection = app.data.createBeanCollection(module, null, options);
            this.collection.setOption('relate', true);
            this.context.set('collection', this.collection);
            this.context.set('link', link);
        } else {
            this.context.unset('link');
        }

        this.before('render', function() {
            if (!this.moduleIsAvailable) {
                this.$el.html(this._noAccessTemplate());
                return false;
            }
            if (!this.filterIsAccessible) {
                this._displayNoFilterAccess();
                return false;
            }
        });

        // the pivot point for the various dashlet paths
        if (this.meta.config) {
            this._configureDashlet();
            this.listenTo(this.layout, 'init', this._addFilterComponent);
            this.listenTo(this.layout.context, 'filter:add', this.updateDashletFilterAndSave);
            this.layout.before('dashletconfig:save', function() {
                this.saveDashletFilter();
                // NOTE: This prevents the drawer from closing prematurely.
                return false;
            }, this);

        } else if (this.moduleIsAvailable) {
            var filterId = this.settings.get('filter_id');
            if (!filterId || this.meta.preview) {
                this._displayDashlet();
                return;
            }

            var filters = app.data.createBeanCollection('Filters');
            filters.setModuleName(this.settings.get('module'));
            filters.load({
                success: _.bind(function() {
                    if (this.disposed) {
                        return;
                    }
                    var filter = filters.collection.get(filterId);
                    var filterDef = filter && filter.get('filter_definition');
                    // In case the filter assigned to the list-dashlet is NOT in the filters collection,
                    // as collection only contains certain number (= max_filters) of entries.
                    // Will make a separate api call to fetch the specified filter data.
                    if (!filterDef) {
                        var url = app.api.buildURL('Filters/' + filterId, null, null);
                        app.api.call('read', url, null, {
                            success: _.bind(this.triggerDashletSetup, this),
                            error: _.bind(this._displayNoFilterAccess, this)
                        });
                    } else if (_.isUndefined(filterDef)) {
                        this.filterIsAccessible = false;
                        this._displayNoFilterAccess();
                    } else {
                        this._displayDashlet(filterDef);
                    }
                }, this),
                error: _.bind(function() {
                    if (this.disposed) {
                        return;
                    }
                    this._displayDashlet();
                }, this)
            });
        }
    },

    /**
     * Display a message when dashlet filter is not accessible.
     */
    _displayNoFilterAccess: function() {
        var template = app.template.get(this.name + '.nofilteraccess');
        var noFilterAccessSupportUrl = null;
        if (!_.isUndefined(app.help) && _.isFunction(app.help.getMoreInfoHelpURL)) {
            noFilterAccessSupportUrl = app.help.getMoreInfoHelpURL('nofilter', 'listviewdashlet');
        }
        this.$el.html(template({noFilterAccessSupportUrl: noFilterAccessSupportUrl}));
        var listBottom = this.layout.getComponent('list-bottom');
        if (listBottom) {
            listBottom.hide();
        }
    },

    /**
     * @inheritdoc
     * Don't load data if dashlet filter is not accessible.
     */
    loadData: function(options) {
        if (!this.filterIsAccessible) {
            if (options && _.isFunction(options.complete)) {
                options.complete();
            }
            return;
        }
        this._super('loadData', [options]);
    },

    /**
     * Fetch the next pagination records.
     */
    showMoreRecords: function() {
        // Show alerts for this request
        this.getNextPagination();
    },

    /**
     * Returns a custom label for this dashlet.
     *
     * @return {string}
     */
    getLabel: function() {
        var module = this.settings.get('module') || this.context.get('module');
        var moduleName = app.lang.getModuleName(module, {plural: true});
        return app.lang.get(this.settings.get('label'), module, {module: moduleName});
    },

    /**
     * This function is invoked by the `dashletconfig:save` event. If the dashlet
     * we are saving is a dashable list, it initiates the save process for a new
     * filter on the appropriate module's list view, otherwise, it takes the
     * `currentFilterId` stored on the context, and saves it on the dashlet.
     *
     * @param {Bean} model The dashlet model.
     */
    saveDashletFilter: function() {
        // Accessing the dashableconfiguration context.
        var context = this.layout.context;

        if (context.editingFilter) {
            // We are editing/creating a new filter
            if (!context.editingFilter.get('name')) {
                context.editingFilter.set('name', app.lang.get('LBL_DASHLET') +
                    ': ' + app.lang.get(this.settings.get('label'), this.settings.get('module')));
            }
            // Triggers the save on `filter-rows` which then triggers
            // `filter:add` which then calls `updateDashletFilterAndSave`
            context.trigger('filter:create:save');
        } else {
            // We are saving a dashlet with a predefined filter
            var filterId = context.get('currentFilterId');
            var obj = {id: filterId};
            this.updateDashletFilterAndSave(obj);
        }
    },

    /**
     * This function is invoked by the `filter:add` event. It saves the
     * filter ID on the dashlet model prior to saving it, for later reference.
     *
     * @param {Bean} filterModel The saved filter model.
     */
    updateDashletFilterAndSave: function(filterModel) {
        // We need to save the filter ID on the dashlet model before saving
        // the dashlet.
        var id = filterModel.id || filterModel.get('id');
        this.settings.set('filter_id', id);
        this.dashModel.set('filter_id', id);

        var componentType = this.dashModel.get('componentType') || 'view';

        // Adding a new dashlet requires componentType to be set on the model.
        if (!this.dashModel.get('componentType')) {
            this.dashModel.set('componentType', componentType);
        }

        app.drawer.close(this.dashModel);
        // The filter collection is not shared amongst views and therefore
        // changes to this collection on different contexts (list views and
        // dashlets) need to be kept in sync.
        app.events.trigger('dashlet:filter:save', this.dashModel.get('module'));
    },

    /**
     * Certain dashlet settings can be defaulted.
     *
     * Builds the available module cache by way of the
     * {@link BaseDashablelistView#_setDefaultModule} call. The module is set
     * after "filter_id" because the value of "filter_id" could impact the value
     * of "label" when the label is set in response to the module change while
     * in configuration mode (see the "module:change" listener in
     * {@link BaseDashablelistView#initDashlet}).
     *
     * @private
     */
    _initializeSettings: function() {
        if (this.intelligent === '0') {
            _.each(this.dashletConfig.panels, function(panel) {
                panel.fields = panel.fields.filter(function(el) {return el.name !== 'intelligent';});
            }, this);
            this.settings.set('intelligent', '0');
            this.dashModel.set('intelligent', '0');
        } else {
            if (_.isUndefined(this.settings.get('intelligent'))) {
                this.settings.set('intelligent', this._defaultSettings.intelligent);
            }
        }
        this.setLinkedFieldVisibility('1', this.settings.get('intelligent'));
        if (!this.settings.get('limit')) {
            this.settings.set('limit', this._defaultSettings.limit);
        }
        if (!this.settings.get('filter_id')) {
            this.settings.set('filter_id', this._defaultSettings.filter_id);
        }
        if (_.isUndefined(this.settings.get('freeze_first_column'))) {
            this.settings.set('freeze_first_column', this._defaultSettings.freeze_first_column);
        }
        this._setDefaultModule();
        if (!this.settings.get('label')) {
            this.settings.set('label', 'LBL_MODULE_NAME');
        }
    },

    /**
     * Sets the default module when a module isn't defined in the dashlet's
     * view definition.
     *
     * If the module was defined but it is not in the list of available modules
     * in config mode, then the view's module will be used.
     * @private
     */
    _setDefaultModule: function() {
        var availableModules = _.keys(this._getAvailableModules());
        var module = this.settings.get('module') || this.context.get('module');

        if (_.contains(availableModules, module)) {
            this.settings.set('module', module);
        } else if (this.meta.config) {
            module = this.context.parent.get('module');
            if (_.contains(this.moduleBlacklist, module)) {
                module = _.first(availableModules);
                // On 'initialize' model is set to context's model - that model can have no access at all
                // and we'll result in 'no-access' template after render. So we change it to default model.
                this.model = app.data.createBean(module);
            }
            this.settings.set('module', module);
        } else {
            this.moduleIsAvailable = false;
        }
    },

    /**
     * When creating a dashlet by default all columns available will be shown.
     * By a flag set in metadata (selected) some column can be rendered hidden
     * and optionally selectable. Display only columns that are not excluded from
     * the initial list of columns. Changes made by the users should not be overwritten.
     */
    _hideUnselectedColumns: function() {
        var module = this.settings.get('module');
        var columns = this.settings.get('display_columns');
        _.each(this.getFieldMetaForView(this._getListMeta(module)), function(fieldDef) {
            if (_.contains(columns, fieldDef.name) && fieldDef.selected === false) {
                columns = _.without(columns, fieldDef.name);
            }
        });
        this.settings.set('display_columns', columns);
    },

    /**
     * Update the display_columns attribute based on the current module defined
     * in settings.
     *
     * This will mark, as selected, all fields in the module's list view
     * definition. Any existing options will be replaced with the new options
     * if the "display_columns" DOM field ({@link EnumField}) exists.
     *
     * @private
     */
    _updateDisplayColumns: function() {
        var availableColumns = this._getAvailableColumns();
        var columnsFieldName = 'display_columns';
        var columnsField = this.getField(columnsFieldName);
        if (columnsField) {
            columnsField.items = availableColumns;
        }
        this.settings.set(columnsFieldName, _.keys(availableColumns));
    },

    /**
     * Update options for `linked_fields` based on current selected module.
     * If there are no options field is hidden.
     *
     * @param {String} moduleName Name of selected module.
     */
    updateLinkedFields: function(moduleName) {
        var linked = this.getLinkedFields(moduleName);
        var displayColumn = this.getField('linked_fields');
        var intelligent = this.dashModel.get('intelligent');
        if (displayColumn) {
            displayColumn.items = linked;
            this.setLinkedFieldVisibility('1', intelligent);
        } else {
            this.setLinkedFieldVisibility('0', intelligent);
        }
        this.settings.set('linked_fields', _.keys(linked)[0]);
    },

    /**
     * Returns object with linked fields.
     *
     * @param {String} moduleName Name of module to find linked fields with.
     * @return {Object} Hash with linked fields labels.
     */
    getLinkedFields: function(moduleName) {
        var fieldDefs = app.metadata.getModule(this.layout.module).fields;
        var relates = _.filter(fieldDefs, function(field) {
            if (!_.isUndefined(field.type) && (field.type === 'link')) {
                if (app.data.getRelatedModule(this.layout.module, field.name) === moduleName) {
                    return true;
                }
            }
            return false;
        }, this);
        var result = {};
        _.each(relates, function(field) {
            result[field.name] = app.lang.get(field.vname || field.name, [this.layout.module, moduleName]);
        }, this);
        return result;
    },

    /**
     * Gets the fields metadata from a particular view's metadata.
     *
     * @param {Object} meta The view's metadata.
     * @return {Object[]} The fields metadata or an empty array.
     */
    getFieldMetaForView: function(meta) {
        meta = _.isObject(meta) ? meta : {};
        return !_.isUndefined(meta.panels) ? _.flatten(_.pluck(meta.panels, 'fields')) : [];
    },

    /**
     * @inheritdoc
     */
    getRowDomForModelId: function(id) {
        return this.$(`tr[data-id="${id}"]`);
    },

    /**
     * @inheritdoc
     */
    makeRowVisible: function($selected) {
        if (!$selected) {
            this.$el.scrollTop();
            return;
        }

        let rowTop = $selected.position().top;
        let rowHeight = $selected.height();
        let rowBottom = rowTop + rowHeight;
        let dashletTop = this.$el.scrollTop();
        let dashletHeight = this.$el.height();
        let dashletBottom = dashletTop + dashletHeight;

        if (rowBottom >= dashletBottom || rowTop <= dashletTop) {
            this.$el.scrollTop(rowTop);
        }
    },

    /**
     * ListView sort will close previews, but this is not needed for dashablelists
     * In fact, closing preview causes problem when previewing this list dashlet
     * from dashlet-select
     */
    sort: $.noop,

    /**
     * Perform any necessary setup before the user can configure the dashlet.
     *
     * Modifies the dashlet configuration panel metadata to allow it to be
     * dynamically primed prior to rendering.
     *
     * @private
     */
    _configureDashlet: function() {
        var availableModules = this._getAvailableModules();
        var availableColumns = this._getAvailableColumns();
        var relates = this.getLinkedFields(this.module);
        _.each(this.getFieldMetaForView(this.meta), function(field) {
            switch (field.name) {
                case 'module':
                    // load the list of available modules into the metadata
                    field.options = availableModules;
                    break;
                case 'display_columns':
                    // load the list of available columns into the metadata
                    field.options = availableColumns;
                    break;
                case 'linked_fields':
                    field.options = relates;
                    break;
            }
        });

        // From ConfigDrivenList Plugin
        this.filterConfigFieldsForDashlet();
    },

    /**
     * This function adds the `dashablelist-filter` component to the layout
     * (dashletconfiguration), if the component doesn't already exist.
     */
    _addFilterComponent: function() {
        var filterComponent = this.layout.getComponent('dashablelist-filter');
        if (filterComponent) {
            return;
        }

        this.layout.initComponents([{
            layout: 'dashablelist-filter'
        }]);
    },

    /**
     * This function get Displayed Portal Modules
     *
     * @private
     */
    _portalModulesDelimitation: function() {
        var url = app.api.buildURL('Administration/portalmodules');
        app.api.call('read', url, null, {
            success: _.bind(function(data) {
                app.metadata.portalModules = _.difference(data, this.moduleBlacklist);
            }, this)
        });
    },

    /**
     * Gets all of the modules the current user can see.
     *
     * This is used for populating the module select and list view columns
     * fields. Filters any modules that are blacklisted.
     *
     * @return {Object} {@link BaseDashablelistView#_availableModules}
     * @private
     */
    _getAvailableModules: function() {
        if (_.isEmpty(this._availableModules) || !_.isObject(this._availableModules)) {
            this._availableModules = {};
            var visibleModules = app.metadata.getModuleNames({filter: 'visible', access: 'read'});
            var allowedModules = _.difference(visibleModules, this.moduleBlacklist);

            var contextModule = app.controller.context.get('module');
            var contextLayout = app.controller.context.get('layout');
            if (contextModule == 'Administration' && contextLayout == 'portaltheme-config') {
                this._portalModulesDelimitation();
                if (app.metadata.portalModules) {
                    allowedModules = _.intersection(allowedModules, app.metadata.portalModules);
                }
            }

            _.each(this.additionalModules, function(extraModules, module) {
                if (_.contains(allowedModules, module)) {
                    allowedModules = _.sortBy(_.union(allowedModules, extraModules), function(name) {return name;});
                }
            });
            _.each(allowedModules, function(module) {
                var hasListView = !_.isEmpty(this.getFieldMetaForView(app.metadata.getView(module, 'list')));
                if (hasListView) {
                    this._availableModules[module] = app.lang.getModuleName(module, {plural: true});
                }
            }, this);
        }
        return this._availableModules;
    },

    /**
     * Gets the correct list view metadata.
     *
     * Returns the correct module list metadata
     *
     * @param  {String} module
     * @return {Object}
     */
    _getListMeta: function(module) {
        return app.metadata.getView(module, 'list');
    },

    /**
     * Gets all of the fields from the list view metadata for the currently
     * chosen module.
     *
     * This is used for the populating the list view columns field and
     * displaying the list.
     *
     * @return {Object} {@link BaseDashablelistView#_availableColumns}
     * @private
     */
    _getAvailableColumns: function() {
        var columns = {};
        var module = this.settings.get('module');
        if (!module) {
            return columns;
        }

        _.each(this.getFieldMetaForView(this._getListMeta(module)), function(field) {
            columns[field.name] = app.lang.get(field.label || field.name, module);
        });

        return columns;
    },

    /**
     * Perform any necessary setup before displaying the dashlet.
     *
     * @param {Array} [filterDef] The filter definition array.
     * @private
     */
    _displayDashlet: function(filterDef) {
        // Get the columns that are to be displayed and update the panel metadata.
        var columns = this._getColumnsForDisplay();
        this.meta.panels = [{fields: columns}];

        this.context.set('skipFetch', false);
        this.context.set('limit', this.settings.get('limit'));
        this.context.set('fields', this.getFieldNames());

        if (filterDef) {
            this._applyFilterDef(filterDef);
            this.context.reloadData({
                recursive: false,
                error: _.bind(this._displayNoFilterAccess, this)
            });
        } else {
            var listBottom = this.layout.getComponent('list-bottom');
            if (listBottom) {
                listBottom.render();
            }
        }
        this._startAutoRefresh();
    },

    /**
     * Sets the filter definition on the context collection to retrieve records
     * for the list view.
     *
     * @param {Array} filterDef The filter definition array.
     * @private
     */
    _applyFilterDef: function(filterDef) {
        if (filterDef) {

            filterDef = _.isArray(filterDef) ? filterDef : [filterDef];
            /**
             * Filter fields that don't exist either on vardefs or search definition.
             *
             * Special fields (fields that start with `$`) like `$favorite` aren't
             * cleared.
             *
             * TODO move this to a plugin method when refactoring the code (see SC-2555)
             * TODO we should support cleanup on all levels (currently made on 1st
             * level only).
             */
            var specialField = /^\$/;
            var meta = app.metadata.getModule(this.module);
            filterDef = _.filter(filterDef, function(def) {
                var fieldName = _.keys(def).pop();
                return specialField.test(fieldName) || meta.fields[fieldName];
            }, this);

            this.context.get('collection').filterDef = filterDef;
        }
    },

    /**
     * Gets the columns chosen for display for this dashlet list.
     *
     * The display_columns setting might not have been defined when the dashlet
     * is being displayed from a metadata definition, like is the case for
     * preview and the default dashablelist's that are defined. All columns for
     * the selected module are shown in these cases.
     *
     * @return {Object[]} Array of objects defining the field metadata for
     *   each column.
     * @private
     */
    _getColumnsForDisplay: function() {
        var columns = [];
        var fields = this.getFieldMetaForView(this._getListMeta(this.settings.get('module')));
        var moduleMeta = app.metadata.getModule(this.module);
        if (!this.settings.get('display_columns')) {
            this._updateDisplayColumns();
            this._hideUnselectedColumns();
        }
        if (!this.settings.get('linked_fields')) {
            this.updateLinkedFields(this.model.module);
        }
        _.each(this.settings.get('display_columns'), function(name) {
            var field = _.find(fields, function(field) {
                return field.name === name;
            }, this);
            // If we don't have metadata for a field, skip it to avoid
            // adding an empty column to the dashlet
            if (_.isUndefined(field)) {
                return;
            }
            // It's possible that a column is on the dashlet and not on the
            // main list view (thus was never patched by metadata-manager).
            // We need to fix up the columns in that case.
            // FIXME: This method should not be used as a public method (though
            // it's being used everywhere in the app) this should be reviewed
            // when SC-3607 gets in.
            field = field || app.metadata._patchFields(this.module, moduleMeta, [name]);

            // Handle setting of the sortable flag on the list. This will not
            // always be true
            var sortableFlag;
            var fieldDef = app.metadata.getModule(this.module).fields[field.name];

            // If the module's field def says nothing about the sortability, then
            // assume it's ok to sort
            if (_.isUndefined(fieldDef) || _.isUndefined(fieldDef.sortable)) {
                sortableFlag = true;
            } else {
                // Get what the field def says it is supposed to do
                sortableFlag = !!fieldDef.sortable;
            }

            var column = _.extend({sortable: sortableFlag}, field);

            columns.push(column);
        }, this);
        return columns;
    },

    /**
     * Starts the automatic refresh of the dashlet.
     *
     * @private
     */
    _startAutoRefresh: function() {
        var refreshRate = parseInt(this.settings.get('auto_refresh'), 10);
        if (refreshRate) {
            this._stopAutoRefresh();
            this._timerId = setInterval(_.bind(function() {
                this.context.resetLoadFlag();
                this.layout.loadData();
            }, this), refreshRate * 1000 * 60);
        }
    },

    /**
     * Cancels the automatic refresh of the dashlet.
     *
     * @private
     */
    _stopAutoRefresh: function() {
        if (this._timerId) {
            clearInterval(this._timerId);
        }
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        if (!this.meta || !this.meta.config) {
            return this._super('_render');
        }

        this.action = 'list';
        return this._super('_render');
    },

    /**
     * @inheritdoc
     *
     * Calls {@link BaseDashablelistView#_stopAutoRefresh} so that the refresh will
     * not continue after the view is disposed.
     *
     * @private
     */
    _dispose: function() {
        this._stopAutoRefresh();
        this._super('_dispose');
    }
}) },
"cabmenu": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This view is created from the old activity-card-menu, which now extends this view to add
 * customizations specific to timeline. Since its implemented as a view, it can be added
 * to a layout's metadata file or in a view's controller dynamically, eg:
 *
 *      var cm = app.view.createView({
	// Cabmenu View (base) 

 *          type: 'cabmenu',
 *          context: this.context,
 *          layout: this.layout,
 *          model: this.model,
 *          cab_menu: [
 *              {
 *                  type: 'focuscab',
 *                  css_class: 'dashboard-icon',
 *                  icon: 'sicon-focus-drawer',
 *                  tooltip: 'LBL_FOCUS_DRAWER_DASHBOARD'
 *              },
 *              {
 *                  type: 'cab_actiondropdown',
 *                  buttons: [
 *                      {
 *                          type: 'unlinkcab',
 *                          icon: 'sicon-unlink',
 *                          label: 'LBL_UNLINK_BUTTON'
 *                      },
 *                  ],
 *              },
 *          ],
 *      });
 *      cm.render();
 *      this.$el.append(cm.$el);
 *
 * The menu items can be dashletaction, cab, or other button/field types.
 * @class View.Views.Base.CabmenuView
 * @alias SUGAR.App.view.views.BaseCabmenuView
 * @extends View.Views.Base.View
 */
({
    className: 'cabmenu',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.initCabMenu();
    },

    /**
     * Initialize variables for menu generation
     */
    initCabMenu: function() {
        this.cabMenu = this.getCabMeta();

        var cabDropdown = _.find(this.cabMenu, function(menuItem) {
            return menuItem.type === 'cab_actiondropdown';
        });
        this.cabButtons = cabDropdown ? cabDropdown.buttons : null;
    },

    /**
     * Return metadata
     *
     * @return {Array}
     */
    getCabMeta: function() {
        return this.options.cab_menu || [];
    }
}) },
"omnichannel-detail": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The call/chat detail panel.
 *
 * @class View.Layouts.Base.OmnichannelDetailView
 * @alias SUGAR.App.view.layouts.BaseOmnichannelDetailView
 * @extends View.View
 */
({
	// Omnichannel-detail View (base) 

    className: 'omni-detail',

    events: {
        'click [data-action=show-tab]': 'showTab',
    },

    /**
     * Sugar Models related to active calls or chats stored by aws Contact Id
     * e.g.
     * {
     *     'aws-contact-id-1': {
     *         'Cases': { Case Bean }
     *         'Contacts': { Contact Bean }
     *     },
     *     'aws-contact-id-2': {
     *         'Cases': { Case Bean 2 }
     *         'Contacts': { Contact Bean 2 }
     *     },
     *     ...
     * }
     * @property {Object}
     */
    modelsByContactId: {},

    /**
     * Fields to be displayed in omnichannel detail panel.
     * @property [Array]
     */
    summaryFields: [
        {
            name: 'invitees',
            type: 'guest',
            links: [
                'contacts',
                'leads',
                'users',
            ],
            label: 'LBL_INVITEES',
        },
        {
            name: 'parent_name',
            type: 'parent',
            label: 'LBL_LIST_RELATED_TO',
        },
    ],

    /**
     * A list of modules whose records can be set as "Guests" on a Call
     */
    guestModuleLinks: {
        Contacts: 'contacts',
        Leads: 'leads',
        Users: 'users'
    },

    /**
     * Current AWS connect contact id.
     * @property {string}
     */
    currentContactId: null,

    /**
     * Current module for the contact
     * @property {string}
     */
    currentContactModule: 'Calls',

    /**
     * Editable information from the summary panel.
     * @property {Object}
     */
    summary: {},

    /**
     * Title of the detail block.
     * @property {string}
     */
    summaryTitle: null,

    /**
     * Boolean if fields in the detail summary view are enabled or not
     */
    areFieldsEnabled: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.model = app.data.createBean();
        this._super('initialize', [options]);

        this.updateMetadata();
        this.currentContactId = null;
        this.context.set('model', this.model);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.layout.on('contact:view', this.showContact, this);
        this.layout.on('contact:destroyed', this.removeContact, this);
        this.layout.on('contact:model:loaded', this._setInitialSummary, this);
        this.layout.on('contact:records:matched', this._handleContactRecordsMatched, this);
        this.layout.on('omniconfig:reopen', this._updateAndRender, this);
        this.layout.on('omniconsole:record-link:clicked', this._recordLinkButtonClicked, this);
        this.layout.on('omniconsole:activeCall', this._toggleEnabledFields, this);
        this.on('render', this._resizeCCP, this);
    },

    /**
     * @inheritdoc
     */
    render: function() {
        this._super('render');

        this._toggleEnabledFields(this.layout.isCallActive);
    },

    /**
     * Toggles fields to enabled or disabled/readonly mode
     *
     * @param {boolean} enableFields True if enable fields, false if disable
     */
    _toggleEnabledFields: function(enableFields) {
        // if fields are already enabled, dont enable again and cause an extra render
        if (this.areFieldsEnabled === enableFields) {
            return;
        }

        this.areFieldsEnabled = enableFields;
        if (!this.areFieldsEnabled) {
            // clear out the summary panel model when disabling fields
            this.model.clear({
                silent: true
            });
        }

        // enable/disable all fields in the summary panel
        _.each(this.fields, field => {
            field.setMode(enableFields ? 'edit' : 'disabled');
        }, this);
    },

    /**
     * Handles when records are matched to an AWS contact
     *
     * @param {Object} contact connect-streams Contact object
     * @param {Array} records the array of matched records
     * @param {Object} context the context in which the records were matched
     * @private
     */
    _handleContactRecordsMatched: function(contact, records, context) {
        // Set the Guest link from the record match results
        var guest = this._determineGuestFromMatch(contact, records, context);
        if (!_.isEmpty(guest)) {
            this.setModel(contact, guest);
        }

        // Set the Related To link from the record match results
        var relatedTo = this._determineRelatedToFromMatch(contact, records, context);
        if (!_.isEmpty(relatedTo)) {
            this.setModel(contact, relatedTo);
        }
    },

    /**
     * Determines what link to make for the "Guest" when records are matched
     * to an AWS contact
     *
     * @param {Object} contact connect-streams Contact object
     * @param {Array} records the array of matched records
     * @param {Object} context the context in which the records were matched
     * @return {Bean|null} the Guest model to link if found; null otherwise
     * @private
     */
    _determineGuestFromMatch(contact, records, context) {
        var guest = null;

        if (contact.isInbound()) {
            // If we have a sugarContactId, link its Contact
            guest = context && context.sugarContactId && _.find(records, function(record) {
                return record.module === 'Contacts' && record.get('id') === context.sugarContactId;
            }, this);
        } else {
            // Use the record the user dialed
            if (context && context.dialedRecord) {
                var module = context.dialedRecord.module || context.dialedRecord.get('_module');
                var id = context.dialedRecord.get('id');
                guest = _.find(records, function(record) {
                    return record.get('id') === id && record.module === module;
                }, this);
            }
        }

        // Only link the record as Guest if it is a valid Guest module
        guest = this._isValidGuest(guest) ? guest : null;

        return guest;
    },

    /**
     * Determines what link to make for the "Related To" field when records are
     * matched to an AWS contact
     *
     * @param {Object} contact connect-streams Contact object
     * @param {Array} records the array of matched records
     * @param {Object} context the context in which the records were matched
     * @return {Bean|null} the Related To model to link if found; null otherwise
     * @private
     */
    _determineRelatedToFromMatch(contact, records, context) {
        var relatedTo = null;

        if (contact.isInbound()) {
            // If we have a sugarCaseNumber, link its Case
            relatedTo = context && context.sugarCaseNumber && _.find(records, function(record) {
                return record.module === 'Cases' && record.get('case_number') === context.sugarCaseNumber;
            }, this);
        } else {
            // If the user dialed a Guest record, or there was no dialed record,
            // use the focused record. Otherwise, use the dialed record
            relatedTo = context && context.dialedRecord && !this._isValidGuest(context.dialedRecord) ?
                context.dialedRecord : context.focusedRecord;
        }

        // Only link the record as Related To if it is explicitly a valid
        // Related To module
        relatedTo = this._isValidRelatedTo(contact, relatedTo) && !this._isValidGuest(relatedTo) ? relatedTo : null;

        return relatedTo;
    },

    /**
     * Handles when an Omnichannel link button is clicked on a record view or record view dashlet
     *
     * @param {Bean} model the model of the record
     * @private
     */
    _recordLinkButtonClicked: function(model) {
        // Link the model to the Call or Message
        this.setModel(null, model);
    },

    /**
     * Link a record to the Call/Message details
     * @param contact
     * @param model
     */
    _linkRecord: function(contact, model) {
        contact = contact || this._getActiveContact();
        if (!_.isEmpty(contact) && this._canLinkRecord(contact, model)) {
            this._updateContactModelValuesFromModel(contact, model);
            this._setModelByContactId(contact, model);
            this._notifyContactChanged(contact);
        }
    },

    /**
     * set or remove appropriate record to the contactID inorder to keep the link record icon updated
     * @private
     */
    _guestFieldChanged: function() {
        var model = _.first(this.model.get('invitees').models);
        var contact = this._getActiveContact();
        if (model) {
            this._setModelByContactId(null, model);
        } else {
            this._removePreviousLinkedGuest();
        }
        this._notifyContactChanged(contact);
    },

    /**
     * Determines whether the given model is linkable to the Call/Message
     *
     * @param contact current contact
     * @param model the model to check
     * @return {bool} true if the model is linkable; false otherwise
     * @private
     */
    _canLinkRecord: function(contact, model) {
        return this._isValidGuest(model) || this._isValidRelatedTo(contact, model);
    },

    /**
     * Retrieves the active AWS contact from the Amazon CCP
     *
     * @return {Object} the active contact's connect-streams Contact object
     * @private
     */
    _getActiveContact: function() {
        var ccp = this.layout.getComponent('omnichannel-ccp');
        return ccp.getActiveContact();
    },

    /**
     * Retrieves the Call or Message model created for an AWS contact
     *
     * @param {Object} contact connect-streams Contact object
     * @return {Bean|null} the Call or Message model, or null if the contact
     *                      doesn't have one
     * @private
     */
    _getModelForContact: function(contact) {
        var contactModel = null;

        if (!_.isEmpty(contact)) {
            var ccp = this.layout.getComponent('omnichannel-ccp');
            contactModel = ccp.connectionRecords[contact.getContactId()] || null;
        }

        return contactModel;
    },

    /**
     * Links the given model to the Call/Message that is associated with the
     * given AWS contact
     *
     * @param {Object} contact connect-streams Contact object
     * @param {Bean} model the model to link to the contact's Call/Message
     * @private
     */
    _updateContactModelValuesFromModel: function(contact, model) {
        // Set either the "Guests" or "Relates To" values.
        if (this._isValidGuest(model)) {
            guestField = this.getField('invitees');
            if (guestField) {
                guestField.setValue(model.attributes);
            }
        } else if (this._isValidRelatedTo(contact, model)) {
            this._removePreviousLinkedRelatedRecord(contact);
            this._setRelatedToFieldFromModel(contact, model);
        }
    },

    /**
     * Updates modelsByContactId with the given model for the given AWS contact
     *
     * @param {Object} contact connect-streams Contact object
     * @param {Bean} model the model to set
     * @private
     */
    _setModelByContactId: function(contact, model) {
        let awsId = this._getContactId(contact);
        let module = !_.isEmpty(model) ? model.module || model.get('_module') : null;
        if (_.isUndefined(this.modelsByContactId[awsId])) {
            this.modelsByContactId[awsId] = {};
        }
        this.modelsByContactId[awsId][module] = model;
    },

    /**
     * Notifies the layout that the contact's Call/Message record has changed
     *
     * @param {Object} contact connect-streams Contact object
     * @private
     */
    _notifyContactChanged: function(contact) {
        var contactModel = this._getModelForContact(contact);
        app.events.trigger('omniconsole:contact:changed', contact, contactModel);
    },

    /**
     * Returns whether a contact is a call or chat session
     *
     * @param {Object} contact (optional) the AWS contact; if not provided, uses
     *                  the current active contact
     * @return {boolean} true if the contact is a call or chat
     * @private
     */
    _isCall(contact) {
        var ccp = this.layout.getComponent('omnichannel-ccp');
        contact = contact || ccp.getActiveContact();
        return ccp.isCall(contact);
    },

    /**
     * Returns whether the given model is a valid one to link via "Guests"
     *
     * @param model
     * @return {bool} true if the model can be linked as a "Guest"
     * @private
     */
    _isValidGuest(model) {
        if (_.isEmpty(model)) {
            return false;
        }
        var module = model.module || model.get('_module');
        return _.contains(_.keys(this.guestModuleLinks), module);
    },

    /**
     * Returns whether the given model is a valid one to link via "Related To"
     *
     * @param contact
     * @param model
     * @return {boolean} true if the model can be linked as a "Related To"
     * @private
     */
    _isValidRelatedTo(contact, model) {
        if (_.isEmpty(model)) {
            return false;
        }
        var modelModule = model.module || model.get('_module');

        let contactModuleMetadata = app.metadata.getModule(this._getModuleForContact(contact));
        let linkableModules = app.lang.getAppListKeys(contactModuleMetadata.fields.parent_name.options);
        return linkableModules.includes(modelModule);
    },

    /**
     * Gets the module used for the given contact
     * @param contact
     * @return {string}
     * @private
     */
    _getModuleForContact: function(contact) {
        return contact.getType() === 'voice' ? 'Calls' : 'Messages';
    },

    /**
     * Sets the "Guests" field of this model to add the given model
     *
     * @param contact
     * @param {Bean} model the model of the Contact or Lead record to set
     * @private
     */
    _setGuestFieldFromModel: function(contact, model) {
        var contactModel = this._getModelForContact(contact);
        if (!_.isEmpty(model) && !_.isEmpty(contactModel)) {
            var module = model.module || model.get('_module');
            var link = this._getGuestModuleLink(module);

            // Set the model to add to the guests
            var guestCollectionUpdate = {
                add: [model.attributes]
            };

            // Set the model to update the guest collection on the next save
            contactModel.set(link, guestCollectionUpdate);
        }
    },

    /**
     * Removes the previously linked guest, checking all guest links
     * @private
     */
    _removePreviousLinkedGuest: function() {
        let awsId = this._getContactId();
        let self = this;
        _.each(_.keys(this.guestModuleLinks), function(guestModule) {
            if (!self.modelsByContactId[awsId][guestModule]) {
                return;
            }
            delete self.modelsByContactId[awsId][guestModule];
        });
    },

    /**
     * Remove the previously linked related record from the stored models
     * @param contact
     * @private
     */
    _removePreviousLinkedRelatedRecord: function(contact) {
        var contactModel = this._getModelForContact(contact);
        let awsId = this._getContactId(contact);
        if (!this.modelsByContactId || !this.modelsByContactId[awsId] || !contactModel ||
            _.isEmpty(contactModel.get('parent_id'))) {
            return;
        }

        let parentModule = contactModel.get('parent_type');
        delete this.modelsByContactId[awsId][parentModule];
    },

    /**
     * Gets the name for the guest link for the given module
     * @param module
     * @return link
     * @private
     */
    _getGuestModuleLink: function(module) {
        let link = this.guestModuleLinks[module];

        // Message links are not named the same as Call links
        if (!this._isCall()) {
            link = 'invitee_' + link;
        }

        return link;
    },

    /**
     * Sets the "Related To" of this model to point to the given model
     *
     * @param {Bean} model the model of the "Related To" record to set
     * @private
     */
    _setRelatedToFieldFromModel: function(contact, model) {
        var contactModel = this._getModelForContact(contact);
        if (!_.isEmpty(model) && !_.isEmpty(contactModel)) {
            contactModel.set({
                parent_type: model.module || model.get('_module'),
                parent_id: model.get('id'),
                parent: model,
                parent_name: model.get('name')
            });
        }
    },

    /**
     * Show tab in active dashboard matching record user clicks in
     * omnichannel detail panel
     * @param {Event} event click event
     */
    showTab: function(event) {
        var module = event.target.getAttribute('data-module');
        var model = this.getModel(null, module);
        var dashboardSwitch = this.layout.getComponent('omnichannel-dashboard-switch');
        dashboardSwitch.setModel(this.currentContactId, model);
    },

    /**
     * Set title of the detail panel.
     * @param {Object} contact AWS contact
     */
    setSummaryTitle: function(contact) {
        var isChat = contact.getType() === connect.ContactType.CHAT;
        var lbl = isChat ? 'LBL_OMNICHANNEL_CHAT_SUMMARY' : 'LBL_OMNICHANNEL_CALL_SUMMARY';
        this.summaryTitle = app.lang.get(lbl, this.module);
    },

    /**
     * Set data of the active contact to model.
     * @param {Object} contact AWS contact
     */
    setSummary: function(contact) {
        this.setSummaryTitle(contact);
        var ccp = this.layout.getComponent('omnichannel-ccp');
        var model = ccp.connectionRecords[contact.getContactId()];
        if (model) {
            this.model = model;
        } else {
            if (this._isCall()) {
                this.model = app.data.createBean('Calls');
            } else {
                this.model = app.data.createBean('Messages');
            }
        }
    },

    /**
     * Save the summary data.
     */
    saveSummary: function() {
        var ccp = this.layout.getComponent('omnichannel-ccp');
        ccp._updateConnectionRecord(ccp.activeContact, {});
    },

    /**
     * Set the initial summary after the contact's Call/Message model is created
     *
     * @param {Object} contact connect-streams Contact object
     * @private
     */
    _setInitialSummary: function(contact) {
        var ccp = this.layout.getComponent('omnichannel-ccp');
        var model = ccp.connectionRecords[contact.getContactId()];

        if (model) {
            this.updateMetadata(contact);
            this.model = model;
            this.model.on('change', this.saveSummary, this);
            this.model.on('change:invitees', this._guestFieldChanged, this);
            this.model.on('change:parent_id', () => {
                this._notifyContactChanged(this._getActiveContact());
            }, this);
            this.render();
            this._resizeCCP();
        }
    },

    /**
     * Show/hide the detail panel
     *
     * @deprecated Since 11.1, this is no longer used
     */
    toggle: function() {
        this.$el.toggle();
    },

    /**
     * Show contact and case records for a different AWS contact.
     * @param {Object} contact AWS contact
     */
    showContact: function(contact) {
        if (!_.isEmpty(contact)) {
            this.updateMetadata(contact);
            this.setSummary(contact);
        }

        var contactId = this._getContactId(contact);

        this.currentContactId = contactId;
        this.render();
        this._resizeCCP();
    },

    /**
     * Remove linked records for an AWS contact.
     * @param {string} contactId The id of a contact.
     */
    removeContact: function(contactId) {
        this.modelsByContactId = _.omit(this.modelsByContactId, contactId);
    },

    /**
     * Set contact model.
     * @param {Object} contact AWS contact
     * @param {Bean} contactModel Sugar contact
     * @deprecated Since 11.1, use setModel() instead
     */
    setContactModel: function(contact, contactModel) {
        this.setModel(contact, contactModel);
    },

    /**
     * Set case model.
     * @param {Object} contact AWS contact
     * @param {Bean} caseModel Sugar case
     * @deprecated Since 11.1, use setModel() instead
     */
    setCaseModel: function(contact, caseModel) {
        this.setModel(contact, caseModel);
    },

    /**
     * Set a related model for display in the omnichannnel detail panel
     * @param {Object} contact connect-streams Contact object
     * @param {Bean} model the related model to set
     */
    setModel: function(contact, model) {
        contact = contact || this._getActiveContact();
        this._linkRecord(contact, model);
        if (this._getContactId(contact) === this.currentContactId) {
            this.showContact(contact);
        }
    },

    /**
     * Get all linked models for a given contact
     *
     * @param {Object} contact AWS contact
     * @return {Object} The set of models for the given contact
     */
    getModels: function(contact) {
        var contactId = this._getContactId(contact);
        return this.modelsByContactId[contactId] || {};
    },

    /**
     * Get the linked model for a given module for a given contact
     * @param {Object} contact AWS contact
     * @param {string} module module of model to return
     * @return {Bean|undefined} The model if it exists; undefined otherwise
     */
    getModel: function(contact, module) {
        return this.getModels(contact)[module];
    },

    /**
     * Util to get the ID of a connect-streams contact. If given an empty value,
     * return the ID of the currently active contact.
     *
     * @param {Object|null} contact AWS-streams contact
     * @return {string} ID of provided or current contact
     * @private
     */
    _getContactId: function(contact) {
        return !_.isEmpty(contact) ? contact.getContactId() : this.currentContactId;
    },

    /**
     * Get contact model.
     * @param {Object} contact AWS contact
     * @return {Bean} contactModel Sugar contact
     * @deprecated Since 11.1, use getModel() instead
     */
    getContactModel: function(contact) {
        return this.getModel(contact, 'Contacts');
    },

    /**
     * Get case model.
     * @param {Object} contact AWS contact
     * @return {Bean} caseModel Sugar case
     * @deprecated Since 11.1, use getModel() instead
     */
    getCaseModel: function(contact) {
        return this.getModel(contact, 'Cases');
    },

    /**
     * Updates view metadata to use appropriate module-specific custom metadata.
     * This is called when setting initial summary, and when viewing a new
     * contact.
     *
     * @param {Object} contact AWS Contact
     */
    updateMetadata: function(contact) {
        var ccp = this.layout.getComponent('omnichannel-ccp');
        if (!_.isUndefined(ccp) && !_.isUndefined(contact)) {
            this.currentContactModule = ccp.contactTypeModule[contact.getType()];
        }
        this.meta = app.metadata.getView(this.currentContactModule, this.name);
        this.model.module = this.currentContactModule;
    },

    /**
     * Private util function to update metadata and rerender the view.
     * @private
     */
    _updateAndRender: function() {
        this.updateMetadata();
        this.render();
    },

    /**
     * Resizes CCP after re-render as our height might have changed.
     * @private
     */
    _resizeCCP: function() {
        var ccp = this.layout.getComponent('omnichannel-ccp');
        ccp.resize();
    },

    _dispose: function() {
        this.layout.off('contact:view', this.showContact, this);
        this.layout.off('contact:destroyed', this.removeContact, this);
        this.layout.off('contact:model:loaded', this._setInitialSummary, this);
        this.layout.off('omniconfig:reopen', this._updateAndRender, this);
        this.off('render', this._resizeCCP, this);
        this._super('_dispose');
    }
}) },
"stage2-related-contacts": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Stage2-related-contacts View (base) 

    plugins: ['EllipsisInline', 'Stage2CssLoader', 'EmailClientLaunch'],

    events: {
        'click [data-action="show_more"]': 'showMore',
    },
    _contactsLimit: 3,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var self = this;
        options.context.set('forceNew', true);
        options.context.set('skipFetch', true);
        this._super('initialize', [options]);
        this._setRequestLoading(true);
        this.isDarkMode = app.hint.isDarkMode();
        app.api.call('GET', app.api.buildURL('stage2/params'), null, {
            success: function(data) {
                self.sugarVersion = data.sugarVersion;
                self._stage2url = data.enrichmentServiceUrl;
            },
            error: function(err) {
                app.logger.error('Failed to get Hint params: ' + JSON.stringify(err));
            }
        });
        this.on('changed:isHintRequestLoading', this.render, this);
        this.context.parent.on('change:model', function(ctx, model) {
            self._setRequestLoading(true);
            this._getContacts(model);
        }, this);

        this._getContacts(this.context.parent.get('model'));
    },

    /**
     * Set request loading
     *
     * @param {boolean} value
     */
    _setRequestLoading: function(value) {
        this.isHintRequestLoading = value;
        this.trigger('changed:isHintRequestLoading');
    },

    /**
     * Get contacts
     *
     * @param {Object} model
     */
    _getContacts: function(model) {
        var accountBean;
        var self = this;
        self._parentModule = model.module;
        self._parentId = model.id;
        self._currentModel = model;
        var accountBean = app.data.createBean('Accounts', {
            id: self._parentId
        });
        accountBean.fetch({
            success: function(accountBean) {
                self.collection = app.data.createRelatedCollection(accountBean || self._currentModel, 'contacts');

                self.collection.fetch({
                    relate: true,
                    success: function(data) {
                        if (!self.disposed) {
                            self._showMore = self.collection.models.length > 3 ? true : false;
                            self._setRequestLoading(false);
                        }
                    },
                    error: _.bind(function() {
                        app.logger.error('Failed to fetch relatedCollection for accountBean: ' + JSON.stringify(err));
                        self._setRequestLoading(false);
                    }, this),
                    complete: null,
                    limit: -1,
                });
            },
            error: function() {
                app.logger.error('Failed to fetch accountBean: ' + JSON.stringify(err));
            }
        });
    },

    /**
     * Show more
     *
     * @param {Object} e
     */
    showMore: function(e) {
        var self = this;
        var _parentModel = self.context.parent.get('model');
        var filters = [{
            'account_name': {
                '$in': [_parentModel.get('name')]
            }
        },];

        self._relatedContacts = app.data.createBeanCollection('Contacts');
        var request = self._relatedContacts.fetch({
            'filter': filters
        });

        request.xhr.success(function(data) {
            app.drawer.open({
                layout: 'selection-list',
                context: {
                    module: 'Contacts',
                    model: self._relatedContacts.models[0],
                    collection: self._relatedContacts,
                    filterOptions: {
                        auto_apply: false
                    },
                }
            },
                function(model) {
                    if (!model) {
                        return;
                    }
                    if (model.id) {
                        app.router.redirect('#Contacts/' + model.id);
                    }
                });
        });
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this._super('_dispose');
    },

    /**
     * Retrieve email options from link
     *
     * @param {jQuery} $el
     */
    _retrieveEmailOptionsFromLink: function($el) {
        var email = $el.data('email-to');
        var model = _.find(this.collection.models, function(model) {
            if (_.indexOf(_.pluck(model.get('email'), 'email_address'), email) >= 0) {
                return model;
            }
        }, this);
        if (this.sugarVersion) {
            if (this.sugarVersion.match(/^7\.([89])(\.[\d]+)?(\.[\d]+)?$/)) {
                return {
                    to_addresses: [{
                        email: email,
                        bean: model
                    }]
                };
            } else {
                return {
                    to: [{
                        bean: model
                    }],
                    related: model
                };
            }
        }
    },

    /**
     * @inheritdoc
     */
    _render: function(options) {
        this._super('_render', [options]);
        if (this.collection.models) {
            _.each(this.collection.models, function(model) {
                var id = model.get('id');
                var _erasedFields = model.get('_erased_fields');
                // NOTE: email isn't here because we don't show the Value Erased message for emails currently.
                if (_.contains(_erasedFields, 'title')) {
                    this.$('#' + id).find('.title_erased').removeClass('hidden');
                }
                if (_.contains(_erasedFields, 'phone_mobile')) {
                    this.$('#' + id).find('.phone_erased').removeClass('hidden');
                }
                if (_.contains(_erasedFields, 'first_name') && _.contains(_erasedFields, 'last_name')) {
                    this.$('#' + id).find('span#first_name_erased').removeClass('hidden');
                }
            }, this);
        }
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        var self = this;
        if (this.collection.models) {
            _.each(this.collection.models, function(model) {
                var id = model.get('id');
                var link = '#' + model.module + '/' + id;
                var _src = model.get('picture');
                if (!_.isEmpty(_src)) {
                    _src = 'rest/v10/Contacts/' + id +
                        '/file/picture?format=sugar-html-json&platform=base&_hash=' + _src;
                }
                model.set({
                    '_src': _src,
                    '_link': link,
                });
            }, this);

            // Sort the models in collection by date.
            this.collection.comparator = function(model) {
                return -(new Date(model.get('date_modified')).getTime());
            };
            this.collection.sort();
            this.collection.reset(this.collection.first(3));
        }
        return this._super('_renderHtml');
    }

}) },
"product-quick-picks": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Views.Base.ProductQuickPicksView
 * @alias SUGAR.App.view.views.BaseProductQuickPicksView
 * @extends View.Views.Base.TabbedDashletView
 */
({
	// Product-quick-picks View (base) 

    extendsFrom: 'TabbedDashletView',

    className: 'product-catalog-quick-picks',

    events: {
        'click [data-action=page-clicked]': 'getPageNumClicked',
        'click [data-action=tab-switcher]': 'tabSwitcher',
        'click [data-action=page-nav-clicked]': 'onPageNavClicked',
        'click .recent-link': 'onNameClicked',
        'click .recent-records .quick-picks-list': 'onNameClicked',
        'click .recent-records .quick-picks-preview': 'onIconClicked'
    },

    /**
     * Whether or not the user has access to the product catalog
     */
    hasAccess: false,

    //declaring global variables
    activeTab: undefined,
    dataFetched: undefined,
    pageNumList: undefined,
    pageNumClicked: undefined,
    paginationLength: undefined,
    isPrevDisabled: undefined,
    isNextDisabled: undefined,
    isPageNumDisabled: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.without(this.plugins, 'Pagination');
        this.plugins = _.union(this.plugins, 'Tooltip');
        this._super('initialize', [options]);

        this.pageNumClicked = 1;
        this.paginationLength = 0;

        this.activeTab = '';

        this.pageNumList = [];

        this.dataFetched = false;
        this.isPrevDisabled = false;
        this.isNextDisabled = false;
        this.isPageNumDisabled = false;

        this.recentCollection = new Backbone.Collection();

        this.hasAccess = this._checkAccess();
    },

    /**
     * Check whether the user has access to ProductTemplates
     * @return boolean true if the user has access
     * @private
     */
    _checkAccess: function() {
        return app.acl.hasAccess('list', 'ProductTemplates');
    },

    /**
     * Initialize tabs.
     * @chainable
     * @protected
     */
    _initTabs: function() {
        this._super('_initTabs');
        // Remove Recent used tabs for Opportunity Only mode
        if (app.controller.context.get('module') !== 'Quotes' || this.layout.module === 'Opportunities') {
            if (app.metadata.getModule('Opportunities', 'config').opps_view_by === 'Opportunities') {
                this.tabs = _.without(this.tabs, _.findWhere(this.tabs, {
                    label: 'LBL_DASHLET_PRODUCT_QUICK_PICKS_RECENT_TAB'
                }));
            }
        }
        return this;
    },

    /**
     * Get url for recent/favorites api
     */
    getUrl: function(payloadData) {
        var tab = this.tabs[this.settings.get('activeTab')];
        if (tab.label === 'LBL_DASHLET_PRODUCT_QUICK_PICKS_RECENT_TAB') {
            this.activeTab = 'recent-product';
        } else {
            this.activeTab = 'favorites';
        }

        if (this.layout.module === 'Home') {
            return app.api.buildURL(app.controller.context.get('module'), this.activeTab, null,
                this.activeTab === 'favorites' ? payloadData : null
            );
        } else {
            return app.api.buildURL(this.layout.module, this.activeTab, null,
                this.activeTab === 'favorites' ? payloadData : null
            );
        }
    },

    /**
     * Gets the current pagination number <li> object
     * to be used while showing just three pages with current
     * page at center, in case total pages are more than 4
     */
    getCurrentObj: function() {
        return _.find(this.pageNumList, function(tmpObj) {
            return tmpObj.pageNum === this.pageNumClicked;
        }, this);
    },

    /**
     * {@inheritDoc}
     * @param options gets page number for Pagination in Favorites tab
     */
    loadData: function(options) {
        if (!this.hasAccess || _.isEmpty(this.tabs)) {
            return;
        }
        var data = {
            results: [],
            // only show one page of results
            // if more results are needed, then the address book should be used
            more: false
        };
        var callbacks = {};
        var url;
        var payloadData = {};

        if (options && options.pageNum !== undefined) {
            this.pageNumClicked = options.pageNum;
        }

        if (this.activeTab === 'favorites') {
            payloadData.pageNum = this.pageNumClicked - 1;
        }
        url = this.getUrl(payloadData);
        this.toggleLoading(true);
        callbacks.success = _.bind(this.onProductFetchSuccess, this);
        callbacks.error = _.bind(function() {
            // don't add any recipients via the select2 callback
            this.dataFetched = true;
            this.toggleLoading(false);
            data.results = [];
        }, this);
        app.api.call('read', url, null, callbacks);
    },

    /**
     * This gets called on callback success of LoadData and fetches records
     * for dashlet rows
     * @param options gets page number for Pagination in Favorites tab
     * @param result response data from the api call
     */
    onProductFetchSuccess: function(result) {
        var favRecords = [];
        var tmpLeftEllipsesObject = {};
        var tmpRightEllipsesObject = {};

        var currentIndex = 0;
        var startIndex = 0;

        //reset global variables
        this.pageNumList = [];
        this.recentCollection.reset();

        this.dataFetched = true;
        this.isNextDisabled = false;
        this.isPrevDisabled = false;
        this.isPageNumDisabled = false;

        this.paginationLength = 0;

        //if some data is returned
        if (result.records.length > 0) {
            //if 'Recent used' is the active tab
            if (this.activeTab === 'recent-product') {
                this.recentCollection.reset(result.records);
            } else { //else 'Favorites' tab is active
                this.paginationLength = result.totalPages;

                this.pageNumClicked = this.pageNumClicked > this.paginationLength ?
                    this.pageNumClicked - 1 : this.pageNumClicked;

                if (this.pageNumClicked === this.paginationLength || this.paginationLength === 1) {
                    this.isNextDisabled = true;
                }
                if (this.pageNumClicked === 1 || this.paginationLength === 1) {
                    this.isPrevDisabled = true;
                }

                this.isPageNumDisabled = this.pageNumClicked === 1 && this.paginationLength === 1 ? true : false;

                tmpLeftEllipsesObject = {
                    isIcon: true,
                    listClass: 'favorite-pagination',
                    subListClass: 'left-ellipsis-icon fa fa-ellipsis-h'
                };

                tmpRightEllipsesObject = {
                    isIcon: true,
                    listClass: 'favorite-pagination',
                    subListClass: 'right-ellipsis-icon fa fa-ellipsis-h'
                };

                //Push details for each list item in the pagination
                for (var page = 0; page < result.totalPages; page++) {
                    this.pageNumList.push({
                        isIcon: false,
                        listClass: 'favorite-pagination',
                        subListClass: 'paginate-num-button btn btn-link btn-invisible',
                        pageNum: page + 1,
                        isActive: this.pageNumClicked === page + 1 && !this.isPageNumDisabled ? true : false
                    });
                }

                //If more than 4 pages then display just 3 pages with ellipsis
                if (result.totalPages > 4) {
                    currentIndex = this.pageNumList.indexOf(this.getCurrentObj());

                    if (currentIndex > 0) {
                        startIndex = currentIndex < this.pageNumList.length - 1 ?
                            currentIndex - 1 : this.pageNumList.length - 3;
                    } else {
                        startIndex = 0;
                    }

                    //Get just three objects with active item in the center
                    this.pageNumList = this.pageNumList.slice(startIndex, startIndex + 3);
                    if (startIndex !== 0) {
                        this.pageNumList.unshift(tmpLeftEllipsesObject);
                    }
                    if (result.totalPages - currentIndex >= 3) {
                        this.pageNumList.push(tmpRightEllipsesObject);
                    }
                }
            }

            //favRecords represents a page displayed on the Favorite tab
            for (var count = 0; count < result.records.length; count++) {
                favRecords[count] = result.records[count];
            }

            this.recentCollection.reset(favRecords);
        }
        this.toggleLoading(false);
        this.render();
    },

    /**
     * Get the page Number clicked in Favorites Tab
     * @param evt
     */
    getPageNumClicked: function(evt) {
        evt.preventDefault();
        var pageId = this.$(evt.target).data('page-id');
        if (this.pageNumClicked === pageId) {
            return;
        }
        this.loadData({
            pageNum: pageId
        });
        this.toggleLoading(false);
        this.render();
    },

    /**
     * Event handler for navigantion button click events in the pagination footer
     * @param evt
     */
    onPageNavClicked: function(evt) {
        evt.preventDefault();
        var $el = this.$(evt.target);
        var currentPageNum = $el.data('page-id');
        if ($el.hasClass('previous-fav') || $el.hasClass('nav-previous')) {
            this.loadData({
                pageNum: currentPageNum - 1
            });
        } else if ($el.hasClass('next-fav') || $el.hasClass('nav-next')) {
            this.loadData({
                pageNum: currentPageNum + 1
            });
        }
        this.toggleLoading(false);
        this.render();
    },

    /**
     * Event handler to handle click on record names
     * @param evt
     */
    onNameClicked: function(evt) {
        evt.preventDefault();
        let recordId = this.$(evt.target).closest('li').data('record-id');
        var data = this.recentCollection.get(recordId);
        if (data) {
            data = data.toJSON();
            // copy Template's id and name to where the QLI expects them
            data.product_template_id = data.id;
            data.product_template_name = data.name;
            data.created_by = data.created_by && data.created_by.trim();
            data.modified_user_id = data.modified_user_id && data.modified_user_id.trim();
            data.currency_id = data.currency_id && data.currency_id.trim();
            data.assigned_user_id = app.user.id;

            // remove ID/etc since we dont want Template ID to be the record id
            delete data.id;
            delete data.date_entered;
            delete data.date_modified;
            delete data.pricing_formula;
            delete data.my_favorite;
            delete data.sync_key;

            let closestComp = this._getClosestComponent();
            if (closestComp && closestComp.triggerBefore('productCatalogDashlet:add:allow')) {
                app.controller.context.trigger(closestComp.cid + ':productCatalogDashlet:add', data);
            }
        }
    },

    /**
     * @inheritdoc
     */
    tabSwitcher: function(event) {
        this.dataFetched = false;
        this._super('tabSwitcher', [event]);
        //Resetting pageNumClicked on switching back to Favorites tab
        if (this.activeTab === 'favorites') {
            this.pageNumClicked = 1;
        }
        this.loadData();
    },

    /**
     * Toggles the spinning Loading icon on the header bar
     *
     * @param {boolean} startLoading If we should start the spinning icon or hide it
     */
    toggleLoading: function(startLoading) {
        if (startLoading) {
            this.$('.loading-icon').show();
        } else {
            this.$('.loading-icon').hide();
        }
    },

    /**
     * Fetches a Product Template record given the ID, and sends the response data to `callbacks.success`
     *
     * @param {string} id The ProductTemplate ID Hash to fetch
     * @private
     */
    _fetchProductTemplate: function(id) {
        var url = app.api.buildURL('ProductTemplates/' + id);
        app.api.call('read', url, null, null, {
            success: _.bind(this._openItemInDrawer, this)
        });
    },

    /**
     * Gets the record Id for the item corresponding to the clicked icon and passes it to
     * _fetchProductTemplate()
     *
     * @param evt
     */
    onIconClicked: function(evt) {
        let recordId = this.$(evt.target).closest('li').data('record-id');
        this._fetchProductTemplate(recordId);
    },

    /**
     * Gets the closest component to the dashlet
     * @return {Object|null}
     * @private
     */
    _getClosestComponent: function() {
        let componentNames = ['record', 'create', 'convert', 'records', 'side-drawer', 'omnichannel-dashboard'];
        for (let componentName of componentNames) {
            let component = this.closestComponent(componentName);
            if (component) {
                return component;
            }
        }
        return null;
    },

    /**
     * Sends the ProductTemplate data item to a Drawer layout
     *
     * @param {Object} data The ProductTemplate data
     * @private
     */
    _openItemInDrawer: function(response) {
        var data = app.data.createBean('ProductTemplates', response);
        let closestComp = this._getClosestComponent();
        data.viewId = closestComp.cid;
        app.drawer.open({
            layout: 'product-catalog-dashlet-drawer-record',
            context: {
                module: 'ProductTemplates',
                model: data,
                closestComponent: closestComp
            }
        });
    },

    /**
     * @inheritdoc
     *
     * Hides the view if the user does not have access to the necessary modules
     * @override
     */
    render: function() {
        if (!this.hasAccess) {
            this.template = app.template.get(this.name + '.noaccess');
        }
        this._super('render');
    },
}) },
"cloud-drive": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.CloudDriveView
 * @alias SUGAR.App.view.views.BaseCloudDriveView
 * @extends View.View
 */
({
	// Cloud-drive View (base) 

    /**
     * @inheritdoc
     */
    events: {
        'click .folder': 'intoFolder',
        'click .toggleShared': 'toggleShared',
        'click .parentFolder': 'intoFolder',
        'click .file': 'previewFile',
        'click .loadmore': 'loadMore',
        'click .downloadFile': 'downloadFile',
        'click .deleteFile': 'deleteFile',
        'click .createSugarDocument': 'createSugarDocument',
        'click .createFolder': 'createFolder',
        'click .refreshPath': 'refreshPath',
        'click .sorting': 'sortColumn',
        'mouseenter [data-toggle=tooltip]': 'showTooltip',
        'mouseleave [data-toggle=tooltip]': 'hideTooltip'
    },

    /**
     * @inheritdoc
     */
    plugins: ['Dashlet'],

    /**
     * Default drive type
     */
    _defaultDriveType: 'google',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', arguments);
        this.parentIds = ['root'];
        this.persistentSettings = {
            shared: {
                folderId: 'root',
                path: [{name: 'Shared', folderId: 'root', sharedWithMe: true},],
                parentId: null,
                driveId: null,
            },
            regular: {
                folderId: 'root',
                path: [{name: 'My files', folderId: 'root'},],
                parentId: null,
                driveId: null,
            }
        };
        this._defaultRootFolder = this.sharedWithMe ?  [
            {name: 'Shared', folderId: 'root', sharedWithMe: true},
        ] : [
            {name: 'My files', folderId: 'root'},
        ];
        app.events.on(`${this.cid}:cloud-drive:reload`, this.loadFiles, this);
        $(window).on('resize.' + this.cid, _.bind(_.debounce(this.adjustHeaderPaneTitle, 50), this));
    },

    /**
     * Init dashle settings
     */
    initDashlet: function() {
        this.options.driveType = this.settings.get('drive_type') || this._defaultDriveType;
        app.cache.set(this.cid, {
            driveType: this.options.driveType,
        });

        this.getRootFolder();
    },

    /**
     * Adds the events for the buttons inside the popover
     *
     * @param {Event} evt
     */
    addPopoverEvents: function(evt) {
        //The popover is not rendered on this.$el, have to use global selection
        $('.createFolderBtn').on('click', _.bind(this.createNewFolder, this));
        $('.uploadFileBtn').on('click', _.bind(this.uploadNewFile, this));
        $('body').on(`click.${this.cid}`, _.bind(this.closeOnOutsideClick, this));
        this.popover = true;
    },

    /**
     * Closes the popover when user clcks outside it
     *
     * @param {Event} evt
     */
    closeOnOutsideClick: function(evt) {
        //Using global jquery since the popover is not generated on this.$el
        if ($(evt.target).closest('.popover').length === 0) {
            this.hidePopover();
        }

        return;
    },

    /**
     * Removes the events added for the buttons inside the popover
     *
     * @param {Event} evt
     */
    removePopoverEvents: function(evt) {
        $('.createFolderBtn').off();
        $('.uploadFileBtn').off();
        $('body').off(`click.${this.cid}`);
        this.popover = false;
    },

    /**
     * Load dashlet files
     *
     * @param {Function} callback
     * @param {bool} isRefresh
     */
    loadFiles: function(callback, isRefresh) {
        callback = _.isFunction(callback) ? callback : this.displayItems;

        if (!this.folderId) {
            this.showCreateMessage = true;
            this.render();
            return;
        }

        if (this.folderId === 'root') {
            this.driveId = null;
        }

        this._updateDashletCache({
            folderId: this.folderId,
            driveId: this.driveId,
        });

        const url = app.api.buildURL('CloudDrive/list', 'files');
        app.alert.show('drive-loading', {
            level: 'process'
        });

        let nextPageToken = isRefresh ? null : this.nextPageToken;

        app.api.call('create', url, {
            folderId: this.folderId,
            nextPageToken: nextPageToken,
            sharedWithMe: this.sharedWithMe,
            type: this.options.driveType,
            driveId: this.driveId,
            sortOptions: this.sortOptions,
        }, {
            success: _.bind(callback, this),
            error: _.bind(this._handleDriveError, this),
            complete: function() {
                app.alert.dismiss('drive-loading');
            },
        });
    },

    /**
     * Gets some data for displaying
     *
     * @param {Object} data
     */
    displayItems: function(data) {
        this.showCreateMessage = false;
        this.files = data.files;
        this.nextPageToken = data.nextPageToken;
        this.render();
    },

    /**
     * Get the root context id for the current context
     *
     * @param {Function} callback
     */
    getRootFolder: function() {
        app.alert.dismiss('drive-syncing');
        app.alert.show('drive-loading', {
            level: 'process'
        });
        this.loading = true;
        /**
         * From the drivePaths module we will get a folderId or a folderName
         * if we get a folderId just set it on this.folderId and call calback
         * otherwise we need to search for folder and get it's id
         */
        const url = app.api.buildURL('CloudDrive', 'path', null, {
            module: this.module,
            recordId: this.model.get('id'),
            type: this.options.driveType,
            layoutName: app.controller.context.get('layout'),
        });

        app.api.call('read', url, null, {
            success: _.bind(function(result) {
                if (result.success === false) {
                    this.noConnection = true;
                    this.errorMessage = result.message;
                    this.render();
                } else {
                    this.noConnection = false;
                    this.folderId = result.root;
                    this.sharedWithMe = result.isShared;

                    if (_.isString(result.path)) {
                        result.path = JSON.parse(result.path);
                    }

                    this.pathFolders = result.path || this._defaultRootFolder;

                    this.pathCreateIndex = result.pathCreateIndex;
                    this.nextPageToken = result.nextPageToken;
                    this.parentId = result.parentId;
                    this.driveId = result.driveId;
                    this.setPersistentSettings();
                    this.loadFiles();
                }
            }, this),
            error: _.bind(this._handleDriveError, this),
            complete: _.bind(function() {
                app.alert.dismiss('drive-loading');
                this.loading = false;
                this.render();
            }, this),
        });
    },

    /**
     * steps into folder
     *
     * @param {Event} evt
     */
    intoFolder: function(evt) {
        if (evt.target.dataset.id) {
            this.folderId = evt.target.dataset.id;
            this.driveId = evt.target.dataset.driveid;
        }

        if (evt.target.classList.contains('back')) {
            let parentIdsRemoveIndex = this.parentIds.indexOf(this.folderId);
            this.parentIds.splice(parentIdsRemoveIndex + 1);

            let pathRemoveIndex = this.pathFolders.findIndex(function(element, index) {
                if (element.folderId === this.folderId) {
                    return true;
                }
            }.bind(this));
            this.pathFolders.splice(pathRemoveIndex + 1);
        } else {
            this.pathFolders.push({
                name: evt.target.text,
                folderId: this.folderId,
                driveId: this.driveId,
            });
            this.parentIds.push(this.folderId);
        }
        this.setPersistentSettings();

        this.parentId = this.parentIds[this.parentIds.length - 2];
        this.nextPageToken = null;
        this.getParent(this.navigateTo);
    },

    /**
     * Sets persistent settings for local/shared paths
     */
    setPersistentSettings: function() {
        if (this.sharedWithMe) {
            this.persistentSettings.shared = _.assign({}, {
                folderId: this.folderId,
                path: this.pathFolders,
                parentId: this.parentId,
                driveId: this.driveId
            });
        } else {
            this.persistentSettings.regular = _.assign({}, {
                folderId: this.folderId,
                path: this.pathFolders,
                parentId: this.parentId,
                driveId: this.driveId
            });
        }
    },

    /**
     * Gets the persistent settings for local/shared paths
     *
     * @param {bool} sharedWithMe
     */
    getPersistentSettings: function(sharedWithMe) {
        if (sharedWithMe) {
            return this.persistentSettings.shared;
        }

        return this.persistentSettings.regular;
    },

    /**
     * Navigate inside a folder
     *
     * @param {string} file
     */
    navigateTo: function(file) {
        this.parentId = this.parentId === 'root' ?
                        'root' : file && file.parents && file.parents.length ?
                                 file.parents[0] : this.parentId;
        this.files = [];

        const lastOffset = 2;
        let lastPaths = this.pathFolders.slice(this.pathFolders.length - lastOffset);

        if (_.isArray(lastPaths) && _.isUndefined(lastPaths[0].folderId)) {
            lastPaths[0].folderId = this.parentId;
            lastPaths[0].driveId = this.driveId;
        }
        this.loadFiles();
    },

    /**
     * Retrieves parent id
     *
     * @param {Function} callback
     */
    getParent: function(callback) {
        const url = app.api.buildURL('CloudDrive/file', this.folderId, null, {
            type: this.options.driveType,
            driveId: this.driveId
        });
        app.api.call('read', url, null, {
            success: _.bind(callback, this),
            error: _.bind(this._handleDriveError, this),
        });
    },

    /**
     * toggle the "Shared With Me" option
     *
     * @param {Event} evt
     */
    toggleShared: function(evt) {
        this.sharedWithMe = evt.target.dataset.sharedwithme === 'true';
        this.nextPageToken = null;
        this.files = [];
        const persistentSettings = this.getPersistentSettings(this.sharedWithMe);
        this.folderId = persistentSettings.folderId;
        this.pathFolders = persistentSettings.path;
        this.parentId = persistentSettings.parentId;
        this.driveId = persistentSettings.driveId;
        this.sortOptions = null;
        this.loadFiles();
    },

    /**
     * Retrieves file view link
     *
     * @param {Event} evt
     */
    previewFile: function(evt) {
        const fileId = evt.target.dataset.id;
        const webViewLink = evt.target.dataset.link;
        if (webViewLink) {
            this.showPreview({webViewLink: webViewLink});
        } else {
            const url = app.api.buildURL('CloudDrive/file', fileId, null, {type: this.options.driveType});
            app.api.call('read', url, null, {
                success: _.bind(this.showPreview, this),
                error: _.bind(this._handleDriveError, this),
            });
        }
    },

    /**
     * Shows file preview
     *
     * @param {string} file
     */
    showPreview: function(file) {
        window.open(file.webViewLink, '_blank');
    },

    /**
     * Load more files
     *
     * @param {Event} evt
     */
    loadMore: function(evt) {
        this.loadFiles(this.appendData);
    },

    /**
     * Append files to existing
     *
     * @param {Array} data
     */
    appendData: function(data) {
        this.files.push(...data.files);
        this.nextPageToken = data.nextPageToken;
        this.render();
    },

    /**
     * Download a file from drive
     *
     * @param {Event} evt
     */
    downloadFile: function(evt) {
        const fileId = evt.target.dataset.id;
        const driveId = evt.target.dataset.driveid;
        const downloadUrl = evt.target.dataset.downloadurl;

        if (!_.isEmpty(downloadUrl)) {
            window.open(downloadUrl, '_blank');
            return;
        }

        const file = _.filter(this.files, function(item) {return item.id === fileId;})[0];
        const fileName = file.name || 'unknown';

        app.alert.show('drive-syncing', {
            level: 'process'
        });
        const url = app.api.buildURL('CloudDrive/download');
        app.api.call('create', url, {
            fileId: fileId,
            driveId: driveId,
            type: this.options.driveType,
        }, {
            success: _.bind(function(data) {
                if (data.success) {
                    this.downloadFileLocally(fileName, data.usableMimeType, data.content);
                } else {
                    app.alert.show('drive-error-download', {
                        level: 'error',
                        title: app.lang.get('LBL_DRIVE_UNABLE_TO_DOWNLOAD')
                    });
                }
            }, this),
            error: _.bind(this._handleDriveError, this),
            complete: function() {
                app.alert.dismiss('drive-syncing');
            }
        });
    },

    /**
     * Downloads a file on the file system
     *
     * @param {string} filename
     * @param {string} fileType
     * @param {string} content
     */
    downloadFileLocally: function(filename, fileType, content) {
        const dataURIToBlob = function(dataURI) {
            let binStr = atob(dataURI);
            let len = binStr.length;
            let arr = new Uint8Array(len);

            for (let i = 0; i < len; i++) {
                arr[i] = binStr.charCodeAt(i);
            }

            return new Blob([arr], {
                type: fileType
            });
        };
        const blob = dataURIToBlob(content);
        const url = URL.createObjectURL(blob);

        let element = document.createElement('a');
        element.setAttribute('href', url);
        element.setAttribute('download', filename);

        element.style.display = 'none';
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
    },

    /**
     * Handles drive errors
     *
     * @param {Object} error
     */
    _handleDriveError: function(error) {
        if (this.popover) {
            this.hidePopover();
        }

        const alertId = App.utils.generateUUID();
        app.alert.show('drive-error' + alertId, {
            level: 'error',
            messages: error.message
        });
        this.render();
    },

    /**
     * Deletes a file from drive
     *
     * @param {Event} evt
     */
    deleteFile: function(evt) {
        app.alert.show('drive_delete', {
            level: 'confirmation',
            messages: app.lang.get('LBL_DRIVE_DELETE_CONFIRM'),
            autoClose: false,
            onConfirm: _.bind(function() {
                this._deleteFile(evt);
            }, this),
        });
    },

    /**
     * Deletes a file from drive
     *
     * @param {Event} evt
     */
    _deleteFile: function(evt) {
        const fileId = evt.target.dataset.id;
        const driveId = evt.target.dataset.driveid;
        app.alert.show('drive-syncing', {
            level: 'process'
        });
        const url = app.api.buildURL('CloudDrive/delete');
        app.api.call('create', url, {
            fileId: fileId,
            driveId: driveId,
            type: this.options.driveType,
        }, {
            error: _.bind(this._handleDriveError, this),
            complete: _.bind(function() {
                this.loadFiles();
                app.alert.dismiss('drive-syncing');
            }, this),
        });
    },

    /**
     * Creates a document in sugar
     *
     * @param {Event} evt
     */
    createSugarDocument: function(evt) {
        const fileId = evt.target.dataset.id;
        const fileName = evt.target.dataset.filename;
        const driveId = evt.target.dataset.driveid;
        const recordId = this.model.get('id');
        const recordModule = this.model.get('_module');

        const url = app.api.buildURL('CloudDrive/createSugarDocument');
        app.api.call('create', url, {
            fileId: fileId,
            fileName: fileName,
            recordModule: recordModule,
            recordId: recordId,
            driveId: driveId,
            type: this.options.driveType
        }, {
            success: _.bind(function() {
                app.alert.show('drive-syncing', {
                    level: 'success',
                    messages: app.lang.get('LBL_DRIVE_DOCUMENT_CREATED'),
                });

                if (this.context.get('layout') === 'record') {
                    this.context.trigger('subpanel:reload', {
                        links: ['documents']
                    });
                }
            }, this),
            error: _.bind(this._handleDriveError, this),
        });
    },

    /**
     * Create a folder on the drive
     *
     * @param {Event} evt
     */
    createFolder: function(evt) {
        if (_.isArray(this.pathFolders) && !_.isEmpty(this.parentId)) {
            let parentFolderId = this.parentId || this.folderId;

            if (this.pathCreateIndex === this.pathFolders.length) {
                this.folderId == this.parentId;
                this.parentId = this.oldParentId;
                this.showCreateMessage = false;

                if (this.options.driveType === 'onedrive') {
                    app.alert.show('drive-syncing', {
                        level: 'process',
                        title: app.lang.get('LBL_MICROSOFT_DELAY'),
                    });
                    setTimeout(_.bind(this.getRootFolder, this), 20000);
                } else {
                    this.getRootFolder();
                }

                return;
            }
            const folder = _.filter(this.pathFolders, function(item) {
                return item.name;
            })[this.pathCreateIndex];
            if (!_.isUndefined(folder) && _.isString(folder.name)) {
                const url = app.api.buildURL('CloudDrive', 'folder');
                app.api.call('create', url, {
                    'name': folder.name,
                    'parent': parentFolderId,
                    'driveId': this.driveId,
                    'type': this.options.driveType,
                }, {
                    success: _.bind(function(result) {
                        this.pathCreateIndex++;
                        this.oldParentId = this.parentId;
                        this.parentId = result.id;
                        this.driveId = result.driveId || this.driveId;
                        this.createFolder();
                    }, this),
                    error: _.bind(this._handleDriveError, this),
                    complete: function() {}
                });
            } else {
                this.folderId == this.parentId;
                this.parentId = this.oldParentId;
                this.showCreateMessage = false;
                this.getRootFolder();
            }
        }
    },

    /**
     * Refresh the dashlet
     *
     * @param {Event} evt
     */
    refreshPath: function(evt) {
        this.loadFiles(null, true);
    },

    /**
     * Creates a new folder on the drive
     *
     * @param {Event} evt
     */
    createNewFolder: function(evt) {
        const folderName = $('[name=folderName]').val();
        const url = app.api.buildURL('CloudDrive', 'folder');

        app.alert.show('drive-create-folder', {
            level: 'process'
        });

        app.api.call('create', url, {
            'name': folderName,
            'parent': this.folderId,
            'driveId': this.driveId,
            'type': this.options.driveType,
        }, {
            success: _.bind(this.loadFiles, this),
            error: _.bind(this._handleDriveError, this),
            complete: _.bind(function() {
                app.alert.dismiss('drive-create-folder');
                this.hidePopover();
            }, this)
        });
    },

    /**
     * Uploads a file on the drive
     * @param {Event} evt
     */
    uploadNewFile: function(evt) {
        const element = _.first($('input[name=uploadFile]'));
        const file = _.first(element.files);
        let formData = new FormData();
        formData.append('file', file);
        formData.append('fileName', file.name);
        formData.append('parentId', this.folderId);
        formData.append('type', this.options.driveType);

        if (!_.isEmpty(this.driveId)) {
            formData.append('driveId', this.driveId);
        }

        const url = app.api.buildURL('CloudDrive', 'file');

        app.alert.show('drive-upload', {
            level: 'process'
        });

        app.api.call('create', url, formData, {
            success: _.bind(function(result) {
                app.alert.show('upload-success', {
                    level: 'info',
                    messages: app.lang.get(result.message),
                });
                this.loadFiles();
            }, this),
            error: _.bind(this._handleDriveError, this),
            complete: _.bind(function() {
                app.alert.dismiss('drive-upload');
                this.hidePopover();
            }, this)
        }, {
            contentType: false,
            processData: false
        });
    },

    /**
     * Hides the popover
     */
    hidePopover: function() {
        const $popover = this.$('[rel=popover]');
        if ($popover.length) {
            $popover.popover('hide');
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render', arguments);

        this.initPopovers();
        this.adjustDropdowns();
    },

    /**
     * Initializes the popovers
     */
    initPopovers: function() {
        const fileForm = app.template.getView('cloud-drive', 'upload-form');
        const createFolderForm = app.template.getView('cloud-drive', 'create-folder');

        this.$('.uploadFile[rel=popover]').popover({
            container: 'body',
            html: true,
            title: app.lang.get('LBL_UPLOAD_FILE'),
            content: fileForm,
            placement: 'bottom',
            sanitize: false,
        });

        this.$('.newFolder[rel=popover]').popover({
            container: 'body',
            html: true,
            title: app.lang.get('LBL_CREATE_FOLDER'),
            content: createFolderForm,
            placement: 'bottom',
            sanitize: false,
        });

        this.$('[rel=popover]').on('show.bs.popover', _.bind(this.checkForPermission, this));
        this.$('[rel=popover]').on('shown.bs.popover', _.bind(this.addPopoverEvents, this));
        this.$('[rel=popover]').on('hidden.bs.popover', _.bind(this.removePopoverEvents, this));
        this.$('.list-view').on('scroll', _.bind(this.adjustDropdowns, this));
        this.$('[data-toggle=tooltip]').tooltip();
    },

    /**
     * Checks for permission to create folder or upload file
     *
     * @param {Event} evt
     */
    checkForPermission: function(evt) {
        if (this.folderId === 'root' && this.sharedWithMe) {
            app.alert.show('drive-permission-warning', {
                level: 'info',
                messages: app.lang.get('LBL_PERMISSION_ERROR'),
                autoClose: true,
            });

            return false;
        }
    },

    /**
     * Adjusts the dropdowns for better visibility
     *
     * @param {Event} evt
     */
    adjustDropdowns: function(evt) {
        if (this.disposed === true) {
            return;
        }

        const dropdowns = this.$('.btn-group.fieldset');
        const dashletBottom = this.$el.offset().top + this.$el.height();

        _.each(dropdowns, _.bind(function(dropdown) {
            if (this.isVisibleElement(dropdown)) {
                const offset = 2;
                const totalDropdownHeight = this.$(dropdown).innerHeight() +
                                            this.$(dropdown).find('ul').height() +
                                            offset;
                const dropdownOffset = this.$(dropdown).offset().top;
                const difference = dashletBottom - dropdownOffset;

                if (difference < totalDropdownHeight) {
                    $(dropdown).addClass('dropup');
                } else {
                    $(dropdown).removeClass('dropup');
                }
            }
        }, this));
    },

    /**
     * Checks if the element is visible
     *
     * @param {Element} element
     */
    isVisibleElement: function(element) {
        const rect = element.getBoundingClientRect();
        const top = rect.top;
        const bottom = rect.bottom;

        return top < window.innerHeight && bottom >= 0;
    },

    /**
     * Sorts columns
     *
     * @param {Event} evt
     */
    sortColumn: function(evt) {
        const target = this.$(evt.currentTarget);
        if (target.find('.sortable-row-header-container').length == 0) {
            return;
        }

        this.updateSortingStatus(target);
        const fieldName = target.data('fieldname');
        const direction = target.data('orderby');
        this.sortOptions = {
            direction: direction,
            fieldName: fieldName
        };

        this.loadFiles();
    },

    /**
     * Updates the sorting status for a column
     *
     * @param {jQuery} target
     */
    updateSortingStatus: function(target) {
        const status = target.data('orderby');
        const newStatus = status == 'asc' ? 'desc' : 'asc';
        target.data('orderby', newStatus);
    },

    /**
     * Triggers the showing of the tooltip
     *
     * @param {Event} evt
     */
    showTooltip: function(evt) {
        this.$(evt.currentTarget.firstElementChild).tooltip('show');
    },

    /**
     * Hides the tooltip
     *
     * @param {Event} evt
     */
    hideTooltip: function(evt) {
        this.$(evt.currentTarget.firstElementChild).tooltip('hide');
    },

    /**
     * Destoys the generated tooltips
     */
    destroyTooltips: function() {
        const tooltips = this.$('[data-toggle=tooltip]');
        tooltips.each(_.bind(function(index, tooltip) {
            $(tooltip).tooltip('destroy');
        }, this));
    },

    /**
     * Disposes the dropdowns
     */
    disposeDropdowns: function() {
        this.$('.list-view').off();
    },

    /**
     * Disposes the popovers
     */
    disposePopovers: function() {
        this.$('[rel=popover]').off();
    },

    /** Triggers the dashlet refresh
     *
     * @param {Event} evt
     */
    refreshClicked: function(evt) {
        evt.preventDefault();
        this.getRootFolder();
    },

    /** Update the cache associated with this dashlet
     *
     * @param {Object} data
     */
    _updateDashletCache: function(data) {
        let cache = app.cache.get(this.cid);
        _.extend(cache, data);
        app.cache.set(this.cid, cache);
    },

    /**
     * Adjusts the dashlet title and buttons when resizing
     */
    adjustHeaderPaneTitle: function() {
        const dashletToolbar = this.layout.getComponent('dashlet-toolbar');

        if (_.isEmpty(dashletToolbar)) {
            return;
        }

        dashletTitle = dashletToolbar.$('.dashlet-title');
        const textWidth = this.getTextWidth(dashletTitle.text(), dashletTitle.css('font'));
        const titleRect = dashletTitle[0].getBoundingClientRect();
        const buttonGroupRect = this.$('.refreshPath')[0].getBoundingClientRect();
        this.titleLeft = titleRect.left === 0 ? this.titleLeft : titleRect.left;
        const buttonGroupLeft = buttonGroupRect.left;

        if ((this.titleLeft + textWidth) > buttonGroupLeft) {
            dashletTitle.hide();
            dashletToolbar.$el.addClass('pull-right');
        } else {
            dashletTitle.show();
            dashletToolbar.$el.removeClass('pull-right');
        }
    },

    /**
     * Gets the width of the title
     *
     * @param {string} text
     * @param {string} font
     */
    getTextWidth: function(text, font) {
        this.canvas = this.canvas ? this.canvas : document.createElement('canvas');
        const context = this.canvas.getContext('2d');
        context.font = font;
        const metrics = context.measureText(text);

        return metrics.width;
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        app.cache.set(this.cid, null);
        app.events.off('cloud-drive:reload');
        $(window).off('resize.' + this.cid);
        this.hidePopover();
        this.disposePopovers();
        this.disposeDropdowns();
        this.removePopoverEvents();
        this.destroyTooltips();
        this._super('_dispose');
    }
}) },
"audit-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.AuditHeaderpaneView
 * @alias SUGAR.App.view.views.BaseAuditHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Audit-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click a[name=close_button]': 'close'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //shortcut keys
        app.shortcuts.register({
            id: 'AuditHeaderPanel:Close',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $closeButton = this.$('a[name=close_button]');
                if ($closeButton.is(':visible') && !$closeButton.hasClass('disabled')) {
                    $closeButton.click();
                }
            }
        });
    },

    /**
     * Closes the drawer.
     */
    close: function() {
        app.drawer.close();
    },

    /**
     * @override
     *
     * Overriding to show record name on title header if it is available;
     * if not, use the standard title.
     */
    _formatTitle: function(title) {
        var model = this.context.get('model');
        var recordName = app.utils.getRecordName(model);
        if (recordName) {
            return app.lang.get('TPL_AUDIT_LOG_TITLE', model.module, {name: recordName});
        } else if (title) {
            return app.lang.get(title, this.module);
        } else {
            return '';
        }
    }
}) },
"preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PreviewView
 * @alias SUGAR.App.view.views.BasePreviewView
 * @extends View.Views.Base.RecordView
 */
({
	// Preview View (base) 

    extendsFrom: 'RecordView',
    plugins: ['ToggleMoreLess', 'Editable', 'ErrorDecoration', 'SugarLogic'],
    fallbackFieldTemplate: 'detail',
    /**
     * Events related to the preview view:
     *  - preview:open                  indicate we must show the preview panel
     *  - preview:render                indicate we must load the preview with a model/collection
     *  - preview:collection:change     indicate we want to update the preview with the new collection
     *  - preview:close                 indicate we must hide the preview panel
     *  - preview:pagination:fire       (on layout) indicate we must switch to previous/next record
     *  - preview:pagination:update     (on layout) indicate the preview header needs to be refreshed
     *  - list:preview:fire             indicate the user clicked on the preview icon
     *  - list:preview:decorate         indicate we need to update the highlighted row in list view
     */

    // "binary semaphore" for the pagination click event, this is needed for async changes to the preview model
    switching: false,

    hiddenPanelExists: false,

    initialize: function(options) {
        // Use preview view if available, otherwise fallback to record view
        this.dataView = 'preview';
        /**
         * From SS-609.
         * In certain instances of loading a preview, the view may fallback on the record view metadata and therefore be
         * distinguished as 'record' view instead of 'preview'. This flag allows us to keep track of the origin of this
         * component so we can update it upon save.
         */
        options.context.set('isPreview', true);
        var previewMeta = app.metadata.getView(options.module, 'preview');
        var recordMeta = app.metadata.getView(options.module, 'record');

        if (_.isEmpty(previewMeta) || _.isEmpty(previewMeta.panels)) {
            this.dataView = 'record';
        }

        this._super('initialize', [options]);
        this.meta = _.extend(this.meta, this._previewifyMetadata(_.extend({}, recordMeta, previewMeta)));
        this.action = 'detail';
        this.viewAction = 'preview';
        this._delegateEvents();

        /**
         * An array of the {@link #alerts alert} names in this view.
         *
         * @property {Array}
         * @protected
         */
        this._viewAlerts = [];

        /**
         * A collection of alert messages to be used in this view. The alert methods
         * should be invoked by Function.prototype.call(), passing in an instance of
         * a sidecar view. For example:
         *
         *     // ...
         *     this.alerts.showInvalidModel.call(this);
         *     // ...
         *
         * FIXME: SC-3451 will refactor this `alerts` structure.
         * @property {Object}
         */
        this.alerts = {
            showInvalidModel: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                var name = 'invalid-data';
                this._viewAlerts.push(name);
                app.alert.show(name, {
                    level: 'error',
                    messages: 'ERR_RESOLVE_ERRORS'
                });
            },
            showNoAccessError: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                // dismiss the default error
                app.alert.dismiss('data:sync:error');
                // display no access error
                app.alert.show('server-error', {
                    level: 'error',
                    messages: 'ERR_HTTP_404_TEXT_LINE1'
                });
                // discard any changes before redirect
                this.handleCancel();
                // redirect to list view
                var route = app.router.buildRoute(this.module);
                app.router.navigate(route, {trigger: true});
            }
        };

        this.saveCallback = function(wasSaved) {
            if (wasSaved) {
                app.events.trigger('preview:edit:save');
            }
        };
    },

    /**
     * @inheritdoc
     *
     * Patches metadata for use in Preview when a dropdown-based view changes
     * the metadata panels
     */
    _setDbvMeta: function(dbvKey) {
        this._super('_setDbvMeta', [dbvKey]);
        this.meta = this._previewifyMetadata(this.meta);
    },

    /**
     * @inheritdoc
     *
     * @override Overriding to get preview specific buttons
     */
    toggleButtons: function(enable) {
        if (this.layout.previewEdit) {
            var previewLayout = this.layout.getComponent('preview-header');
            previewLayout.getField('save_button').setDisabled(!enable);
            previewLayout.getField('cancel_button').setDisabled(!enable);
        }
    },

    /**
     * Runs when validation is successful
     * Returns the preview to detail view
     *
     * @override Overriding because we need to trigger 'preview:edit:complete'
     * and not do record view specific actions like: this.inlineEditMode = false;
     */
    handleSave: function() {
        if (this.disposed) {
            return;
        }
        app.alert.dismiss('cancel-dropdown-view-change');
        this._saveModel();
        this.layout.trigger('preview:edit:complete');
        this.unsetContextAction();
        this.toggleFields(this.editableFields, false);
        this.toggleLocks(false);
        this.action = 'detail';
        this.setButtonStates(this.STATE.VIEW);
    },

    /**
     * When clicking cancel, return the preview view to detail state
     * and revert the model
     *
     * @override Overriding in order to trigger 'preview:edit:complete'
     */
    cancelClicked: function() {
        app.alert.dismiss('cancel-dropdown-view-change');
        this.model.revertAttributes({
            hideDbvWarning: true
        });
        this.action = 'detail';
        this.toggleFields(this.editableFields, false);
        this.toggleLocks(false);
        this._dismissAllAlerts();
        this.clearValidationErrors(this.editableFields);
        this.unsetContextAction();
        this.layout.trigger('preview:edit:complete');
    },

    /**
     * Add event listeners
     *
     * @private
     */
    _delegateEvents: function() {
        app.events.on('preview:collection:change', this.showPreviousNextBtnGroup, this);
        //FIXME: SC-4915 will delete this listener.
        app.events.on('app:help:shown', function() {
            app.events.trigger('list:preview:decorate', false);
            this.closePreview();
        }, this);

        // TODO: Remove when pagination on activity streams is fixed.
        app.events.on('preview:module:update', this.updatePreviewModule, this);

        if (this.layout) {
            this.layout.on('preview:pagination:fire', this.switchPreview, this);
        }
    },

    /**
     * Setup event listeners for buttons
     *
     * @override Override because we only want to set events if
     * previewEdit is enabled
     */
    delegateButtonEvents: function() {
        if (this.layout && this.layout.previewEdit) {
            this.context.on('button:save_button:click', this.saveClicked, this);
            this.context.on('button:cancel_button:click', this.cancelClicked, this);
            this.layout.on('preview:edit', this.handleEdit, this);
        }
    },

    /**
     * Calls `View.Views.Base.PreviewView#showPreviousNextBtnGroup`.
     *
     * @deprecated since 7.8, will be removed in 7.9.
     * @param {Data.BeanCollection} collection the given collection (unused)
     */
    updateCollection: function(collection) {
        app.logger.warn('View.Views.Base.PreviewView#updateCollection is deprecated since 7.8 and will be' +
            ' removed in 7.9. Since the preview layout now share the view collection, this method is obsolete.');

        this.showPreviousNextBtnGroup();
    },

    // TODO: Remove when pagination on activity streams is fixed.
    updatePreviewModule: function(module) {
        this.previewModule = module;
    },

    filterCollection: function() {
        this.collection.remove(_.filter(this.collection.models, function(model){
            return !app.acl.hasAccessToModel('view', model);
        }, this), { silent: true });
    },

    _renderHtml: function(){
        this.showPreviousNextBtnGroup();
        app.view.View.prototype._renderHtml.call(this);
    },

    /**
     * Show previous and next buttons groups on the view.
     *
     * This gets called everytime the collection gets updated. It also depends
     * if we have a current model or layout.
     *
     * TODO we should check if we have the preview open instead of doing a bunch
     * of if statements.
     */
    showPreviousNextBtnGroup: function () {
        if (!this.model || !this.layout) {
            return;
        }

        var collection = this.collection;
        if (!collection || !collection.size()) {
            this.layout.hideNextPrevious = true;
            // Need to rerender the preview header
            this.layout.trigger('preview:pagination:update');
            return;
        }

        var recordIndex = collection.indexOf(collection.get(this.model.id));
        this.layout.previous = collection.models[recordIndex-1] ? collection.models[recordIndex-1] : undefined;
        this.layout.next = collection.models[recordIndex+1] ? collection.models[recordIndex+1] : undefined;
        this.layout.hideNextPrevious = _.isUndefined(this.layout.previous) && _.isUndefined(this.layout.next);

        // Need to rerender the preview header
        this.layout.trigger('preview:pagination:update');
    },

    /**
     * Renders the preview dialog with the data from the current model and collection.
     *
     * @deprecated Deprecated since 7.8.0. Will be removed in 7.10.0.
     * @param model Model for the object to preview
     * @param collection Collection of related objects to the current model
     * @param {Boolean} fetch Optional Indicates if model needs to be synched with server to populate with latest data
     * @param {Number|String} previewId Optional identifier use to determine event origin. If event origin is not the same
     * but the model id is the same, preview should still render the same model.
     * @private
     */
    _renderPreview: function(model, collection, fetch, previewId) {
        app.logger.warn('`Base.PreviewView#_renderPreview` has been deprecated since 7.8.0 and' +
            'will be removed in 7.10.0.');

        var self = this;

        // If there are drawers there could be multiple previews, make sure we are only rendering preview for active drawer
        if(app.drawer && !app.drawer.isActive(this.$el)){
            return;  //This preview isn't on the active layout
        }

        // Close preview if we are already displaying this model
        if (this.model && model && (this.model.get('id') == model.get('id') && previewId == this.previewId)) {
            // Remove the decoration of the highlighted row
            app.events.trigger('list:preview:decorate', false);
            // Close the preview panel
            app.events.trigger('preview:close');
            return;
        }

        if (app.metadata.getModule(model.module).isBwcEnabled) {
            // if module is in BWC mode, just return
            return;
        }

        if (model) {
            // Use preview view if available, otherwise fallback to record view
            var viewName = 'preview',
                previewMeta = app.metadata.getView(model.module, 'preview'),
                recordMeta = app.metadata.getView(model.module, 'record');
            if (_.isEmpty(previewMeta) || _.isEmpty(previewMeta.panels)) {
                viewName = 'record';
            }
            this.meta = this._previewifyMetadata(_.extend({}, recordMeta, previewMeta));
            this.renderPreview(model, collection);
            fetch && model.fetch({
                showAlerts: true,
                view: viewName
            });
        }

        this.previewId = previewId;
    },
    /**
     * Use the given model to render preview.
     * @param {Bean} model Model to render preview
     */
    switchModel: function(model) {
        this.model && this.model.abortFetchRequest();
        this.stopListening(this.model);
        if (_.isFunction(this.stopSugarLogic)) {
            this.stopSugarLogic();
        }

        this.model = model;

        if (_.isFunction(this.startSugarLogic)) {
            this.startSugarLogic();
        }

        this._initDropdownBasedViewsForModel();

        // Close preview when model destroyed by deleting the record
        this.listenTo(this.model, 'destroy', function() {
            // Remove the decoration of the highlighted row
            app.events.trigger('list:preview:decorate', false);
            // Close the preview panel
            app.events.trigger('preview:close');
        });
    },
    /**
     * Renders the preview dialog with the data from the current model and collection
     *
     * @deprecated Deprecated since 7.8.0. Will be removed in 7.10.0.
     * @param model Model for the object to preview
     * @param collection Collection of related objects to the current model
     */
    renderPreview: function(model, newCollection) {
        app.logger.warn('`Base.PreviewView#renderPreview` has been deprecated since 7.8.0 and' +
            'will be removed in 7.10.0.');

        if(newCollection) {
            this.collection.reset(newCollection.models);
        }

        if (model) {
            this.switchModel(model);
            if (this.layout) {
                this.layout.trigger('previewheader:ACLCheck', model);
            }

            // TODO: Remove when pagination on activity streams is fixed.
            if (this.previewModule && this.previewModule === 'Activities') {
                // We need to set previewEdit to false before render but set
                // hideNextPreview and trigger 'preview:pagination:update' after
                this.layout.previewEdit = false;
                this.render();
                this.layout.hideNextPrevious = true;
                this.layout.trigger('preview:pagination:update');
            } else {
                // If we aren't on activitystream, then just render
                this.render();
            }
            // Open the preview panel
            app.events.trigger('preview:open', this);
            // Highlight the row
            app.events.trigger('list:preview:decorate', this.model, this);
        }
    },

    /**
     * Normalizes the metadata, and removes favorite/follow fields that gets
     * shown in Preview dialog.
     *
     * @param meta Layout metadata to be trimmed
     * @return Returns trimmed metadata
     * @private
     */
    _previewifyMetadata: function(meta){
        this.hiddenPanelExists = false; // reset
        _.each(meta.panels, function(panel){
            if(panel.header){
                panel.header = false;
                panel.fields = _.filter(panel.fields, function(field){
                    //Don't show favorite or follow in Preview, it's already on list view row
                    return field.type != 'favorite' && field.type != 'follow';
                });
            }
            //Keep track if a hidden panel exists
            if(!this.hiddenPanelExists && panel.hide){
                this.hiddenPanelExists = true;
            }
        }, this);
        return meta;
    },
    /**
     * Switches preview to left/right model in collection.
     * @param {Object} data
     * @param {String} data.direction Direction that we are switching to, either 'left' or 'right'.
     * @param index Optional current index in list
     * @param id Optional
     * @param module Optional
     */
    switchPreview: function(data, index, id, module) {
        var currID = id || this.model.get('id'),
            currIndex = index || _.indexOf(this.collection.models, this.collection.get(currID));

        if( this.switching || this.collection.models.length < 2) {
            // We're currently switching previews or we don't have enough models, so ignore any pagination click events.
            return;
        }
        this.switching = true;

        if (data.direction === 'left' && (currID === _.first(this.collection.models).get('id')) ||
            data.direction === 'right' && (currID === _.last(this.collection.models).get('id'))) {
            this.switching = false;
            return;
        } else {
            // We can increment/decrement
            data.direction === 'left' ? currIndex -= 1 : currIndex += 1;

            //Reset the preview
            app.events.trigger('preview:render', this.collection.models[currIndex], this.collection, true);
            this.switching = false;
        }
    },

    /**
     * @deprecated Deprecated since 7.8.0. Will be removed in 7.10.0.
     */
    closePreview: function() {
        app.logger.warn('`Base.PreviewView#closePreview` has been deprecated since 7.8.0 and' +
            ' will be removed in 7.10.0.');

        if(_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)){
            this.switching = false;
            delete this.model;
            this.collection.reset();
        }
    },

    bindDataChange: function() {
        if(this.collection) {
            this.collection.on('reset', this.filterCollection, this);
            // when remove active model from collection then close preview
            this.collection.on('remove', function(model) {
                if (model && this.model && (this.model.get('id') == model.get('id'))) {
                    // Remove the decoration of the highlighted row
                    app.events.trigger('list:preview:decorate', false);
                    // Close the preview panel
                    app.events.trigger('preview:close');
                }
            }, this);
        }
        // When the preview layout sets the new model in the context, the view
        // needs to switch the model and render for the fields to listen to the new
        // model changes.
        // Since the layout calls loadData, the fields will rerender when the data comes back
        // from the sever.
        this.context.on('change:model', function(ctx, model) {
            this.cancelClicked();
            this.switchModel(model);
            this.render();
        }, this);
    },

    /**
     * When clicking on the pencil icon, toggle all editable fields
     * to edit mode
     */
    handleEdit: function() {
        this.setEditableFields();
        this.toggleFields(this.editableFields, true);
        this.toggleButtons(true);
        this.action = 'edit';
        this.setButtonStates(this.STATE.EDIT);
        this.toggleLocks(true);
    },

    /**
     * @inheritdoc
     *
     * Tells the layout to update the state of the buttons in the preview header
     */
    setButtonStates: function(state) {
        this._super('setButtonStates', [state]);
        this.layout.trigger('preview:header:edit', state === this.STATE.EDIT);
    },

    /**
     * Show or hide lock icons for locked fields
     *
     * @param {boolean} activate `true` to show lock icon on locked fields
     */
    toggleLocks: function(activate) {
        // Get the locked fields from the model
        var lockedFields = this.model.get('locked_fields') || [];

        if (!this._hasLockedFields) {
            return;
        }

        if (activate) {
            this.warnLockedFields();
        }
        _.each(this.fields, function(field) {
            if (_.contains(lockedFields, field.name)) {
                this.$('.preview-lock-link-wrapper[data-name=' + field.name + ']').toggleClass('hide', !activate);
            }
        }, this);
    },

    /**
     * Set a list of editable fields
     *
     * @override Overriding to checking field def if preview edit
     * is allowed
     */
    setEditableFields: function() {
        // Get the locked fields from the model
        var lockedFields = this.model.get('locked_fields') || [];

        // Clear any old locked fields that may have been set
        this._hasLockedFields = false;

        // we only want to edit non readonly fields
        this.editableFields = _.reject(this.fields, function(field) {
            // Locked fields should not be editable
            if (_.contains(lockedFields, field.name)) {
                this._hasLockedFields = true;
                return true;
            }
            return field.def.readOnly || field.def.calculated ||
                //Added for SugarLogic fields since they are not supported
                //Fixme: PAT-2241 will remove this
                field.def.previewEdit === false ||
                !app.acl.hasAccessToModel('edit', this.model, field.name);
        }, this);
    },

    /**
     * @inheritdoc
     */
    hasUnsavedChanges: function() {
        if (_.isUndefined(this.model)) {
            return false;
        }
        return this._super('hasUnsavedChanges');
    }
}) },
"bubblechart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.BubblechartView
 * @alias SUGAR.App.view.views.BaseBubblechartView
 * @extends View.View
 */
({
	// Bubblechart View (base) 

    plugins: ['Dashlet', 'Chart'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // Track if current user is manager
        this.isManager = app.user.get('is_manager');
        this._initPlugins();

        var config = app.metadata.getModule('Forecasts', 'config');
        // What module are we forecasting by?
        this.forecastBy = config && config.forecast_by || 'Opportunities';

        // set the title label in meta the same way the dashlet title is set on render
        options.meta.label = app.lang.get(options.meta.label, this.forecastBy);

        this._super('initialize', [options]);

        var fields = [
            'id',
            'name',
            'account_name',
            'base_rate',
            'currency_id',
            'assigned_user_name',
            'date_closed',
            'probability',
            'account_id',
            'sales_stage',
            'commit_stage'
        ];

        var orderBy = '';
        // Which field holds the likely case value?
        if (this.forecastBy === 'Opportunities') {
            fields.push('amount');
            orderBy = 'amount:desc';
            this.likelyField = 'amount';
        } else {
            fields.push('likely_case');
            orderBy = 'likely_case:desc';
            this.likelyField = 'likely_case';
        }

        this.params = {
            'fields': fields.join(','),
            'max_num': 10,
            'order_by': orderBy
        };

        // get the locale settings for the active user
        // this.locale is stored by reference in the chart model
        this.locale = SUGAR.charts.getUserLocale();
        // create deep copy for tooltip temp use, etc.
        // it will be set to chart.locality() after instantiation
        this.locality = {};

        this.tooltipTemplate = app.template.getView(this.name + '.tooltiptemplate');
    },

    /**
     * @inheritdoc
     */
    initDashlet: function(view) {
        var self = this;

        if (this.settings.get('filter_duration') == 0) {
            this.settings.set({'filter_duration': 'current'}, {'silent': true});
        }

        this.setDateRange();

        if (!this.isManager && this.meta.config) {
            // FIXME: Dashlet's config page is loaded from meta.panels directly.
            // See the "dashletconfiguration-edit.hbs" file.
            this.meta.panels = _.chain(this.meta.panels).filter(function(panel) {
                panel.fields = _.without(panel.fields, _.findWhere(panel.fields, {name: 'visibility'}));
                return panel;
            }).value();
        }

        this.chart = sucrose.charts.bubbleChart()
            .x(function(d) {
                return d3sugar.timeParse('%Y-%m-%d')(d.x);
            })
            .y(function(d) {
                return d.y;
            })
            .margin({top: 0})
            .tooltipContent(_.bind(function(eo, properties) {
                var point = eo.point;
                var value = this.chart.x()(point);
                point.close_date = sucrose.utility.dateFormat(value, this.locality.date, this.locality);
                point.likely = app.currency.formatAmountLocale(point.base_amount, point.currency_id);
                return self.tooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
            }, this))
            .showTitle(false)
            .tooltips(true)
            .showLegend(true)
            .direction(app.lang.direction)
            .seriesClick(function(data, eo, chart) {
                self.chart.dispatch.call('tooltipHide', this);
                app.router.navigate(app.router.buildRoute(self.forecastBy, eo.point.id), {trigger: true});
            })
            .colorData('class', {step: 2})
            .groupBy(function(d) {
                return (self.isManager && self.getVisibility() === 'user') ?
                    d.sales_stage_short :
                    d.assigned_user_name;
            })
            .filterBy(function(d) {
                return d.probability;
            })
            .strings({
                legend: {
                    close: app.lang.get('LBL_CHART_LEGEND_CLOSE'),
                    open: app.lang.get('LBL_CHART_LEGEND_OPEN')
                },
                noData: app.lang.get('LBL_CHART_NO_DATA'),
                noLabel: app.lang.get('LBL_CHART_NO_LABEL')
            })
            .locality(this.locale);

        // create deep copy for tooltip temp use
        this.locality = sucrose.utility.buildLocality(this.chart.locality(), true);

        this.on('data-changed', function() {
            this.renderChart();
        }, this);
        this.settings.on('change:filter_duration', this.changeFilter, this);

        this.layout.on('render', function() {
            if (!this.disposed && !this.settings.get('config')) {
                this.layout.setTitle(app.lang.get(this.meta.label, this.forecastBy));
            }
        }, this);
    },

    /**
     * Initialize plugins.
     * Only manager can toggle visibility.
     *
     * @return {View.Views.BaseBubbleChart} Instance of this view.
     * @protected
     */
    _initPlugins: function() {
        if (this.isManager) {
            this.plugins = _.union(this.plugins, [
                'ToggleVisibility'
            ]);
        }
        return this;
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }

        // Clear out the current chart before a re-render
        this.$('svg#' + this.cid).children().remove();

        // Load data into chart model and set reference to chart
        d3sugar.select('svg#' + this.cid)
            .datum(this.chartCollection)
            .transition().duration(500)
            .call(this.chart);

        this.chart_loaded = _.isFunction(this.chart.render);
        this.displayNoData(!this.chart_loaded);
    },

    /**
     * Override the chartResize method in Chart plugin because
     * bubblechart sucrose model uses render instead of update.
     */
    chartResize: function() {
        this.chart.render();
    },

    /**
     * Filter out records that don't meet date criteria
     * and convert into format convenient for d3
     */
    evaluateResult: function(data) {
        this.total = data.records.length;

        var statusOptions = 'sales_stage_dom',
            fieldMeta = app.metadata.getModule(this.forecastBy, 'fields');

        if (fieldMeta) {
            statusOptions = fieldMeta.sales_stage.options || statusOptions;
        }

        this.chartCollection = {
            data: data.records.map(function(d) {
                var sales_stage = app.lang.getAppListStrings(statusOptions)[d.sales_stage] || d.sales_stage;

                // if probability is null or empty set to 0
                if(_.isNull(d.probability) || d.probability === '') {
                    d.probability = 0;
                }

                // if likely is null or empty set to 0, for customers that do not require likely
                if(_.isNull(d[this.likelyField]) || d[this.likelyField] === '') {
                    d[this.likelyField] = 0;
                }

                return {
                    id: d.id,
                    x: d.date_closed,
                    y: Math.round(parseInt(d[this.likelyField], 10) / parseFloat(d.base_rate)),
                    shape: 'circle',
                    account_name: d.account_name,
                    assigned_user_name: d.assigned_user_name,
                    sales_stage: sales_stage,
                    sales_stage_short: sales_stage,
                    probability: parseInt(d.probability, 10),
                    base_amount: d[this.likelyField],
                    currency_symbol: app.currency.getCurrencySymbol(d.currency_id),
                    currency_id: d.currency_id
                };
            }, this),
            properties: {
                title: app.lang.get('LBL_DASHLET_TOP10_SALES_OPPORTUNITIES_NAME'),
                value: data.records.length,
                xDataType: 'datetime',
                yDataType: 'numeric'
            }
        };
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var self = this,
            _filter = [
                {
                    'date_closed': {
                        '$gte': self.dateRange.begin
                    }
                },
                {
                    'date_closed': {
                        '$lte': self.dateRange.end
                    }
                }
            ];

        if (!this.isManager || this.getVisibility() === 'user') {
            _filter.push({'$owner': ''});
        }

        var _local = _.extend({'filter': _filter}, this.params);
        var url = app.api.buildURL(this.forecastBy, null, null, _local, this.params);

        // Request data from REST endpoint, evaluate result and trigger data change event
        app.api.call('read', url, null, {
            success: function(data) {
                self.evaluateResult(data);
                if (!self.disposed) {
                    self.trigger('data-changed');
                }
            },
            error: _.bind(function() {
                this.displayNoData(true);
            }, this),
            complete: options ? options.complete : null
        });
    },

    /**
     * Calculate date range based on date range dropdown control
     */
    setDateRange: function() {
        var now = new Date(),
            mapping = {
                'current' : 0,
                'next' : 3,
                'year' : 12
            },
            duration = mapping[this.settings.get('filter_duration')],
            startMonth = Math.floor(now.getMonth() / 3) * 3,
            startDate = new Date(now.getFullYear(), (duration === 12 ? 0 : startMonth + duration), 1),
            addYear = 0,
            addMonth = duration === 12 ? 12 : 3,
            endDate;

        // if "Next Quarter" is selected and the current month is Oct/Nov/Dec, add 1 to the year
        if(duration === 3 && now.getMonth() >= 9) {
            addYear = 1;
        }
        endDate = new Date(now.getFullYear() + addYear, startDate.getMonth() + addMonth, 0);

        this.dateRange = {
            'begin': app.date.format(startDate, 'Y-m-d'),
            'end': app.date.format(endDate, 'Y-m-d')
        };
    },

    /**
     * Trigger data load event based when date range dropdown changes
     */
    changeFilter: function() {
        this.setDateRange();
        this.loadData();
    },

    /**
     * @inheritdoc
     *
     * Additional logic on switch visibility event.
     */
    visibilitySwitcher: function() {
        var activeVisibility;
        if (!this.isManager) {
            return;
        }
        activeVisibility = this.getVisibility();
        this.$el.find('[data-action=visibility-switcher]')
            .attr('aria-pressed', function() {
                return $(this).val() === activeVisibility;
            });
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.off('data-changed');
        this.settings.off('change:filter_duration');
        this._super('_dispose');
    }
}) },
"language-actions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.LanguageActionsView
 * @alias SUGAR.App.view.views.BaseLanguageActionsView
 * @extends View.View
 */
({
	// Language-actions View (base) 

    events: {
        'click [data-action=languageList] .dropdown-menu a' : 'setLanguage'
    },
    tagName: "span",
    plugins: ['Dropdown'],
    /**
     * @override
     * @param {Object} options
     */
    initialize: function(options) {
        app.events.on("app:sync:complete", this.render, this);
        app.events.on("app:login:success", this.render, this);
        app.events.on("app:logout", this.render, this);
        app.view.View.prototype.initialize.call(this, options);
        $(window).on('resize', _.debounce(_.bind(this.adjustMenuHeight, this), 100));
    },
    /**
     * @override
     * @private
     */
    _renderHtml: function() {
        this.isAuthenticated = app.api.isAuthenticated();
        this.currentLang = app.lang.getLanguage() || "en_us";
        this.languageList = this.formatLanguageList();
        app.view.View.prototype._renderHtml.call(this);
        this.$('[data-toggle="dropdown"]').dropdown();
        this.adjustMenuHeight();
    },
    /**
     * When a user selects a language in the dropdown, set this language.
     * Note that on login, user's preferred language will be updated to this language
     *
     * @param {Event} e
     */
    setLanguage: function(e) {
        var $li = this.$(e.currentTarget);
        var langKey = $li.data('lang-key');
        var currentLanguageForDom = _.first(langKey.split('_'));
        // Use the simple language code as per HTML qualifications
        document.documentElement.lang = currentLanguageForDom;
        app.alert.show('language', {level: 'warning', title: app.lang.get('LBL_LOADING_LANGUAGE'), autoclose: false});
        app.user.setPreference('language', langKey);
        app.lang.setLanguage(langKey, function() {
            app.alert.dismiss('language');
        });
    },
    adjustMenuHeight: function(){
        if (this.$('[data-action=languageList]').length === 0) {
            return;
        }
        var linkButton = this.$('[data-action=languageList]'),
            dropupMenu = this.$('[data-action=languageList] .dropdown-menu.bottom-up'),
            linkBottomPosition = parseInt($('footer').height() - linkButton.height() - linkButton.position().top, 10),
            dropupOffset = parseInt(dropupMenu.css('bottom'), 10),
            borderTop = parseInt(dropupMenu.css('border-top-width'), 10),
            menuHeight = Math.round($(window).height() - borderTop - dropupOffset - linkBottomPosition);
        dropupMenu.css('max-height', menuHeight);
    },
    /**
     * Formats the language list for the template
     *
     * @return {Array} of languages
     */
    formatLanguageList: function() {
        // Format the list of languages for the template
        var list = [],
            languages = app.lang.getAppListStrings('available_language_dom');

        _.each(languages, function(label, key) {
            if (key !== '') {
                list.push({ key: key, value: label });
            }
        });
        return list;
    },
    /**
     * @inheritdoc
     */
    _dispose: function() {
        $(window).off('resize');
        app.view.View.prototype._dispose.call(this);
    }
}) },
"baseeditmodal": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.BaseeditmodalView
 * @alias SUGAR.App.view.views.BaseBaseeditmodalView
 * @extends View.View
 */
({
	// Baseeditmodal View (base) 

    events: {
        'click [name=save_button]': 'saveButton',
        'click [name=cancel_button]': 'cancelButton'
    },
    // Delegate events
    saveButton: function() {
        var createModel = this.context.get('createModel');

        this.$('[name=save_button]').attr('data-loading-text', app.lang.get('LBL_LOADING'));
        this.$('[name=save_button]').button('loading');

        // Disable the buttons during save.
        this.disableButtons(true);
        this.processModel(createModel);

        // saves the related bean
        createModel.save(null, {
            relate: true,
            fieldsToValidate: this.getFields(this.module),
            success: _.bind(function() {
                this.saveComplete();
            }, this),
            error: _.bind(function() {
                this.disableButtons(false);
            }, this)

        });
    },
    /**
     * Preprocess the model before saving. This function is here so that children may override it as necessary.
     * @param {object} model
     */
    processModel: function(model) {

    },
    cancelButton: function() {
        if (Modernizr.touch) {
            app.$contentEl.removeClass('content-overflow-visible');
        }
        this.$('.modal').modal('hide').find('form').get(0).reset();
        if (this.context.has('createModel')) {
            this.context.get('createModel').clear();
        }
    },
    saveComplete: function() {
        //reset the form
        this.$('.modal').modal('hide').find('form').get(0).reset();
        //reset the `Save` button
        this.disableButtons(false);
        //add the new model to the collection
        this.collection.fetch({relate: true});
    },

    /**
     * Enables or disables the buttons from the metadata. Disables them by
     * default.
     *
     * @param {boolean} [disable=true] Whether to enable or disable the buttons.
     *   Defaults to `true`.
     */
    disableButtons: function(disable) {
        var state = _.isUndefined(disable) ? true : disable;

        _.each(this.meta.buttons, function(button) {
            var btn = this.getField(button.name);
            btn.setDisabled(state);
        }, this);
    }
}) },
"selection-list-context": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 *
 * This view displays the selected records at the top of a selection list. It
 * also allows to unselect them.
 *
 * @class View.Views.Base.SelectionListContextView
 * @alias SUGAR.App.view.views.BaseSelectionListContextView
 * @extends View.View
 */

({
	// Selection-list-context View (base) 

    className: 'selection-context',
    events: {
        'click [data-close-pill]': 'handleClosePillEvent',
        'click .reset_button': 'removeAllPills'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.pills = [];
        /**
         * The maximum number of pills that can be displayed.
         *
         * @property {number}
         */
        this.maxPillsDisplayed = 50;
        this._super('initialize', [options]);
     },

    /**
     * Adds a pill in the template.
     *
     * @param {Data.Bean|Object|Array} models The model, set of model attributes
     * or array of those corresponding to the pills to add.
     */
    addPill: function(models) {

        models = _.isArray(models) ? models : [models];

        if (_.isEmpty(models)) {
            return;
        }

        var pillsAttrs = [];
        var pillsIds = _.pluck(this.pills, 'id');

        _.each(models, function(model) {
            //FIXME : SC-4196 will remove this.
            var modelName = model.get('name') || model.get('full_name') ||
                app.utils.formatNameLocale(model.attributes) ||
                model.get('document_name');

            if (modelName && !_.contains(pillsIds, model.id)) {
                pillsAttrs.push({id: model.id, name: modelName});
            }
        });

        this.pills.push.apply(this.pills, pillsAttrs);

        this._debounceRender();
    },

    /**
     * Removes a pill from the template.
     *
     * @param {Data.Bean|Object|Array} models The model or array of models
     * corresponding to the pills to remove. It can also be an object or array
     * of objects containing the 'id' of the pills to remove.
     *
     */
    removePill: function(models) {
        models = _.isArray(models) ? models : [models];
        var ids = _.pluck(models, 'id');
        this.pills = _.reject(this.pills, function(pill) {
            return _.contains(ids, pill.id);
        });
        this._debounceRender();
    },

    /**
     * Removes all the pills and sends an event to clear the mass collection.
     *
     * @param {Event} The click event.
     */
    removeAllPills: function(event) {
        if (event) {
            if (this.$(event.target).hasClass('disabled')) {
                return;
            }
        }
        this.pills = [];
        this.render();
        this.context.trigger('mass_collection:clear');
    },

    /**
     * Resets the pills to match the mass collection. Useful to update pills
     * on mass collection reset.
     *
     * @param {Data.BeanCollection} collection The collection that has been reset.
     */
    resetPills: function(collection) {
        if (!collection.length) {
            this.pills = [];
        }
        this.render();
    },

    /**
     * Click handler for the `close` button on a pill.
     *
     * @param {Event} event The click event.
     */
    handleClosePillEvent: function(event) {
        var id = this.$(event.target).closest('.select2-search-choice').data('id').toString();
        this.closePill(id);
    },

    /**
     * Removes the pill and triggers an event to remove it the model from the
     * mass collection.
     *
     * @param {string} modelId The id of the model to remove.
     */
    closePill: function(modelId) {
        this.removePill({id: modelId});
        var model = this.massCollection.get(modelId);
        this.context.trigger('mass_collection:remove', model);
    },

    /**
     * Debounced version of render.
     *
     * @private
     */
    _debounceRender: _.debounce(function() {
        this.render();
    }, 50),

    /**
     * @inheritdoc
     */
    _render: function() {
        this.massCollection = this.context.get('mass_collection');
        if (!this.massCollection) {
            return;
        }

        if (this.pills.length > this.maxPillsDisplayed) {
            this.displayedPills = this.pills.slice(0, this.maxPillsDisplayed);
            this.tooManySelectedRecords = true;
            this.msgMaxPillsDisplayed = app.lang.get('TPL_MAX_PILLS_DISPLAYED', this.module, {
                maxPillsDisplayed: this.maxPillsDisplayed
            });
        } else {
            this.tooManySelectedRecords = false;
            this.displayedPills = this.pills;
        }

        var recordsLeft = this.massCollection.length - this.displayedPills.length;
        if (recordsLeft) {
            this.moreRecords = true;
            var label = this.displayedPills.length ? 'TPL_MORE_RECORDS' : 'TPL_RECORDS_SELECTED';
            this.msgMoreRecords = app.lang.get(label, this.module, {
                recordsLeft: recordsLeft
            });
        } else {
            this.moreRecords = false;
        }

        this._super('_render');
        this.stopListening(this.massCollection);

        this.listenTo(this.massCollection, 'add', this.addPill);
        this.listenTo(this.massCollection, 'remove', this.removePill);
        this.listenTo(this.massCollection, 'reset', this.resetPills);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.collection.on('sync', function() {

            var recordsToAdd = this.collection.filter(_.bind(function(model) {
                return this.massCollection.get(model.id);
            }, this));

            this.addPill(recordsToAdd);

        }, this);
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.stopListening(this.massCollection);
        this._super('unbind');
    }
}) },
"wizard-page": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * An abstract WizardPageView.
 *
 * Wizard pages should extend this and provide field metadata, custom logic,
 * etc. This view is detached from Wizard layout when it is not the current
 * page. When it becomes the current page it is appended to Wizard layout and
 * render is called.
 *
 * If you want to use the default Wizard template, you'll need to load it in
 * `initialize`.
 *
 * For example,
 *
 *     initialize: function(options){
 *         //Load the default wizard page template, if you want to.
 *         options.template = app.template.getView("wizard-page");
 *         this._super("initialize", [options]);
 *     }
 *
 * @class View.Views.Base.WizardPageView
 * @alias SUGAR.App.view.views.BaseWizardPageView
 * @extends View.View
 */
({
	// Wizard-page View (base) 

    plugins: ['GridBuilder', 'ErrorDecoration'],

    events: {
        'click [name=previous_button]:not(.disabled)': 'previous',
        'click [name=next_button]:not(.disabled)': 'next'
    },
    /**
     * Current progress through wizard, updated automatically on each render.
     */
    progress: null,
    /**
     * Flags if all required fields have at least one character or not. This is
     * used to determine whether we enable or disable the wizard's next button.
     * @type {Boolean}
     */
    areAllRequiredFieldsNonEmpty: false,
    /**
     * Initialize the wizard controller and load header and footer partials
     * @param  {options} options the options
     */
    initialize: function(options){
        this.fieldsToValidate = this._fieldsToValidate(options.meta);
        Handlebars.registerPartial("wizard-page.header", app.template.get("wizard-page.header"));
        Handlebars.registerPartial("wizard-page.footer", app.template.get("wizard-page.footer"));
        this._super('initialize', [options]);
    },
    /**
     * Additionally update current progress and button status during a render.
     *
     * @override
     * @private
     */
    _render: function(){
        this._buildGridsFromPanelsMetadata(this.meta.panels);
        this.progress = this.layout.getProgress();
        this.percentComplete = this._getPercentageComplete();
        this.wizardCompleted = (this.progress.page === this.progress.lastPage)?true:false;
        this._super('_render');
        this.checkIfPageComplete();

        this.layout.trigger("wizard-page:render:complete");
        return this;
    },

    /**
     * We have to check if required fields are pre-filled once we've sync'd. For example,
     * user might have valid required field values (in which case we enable next button).
     */
    bindDataChange: function() {
        var self = this;
        if (this.model) {
            this.listenTo(this.model, "sync", function() {
                self.checkIfPageComplete();
            });
            _.each(this.fieldsToValidate, function(field) {
               if (field && field.required) {
                  self.listenTo(self.model, 'change:'+field.name, function() {
                      self.checkIfPageComplete();
                  });
               }
            });
        }
    },
    /**
     * Used to build our multi-column grid (user wizard is 2 col panel).
     * @param  {Object} panels the meta.panels
     * @protected
     */
    _buildGridsFromPanelsMetadata: function(panels) {
        _.each(panels, function(panel) {
            if (_.isFunction(this.getGridBuilder)) {
                var options = {
                        fields:      panel.fields,
                        columns:     panel.columns,
                        labels:      panel.labels,
                        labelsOnTop: true,
                    },
                    gridResults = this.getGridBuilder(options).build();
                panel.grid   = gridResults.grid;
            }
        }, this);
    },
    /**
     * Gets the percentage of pages complete. We consider being on a page as counting towards
     * completed pages (as this seems to be the norm) e.g. arriving at 1 of 3 results in 33%
     * @protected
     * @return {Number} Percentage complete as int
     */
    _getPercentageComplete: function() {
        return Math.floor(this.progress.page / this.progress.lastPage * 100);
    },
    /**
     * Called after render to update status of next/previous buttons.
     */
    updateButtons: function(){
        var prevBtn = this.getField("previous_button");
        if (prevBtn) {
            if (this.progress && this.progress.page > 1) {
                prevBtn.show();
            } else {
                prevBtn.hide();
            }
        }
        var nextBtn = this.getField("next_button");
        if (nextBtn) {
            nextBtn.setDisabled(!this.isPageComplete());
        }
    },

    /**
     * Called after initialization of the wizard page but just before it gets
     * added as a component to the Wizard layout.  Allows implementers to
     * control when a wizard page is included. Default implementation hides
     * page if it will not render because of ACL checks.
     *
     * @property {boolean|Function} showPage
     * @return {boolean} `true` to show the page.
     */
    showPage: function() {
        return app.acl.hasAccessToModel(this.action, this.model);
    },

    /**
     * We can advance the page once we know it is complete. Wizard page's
     * should override this function to provide custom validation logic.
     *
     * @return {boolean} `true` if this page is complete
     * @override
     */
    isPageComplete: function(){
        return true;
    },
    /**
     * Listen to changes on required fields. If all required fields contain
     * at least one character, we enable the next button. Implementers of
     * wizard pages may override this method to customize if desired, although
     * you may be able to just override `requiredTypesToPrevalidate`.
     *
     * See {@link View.Views.Base.UserWizardPageView}.
     *
     * @param {Object} evt the event
     */
    checkIfPageComplete: function(evt) {
        var self = this;
        this.areAllRequiredFieldsNonEmpty = true;
        _.each(this.fields, function(field) {
            if (!field.def.required) return;
            var value = field.$(field.fieldTag + ".required").val();
            var invalid = app.validation.requiredValidator(field.def, field.name, field.model, value);
            if (invalid) {
                self.areAllRequiredFieldsNonEmpty = false;
            }
        });
        this.updateButtons();
    },
    /**
     * Only validate fields pertinent to wizard page
     * @param  {Object} meta The meta
     * @return {Object} fields The fields to validate on
     * @private
     */
    _fieldsToValidate: function(meta) {
        meta = meta || {};
        var fields = {};
        _.each(_.flatten(_.pluck(meta.panels, "fields")), function(field) {
            fields[field.name] = field;
        });
        return fields;
    },
    /**
     * Next button pressed
     */
    next: function() {
        var self = this;
        if (this.progress.page !== this.progress.lastPage) {
            this.beforeNext(function(success) {
                if (success) {
                    self.progress = self.layout.nextPage();
                } else {
                    app.logger.debug("There was an unknown issue after calling beforeNext from wizard");
                }
            });
        } else {
            this.beforeFinish(function(success) {
                if (success) {
                    self.finish();
                } else {
                    app.logger.debug("There was an unknown issue after calling beforeFinish from wizard");
                }
            });
        }
    },
    /**
     * Do any actions like http requests, etc., before allowing user to proceed to next
     * page. Implementers should override this.
     * @param {Function} callback The callback to call once actions are completed
     * @return {boolean} Whether action was performed successfully or not
     */
    beforeNext: function(callback) {
        app.logger.debug("wizard's beforeNext called directly. Derived controllers should have overridden this!");
        callback(true);
    },
    /**
     * Do any actions like http requests, etc., before allowing user to proceed to finish
     * the wizard. Implementers should override this.
     * @param {Function} callback The callback to call once actions are completed
     * @return {boolean} Whether action was performed successfully or not
     */
    beforeFinish: function(callback){
        app.logger.debug("wizard's beforeFinish called directly. Derived controller should have overridden this!");
        callback(true);
    },
    /**
     * Previous button pressed
     */
    previous: function(){
        this.progress = this.layout.previousPage();
    },
    /**
     * Next button pressed and this is the last page. We need to PUT /me to indicate that the
     * "instance is configured". Calls finished on WizardLayout on complete.
     */
    finish: function(){
        this.layout.finished();
    }

}) },
"merge-duplicates": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for merge duplicates.
 *
 * @class View.Views.Base.MergeDuplicatesView
 * @alias SUGAR.App.view.views.BaseMergeDuplicatesView
 * @extends View.Views.Base.ListView
 */
({
	// Merge-duplicates View (base) 

    extendsFrom: 'ListView',

    plugins: ['SugarLogic', 'Editable', 'ErrorDecoration', 'MergeDuplicates'],

    events: {
        'click [data-mode=preview]' : 'togglePreview',
        'click [data-action=copy]' : 'triggerCopy',
        'click [data-action=delete]' : 'triggerDelete'
    },

    dataView: '',

    /**
     * Default settings used when none are supplied through metadata.
     *
     * Supported settings:
     * - {Number} merge_relate_fetch_concurrency Determining how many worker
     *   functions should be run in parallel for fetch.
     * - {Number} merge_relate_fetch_timeout Timeout for fetch related records
     *   call (milliseconds).
     * - {Number} merge_relate_fetch_limit Max number of records to fetch
     *   for related collection at a time.
     * - {Number} merge_relate_update_concurrency Determining how many worker
     *   functions should be run in parallel for update beans.
     * - {Number} merge_relate_update_timeout Timeout for update
     *   beans (milliseconds).
     * - {Number} merge_relate_max_attempt Max number of attemps for
     *   merge related.
     *
     * Example:
     * <pre><code>
     * // ...
     * 'settings' => array(
     *      'merge_relate_fetch_concurrency' => 2,
     *      'merge_relate_fetch_timeout' => 90000,
     *      'merge_relate_fetch_limit' => 20,
     *      'merge_relate_update_concurrency' => 4,
     *      'merge_relate_update_timeout' => 90000,
     *      'merge_relate_max_attempt' => 3,
     *      //...
     * ),
     * // ...
     * </code></pre>
     *
     * @property {Object}
     * @protected
     */
    _defaultSettings: {
        merge_relate_fetch_concurrency: 2,
        merge_relate_fetch_timeout: 90000,
        merge_relate_fetch_limit: 20,
        merge_relate_update_concurrency: 4,
        merge_relate_update_timeout: 90000,
        merge_relate_max_attempt: 3
    },

    /**
     * List of fields to generate the metadata on the fly.
     *
     * @property {Array} mergeFields
     */
    mergeFields: [],

    /**
     * @property {Object} rowFields
     */
    rowFields: {},

    /**
     * @property {Data.Bean} primaryRecord
     */
    primaryRecord: {},

    /**
     * @property {Boolean} [toggled=false]
     */
    toggled: false,

    /**
     * @property {Boolean} [isPreviewOpen=false]
     */
    isPreviewOpen: false,

    /**
     * Array of field defs keys that contain fields to populate.
     *
     * For some types of field we should populate additional fields
     * that can be determined from fields defs. E.g.
     * 1. if field type is 'relate' and 'parent'
     *     - def.id_name contains field name for id of related
     * 2. if field type is 'parent'
     *     - def.type_name contains field name for type of related
     *
     * @property {Array} relatedFieldsMap
     */
    relatedFieldsMap: ['id_name', 'type_name'],

    /**
     * Field names won't be mergeable.
     *
     * @property {Array} fieldNameBlacklist
     */
    fieldNameBlacklist: [
        'date_entered', 'date_modified', 'modified_user_id', 'created_by', 'deleted'
    ],

    /**
     * Field types won't be mergeable.
     *
     * @property {Array} fieldTypesBlacklist
     *
     * TODO: remove types that have properly implementation for merge interface
     */
    fieldTypesBlacklist: ['team_list', 'link', 'id', 'password'],

    /**
     * Links names won't be mergeable.
     * Those links will be not used in merge related records.
     *
     * @property {Array} relatesBlacklist
     */
    relatesBlacklist: [
        'assigned_user_link', 'modified_user_link', 'created_by_link',
        'teams', 'team_link', 'team_count_link',
        'archived_emails', 'email_addresses', 'email_addresses_primary',
        'forecastworksheets',
        'currencies'
    ],

    /**
     * Links names for certain module won't be mergeable.
     * Those links will be not used in merge related records for certain module.
     *
     * @property {Object} relatesBlacklistForModule
     */
    relatesBlacklistForModule: {
        Accounts: ['revenuelineitems'],
        Opportunities: ['accounts'],
        Leads: ['meetings_parent', 'calls_parent'],
        Prospects: ['tasks'],
        Bugs: ['project'],
        RevenueLineItems: ['campaign_revenuelineitems']
    },

    /**
     * @property {Object} mergeStat Contains stat after merging.
     */
    mergeStat: null,

    /**
     * Object used as context for merge duplicates view.
     *
     * {Backbone.Model} mergeProgressModel
     */
    mergeProgressModel: null,

    /**
     * @property {Backbone.Model} mergeRelatedCollection Contains related records to merge.
     */
    mergeRelatedCollection: null,

    /**
     * Attribute combos allowed to merge.
     *
     * @property {Array} validArrayAttributes
     */
    validArrayAttributes: [
        { type: 'datetimecombo', source: 'db' },
        { type: 'datetime', source: 'db' },
        { type: 'varchar', source: 'db' },
        { type: 'enum', source: 'db' },
        { type: 'multienum', source: 'db' },
        { type: 'text', source: 'db' },
        { type: 'date', source: 'db' },
        { type: 'time', source: 'db' },
        { type: 'currency', source: 'db', calculated: false },
        { type: 'int', source: 'db' },
        { type: 'long', source: 'db' },
        { type: 'double', source: 'db' },
        { type: 'float', source: 'db' },
        { type: 'short', source: 'db' },
        { dbType: 'varchar', source: 'db' },
        { dbType: 'double', source: 'db' },
        { type: 'relate' },
        { type: 'parent' },
        { type: 'image' },
        { type: 'teamset' },
        { type: 'email' },
        { type: 'tag' }
    ],

    /**
     * Types of fields that can be processed
     * in {@link View.Views.BaseMergeDuplicatesView#flattenFieldsets}.
     * @property {Array} flattenFieldTypes
     */
    flattenFieldTypes: ['fieldset', 'fullname'],

    /**
     * Variable to store generated values for some types of fields (e.g. teamset).
     * @property {Object} generatedValues
     */
    generatedValues: null,

    /**
     * Variable to store a copy of primary record's model for showing it
     * on preview panel
     * @property {Backbone.Model} previewModel Contains copy of primary record.
     */
    previewModel: {},

    /**
     * @inheritdoc
     *
     * Initialize merge collection as collection of selected records and
     * initialise fields that can be used in merge.
     */
    initialize: function(options) {
        this._initializeMergeFields(options.module);
        this._super('initialize', [options]);
        this._initSettings();
        this._initializeMergeCollection(this._prepareRecords());

        this.action = 'list';
        this._delegateEvents();
    },

    /**
     * Add event listeners
     *
     * @private
     */
    _delegateEvents: function() {
        this.layout.on('mergeduplicates:save:fire', this.triggerSave, this);

        app.events.on('preview:open', _.bind(this._onPreviewToggle, this, true), this);
        app.events.on('preview:close', _.bind(this._onPreviewToggle, this, false), this);
        this.on('render', this._showAlertIfIdentical, this);
    },

    /**
     * Initialize settings, default settings are used when none are supplied
     * through metadata.
     *
     * @return {View.Views.BaseMergeDuplicatesView} Instance of this view.
     * @protected
     */
    _initSettings: function() {

        var configSettings = app.config.mergeDuplicates && {
            merge_relate_fetch_concurrency: app.config.mergeDuplicates.mergeRelateFetchConcurrency,
            merge_relate_fetch_timeout: app.config.mergeDuplicates.mergeRelateFetchTimeout,
            merge_relate_fetch_limit: app.config.mergeDuplicates.mergeRelateFetchLimit,
            merge_relate_update_concurrency: app.config.mergeDuplicates.mergeRelateUpdateConcurrency,
            merge_relate_update_timeout: app.config.mergeDuplicates.mergeRelateUpdateTimeout,
            merge_relate_max_attempt: app.config.mergeDuplicates.mergeRelateMaxAttempt
        };

        this._settings = _.extend(
            this._defaultSettings,
            configSettings,
            this.meta && this.meta.settings || {}
        );
        return this;
    },

    /**
     * Standardize primary record from list of records.
     *
     * Put primary at the beginning of records.
     * This is useful primarily to know which record will be the primary
     * in the collection to be pulled later. We do not use the input models.
     *
     * @return {Array} records.
     * @private
     */
    _prepareRecords: function() {
        var records = this._validateModelsForMerge(this.context.get('selectedDuplicates'));

        this.setPrimaryRecord(this._findPrimary(records));
        return records;
    },

    /**
     * Find primary model from models chosen for merge.
     *
     * If primary model has no access to edit it finds first model that can
     * be edited and sets it as primary.
     *
     * @param {Data.Bean[]} models Set of models to merge.
     * @return {Data.Bean} Primary model
     * @protected
     */
    _findPrimary: function(models) {
        var primary = this.context.has('primaryRecord') &&
            _.findWhere(models, {id: this.context.get('primaryRecord').id});

        return primary || _.find(models, function(model) {
            return app.acl.hasAccessToModel('edit', model);
        });
    },

    /**
     * Initialize fields for merge.
     *
     * Creates filtered set of model's fields that can be merged.
     *
     * @param {string} module Module to retrieve metadata from.
     * @protected
     */
    _initializeMergeFields: function(module) {
        var meta = app.metadata.getView(module, 'record');
        var fieldDefs = app.metadata.getModule(module).fields;

        this.mergeFields = _.chain(meta.panels)
            .map(function(panel) {
                return this.flattenFieldsets(panel.fields);
            }, this)
            .flatten()
            .filter(function(field) {
                return field.name && this.validMergeField(fieldDefs[field.name]);
            }, this)
            .value();
    },

    /**
     * Initialize collection for merge.
     *
     * Enforce the order of the ids so that primaryRecord always appears first
     * and only retrieve the records specified.
     * @param {Array} records
     * @private
     */
    _initializeMergeCollection: function(records) {
        var ids = (_.pluck(records, 'id'));

        if (this.collection) {
            this.collection.filterDef = [];
            this.collection.filterDef.push({ 'id': { '$in' : ids}});
            this.collection.comparator = function(model) {
                return _.indexOf(ids, model.get('id'));
            };
        }
    },

    /**
     * Handler for save merged records event.
     *
     * Shows confirmation message and calls
     * {@link View.Views.BaseMergeDuplicatesView#_savePrimary} on confirm.
     */
    triggerSave: function() {
        var self = this,
            alternativeModels = _.without(this.collection.models, this.primaryRecord),
            alternativeModelNames = [];

        _.each(alternativeModels, function(model) {
            alternativeModelNames.push(app.utils.getRecordName(model));
        }, this);

        this.clearValidationErrors(this.getFieldNames());

        app.alert.show('merge_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_MERGE_DUPLICATES_CONFIRM') + ' ' +
                // FIXME needs to be removed on SC-4494.
                Handlebars.Utils.escapeExpression(alternativeModelNames.join(', ')) + '. ' +
                app.lang.get('LBL_MERGE_DUPLICATES_PROCEED'),
            onConfirm: _.bind(this._savePrimary, this)
        });
    },

    /**
     * Prevent required and dependent fields from stopping save merge action
     * by setting required flag to false on fields.
     *
     */
    preventRequiredFieldsValidation: function() {
        // Get all primary record fields.
        var allPrimaryRecordFields = _.filter(this.primaryRecord.fields, function(primaryField) {
            // Return if selected primary field is required.
            return primaryField.required;
        });
        _.each(allPrimaryRecordFields, function(primaryField) {
            // this.rowFields[this.primaryRecord.get('id')] return the record fields from all available fields.
            _.each(this.rowFields[this.primaryRecord.get('id')], function(field) {
                // SugarLogic disables dependent field since dependency condition is not met.
                if (primaryField.name === field.name && primaryField.required !== field.def.required) {
                    // SugarLogic is not updating this.primaryRecord fields since
                    // this is just a data representation of selected values.
                    // Sync primaryField.required flag with the modified SugarLogic field.def.required since
                    // required and dependent fields condition is not met.
                    primaryField.required = field.def.required;
                }
            }, this);
        }, this);
    },

    /**
     * Saves primary record and triggers `mergeduplicates:primary:saved` event on success.
     * Before saving triggers also `duplicate:unformat:field` event.
     *
     * @private
     */
    _savePrimary: function() {
        var self = this;
        var fields = this.getFieldNames().filter(function(field) {
            return app.acl.hasAccessToModel('edit', this.primaryRecord, field);
        }, this);
        var headerpaneView = this.layout.getComponent('merge-duplicates-headerpane');

        headerpaneView.getField('cancel_button').setDisabled(true);

        this.primaryRecord.trigger('duplicate:unformat:field');
        // Prevent required and dependent fields from stopping save merge action.
        this.preventRequiredFieldsValidation();

        this.primaryRecord.save({}, {
            fieldsToValidate: fields,
            success: function() {
                // Trigger format fields again, because they can come different
                // from the server (e.g: only teams checked will be in the
                // response, and we still want to display unchecked teams on the
                // view)
                self.primaryRecord.trigger('duplicate:format:field');
                self.primaryRecord.trigger('mergeduplicates:primary:saved');
            },
            error: function(model, error) {
                if (error.status === 409) {
                    app.utils.resolve409Conflict(error, self.primaryRecord, function(model, isDatabaseData) {
                        if (model) {
                            if (isDatabaseData) {
                                self.resetRadioSelection(model.id);
                                headerpaneView.getField('cancel_button').setDisabled(false);
                            } else {
                                self._savePrimary();
                            }
                        }
                    });
                } else {
                    headerpaneView.getField('cancel_button').setDisabled(false);
                }
            },
            lastModified: this.primaryRecord.get('date_modified'),
            showAlerts: true,
            viewed: true
        });
    },

    /**
     * Removes merged models and triggers `mergeduplicates:primary:merged` on success.
     *
     * We need to wait until all models are removed from server
     * to properly reload records view. Runs destroy methods in parallel
     * and triggers event after all requests have finished.
     *
     * @private
     */
    _removeMerged: function() {
        var self = this,
            models = _.without(this.collection.models, this.primaryRecord);

        async.forEach(models, function(model, callback) {
            self.collection.remove(model);
            model.destroy({success: function() {
                callback.call();
            }});
        }, function() {
            self.primaryRecord.trigger('mergeduplicates:primary:merged');
            self.hideMainPreviewPanel();
        });
    },

    /**
     * Hide the preview panel, from the main drawer
     */
    hideMainPreviewPanel: function() {
        //Get main drawer
        var $main_drawer = app.$contentEl.children().first();
        if (!_.isUndefined($main_drawer) && $main_drawer.hasClass('drawer inactive')) {
            var layout = $main_drawer.find('.sidebar-content');
            layout.find('.side-pane').addClass('active');
            layout.find('.dashboard-pane').show();
            layout.find('.preview-pane').removeClass('active');
        }
    },
    /**
     * @inheritdoc
     *
     * Override fetching fields names. Use fields that are allowed to merge only.
     *
     * Add additional fields for cases:
     * 1. field type is 'relate' and 'parent' (def.id_name)
     *     - def.id_name contains field name for id of related
     * 2. field type is 'parent' (def.type_name)
     *     - def.type_name contains field name for type of related
     *
     * @return {Array} array of field names.
     */
    getFieldNames: function() {
        var fields = [],
            fieldDefs = app.metadata.getModule(this.module).fields;

        _.each(this.mergeFields, function(mergeField) {
            var def = fieldDefs[mergeField.name];
            _.each(this.relatedFieldsMap, function(relatedField) {
                if (!_.isUndefined(def[relatedField]) && !_.isUndefined((fieldDefs[def[relatedField]].name))) {
                    fields.push(fieldDefs[def[relatedField]].name);
                }
            });
            var related_fields = mergeField.related_fields || def.related_fields || undefined;
            if (!_.isUndefined(related_fields) && _.isArray(related_fields)) {
                _.each(related_fields, function(rField) {
                    fields.push(rField);
                });
            }
            fields.push(def.name);
        }, this);
        return _.unique(fields);
    },

    /**
     * Create metadata for panels.
     *
     * Team sets will have a special metadata setup to match the height in all
     * records shown (match height).
     *
     * The fields are sorted by difference of values, showing first the ones
     * that are different among all records and then the ones that are equal.
     *
     * @param {Array} fields The list of fields for the module.
     * @return {Object} The metadata for the view template.
     * @private
     */
    _generateMetadata: function(fields) {
        this.generatedValues = {
            teamsets: []
        };

        _.each(fields, function(field) {
            if (field.type === 'teamset') {

                var teams = {};
                this.collection.each(function(model) {
                    _.each(model.get(field.name), function(team) {
                        teams[team.id] = team;
                    });
                });

                this.generatedValues.teamsets[field.name] = _.values(teams);
                field.maxHeight = _.size(teams);
                field.noRadioBox = true;
            }
        }, this);

        var models = this.collection.without(this.primaryRecord);
        fields = _.sortBy(fields, function(field) {
            return _.every(models, function(model) {
                return _.isEqual(this.primaryRecord.get(field.name), model.get(field.name));
            }, this);
        }, this);

        return {
            type: 'list',
            panels: [
                {
                    fields: fields
                }
            ]
        };
    },

    /**
     * Checks if all values are the same among all models.
     *
     * Compares the field value from primary model with values from other
     * models and returns `false` if it finds 1 field that isn't equal across
     * all models.
     *
     * @param {Data.Bean} primary The model chosen as primary.
     * @param {Data.Bean[]} models The array of models to compare with.
     * @return {Boolean} Is field value the same among all models.
     *
     * @private
     */
    _isSimilar: function(primary, models) {
        return _.every(models, function(model) {
            var modelFields = this.rowFields[model.id],
                primaryFields = this.rowFields[primary.id];

            return _.every(modelFields, function(field, index) {
                return field.equals(primaryFields[index]);
            }, this);
        }, this);
    },

    /**
     * Utility method for determining if a field is mergeable from its def.
     *
     * @param {Object} fieldDef Defs of validated field.
     * @return {Boolean} Is this field a valid field to merge?
     */
    validMergeField: function(fieldDef) {

        if (!fieldDef ||
            fieldDef.auto_increment === true ||
            !this._validMergeFieldName(fieldDef) ||
            !this._validMergeFieldType(fieldDef) ||
            this._isDuplicateMergeDisabled(fieldDef)
        ) {
            return false;
        }

        if (this._isDuplicateMergeEnabled(fieldDef)) {
            return true;
        }

        return this._validMergeFieldAttributes(fieldDef);
    },

    /**
     * Validate field to merge by name.
     *
     * @param {Object} defs Defs of validated field.
     * @return {Boolean}
     * @private
     */
    _validMergeFieldName: function(defs) {
        return !_.contains(this.fieldNameBlacklist, defs.name);
    },

    /**
     * Validate field to merge by type.
     *
     * @param {Object} defs Defs of validated field.
     * @return {Boolean}
     * @private
     */
    _validMergeFieldType: function(defs) {
        return !_.contains(this.fieldTypesBlacklist, defs.type);
    },

    /**
     * Checks if duplicate_merge is disabled in field's defs.
     *
     * @param {Object} defs Defs of validated field.
     * @return {Boolean}
     * @private
     */
    _isDuplicateMergeDisabled: function(defs) {
        if (!_.isUndefined(defs.duplicate_merge) &&
            (defs.duplicate_merge === 'disabled' ||
                defs.duplicate_merge === false)
        ) {
            return true;
        }
        return false;
    },

    /**
     * Checks if duplicate_merge is enabled in field's defs.
     *
     * @param {Object} defs Defs of validated field.
     * @return {Boolean}
     * @private
     */
    _isDuplicateMergeEnabled: function(defs) {
        if (!_.isUndefined(defs.duplicate_merge) &&
            (defs.duplicate_merge === 'enabled' ||
                defs.duplicate_merge === true)
        ) {
            return true;
        }
        return false;
    },

    /**
     * Validate field to merge by attributes.
     *
     * Uses `this.validArrayAttributes` hash to validate attributes.
     * Also checks if field is calculated and if it is returns `false`.
     *
     * @param {Object} defs Defs of validated field.
     * @return {Boolean}
     * @private
     */
    _validMergeFieldAttributes: function(defs) {
        // normalize fields that might not be there
        defs.dbType = defs.dbType || defs.type;
        defs.source = defs.source || 'db';
        defs.calculated = defs.calculated || false;

        if (defs.calculated !== false) {
            return false;
        }

        // compare to values in the list of acceptable attributes
        return _.some(this.validArrayAttributes, function(o) {
            return _.chain(o)
                .keys()
                .every(function(key) {
                    return o[key] === defs[key];
                })
                .value();
        });
    },

    /**
     * Utility method for taking a fieldlist with possible nested fields,
     * and returning a flat array of fields.
     *
     * @param {Array} defs Unprocessed list of fields from metadata.
     * @return {Array} Fields flat list of fields.
     */
    flattenFieldsets: function(defs) {
        var fieldsetFilter = function(field) {
                return (field.type &&
                    _.isArray(field.fields) &&
                    _.contains(this.flattenFieldTypes, field.type));
            },
            fields = _.reject(defs, fieldsetFilter, this),
            fieldsets = _.filter(defs, fieldsetFilter, this),
            sort = _.chain(defs).pluck('name').value() || [],
            sortTemp = [];

        while (fieldsets.length) {
            //collect fields' names from fieldset
            var fieldsNames = _.chain(fieldsets)
                .pluck('fields')
                .flatten()
                .pluck('name')
                .value();
            sortTemp = [];
            // create new sort sequence
            _.each(sort, function(value) {
                if (value === _.first(fieldsets).name) {
                    sortTemp = sortTemp.concat(fieldsNames);
                } else {
                    sortTemp = sortTemp.concat(value);
                }
            }, this);
            sort = sortTemp;
            // fieldsets need to be broken into component fields
            fieldsets = _.chain(fieldsets)
                .pluck('fields')
                .flatten()
                .value();

            // now collect the raw fields from the press
            fields = fields.concat(_.reject(fieldsets, fieldsetFilter));

            // do we have any more fieldsets to squash?
            fieldsets = _.filter(fieldsets, fieldsetFilter);
        }
        // sorting fields acording to sequence
        fields = _.sortBy(fields, function(value, index) {
            var result = index,
                name = value;
            if (!_.isUndefined(value.name)) {
                name = value.name;
                _.each(sort, function(valueSort, indexSort) {
                    if (valueSort == name) {
                        result = indexSort;
                    }
                });
            }
            return result;
        });
        return fields;
    },

    /**
     * Event handler for `preview:open` and `preview:close` events.
     *
     * @param {boolean} open Flag indicating the desired state of the preview
     * @deprecated Since 7.8. Will be removed in 7.9.
     */
    onPreviewToggle: function(open) {
        app.logger.warn('`View.Views.Base.MergeDuplicatesView#onPreviewToggle` has been deprecated since 7.8 and' +
            ' will be removed in 7.9.');
        this.isPreviewOpen = open;
        this.$('[data-mode=preview]').toggleClass('on', open);
    },

    /**
     * Event handler for `preview:open` and `preview:close` events.
     *
     * @param {boolean} open Flag indicating the desired state of the preview
     * @deprecated Since 7.8. Will be removed in 7.9.
     * @private
     */
    _onPreviewToggle: function(open) {
        this.isPreviewOpen = open;
        this.$('[data-mode=preview]').toggleClass('on', open);
    },

    /**
     * Toggles a Preview for the primary record.
     *
     * @param {Event} evt Mouse click event.
     */
    togglePreview: function(evt) {
        if (this.isPreviewOpen) {
            app.events.trigger('preview:close');
        } else {
            this.updatePreviewRecord(this.primaryRecord);
        }
    },

    /**
     * Creates the preview panel for the model in question.
     *
     * @param {Data.Bean} model Model to preview.
     */
    updatePreviewRecord: function(model) {
        var module = model.module || model.get('module');
        var previewCollection;

        // FIXME PX-15: Hack-fix for re-enabling sync on preview panel launch
        // We had to get the delta for primary record from current state until
        // now and reapply all of them after preview is synced
        if (_.isEmpty(this.previewModel) || this.previewModel.get('id') !== model.get('id')) {
            this.previewModel = app.data.createBean(module, model.toJSON());
            previewCollection = app.data.createBeanCollection(module, [this.previewModel]);

            this.previewModel.setOption({
                success: function(changedModel) {
                    var changedAttributes = model.changedAttributes(model.getSynced());
                    changedModel.set(_.mapObject(changedAttributes, function(value, fieldName) {
                        return model.get(fieldName);
                    }, this));
                }
            });
        }

        app.events.trigger('preview:render', this.previewModel, previewCollection, false);
        app.events.trigger('preview:open', true);
    },

    /**
     * Updates the view's title.
     *
     * @param {String} title
     */
    updatePrimaryTitle: function(title) {
        this.$('[data-container=primary-title]').text(title);
    },

    /**
     * @inheritdoc
     *
     * Add additional fields for specific types like 'parent' and 'relate'.
     * Setup primary model editable.
     * Setup drag-n-drop functionality.
     */
    _renderHtml: function() {
        this.meta = this._generateMetadata(this.mergeFields);

        this._super("_renderHtml");

        this.rowFields = {};
        _.each(this.fields, function(field) {
            if (field.model.id && _.isUndefined(field.parent)) {
                this.rowFields[field.model.id] = this.rowFields[field.model.id] || [];
                this.rowFields[field.model.id].push(field);
            }
        }, this);
        this.setPrimaryEditable(this.primaryRecord.id);
        this.setDraggable();
    },

    /**
     * Shows confirmation message if records are identical.
     * @protected
     */
    _showAlertIfIdentical: function() {
        if (!this.collection.length) {
            return;
        }

        var self = this,
            alternatives = this.collection.without(this.primaryRecord);

        if (this._isSimilar(this.primaryRecord, alternatives)) {
            app.alert.show('merge_confirmation_identical', {
                level: 'confirmation',
                messages: app.lang.get('TPL_MERGE_DUPLICATES_IDENTICAL', this.module),
                onConfirm: function() {
                    self.layout.trigger('mergeduplicates:save:fire');
                }
            });
        }
    },

    /**
     * Set ups label of primary record as draggable using jQuery UI Sortable plugin.
     */
    setDraggable: function() {
        var self = this,
        mergeContainer = this.$('[data-container=merge-container]');
        mergeContainer.find('[data-container=primary-label]').sortable({
            connectWith: self.$('[data-container=primary-label]'),
            appendTo: mergeContainer,
            axis: 'x',
            disableSelection: true,
            cursor: 'move',
            placeholder: 'primary-lbl-placeholder-span',
            start: function(event, ui) {
                self.$('[data-container=primary-label]').addClass('primary-lbl-placeholder');
            },
            stop: _.bind(self._onStopSorting, self)
        });

        mergeContainer.find('[data-container=primary-label].disabled').sortable(
            'option', 'disabled', true
        );
    },

    /**
     * Handler for jQuery UI Sortable plugin event triggered when sorting has stopped.
     *
     * Set ups choosed record as primary and make it editable.
     * If old primary record is changed shows confirmation message to confirm action.
     *
     * @param {Event} event
     * @param {Object} ui
     */
    _onStopSorting: function(event, ui) {
        var self = this,
            droppedTo = ui.item.parents('[data-record-id]');

        self.$('[data-container=primary-label]').removeClass('primary-lbl-placeholder');
        // short circuit if we didn't land on anything
        if (droppedTo.length === 0) {
            self.$('[data-container=primary-label]').sortable('cancel');
            return;
        }

        if (self.primaryRecord && self.primaryRecord.id !== droppedTo.data('record-id')) {
            var changedAttributes = self.primaryRecord.changedAttributes(
                self.primaryRecord.getSynced()
            );
            if (!_.isEmpty(changedAttributes)) {
                app.alert.show('change_primary_confirmation', {
                    level: 'confirmation',
                    messages: app.lang.get('LBL_MERGE_UNSAVED_CHANGES'),
                    onConfirm: function() {
                        self.primaryRecord.revertAttributes();
                        self.setPrimaryEditable(droppedTo.data('record-id'));
                    },
                    onCancel: function() {
                        self.$('[data-record-id=' + self.primaryRecord.get('id') + '] ' +
                            '[data-container=primary-label]').sortable('cancel');
                    }
                });
                return;
            }
            self.setPrimaryEditable(droppedTo.data('record-id'));
        }
    },

    /**
     * Enable/disable radio buttons according to ACL access to fields for all models.
     */
    checkCopyRadioButtons: function() {
        if (!this.primaryRecord) {
            return;
        }
        _.each(this.mergeFields, function(field) {
            var model = this.primaryRecord,
                element = this.$('[data-field-name=' + field.name + '][data-record-id=' + model.id + ']'),
                others = this.$('[data-field-name=' + field.name + '][data-record-id!=' + model.id + ']'),
                editAccess = app.acl.hasAccessToModel('edit', model, field.name);

            element.prop('disabled', !editAccess || field.readonly);

            if (!editAccess || field.readonly) {
                others.prop('disabled', true);
                return;
            }

            _.each(others, function(domElement) {
                var el = $(domElement),
                    readAccess = app.acl.hasAccessToModel(
                        'read',
                        this.collection.get(el.data('record-id')),
                        field.name
                    );
                el.prop('disabled', !readAccess);
            }, this);
        }, this);
    },

    /**
     * Prepare primary record for edit mode.
     *
     * Toggle primary record in edit mode, setup panel title and
     * update preview panel if it is opened. Make sure we get the model in
     * the collection, with all fields in it. If id parameter is provided
     * switch primary record to new model before and revert old primary record
     * to standard record. If new model is same as primary no action is taken.
     * Triggers `duplicate:format:field` before toggle fields.
     *
     * @param {String} [id] The record representing the new primary model.
     */
    setPrimaryEditable: function(id) {

        var oldPrimaryRecord = this.primaryRecord,
            newPrimaryRecord = this.collection.get(id || null);

        if (!_.isUndefined(newPrimaryRecord) && newPrimaryRecord !== oldPrimaryRecord) {
            this.setPrimaryRecord(newPrimaryRecord);
        }

        if (!this.primaryRecord) {
            return;
        }

        if (oldPrimaryRecord && oldPrimaryRecord !== this.primaryRecord) {
            this.toggleFields(this.rowFields[oldPrimaryRecord.id], false);
        }

        this.primaryRecord.trigger('duplicate:format:field');

        this.toggleFields(this.rowFields[this.primaryRecord.id], true);
        this.updatePrimaryTitle(app.utils.getRecordName(this.primaryRecord));
        if (this.isPreviewOpen) {
            this.updatePreviewRecord(this.primaryRecord);
        }
        this.$('.primary-edit-mode').removeClass('primary-edit-mode');
        this.$('[data-record-id=' + this.primaryRecord.id + ']').addClass('primary-edit-mode');
        this.resetRadioSelection(this.primaryRecord.id);
        this.checkCopyRadioButtons();
        this._disableRemovePrimary();

        if (this.collection.length <= 2) {
            this.$('[data-action=delete]').css('visibility', 'hidden');
        }
    },

    /**
     * Checks can primary record be removed or not and if not hides remove control.
     *
     * Primary record cannot be removed is there is not other model with edit access.
     *
     * @protected
     */
    _disableRemovePrimary: function() {
        var disableRemovePrimary = !_.some(this.collection.models, function(model) {
            return model !== this.primaryRecord && app.acl.hasAccessToModel('edit', model);
        }, this);

        this.$('[data-record-id=' + this.primaryRecord.get('id') + ']')
            .find('[data-action=delete]')
            .css('visibility', (disableRemovePrimary ? 'hidden' : 'visible'));
    },

    resetRadioSelection: function(modelId) {
        this.$('[data-record-id=' + modelId + '] input[type=radio]').attr('checked', true);
    },

    /**
     * Set a given model as primary.
     *
     * If the given module is already the primary record no action will be taken.
     * This will toggle off all the events of the old primary record and
     * setup the events for the new model. It will also setup primary record
     * 'change' event handler to updates title of panel,
     * 'mergeduplicates:primary:saved' to remove others models and
     * 'mergeduplicates:primary:merged' event handler to close drawer.
     *
     * @param {Data.Bean} model Primary model.
     */
    setPrimaryRecord: function(model) {
        if (this.primaryRecord === model) {
            return;
        }

        if (this.primaryRecord instanceof Backbone.Model) {
            this.primaryRecord.off(null, null, this);
        }

        this.primaryRecord = model;

        this.primaryRecord.on('change', function(model) {
            // Reapply every change on preview model
            if (!_.isEmpty(this.previewModel)) {
                var changedAttributes = this.primaryRecord.changedAttributes();

                this.previewModel.set(_.mapObject(changedAttributes, function(value, fieldName) {
                    return this.primaryRecord.get(fieldName);
                }, this));
            }

            this.updatePrimaryTitle(app.utils.getRecordName(this.primaryRecord));
        }, this);

        this.primaryRecord.on('mergeduplicates:primary:saved', function() {
            this._mergeRelatedRecords();
        }, this);

        this.primaryRecord.on('mergeduplicates:related:merged', function() {
            this._onRelatedMerged();
        }, this);

        this.primaryRecord.on('mergeduplicates:primary:merged', function() {
            app.alert.dismiss('mergeduplicates_merging');
            this._showSuccessMessage();
            app.drawer.close(true, this.primaryRecord);
        }, this);

        this.primaryRecord.on('validation:complete', function(isValid) {
            if (!isValid) {
                var headerpaneView = this.layout.getComponent('merge-duplicates-headerpane');
                headerpaneView.getField('cancel_button').setDisabled(false);
            }
        }, this);
    },

    /**
     * Event handler for radio box controls.
     *
     * Before copy value from model or restore value
     * triggers `before duplicate:field` event.
     *
     * @param {Event} evt Mouse click event.
     */
    triggerCopy: function(evt) {
        var currentTarget = this.$(evt.currentTarget),
            recordId = currentTarget.data('record-id'),
            fieldName = currentTarget.data('field-name'),
            fieldDefs = app.metadata.getModule(this.module).fields,
            model;

        if (_.isUndefined(this.primaryRecord) ||
            _.isUndefined(this.primaryRecord.id) ||
            _.isUndefined(recordId) ||
            _.isUndefined(fieldName) ||
            _.isUndefined(fieldDefs[fieldName])
        ) {
            return;
        }

        model = this.collection.get(recordId);
        if (_.isUndefined(model)) {
            return;
        }

        if (!app.acl.hasAccessToModel('edit', this.primaryRecord, fieldName) ||
            !app.acl.hasAccessToModel('read', model, fieldName)) {
            return;
        }

        var data = currentTarget.data();
        // Unlike data(), attr() doesn't perform type conversions if possible.
        // This is good because recordItemId can sometimes be numeric but must be type of string always.
        data.recordItemId = currentTarget.attr('data-record-item-id');
        data = _.extend({}, data, {
            checked: currentTarget.prop('type') === 'checkbox' ?
                currentTarget.prop('checked') : true
        });
        if (this.triggerBefore('duplicate:field', {model: model, data: data}) === false) {
            return;
        }

        if (model === this.primaryRecord) {
            this.revert(fieldName);
        } else {
            this.copy(fieldName, model);
        }
    },

    /**
     * Copy value from selected field to primary record.
     *
     * Setups new value current field and additional fields.
     * Also triggers `duplicate:field` event on the primary model.
     *
     * @param {String} fieldName Name of field to copy.
     * @param {Data.Bean} model Model to copy from.
     */
    copy: function(fieldName, model) {
        this._setRelatedFields(fieldName, model);
        this.primaryRecord.set(fieldName, model.get(fieldName));

        this.primaryRecord.trigger(
            'duplicate:field:' + fieldName,
            model !== this.primaryRecord ? model : null,
            model !== this.primaryRecord ? model.get(fieldName) : null
        );
    },

    /**
     * Revert value of field to latest sync state.
     *
     * Revert original values.
     * Also triggers `duplicate:field` event on the primary model.
     *
     * @param {String} fieldName Name of field to revert.
     */
    revert: function(fieldName) {
        var syncedAttributes = this.primaryRecord.getSynced();

        this._setRelatedFields(fieldName, this.primaryRecord, true);
        this.primaryRecord.set(
            fieldName,
            !_.isUndefined(syncedAttributes[fieldName]) ?
                syncedAttributes[fieldName] :
                this.primaryRecord.get(fieldName)
        );

        this.primaryRecord.trigger(
            'duplicate:field:' + fieldName,
            this.primaryRecord,
            this.primaryRecord.get(fieldName)
        );
    },

    /**
     * Event handler for model delete button.
     *
     * Shows alert message to confirm model removing.
     *
     * @param {Event} evt Mouse click event.
     */
    triggerDelete: function(evt) {
        var recordId = this.$(evt.currentTarget).closest('[data-record-id]').data('recordId'),
            model = this.collection.get(recordId),
            self = this;
        if (this.collection.length <= 2 || !recordId || !model) {
            return;
        }

        if (model === this.primaryRecord) {
            var allow = _.some(this.collection.models, function(model) {
                return model !== this.primaryRecord && app.acl.hasAccessToModel('edit', model);
            }, this);
            if (!allow) {
                return;
            }
        }
        app.alert.show('record-delete-confirm', {
            level: 'confirmation',
            messages: app.lang.get('LBL_MERGE_DUPLICATES_REMOVE', this.module),
            onConfirm: function() {
                self.deleteFromMerge(model);
                self.$('[data-container="merge-container"]').attr('class', function(){
                    return $(this).attr('class').replace(
                        /\b(num\-cols\-)(\d+)\b/g,
                        '$1' + self.collection.length
                    );
                });
            }
        });
    },

    /**
     * Delete model from collection to merge.
     *
     * If removed model is primary find first model in
     * collection an setup it as primary.
     *
     * @param {Data.Bean} model Model to remove.
     */
    deleteFromMerge: function(model) {

        this.collection.remove(model, {silent: true});

        var selModelEl = '[data-container=merge-record][data-record-id=' + model.get('id') + ']';

        if (model === this.primaryRecord) {
            var primary = this._findPrimary(this.collection.models),
                selNewPrimaryEl = '[data-container=merge-record][data-record-id=' + primary.get('id') + ']',
                primaryEl = this.$(selNewPrimaryEl).find('[data-container=primary-label]'),
                primaryLabel = this.$(selModelEl).find('[data-container=primary-label-span]');

            primaryEl.append(primaryLabel);
            this.setPrimaryEditable(primary.get('id'));

        }

        this.$(selModelEl).remove();

        if (this.collection.length <= 2) {
            this.$('[data-action=delete]').css('visibility', 'hidden');
        }
    },

    /**
     * Copy additional fields to primary model.
     *
     * Cases:
     * 1. field type is 'relate' and 'parent' (def.id_name)
     *     - def.id_name contains field name for id of related.
     * 2. field type is 'parent' (def.type_name)
     *     - def.type_name contains field name for type of related.
     *
     * @param {String} fieldName Name of main field to copy.
     * @param {Data.Bean} model Model from which values should be coped.
     * @param {Boolean} synced Use last synced attributes of model for copy or not.
     * @protected
     */
    _setRelatedFields: function(fieldName, model, synced) {
        synced = synced || false;

        var fieldDefs = app.metadata.getModule(this.module).fields;
            defs = fieldDefs[fieldName],
            syncedAttributes = synced ? model.getSynced() : {},
            fields = _.union(defs.populate_list, defs.related_fields);

        _.each(this.relatedFieldsMap, function(field) {
            if (!_.isUndefined(defs[field]) && !_.isUndefined(fieldDefs[defs[field]].name)) {
                fields.push(fieldDefs[defs[field]].name);
            };
        });

        // FIXME: populate_list is only available on related fields plus
        // related_fields is only available on fieldsets, so this logic should
        // be implemented on field side thus calling a method like
        // this.fields[fieldName].revertTo(model); here SC-3467
        _.each(fields, function(relatedField) {
            if (_.isUndefined(fieldDefs[relatedField])) {
                return;
            }

            this.primaryRecord.set(
                relatedField,
                !_.isUndefined(syncedAttributes[relatedField]) ?
                    syncedAttributes[relatedField] :
                    model.get(relatedField)
            );
        }, this);
    },

    /**
     * Returns defs of bean fields that are valid link for merge related records.
     *
     * @return {Object[]} Defs of fields.
     * @protected
     */
    _getRelatedLinks: function() {
        var fieldDefs = app.metadata.getModule(this.module).fields,
            excludedLinks = this._getExcludedRelatedLinks();

        return _.filter(fieldDefs, function(field) {
            return !_.isUndefined(field.type) && field.type === 'link' &&
                !_.contains(excludedLinks, field.name) &&
                this._isValidRelateLink(field) &&
                this._isValidRelateLinkType(field);
        }, this);
    },

    /**
     * Returns names of links that has been processed using `relate` fields on UI.
     *
     * @return {String[]} Names of links.
     * @protected
     */
    _getExcludedRelatedLinks: function() {
        var excludedLinks = [],
            fieldDefs = app.metadata.getModule(this.module).fields;

        _.each(this.mergeFields, function(mergeField) {
            var def = fieldDefs[mergeField.name];
            if (def.type === 'relate' && !_.isUndefined(def.link)) {
                excludedLinks.push(def.link);
            }
        }, this);

        return excludedLinks;
    },

    /**
     * Check is certain link valid for merge related records.
     *
     * Returns false in cases:
     * 1. link name isn't defined
     * 2. link module doesn't exist in our metadata
     * 3. link is in global black list
     * 4. link is in black list for current module
     * 5. merge is disabled in link defs
     *
     * @param {Object} link Defenition of link field.
     * @return {boolean} Is link valid for merge related.
     *
     * @protected
     */
    _isValidRelateLink: function(link) {
        if (!link || !link.name) {
            return false;
        }

        var module = app.data.getRelatedModule(this.module, link.name);
        if (_.isEmpty(app.metadata.getModule(module))) {
            return false;
        }

        if (_.contains(this.relatesBlacklist, link.name)) {
            return false;
        }

        if (!_.isUndefined(this.relatesBlacklistForModule[this.module]) &&
            _.contains(this.relatesBlacklistForModule[this.module], link.name)
        ) {
            return false;
        }

        if (!_.isUndefined(link.duplicate_merge) &&
            (link.duplicate_merge === 'disabled' ||
                link.duplicate_merge === 'false' ||
                link.duplicate_merge === false)
        ) {
            return false;
        }

        return true;
    },

    /**
     * Check is certain link valid for merge related records by link type.
     *
     * Returns false for cases:
     * 1. type of link is `one`
     *
     * @param {Object} link Defenition of link field.
     * @return {boolean} Is link valid for merge related by link type.
     * @protected
     */
    _isValidRelateLinkType: function(link) {
        if (!_.isUndefined(link.link_type) && link.link_type === 'one') {
            return false;
        }
        return true;
    },

    /**
     * Merge related records using queue.
     * Triggers `mergeduplicates:related:merged` event on finish.
     * @protected
     */
    _mergeRelatedRecords: function() {
        var self = this,
            alternativeModels = _.without(this.collection.models, this.primaryRecord),
            relatedLinks = _.pluck(this._getRelatedLinks(), 'name'),
            progressView,
            queue,
            tasks = [];

        this.mergeStat = {
            records: this.collection.models.length,
            total: 0, total_errors: 0, total_fetch_errors: 0
        };

        this.mergeProgressModel = new Backbone.Model({
            isStopped: false
        });

        this.mergeRelatedCollection = this.getMergeRelatedCollection();

        if (!alternativeModels || !alternativeModels.length) {
            self.primaryRecord.trigger('mergeduplicates:related:merged');
            return;
        }

        if (!relatedLinks || !_.isArray(relatedLinks) || !relatedLinks.length) {
            self.primaryRecord.trigger('mergeduplicates:related:merged');
            return;
        }

        progressView = this._getProgressView();
        progressView.reset();
        progressView.setTotalRecords(alternativeModels.length * relatedLinks.length);

        this.mergeProgressModel.trigger('massupdate:start');

        _.each(relatedLinks, function(link) {
            _.each(alternativeModels, function(model) {
                tasks.push({
                    collection: self._createRelatedCollection(model, link)
                });
            });
        });
        queue = async.queue(function(task, callback) {
            if (self.mergeProgressModel.get('isStopped')) {
                callback.call();
                return;
            }
            self._mergeRelatedCollection(task.collection, callback);
        }, this._settings.merge_relate_fetch_concurrency);
        queue.drain = function() {
            var finishMerge = function() {
                self.mergeProgressModel.trigger('massupdate:end');
                if (!self.mergeProgressModel.get('isStopped')) {
                    self.primaryRecord.trigger('mergeduplicates:related:merged');
                }

                if (self.mergeStat.total_fetch_errors > 0 || self.mergeStat.total_errors > 0) {
                    var headerpaneView = self.layout.getComponent('merge-duplicates-headerpane');
                    headerpaneView.getField('cancel_button').setDisabled(false);
                }
            };
            // Wait until all related records be merged or finish merge.
            self.mergeRelatedCollection.queue.running() ?
                self.mergeRelatedCollection.queue.drain = finishMerge :
                finishMerge();
        };
        queue.push(tasks, function(err) {});
    },

    /**
     * Creates collection against the parent model to merge related records.
     *
     * @return {Backbone.Collection} Merge collection.
     */
    getMergeRelatedCollection: function() {
        var constructor = Backbone.Collection.extend({
            method: 'create',
            queue: null,
            view: null,

            /**
             * @property {String} id Primary record's ID.
             */
            id: this.primaryRecord.id,

            /**
             * @property {String} module Primary record's module name.
             */
            module: this.primaryRecord.module,

            /**
             * @property {Number} attempt Current trial attempt number.
             */
            attempt: 0,

            /**
             * @inheritdoc
             *
             * Sync added set of records and clear collection.
             */
            initialize: function(models, options) {
                this.view = options.view;
                this.queue = async.queue(
                    _.bind(function(task, callback) {
                        this.sync('update', this, {
                            chunk: task,
                            queueSuccess: callback
                        });
                    }, this),
                    this.view._settings.merge_relate_update_concurrency
                );
                this.on('add', function(model, options) {
                    this.queue.push(
                        {
                            link_name: model.link.name,
                            ids: _.pluck(this.models, 'id')
                        },
                        function(err) {}
                    );
                    this.reset();
                }, this);
            },

            /**
             * @inheritdoc
             *
             * Overrides default behaviour to use related API and send related
             * records into chunks.
             */
            sync: function(method, model, options) {
                var apiMethod = options.method || this.method,
                    url = app.api.buildURL(this.module, method, {link: true, id: this.id}, options.params),
                    callbacks = {
                        success: function(data, response) {
                            model.view.mergeStat.total = model.view.mergeStat.total + options.chunk.ids.length;
                            options.queueSuccess();
                            if (_.isFunction(options.success)) {
                                options.success(data);
                            }
                        },
                        error: function(xhr) {
                            model.attempt = model.attempt + 1;
                            model.view.mergeProgressModel.trigger('massupdate:item:attempt', model);
                            if (model.attempt <= (model.view._settings.merge_relate_max_attempt)) {
                                app.api.call(apiMethod, url, options.chunk, callbacks);
                            } else {
                                model.attempt = 0;
                                model.view.mergeStat.total_errors = model.view.mergeStat.total_errors + 1;
                                model.view.mergeProgressModel.trigger('massupdate:item:fail', model);
                            }
                        },
                        complete: function(xhr) {
                            if (_.isFunction(options.complete)) {
                                options.complete(xhr);
                            }
                        }
                    };
                app.api.call(apiMethod, url, options.chunk, callbacks);
            }
        }),
        collection = new constructor([], {view: this});
        return collection;
    },

    /**
     * Called when merge related records process is finished.
     *
     * @protected
     */
    _onRelatedMerged: function() {
        var self = this;

        if (this.mergeStat.total_fetch_errors > 0 ||
            this.mergeStat.total_errors > 0
        ) {
            app.alert.show('final_confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_MERGE_DUPLICATES_FAIL_PROCESS', this.module),
                onConfirm: function() {
                    self._onMergeRelatedCompleted();
                },
                onCancel: function() {
                    self.mergeProgressModel.trigger('massupdate:end');
                },
                autoClose: false
            });
            return;
        }

        this._onMergeRelatedCompleted();
    },

    /**
     * Starts removing models and shows process message.
     * @protected
     */
    _onMergeRelatedCompleted: function() {
        app.alert.show('mergeduplicates_merging', {
            level: 'process',
            title: app.lang.get('LBL_SAVING', this.module)
        });
        this._removeMerged();
    },

    /**
     * Creates related collection.
     * Setup additional parameters for merge process.
     *
     * @param {Data.Bean} model Model to create related collection.
     * @param {String} link Relationship link name.
     * @return {Data.BeanCollection} Created collection.
     * @protected
     */
    _createRelatedCollection: function(model, link) {
        var relatedCollection = app.data.createRelatedCollection(model, link);

        return _.extend(relatedCollection, {
            attempt: 0,
            maxAllowAttempt: this._settings.merge_relate_max_attempt,
            objectName: app.data.getRelatedModule(this.primaryRecord.module, link)
        });
    },

    /**
     * Recursively merge related collection.
     *
     * Recursively fetch data from link collection and creates (links) beans
     * to primary record.
     *
     * @param {Data.BeanCollection} collection Collection to merge.
     * @param {Function} callback Function called on end.
     * @param {Number} offset Offset to fetch data.
     * @protected
     */
    _mergeRelatedCollection: function(collection, callback, offset) {

        if (this.mergeProgressModel.get('isStopped')) {
            callback.call();
            return;
        }

        offset = offset || 0;

        var self = this,
            onCollectionMerged = function() {
                self.mergeProgressModel.trigger('massupdate:item:processed');
                callback.call();
            };

        collection.fetch({
            relate: true,
            limit: this._settings.merge_relate_fetch_limit,
            offset: offset,
            fields: ['id'],
            apiOptions: {
                timeout: this._settings.merge_relate_fetch_timeout,
                skipMetadataHash: true
            },
            success: function(data, response, options) {
                if (!data || !data.models || !data.models.length) {
                    onCollectionMerged.call();
                    return;
                }

                self.mergeRelatedCollection.add(data.models);

                if (!_.isUndefined(data.next_offset) && data.next_offset !== -1) {
                    self._mergeRelatedCollection(collection, callback, data.next_offset);
                } else {
                    onCollectionMerged.call();
                }
            },
            error: function() {
                collection.attempt = collection.attempt + 1;
                self.mergeProgressModel.trigger('massupdate:item:attempt', collection);
                if (collection.attempt <= collection.maxAllowAttempt) {
                    self._mergeRelatedCollection(collection, callback, offset);
                } else {
                    self.mergeStat.total_fetch_errors = self.mergeStat.total_fetch_errors + 1;
                    self.mergeProgressModel.trigger('massupdate:item:fail', collection);
                    onCollectionMerged.call();
                }
            }
        });
    },

    /**
     * Create the Progress view unless it is initialized.
     * Return the progress view component in the same layout.
     *
     * @return {Backbone.View} MergeDuplicatesProgress view component.
     * @protected
     */
    _getProgressView: function() {
        var progressView = this.layout.getComponent('merge-duplicates-progress');
        if (!progressView) {
            progressView = app.view.createView({
                context: this.context,
                type: 'merge-duplicates-progress',
                layout: this.layout,
                model: this.mergeProgressModel
            });
            this.layout._components.push(progressView);
            this.layout.$el.append(progressView.$el);
        }
        progressView.render();
        return progressView;
    },

    /**
     * Displays alert message with last merge related records stat.
     *
     * @protected
     */
    _showSuccessMessage: function() {
        app.alert.show('mergerelated_final_notice', {
            level: 'success',
            messages: app.lang.get('TPL_MERGE_DUPLICATES_STAT', this.module, {
                stat: this.mergeStat
            }),
            autoClose: true,
            autoCloseDelay: 8000
        });
    },

    /**
     * @inheritdoc
     *
     * Override 'reset' event for collection to setup first model ar primary.
     */
    bindDataChange: function() {
        if (!this.collection) {
            return;
        }
        this.collection.on('reset', function(coll) {
            if (coll.length) {
                _.each(coll.models, function(model) {
                    model.readonly = !app.acl.hasAccessToModel('edit', model);
                }, this);
                this.setPrimaryRecord(this._findPrimary(coll.models));
            }
            if (this.disposed) {
                return;
            }
            this.render();
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Off all events on primary model.
     */
    _dispose: function() {
        if (!_.isEmpty(this.primaryRecord)) {
            this.primaryRecord.off(null, null, this);
        }
        this._super('_dispose');
    }
}) },
"omnichannel-ccp": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The ccp container of the Omnichannel console.
 *
 * @class View.Views.Base.OmnichannelCcpView
 * @alias SUGAR.App.view.views.BaseOmnichannelCcpView
 * @extends View.View
 */
({
	// Omnichannel-ccp View (base) 

    className: 'omni-ccp',

    /**
     * A map of contact type to module
     */
    contactTypeModule: {
        voice: 'Calls',
        chat: 'Messages',
    },

    /**
     * Default maximum number of results to be returned by search query
     */
    maxQueryResultsDefault: 5,

    /**
     * The list of source types
     */
    sourceType: {
        voice: 'Phone',
        chat: 'Chat',
    },

    /**
     * The active contact
     */
    activeContact: null,

    /**
     * Call/chat records
     */
    connectionRecords: {},

    /**
     * The list of connected contacts
     */
    connectedContacts: {},

    /**
     * Chat controllers, keyed by contact ID
     */
    chatControllers: {},

    /**
     * Transcripts of chat messages, keyed by contact ID
     */
    chatTranscripts: {},

    /**
     * Is the ccp loaded?
     */
    ccpLoaded: false,

    /**
     * Have we loaded the CCP library?
     */
    libraryLoaded: false,

    /**
     * Is agent logged in?
     */
    agentLoggedIn: false,

    /**
     * Default CCP settings. Will be overridden by admin settings in the future
     */
    defaultCCPOptions: {
        loginPopupAutoClose: true,
        softphone: {
            allowFramedSoftphone: true
        }
    },

    /**
     * Prefix for AWS connect instance URLs
     */
    urlPrefix: 'https://',

    /**
     * Suffix for AWS connect instance URLs
     */
    urlSuffix: '.awsapps.com/connect/ccp-v2/',

    /**
     * A list of fields that might be updated through API from other sources (eg. lambda functions).
     */
    multiSourceFields: ['call_recording_url', 'contact_id'],

    /**
     * A list of modules that will be searched for matching records when a
     * contact starts
     */
    searchModules: ['Contacts', 'Accounts', 'Leads', 'Cases'],

    /**
     * Stores contextual information about AWS contacts by AWS contact ID
     */
    recordMatchContexts: {},

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        // Load the CCP when console drawer opens
        this.layout.on('omniconsole:open', function() {
            this.loadCCP();
            this.resize();
        }, this);

        // Event listener for when the mode of the console changes
        this.layout.on('omniconsole:mode:set', this.resize, this);

        // Event listener for manual refreshes
        $(window).on('beforeunload', _.bind(this._warnOnRefresh, this));

        // resize the CCP on window resize
        var debouncedResize = _.bind(_.debounce(this.resize, 100), this);
        $(window).on('resize.' + this.cid, debouncedResize);
    },

    /**
     * Change the height of CCP when the console (and detail panel) toggles.
     */
    resize: function() {
        if (!this.disposed) {
            this.$el.css('top', this._determineTop());
        }
    },

    /**
     * Calculate the top of CPP.
     * @return {number}
     * @private
     */
    _determineTop: function() {
        // Start by getting the top of the detail panel
        var detailPanel = this.layout.getComponent('omnichannel-detail');

        return parseInt(detailPanel.$el.css('top'), 10) + parseInt(detailPanel.$el.css('height'), 10) + 1;
    },

    /**
     * Load the CCP library if needed, then initialize the CCP. Show an alert
     * message if loading the CCP fails. We expect it to fail in IE and Safari,
     * as the CCP itself is not compatible with those browsers.
     */
    loadCCP: function() {
        if (!this._loadAdminConfig()) {
            this._showNonConfiguredWarning();
            return;
        }
        if (this.libraryLoaded) {
            this.initializeCCP();
            return;
        }
        try {
            var self = this;
            // Load the connect-streams library and initialize the CCP
            $.getScript('include/javascript/amazon-connect/amazon-connect-streams-1.6.9.js', function() {
                // Load chat library here, must be loaded after connect-streams
                $.getScript('include/javascript/amazon-connect/amazon-connect-chat.js', function() {
                    self.libraryLoaded = true;
                    self.initializeCCP();
                    self.initializeChat();
                });
            });

        } catch (error) {
            app.alert.show(error.name, {
                level: 'error',
                messages: 'ERROR_OMNICHANNEL_LOAD_FAILED'
            });
            App.logger.error('Loading connect-streams library failed: ' + error);
        }
    },

    /**
     * Initialize library with options defined above, and load event listeners
     * for different CCP objects.
     */
    initializeCCP: function() {
        if (!this.ccpLoaded) {
            connect.core.initCCP(_.first(this.$('#containerDiv')), this.defaultCCPOptions);
            this.loadAgentEventListeners();
            this.loadContactEventListeners();
            this.loadGeneralEventListeners();
            this.ccpLoaded = true;
        } else if (!this.agentLoggedIn) {
            if (connect.core.loginWindow == null || connect.core.loginWindow.closed) {
                connect.core.loginWindow = window.open(this.defaultCCPOptions.ccpUrl, connect.MasterTopics.LOGIN_POPUP);
            } else {
                connect.core.loginWindow.focus();
            }
        }
    },

    /**
     * Provide initial chat config for use with amazon-connect-chatjs library
     */
    initializeChat: function() {
        var globalConfig = {
            region: this.defaultCCPOptions.region
        };
        connect.ChatSession.setGlobalConfig(globalConfig);
    },

    /**
     * Tear down the CCP instance when an agent logs out. We have to terminate
     * the instance via the Amazon library, and completely remove the iFrame from
     * the DOM so we can load a new one when the drawer is re-opened.
     */
    tearDownCCP: function() {
        this.styleFooterButton('logged-out');
        connect.core.terminate();
        this.$el.find('#containerDiv').empty();
        this.ccpLoaded = false;
        this.agentLoggedIn = false;
    },

    /**
     * Load agent event listeners.
     */
    loadAgentEventListeners: function() {
        var self = this;
        connect.agent(function(agent) {
            // When CCP agent is authenticated, we set the footer style
            self.styleFooterButton('logged-in');
            self.agentLoggedIn = true;

            // Trigger global changes so all parts of the app can go into
            // "CCP mode"
            app.events.trigger('ccp:initiated');

            agent.onStateChange(function(agentStateChange) {
                var isOffline = agentStateChange.newState.toLowerCase() === connect.AgentStateType.OFFLINE;
                var configMode = (isOffline) ? 'init' : 'disabled';

                $('.omni-button .config-menu').attr('data-mode', configMode);
            });
        });
    },

    /**
     * Gets the active contacts.
     * @return {contacts} Active contacts
     */
    getContacts: function() {
        return new connect.Agent().getContacts();
    },

    /**
     * Get the contact id for the active contact
     *
     * @return {string} the contact id or empty string if no active contact
     */
    getActiveContactId: function() {
        if (this.activeContact) {
            return this.activeContact.getContactId();
        }
        return '';
    },

    /**
     * Get active contact
     *
     * @return {Object} active contact
     */
    getActiveContact: function() {
        return this.activeContact;
    },

    /**
     * Gets the model for the current active contact
     * @return {Object} active model
     */
    getActiveModel: function() {
        return this.activeContact ? this.connectionRecords[this.activeContact.getContactId()] : null;
    },

    /**
     * Load contact event listeners.
     */
    loadContactEventListeners: function() {
        var self = this;

        connect.core.onViewContact(function(event) {
            if (self.connectedContacts[event.contactId]) {
                self._setActiveContact(event.contactId);

                app.events.trigger(
                    'omniconsole:contact:changed',
                    this.activeContact || null,
                    this.activeContact ? this.connectionRecords[this.activeContact.getContactId()] : null
                );
            }
        });

        connect.contact(function(contact) {
            var connection = contact.getAgentConnection();
            if (connection.getMediaType() === connect.MediaType.CHAT) {
                self.loadChatListeners(connection);
            }

            // Listener for when a connection is attempted (i.e. when the CCP
            // starts ringing)
            contact.onConnecting(function(contact) {
                if (app.omniConsole.isConfigPaneExpanded) {
                    connection.destroy();
                    app.alert.show('finish_configuring', {
                        level: 'warning',
                        messages: app.lang.get('LBL_OMNICHANNEL_FINISH_CONFIGURING_BEFORE_OUTBOUND_CALL'),
                    });
                } else {
                    // Create context information about the contact
                    self._createRecordMatchContext(contact);

                    self.layout.open();
                }
            });

            // Listener for when a connection is made (i.e. the call/chat is
            // answered)
            contact.onConnected(function(contact) {
                self.styleFooterButton('active-session');
                self.addContactToContactsList(contact);
                self._setActiveContact(contact.contactId);
                self._createConnectionRecord(contact);
            });

            // this listener is subscribed to both call and chat end (ENDED) event
            contact.onEnded(function(contact) {
                if (this.eventName.includes(connect.ContactEvents.ENDED)) {
                    // if the call/chat has ended but the contact is not closed
                    self._handleConnectionEnd(contact);
                }

                // Clear any context information created for the contact
                self._deleteRecordMatchContext(contact);
            });
        });
    },

    /**
     * Creates and stores an object that contains contextual information about
     * record matching on an AWS contact
     *
     * @param {Object} contact connect-streams Contact object
     * @private
     */
    _createRecordMatchContext: function(contact) {
        var context = {};
        var contactAttrs = contact.getAttributes();

        if (this.isChat(contact)) {
            // The Case number from Portal chat
            if (contactAttrs.sugarCaseNumber && contactAttrs.sugarCaseNumber.value) {
                context.sugarCaseNumber = parseInt(contactAttrs.sugarCaseNumber.value);
            }

            // The Contact ID from Portal chat
            if (contactAttrs.sugarContactId && contactAttrs.sugarContactId.value) {
                context.sugarContactId = contactAttrs.sugarContactId.value;
            }

            // The Contact email from inbound chat
            if (contactAttrs.sugarContactEmail && contactAttrs.sugarContactEmail.value) {
                context.sugarContactEmail = contactAttrs.sugarContactEmail.value;
            }

            // The Contact name from inbound chat
            if (contactAttrs.sugarContactName && contactAttrs.sugarContactName.value) {
                context.sugarContactName = contactAttrs.sugarContactName.value;
            }
        } else if (this.isCall(contact)) {
            if (!contact.isInbound()) {
                // The record the user clicked a phone number on
                context.dialedRecord = this._determineDialedRecord();

                // The record the user was focusing on when the call was initiated
                context.focusedRecord = this._determineFocusedRecord();
            }

            // The phone number of the contact
            context.phoneNumber = this._determineGlobalSearchPhoneNumber(contact);
        }

        this.recordMatchContexts[contact.getContactId()] = context;
    },

    /**
     * Removes any stored contextual information about an AWS contact
     *
     * @param {Object} contact connect-streams Contact object
     * @private
     */
    _deleteRecordMatchContext: function(contact) {
        delete this.recordMatchContexts[contact.getContactId()];
    },

    /**
     * Retrieves any stored contextual information about an AWS contact
     *
     * @param {Object} contact connect-streams Contact object
     * @return {Object|null} the context info if it exists; null otherwise
     * @private
     */
    _getRecordMatchContext: function(contact) {
        return this.recordMatchContexts[contact.getContactId()] || null;
    },

    /**
     * Determines what phone number to use for global search record matching by
     * phone number
     *
     * @param {Object} contact connect-streams Contact object
     * @return {Object} the global search term and module list array
     * @private
     */
    _determineGlobalSearchPhoneNumber: function(contact) {
        // Get the endpoint for the contact
        var connection = contact.getInitialConnection();
        var endpoint = connection.getEndpoint();

        // Get the phone number of the connection. Amazon converts all phone
        // numbers to E164 format, which can cause phone number matches to miss
        // if the numbers aren't stored that way in Sugar. Remove the first 4
        // characters of the number (the '+', and 3 digits for the maximum
        // length of the country code). This isn't perfect, but it will have to
        // do unless we can add a new phone number parsing rule to ElasticSearch
        return !_.isEmpty(endpoint.phoneNumber) ? endpoint.phoneNumber.substring(4) : '';
    },

    /**
     * Determines what record the user dialed by clicking a phone number field
     *
     * @return {Bean|null} the dialed record if it exists; null otherwise
     * @private
     */
    _determineDialedRecord: function() {
        var dialedRecord;

        if (!_.isEmpty(this.layout.context.get('lastDialedRecord'))) {
            dialedRecord = this.layout.context.get('lastDialedRecord');
            this.layout.context.unset('lastDialedRecord');
        }

        return dialedRecord || null;
    },

    /**
     * Determines what record the user is currently focusing on
     *
     * @return {Bean|null} the focused record if it exists; null otherwise
     * @private
     */
    _determineFocusedRecord: function() {
        var focusedRecord;

        if (app.sideDrawer && app.sideDrawer.isOpen()) {
            // The focused model the user is looking at in the side drawer
            var rowModelDataLayout = app.sideDrawer.getComponent('row-model-data');
            focusedRecord = rowModelDataLayout && rowModelDataLayout.getRowModel();
        } else if (app.controller.context && app.controller.context.get('layout') === 'record') {
            // The model of the record view the user is looking at
            focusedRecord = app.controller.context.get('model');
        }

        return focusedRecord || null;
    },

    /**
     * Attempts to find Sugar records associated with the given contact
     *
     * @param {Object} contact connect-streams Contact object
     * @private
     */
    _matchRecords: function(contact) {
        // Combine all record fetches/searches into one API call to improve
        // performance. When the search is complete, notify the layout with the
        // list of matched models for the contact
        var url = app.api.buildURL(null, 'bulk');
        var params = {
            requests: this._buildBulkRecordMatchingRequests(contact)
        };
        var callbacks = {
            success: _.bind(function(results) {
                // Notify the layout of the records that were matched, and the
                // context in which they were matched
                var models = this._formatRecordMatchResults(results);
                var context = this._getRecordMatchContext(contact);
                this.layout.trigger('contact:records:matched', contact, models, context);
            }, this)
        };

        // Initiate the bulk API call
        app.api.call('create', url, params, callbacks);
    },

    /**
     * Combines results of multiple searches returned from the bulk API to
     * produce a list of records to associate with a contact
     *
     * @param {Array} results the array of responses from the bulk API
     * @return {Array} the list of
     * @private
     */
    _formatRecordMatchResults: function(results) {
        // The bulk API returns returns as an array of response data. Iterate
        // through each response and process it individually
        var models = [];
        _.each(results, function(result) {
            models = _.union(models, this._formatRecordMatchResult(result));
        }, this);

        // Remove duplicate records from the results, in case multiple searches
        // find the same record
        models = _.uniq(models, function(model) {
            return model.id || model.get('id');
        });

        // Since we are combining results of multiple searches, and matching at
        // most one record per module, we need to remove duplicate modules from
        // the results. This will discard the lower-priority results in favor
        // of keeping the higher-priority ones
        return _.uniq(models, function(model) {
            return model.module || model.get('_module');
        });
    },

    /**
     * Parses the result of a single record search to extract any records that
     * are identified as lone matches for their module
     *
     * @param result
     * @private
     */
    _formatRecordMatchResult: function(result) {
        var models = [];

        // Iterate through the results. For any result such that it is the only
        // record found for its module, create a bean of it and add it to the
        // models to return
        if (result.contents && result.contents.records) {
            var records = result.contents.records;
            _.each(this._getSearchModules(), function(module) {
                var moduleResults = _.filter(records, function(record) {
                    return record._module === module;
                });

                if (moduleResults.length === 1) {
                    var model = app.data.createBean(module, moduleResults[0]);
                    models.push(model);
                }
            }, this);
        }

        return models;
    },

    /**
     * Builds a list of requests to pass in to the bulk API based on the type of
     * contact
     *
     * @param {Object} contact connect-streams Contact object
     * @return {Array} the list of requests, in order of search priority
     * @private
     */
    _buildBulkRecordMatchingRequests: function(contact) {
        // Build the list of requests specific to the direction of the call
        var requests;
        if (contact.isInbound()) {
            requests = this._buildInboundRecordMatchingRequests(contact);
        } else {
            requests = this._buildOutboundRecordMatchingRequests(contact);
        }

        // For calls, include the results of searching by phone number
        if (this.isCall(contact)) {
            var context = this._getRecordMatchContext(contact);
            requests.push(this._buildGlobalSearchBulkRequest(context.phoneNumber));
        }

        return requests;
    },

    /**
     * Builds a list of requests to pass in to the bulk API that are specific
     * to inbound contacts
     *
     * @param {Object} contact connect-streams Contact object
     * @return {Array} the list of requests, in order of search priority
     * @private
     */
    _buildInboundRecordMatchingRequests: function(contact) {
        var requests = [];
        var context = this._getRecordMatchContext(contact);

        if (!context) {
            return requests;
        }

        // If we have a Sugar Case Number, find its matching Case record
        if (context.sugarCaseNumber) {
            requests.push(this._buildRecordFetchBulkRequest('Cases', {
                case_number: context.sugarCaseNumber
            }));
        }

        // If we have a Sugar Contact ID, find its matching Contact record
        if (context.sugarContactId) {
            requests.push(this._buildRecordFetchBulkRequest('Contacts', {
                id: context.sugarContactId
            }));
        }

        // If we have an email address for the contact, search the Contacts module for the record with that email
        if (context.sugarContactEmail) {
            requests.push(this._buildRecordFetchBulkRequest('Contacts', {
                email: context.sugarContactEmail
            }));
        }

        // If we have a name for the contact, search the Contacts module for the record with that name
        if (context.sugarContactName) {
            const nameComponents = context.sugarContactName.split(' ');
            if (nameComponents.length >= 2) {
                // We don't know the format of the name as it comes from Amazon.
                // Assuming the first string is first name and the last string is last name.
                requests.push(this._buildRecordFetchBulkRequest('Contacts', {
                    first_name: nameComponents[0],
                    last_name: nameComponents[nameComponents.length - 1]
                }));
            }
        }

        return requests;
    },

    /**
     * Builds a list of requests to pass in to the bulk API that are specific
     * to outbound contacts
     *
     * @param {Object} contact connect-streams Contact object
     * @return {Array} the list of requests, in order of search priority
     * @private
     */
    _buildOutboundRecordMatchingRequests: function(contact) {
        var requests = [];
        var context = this._getRecordMatchContext(contact);

        // If we dialed out from a specific model, fetch the latest version of it
        if (context.dialedRecord) {
            var module = context.dialedRecord.module || context.dialedRecord.get('_module');
            requests.push(this._buildRecordFetchBulkRequest(module, {
                id: context.dialedRecord.get('id')
            }));
        }
        return requests;
    },

    /**
     * Given a module and filters, builds filter API request data to pass in to
     * the bulk API
     *
     * @param {string} module the module to filter
     * @param {Object} fieldFilters a mapping of {field name} => {value}, used
     *                 for exact matching on field values
     * @return {Object} the filter API request parameters to pass in to the bulk
     *                  API
     * @private
     */
    _buildRecordFetchBulkRequest(module, fieldFilters) {
        var filter = [];

        // If we have field filters defined, build them now
        _.each(fieldFilters, function(fieldValue, fieldName) {
            var fieldFilter = {};
            fieldFilter[fieldName] = {
                $equals: fieldValue
            };
            filter.push(fieldFilter);
        }, this);

        // Construct and return the parameters for a call to the filter API
        var url = app.api.buildURL(module + '/filter');
        return {
            url: url.substr(4),
            method: 'GET',
            data: {
                filter: filter
            }
        };
    },

    /**
     * Given a search term, builds data for a global search request data across the
     * SugarLive modules to pass into the bulk API
     *
     * @param {string} term the term to search
     * @private
     */
    _buildGlobalSearchBulkRequest: function(term) {
        // Construct and return the parameters for a call to the global search
        // API
        var url = app.api.buildURL('globalsearch');
        var data = {
            q: term || '',
            module_list: this._getSearchModules().join(',')
        };
        return {
            url: url.substr(4),
            method: 'GET',
            data: data
        };
    },

    /**
     * Gets the list of modules to perform record matching across
     *
     * @return {Array} the list of modules, excluding any modules without access
     * @private
     */
    _getSearchModules: function() {
        return _.filter(this.searchModules, function(module) {
            return !_.isEmpty(app.metadata.getModule(module)) && app.acl.hasAccess('view', module);
        });
    },

    /**
     * Update call/chat record when a call/chat is ended.
     * @param {Object} contact connect-streams Contact object
     * @private
     */
    _handleConnectionEnd: function(contact) {
        // do nothing if connection record doesn't exist
        if (!this._hasConnectionRecord(contact)) {
            return;
        }

        var data = {};
        var startTime = this.getContactConnectedTime(contact);
        var timeDuration = this.getTimeAndDuration(startTime);
        data.date_end = timeDuration.nowTime;

        if (this.isCall(contact)) {
            data.status = 'Held';
            data.duration_hours = timeDuration.durationHours;
            data.duration_minutes = timeDuration.durationMinutes;
        } else {
            data.status = 'Completed';
            data.conversation = this._getTranscriptForContact(contact);
        }

        this._updateConnectionRecord(contact, data);
    },

    /**
     * Get relevant contact information based on contact type.
     *
     * @param contact
     * @return {Object}
     */
    getContactInfo: function(contact) {
        if (this.isCall(contact)) {
            return this.getVoiceContactInfo(contact);
        } else if (this.isChat(contact)) {
            return this.getChatContactInfo(contact);
        }
    },

    /**
     * Load general event listeners. If the connect-streams API exposes an
     * object.onEvent function, we should prefer that method of event listening.
     * The EventBus should only be used for low-level events that aren't exposed
     * via the agent, contact, etc. object APIs.
     */
    loadGeneralEventListeners: function() {
        var self = this;
        var eventBus = connect.core.getEventBus();
        // This event is fired when an agent logs out, or the connection is lost
        eventBus.subscribe(connect.EventType.TERMINATED, function() {
            self.tearDownCCP();
            self.layout.trigger('ccp:terminated');

            // trigger global events to take app out of "CCP mode"
            app.events.trigger('ccp:terminated');
        });
        // This event is fired if we cannot synchronize with the CCP server
        eventBus.subscribe(connect.EventType.ACK_TIMEOUT, function() {
            if (self.agentLoggedIn) {
                self._showConnectionWarning();
            }
        });
        // This event is triggered when 'Clear Contact' button is clicked
        eventBus.subscribe(connect.ContactEvents.DESTROYED, function(contact) {
            self._closeConnectionRecord(contact);
            if (_.isEmpty(self.getContacts())) {
                // no more active contacts
                self.styleFooterButton('logged-in');

                // empty the active contact
                self._unsetActiveContact();
            }
            self.removeStoredContactData(contact);
            self.layout.trigger('contact:destroyed', contact.getContactId());
        });
    },

    /**
     * Util to trigger the footer style update
     *
     * @param status
     */
    styleFooterButton: function(status) {
        this.layout.context.trigger('omnichannel:auth', status);
    },

    /**
     * Warn users if their admin hasn't added Amazon Connect settings
     * @private
     */
    _showNonConfiguredWarning: function() {
        app.alert.show('omnichannel-not-configured', {
            level: 'warning',
            messages: 'ERROR_OMNICHANNEL_NOT_CONFIGURED'
        });
    },

    /**
     * Warn users if the attempt to contact their Connect instance timed out
     * @private
     */
    _showConnectionWarning: function() {
        app.alert.show('omnichannel-timeout', {
            level: 'warning',
            messages: 'ERROR_OMNICHANNEL_TIMEOUT'
        });
    },

    /**
     * Load admin configuration for AWS Connect. Return true if successful, else
     * false.
     *
     * @return {boolean} whether or not config was loaded
     * @private
     */
    _loadAdminConfig: function() {
        var instanceName = App.config.awsConnectInstanceName;
        var region = App.config.awsConnectRegion;
        var instanceUrl = App.config.awsConnectUrl;
        var identityProvider = App.config.awsConnectIdentityProvider;
        var loginSSO = App.config.awsLoginUrl;
        if (_.isEmpty(instanceName) || _.isEmpty(region)) {
            return false;
        }

        if (_.isEmpty(instanceUrl)) {
            this.defaultCCPOptions.ccpUrl = this.urlPrefix + instanceName + this.urlSuffix;
        } else {
            this.defaultCCPOptions.ccpUrl = instanceUrl;
        }
        if (!_.isUndefined(identityProvider) && identityProvider === 'SAML') {
            this.defaultCCPOptions.loginUrl = loginSSO;
        }
        this.defaultCCPOptions.region = region;
        return true;
    },

    /**
     * Caches the last viewed contact
     *
     * @param {string} id
     * @private
     */
    _setActiveContact: function(id) {
        this.activeContact = _.findWhere(this.getContacts(), {contactId: id});
        this.layout.trigger('contact:view', this.activeContact);
    },

    /**
     * Unset the active contact and other relevant data
     *
     * @private
     */
    _unsetActiveContact: function() {
        this.activeContact = null;
        app.events.trigger('omniconsole:contact:changed', null, null);
    },

    /**
     * Add the contact to the list of connected contacts
     *
     * @param contact
     */
    addContactToContactsList: function(contact) {
        this.connectedContacts[contact.getContactId()] = {
            connectedTimestamp: contact.getStatus().timestamp,
        };
    },

    /**
     * Remove the contact from the list of connected contacts, if it exists
     *
     * @param contact
     */
    removeStoredContactData: function(contact) {
        var contactId = contact.getContactId();

        if (_.has(this.connectedContacts, contactId)) {
            this.connectedContacts = _.omit(this.connectedContacts, contactId);
        }

        if (_.has(this.chatControllers, contactId)) {
            this.chatControllers = _.omit(this.chatControllers, contactId);
        }

        if (_.has(this.chatTranscripts, contactId)) {
            this.chatTranscripts = _.omit(this.chatTranscripts, contactId);
        }

        if (_.has(this.connectionRecords, contactId)) {
            this.connectionRecords = _.omit(this.connectionRecords, contactId);
        }
    },

    /**
     * Get generic contact info that all contact types should have
     *
     * @param contact
     * @return {Object}
     */
    getGenericContactInfo: function(contact) {
        var data = {};

        try {
            data.isContactInbound = contact.isInbound();
        } catch (err) {
            app.logger.error('Amazon Connect: Unable to determine contact inbound/outbound direction');
        }

        data.contactType = contact.getType();
        data.startTime = this.getContactConnectedTime(contact);
        data.aws_contact_id = contact.contactId;

        return data;
    },

    /**
     * Get the relevant information for a voice type contact
     *
     * @param contact
     * @return {Object}
     */
    getVoiceContactInfo: function(contact) {
        var conn = contact.getInitialConnection();
        var endpoint = conn.getEndpoint();

        return {
            phone_work: endpoint.phoneNumber,
            source: this.sourceType.voice
        };
    },

    /**
     * Get the relevant information for a chat type contact
     *
     * @param contact
     * @return {Object}
     */
    getChatContactInfo: function(contact) {
        var lastName = '';
        var data = contact._getData();

        var connectionInfo = _.findWhere(data.connections, {type: 'inbound'});
        if (connectionInfo) {
            lastName = connectionInfo.chatMediaInfo.customerName;
        }

        return {
            last_name: lastName,
            name: (lastName) ? lastName : app.lang.get('LBL_OMNICHANNEL_DEFAULT_CUSTOMER_NAME'),
            source: this.sourceType.chat,
        };
    },

    /**
     * Get the Utils/Date from the contact's timestamp
     *
     * @param contact
     * @return {Date}
     */
    getContactConnectedTime: function(contact) {
        var timestamp = this.connectedContacts[contact.getContactId()].connectedTimestamp;

        return app.date(timestamp);
    },

    /**
     * Get a readable title per the contact type
     *
     * @param module
     * @param data
     * @param contact
     * @return {string}
     */
    getRecordTitle: function(module, data, contact) {
        var title = '';

        // if unfamiliar type, return empty
        if (!(this.isChat(contact) || this.isCall(contact))) {
            return title;
        }

        if (this.isCall(contact)) {
            var contactTypeStr = 'Call';
            var identifier = data.phone_work;
        } else {
            var contactTypeStr = 'Chat';
            var identifier = data.name;
        }
        var direction = _.has(data, 'isContactInbound') ? (data.isContactInbound ? 'from' : 'to') : 'from';

        title = app.lang.get('TPL_OMNICHANNEL_NEW_RECORD_TITLE', module, {
            type: contactTypeStr,
            direction: direction,
            identifier: identifier,
            time: data.startTime.formatUser()
        });

        return title;
    },

    /**
     * Get the time in server format and calculate the duration
     *
     * @param {Date} startTime
     * @return {Object}
     */
    getTimeAndDuration: function(startTime) {
        var nowTime = app.date();

        var timeDiff = nowTime.diff(startTime);
        var durationHours = Math.floor(app.date.duration(timeDiff).asHours());
        var durationMinutes = app.date.duration(timeDiff).minutes();

        return {
            startTime: startTime.formatServer(),
            nowTime: nowTime.formatServer(),
            durationHours: durationHours,
            durationMinutes: durationMinutes,
        };
    },

    /**
     * Create a call/chat record for a new contact.
     * @param {Object} contact connect-streams Contact object
     * @private
     */
    _createConnectionRecord: function(contact) {
        // do nothing if contact type is unfamiliar
        if (!_.has(this.contactTypeModule, contact.getType())) {
            app.logger.error('Amazon Connect: Contact type: ' + contact.getType() + ' is not voice or chat');
            return;
        }

        var module = this.contactTypeModule[contact.getType()];
        var contactId = contact.getContactId();

        // do nothing if contact was from a previous session
        if (!_.has(this.connectedContacts, contactId)) {
            return;
        }

        var searchCallback = _.bind(function(results) {
            var model;

            // do not create a connection record if the unique contact id is already associated with a record
            if (_.isArray(results.records) && results.records.length > 0) {
                model = app.data.createBean(module, _.first(results.records));
                this._handlePostConnectionRecordCreation(model, contact);
            } else {
                var data = _.extendOwn(
                    this.getContactInfo(contact),
                    this.getGenericContactInfo(contact)
                );
                model = this.getNewModelForContact(module, data, contact);
                model.save({}, {
                    silent: true,
                    showAlerts: false,
                    success: _.bind(this._handlePostConnectionRecordCreation, this, model, contact),
                    error: function() {
                        app.logger.error('Failed to create call/chat record for ' + contactId);
                    }
                });
            }
        }, this);

        // before creating the connection record, ensure that the contact id is not
        // already associated with a record
        this._searchRecordByContactId(module, contactId, searchCallback);
    },

    /**
     * Handle actions after the connection record has been created or fetched
     *
     * @param model the model created or fetched
     * @param contact the contact
     * @private
     */
    _handlePostConnectionRecordCreation: function(model, contact) {
        var contactId = contact.getContactId();

        this.connectionRecords[contactId] = model;
        this.layout.trigger('contact:model:loaded', this.activeContact);
        this._matchRecords(contact);

        app.events.trigger('omniconsole:contact:changed', contact, model);
    },

    /**
     * Check if the connection record exists
     * @param {Object} contact connect-streams Contact object
     *
     * @return {boolean} true if the Connect-stream contact object is present in connection records
     * @private
     */
    _hasConnectionRecord: function(contact) {
        return _.has(this.connectionRecords, contact.getContactId());
    },

    /**
     * Update call/chat record when a contact is closed.
     * @param {Object} contact connect-streams Contact object
     * @private
     */
    _closeConnectionRecord: function(contact) {
        // do nothing if connection record doesn't exist
        if (!this._hasConnectionRecord(contact)) {
            return;
        }

        // Save the call or chat record data for the contact
        this._updateConnectionRecord(contact, {},  true);
    },

    /**
     * Failure handler for saving a model from the CCP.
     *
     * @param {Object} contact Connect-streams Contact object.
     */
    saveModelError: function(contact) {
        app.logger.error('Failed to update call/chat record for ' + contact.getContactId());
    },

    /**
     * Success handler for saving a model from the CCP.
     *
     * @param {Bean} model The model to be saved.
     * @param {boolean} contactClosed True if coming from the _closeConnectionRecord chain.
     */
    saveModelSuccess: function(model, contactClosed = false) {
        var context = _.extend({
            module: model.module,
            moduleSingularLower: app.lang.getModuleName(model.module).toLowerCase()
        }, model.attributes);

        if (contactClosed) {
            app.alert.show('save_success', {
                level: 'success',
                autoClose: true,
                messages: app.lang.get('LBL_OMNICHANNEL_RECORD_CREATED', model.module, context)
            });
        }
    },

    /**
     * Create the options for saving a model tied to the given contact and save the model.
     *
     * @param {Bean} model The model to be saved.
     * @param {Object} contact Connect-streams Contact object.
     * @param {boolean} contactClosed True if coming from the _closeConnectionRecord chain.
     */
    saveModel: function(model, contact, contactClosed = false) {
        // if there's no model id, don't save the model
        if (!model.id) {
            return;
        }

        var options = {
            silent: true,
            showAlerts: false,
            error: _.bind(this.saveModelError, this, contact)
        };

        if (_.contains(['Held', 'Completed'], model.get('status'))) {
            options.success = _.bind(this.saveModelSuccess, this, model, contactClosed);
        }

        model.save(null, options);
    },

    /**
     * Re-apply the values of fields that can be changed only through other sources.
     *
     * @param {Bean} model The model tied to the active call/chat.
     * @param {Bean} dbModel The model tied to the active call/chat holding the most up to date data.
     */
    preserveDBFieldValues: function(model, dbModel) {
        //contact_id is handled separately in `updateContactIdField`.
        var fieldNames = _.without(this.multiSourceFields, 'contact_id');
        _.each(fieldNames, function(name) {
            if (dbModel.get(name)) {
                model.set(name, dbModel.get(name));
            }
        });
    },

    /**
     * Check and compare the value of the contact id field from different sources and apply the relevant one.
     *
     * @param {Bean} model The model kept on the view (and thus might be outdated).
     * @param {Bean} dbModel The same model the one kept on the view, but holding the most recent data.
     * @param {Bean} contactModel The contact module record related to the current call model.
     * @deprecated Since 11.1, this is now handled in omnichannel-detail
     */
    updateContactIdField: function(model, dbModel, contactModel) {
        var contacts = {};
        var dbContactId = dbModel.get('contact_id');
        if (contactModel) {
            if (dbContactId && dbContactId !== contactModel.get('id')) {
                contacts.delete = [dbContactId];
                contacts.add = [contactModel.attributes];
            } else if (!dbContactId) {
                contacts.add = [contactModel.attributes];
            }
            model.set('contact_id', contactModel.get('id'));
        } else {
            if (dbContactId) {
                contacts.delete = [dbContactId];
            }
            model.set('contact_id', '');
        }
        model.set('contacts', contacts);
    },

    /**
     * Given a data structure apply the values on the model.
     * In case a contact model or a case model is given, apply only specific fields.
     *
     * @param {Bean} model The model tied to the active call/chat.
     * @param {Bean} dbModel The model tied to the active call/chat
     * and holding the most up to date data.
     * @param {Object} contact Connect-streams Contact object.
     * @param {*} value A value to be applied on the model.
     * @param {string} key Field name or related model module name.
     * @deprecated Since 11.1, this is now handled in omnichannel-detail
     */
    applyChangesToModel: function(model, dbModel, contact, value, key) {
        if (key === 'Contacts') {
            if (this.isCall(contact)) {
                this.updateContactIdField(model, dbModel, value);
            } else if (value) {
                model.set('contact_id', value.get('id'));
            }
        } else if (key === 'Cases' && value) {
            model.set('parent_type', 'Cases');
            model.set('parent_id', value.get('id'));
        } else {
            model.set(key, value);
        }
    },

    /**
     * It will apply a given set of data on the model then save it.
     *
     * @param {Bean} viewModel The model tied to the active contact.
     * @param {Object} clientData A set of details to be saved on the model.
     * @param {Object} contact Connect-streams Contact object.
     * @param {boolean} contactClosed True if coming from the _closeConnectionRecord chain.
     * @param {Bean} dbModel The viewModel with the most up to date field values.
     */
    _updateFetchedRecord: function(viewModel, clientData, contact, contactClosed = false, dbModel) {
        viewModel.set(clientData);
        this.preserveDBFieldValues(viewModel, dbModel);
        this.saveModel(viewModel, contact, contactClosed);
    },

    /**
     * It will find the model tied to the given contact and fetch a copy of it.
     * The given set of data will be applied on the model only after it has been
     * re-fetched. We do this in order to avoid overriding model data saved
     * through other sources.
     *
     * @param {Object} contact Connect-streams Contact object.
     * @param {Object} data A set of details to be saved on the model.
     * @param {boolean} contactClosed True if coming from the _closeConnectionRecord chain.
     */
    _updateConnectionRecord: function(contact, data, contactClosed = false) {
        // if there's no contact, dont update the record
        if (!contact) {
            return;
        }

        var model = this.connectionRecords[contact.getContactId()];
        if (model) {
            var baseModel = app.data.createBean(model.module, {id: model.get('id')});

            baseModel.fetch({
                silent: true,
                showAlerts: false,
                fields: this.multiSourceFields,
                success: _.bind(this._updateFetchedRecord, this, model, data, contact, contactClosed)
            });
        }
    },

    /**
     * Create the model and set appropriate attributes for the contact
     *
     * @param module
     * @param data
     * @param {Object} contact connect-streams Contact object.
     * @return {Object} the model
     */
    getNewModelForContact: function(module, data, contact) {
        var model = app.data.createBean(module);

        if (_.has(data, 'isContactInbound')) {
            model.set({
                direction: data.isContactInbound ? 'Inbound' : 'Outbound',
            });
        }

        if (this.isChat(contact)) {
            model.set({
                channel_type: 'Chat',
            });
        } else {
            model.set({
                duration_hours: 0,
                duration_minutes: 0,
                users: {
                    add: [{
                        id: app.user.id,
                        _module: 'Users'
                    }]
                }
            });
        }

        model.set({
            name: this.getRecordTitle(module, data, contact),
            date_start: data.startTime.formatServer(),
            status: 'In Progress',
            assigned_user_id: app.user.id,
            aws_contact_id: data.aws_contact_id || '',
            invitees: [],
        });

        return model;
    },

    /**
     * Load event listeners specific to chat sessions
     *
     * @param {Object} connection - connect-streams Connection object
     */
    loadChatListeners: function(connection) {
        var controllerHandler = _.bind(this._handleChatMediaController, this);
        connection.getMediaController().then(controllerHandler);
    },

    /**
     * Bind any event listeners onto chat media controllers.
     *
     * @param {Object} controller - ChatSessionController from connect-streams-chatjs
     * @private
     */
    _handleChatMediaController: function(controller) {
        var contactId = controller.controller.contactId;
        this.chatControllers[contactId] = controller;
        controller.onMessage(_.bind(this._handleChatMessage, this));
    },

    /**
     * ChatSessionController.onMessage event handler. Receives the API response
     * object from when messages are sent/received. Overwrites the existing chat
     * transcript for this contact with the most up-to-date version so whenever
     * the chat is ended we can save the transcript.
     *
     * @param {Object} response - connect-streams-chatjs API response
     * @private
     */
    _handleChatMessage: function(response) {
        var controller = this.chatControllers[response.chatDetails.contactId];
        controller.getTranscript({})
            .then(_.bind(this._setChatTranscript, this))
            .catch(function(error) {
                console.log(error);
            });
        if (response.data &&
            response.data.Type === 'MESSAGE' &&
            response.data.ParticipantRole === 'CUSTOMER') {
            this.layout.trigger('omnichannel:message');
        }
    },

    /**
     * Sets a chat transcript to this object's context for reference when the
     * chat session ends
     *
     * @param {Object} transcript - connect-streams-chatjs Transcript object
     * @private
     */
    _setChatTranscript: function(transcript) {
        var currentTranscript = this.chatTranscripts[transcript.data.InitialContactId];
        this.chatTranscripts[transcript.data.InitialContactId] = _.uniq(_.union(
            currentTranscript, transcript.data.Transcript
        ), function(message) {
            return message.Id;
        });
    },

    /**
     * Get a human-readable chat transcript for this contact. This function is
     * called when chat sessions end, and the return value is set on the model
     * when the Messages create drawer opens.
     *
     * @param {Object} contact - connect-streams Contact object
     * @return {string} readableTranscript - human readable chat transcript
     * @private
     */
    _getTranscriptForContact: function(contact) {
        var readableTranscript = '';
        var transcriptJson = this.chatTranscripts[contact.contactId] ||
            this.chatTranscripts[contact.getInitialContactId()] || [];

        _.each(transcriptJson, function(message) {
            readableTranscript += this._formatChatMessage(message);
        }, this);

        return readableTranscript.trim();
    },

    /**
     * Convert a single chat message from JSON to a human-readable format
     *
     * @param {Object} message - JSON-format chat message
     * @return {string} readableMessage - single human-readable chat message
     * @private
     */
    _formatChatMessage: function(message) {
        if (_.isEmpty(message.Content)) {
            return '';
        }
        var offset = app.user.getPreference('tz_offset_sec');
        var dateTime = app.date(message.AbsoluteTime).utcOffset(offset / 60);
        var timeStamp = dateTime.format(app.date.getUserTimeFormat());
        var header = '[' + message.ParticipantRole + ' ' + message.DisplayName + ']';
        header += ' ' + timeStamp;
        return header + '\n' + message.Content + '\n\n';
    },

    /**
     * Search for a record per the specified contact id
     *
     * @param {string} module
     * @param {string} contactId
     * @param {Function} successCallback
     * @private
     */
    _searchRecordByContactId: function(module, contactId, successCallback) {
        var url = app.api.serverUrl + '/' + module + '?filter[0][aws_contact_id][$equals]=' + contactId;
        app.api.call('read', url, null, {
            success: successCallback
        });
    },

    /**
     * Display warning message of potential data loss when user attempts to manually trigger a refresh
     *
     * @return {string|null}
     * @private
     */
    _warnOnRefresh: function() {
        // Only display browser popup if we have an active session
        if (!_.isNull(this.activeContact)) {
            return app.lang.get('LBL_WARN_ACTIVE_CCP_UNSAVED_CHANGES');
        }
    },

    isChat: function(contact) {
        return contact.getType() === connect.ContactType.CHAT;
    },

    isCall: function(contact) {
        return contact.getType() === connect.ContactType.VOICE;
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.layout.off('omniconsole:open', null, this);
        this.layout.off('omniconsole:mode:set', this.resize, this);
        $(window).off('beforeunload', this._warnOnRefresh(), this);
        $(window).off('resize.' + this.cid);
        this._super('_dispose');
    }
}) },
"helplet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * A `helplet` is a view similar to a dashlet thats lives in the help
 * component.
 *
 * TODO: SC-4808: Once MAR-2995 gets merged, we can instead have a collection of
 * helplet views that get iterated over in a helplet-list layout. This will
 * improve performance and provide better flexibility for managing independent
 * helplets.
 *
 * @class View.Views.Base.HelpletView
 * @alias SUGAR.App.view.views.BaseHelpletView
 * @extends View.View
 */
({
	// Helplet View (base) 

    /**
     * Holds the Object returned by `app.help.get()`. Example:
     * <pre><code>
     * {
     *    body: '',
     *    more_help: ''
     * }
     * </code></pre>
     *
     * @type {Object}
     */
    helpObject: {},

    /**
     * Boolean to indicate if the current view's tour is enabled.
     *
     * @type {boolean} `true` if tour is enabled, otherwise `false`.
     * @private
     */
    _tourEnabled: false,

    events: {
        'click [data-action=tour]': 'showTour'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.createHelpObject();
        this.on('render', this.toggleTourLink, this);
    },

    /**
     * Checks if the current view's tour is enabled.
     *
     * @return {boolean} `true` if tour is enabled, otherwise `false`.
     */
    isTourEnabled: function() {
        return this._tourEnabled;
    },

    /**
     * Method to fetch the help object from the app.help utility.
     *
     * @param {Object|null} langContext Additional language to pass in the helpObject strings
     */
    createHelpObject: function(langContext) {
        var helpUrl = _.extend({
            more_info_url: this._createMoreHelpLink(),
            more_info_url_close: '</a>'
        }, langContext);
        var ctx = this.context.parent || this.context;
        this.helpObject = app.help.get(ctx.get('module'), ctx.get('layout'), helpUrl);
    },

    /**
     * Method to set the `tourEnabled` flag based on current module and layout.
     */
    toggleTourLink: function() {
        var ctx = app.controller.context;
        if (app.tutorial.hasTutorial(ctx.get('layout'), ctx.get('module'))) {
            this._tourEnabled = true;
            this.$('[data-action=tour]').removeClass('disabled');
        } else {
            this._tourEnabled = false;
            this.$('[data-action=tour]').addClass('disabled');
        }
    },

    /**
     * Click handler for tour link.
     *
     * Displays the tour and closes the help popup.
     */
    showTour: function() {
        if (!this.isTourEnabled() || app.tutorial.instance) {
            return;
        }

        var ctx = app.controller.context;
        var helpLayout = this.layout.closestComponent('help');
        if (helpLayout && !helpLayout.disposed) {
            helpLayout.toggle(false);
        }

        app.tutorial.resetPrefs();
        app.tutorial.show(ctx.get('layout'), {module: ctx.get('module')});
    },

    /**
     * Override this to sanitize and fix route elements if necessary
     *
     * @param {Object} params
     * @return {Object}
     */
    sanitizeUrlParams: function(params) {
        return params;
    },

    /**
     * Collects server version, language, module, and route and returns an HTML
     * link to be used in the template.
     *
     * @private
     * @return {string} The anchor tag for the 'More Help' link.
     */
    _createMoreHelpLink: function() {
        var serverInfo = app.metadata.getServerInfo();
        var lang = app.lang.getLanguage();
        var module = app.controller.context.get('module');
        var route = app.controller.context.get('layout');
        var products = app.user.getProductCodes().join(',');

        var params = {
            edition: serverInfo.flavor,
            version: serverInfo.version,
            lang: lang,
            module: module,
            route: route,
            products: products
        };

        if (params.route === 'records') {
            params.route = 'list';
        }

        if (params.route === 'bwc') {
            // Parse `action` URL param.
            var action = window.location.hash.match(/#bwc.*action=(\w*)/i);
            if (action && !_.isUndefined(action[1])) {
                params.action = action[1];
            }
        }

        params = this.sanitizeUrlParams(params);

        var url = 'https://www.sugarcrm.com/crm/product_doc.php?' + $.param(params);

        return '<a href="' + url + '" target="_blank">';
    }
}) },
"dupecheck-filter-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckFilterDropdownView
 * @alias SUGAR.App.view.views.BaseDupecheckFilterDropdownView
 * @extends View.Views.Base.FilterFilterDropdownView
 */
({
	// Dupecheck-filter-dropdown View (base) 

    extendsFrom: 'FilterFilterDropdownView',

    /**
     * Display `LBL_DUPECHECK_FILTER_DEFAULT` for all record set label.
     */
    labelAllRecordsFormatted: 'LBL_DUPECHECK_FILTER_DEFAULT'
}) },
"list-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ListHeaderpaneView
 * @alias SUGAR.App.view.views.BaseListHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// List-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // FIXME: SC-3594 will address having child views extending metadata
        // from its parent.
        options.meta = _.extend(
            {},
            app.metadata.getView(null, 'list-headerpane'),
            app.metadata.getView(options.module, 'list-headerpane'),
            options.meta
        );

        this._super('initialize', [options]);

        //shortcut keys
        app.shortcuts.register({
            id: 'List:Headerpane:Create',
            keys: 'a',
            component: this,
            description: 'LBL_SHORTCUT_CREATE_RECORD',
            handler: function() {
                var $createButton = this.$('a[name=create_button]');
                if ($createButton.is(':visible') && !$createButton.hasClass('disabled')) {
                    $createButton.get(0).click();
                }
            }
        });
    }
}) },
"stage2-news": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Stage2-news View (base) 

    plugins: ['EllipsisInline', 'Stage2CssLoader'],

    events: {
        'click [data-action=newsClick]': 'trackNewsSelect'
    },

    /**
     * This is a mapping used to sort news into categories based on Orwell's news types.
     */
    filterMap: {
        'NEWS': 'General',
        'PRESS': 'Press Releases',
        'FUNDING': 'Finance',
        'ACQUISITION': 'Finance',
        'PEOPLE': 'People',
        'BLOG': 'Other',
        'VIDEOS': 'Other'
    },

    /**
     * Load threshold indicates how many news should be fake-loaded initially and on scroll.
     */
    loadThreshold: 5,

    /**
     * The model id is used for saving the user's filter/search preference.
     * When the user opens the same news feed again, the filter/search will be applied.
     */
    modelId: '',

    /**
     * Indicates if more news should be loaded. On initial load and on scroll
     * this variable should be true, but if we simply apply a filter, it should be false.
     */
    loadMore: true,

    /**
     * Shows that how much did we scroll down. When a filter is applied, the scroll is reset.
     * We reapply the amount of scroll we did with the help of the scrollPosition.
     */
    scrollPosition: 0,

    /**
     * Shows that how many times is the news request retryed on error.
     * On each fail the counter will be decreased and on 0 retry will be stopped.
     */
    newsRetryCounter: 3,

    /**
     * Shows the order number of the last displayed news article.
     * Filtering/searching will always be done only on the news already displayed once.
     */
    lastDisplayedNewsIndex: 0,

    /**
     * Initially and on loading we would like to show a placeholder for the user.
     * Since we start with loading the dependencies, we show the placeholder by default.
     */
    isHintRequestLoading: true,

    /**
     * The list of news articles loaded.
     */
    news: [],

    /**
     * The list of news articles based on the search term/filer.
     */
    searchResults: [],

    /**
     * Holds the time duration of a valid data enrichment access token (1 hour).
     */
    tokenExpirationTimeOut: 60 * 60 * 1000,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.context.set('forceNew', true);
        this._super('initialize', [options]);
        this.getDependencies();
        this.isDarkMode = app.utils.isDarkMode();
        app.events.on('hint-news-panel:filter', this.applyFilter, this);
        this.context.parent.on('change:model', _.bind(this.refreshNews, this));
    },

    /**
     * An error handler used by the stage2 dependency calls.
     *
     * @param {string} message Error message to log.
     * @param {Object} error Error object holding information about the failed request.
     */
    setStage2errorCode: function(message, error) {
        app.logger.error(message.concat(JSON.stringify(error)));
        if (_.isUndefined(this.stage2errorCode)) {
            this.stage2errorCode = error.status;
            this.render();
        }
    },

    /**
     * First dependency of the news request. The news will be get using the url retrieved from here.
     * Invokes the callback function once we have obtained the url.
     */
    getStage2Url: function(callback) {
        var self = this;
        app.api.call('GET', app.api.buildURL('stage2/params'), null, {
            success: function(data) {
                self.stage2url = data.enrichmentServiceUrl;
                callback();
            },
            error: _.bind(this.setStage2errorCode, this, 'Failed to get Hint param: ')
        });
    },

    /**
     * Second dependency of the news request. News can be retrieved only with a valid access token.
     * Invokes the callback function once we have obtained the auth token.
     */
    getStage2AccessToken: function(callback) {
        var self = this;
        app.api.call('create', app.api.buildURL('stage2/token'), null, {
            success: function(data) {
                // Track the data enrichment access token locally so we know when that we have it
                // and that it is valid or invalid (and when invalid to update the token).
                SUGAR.App.user.set('authToken', data.accessToken);
                SUGAR.App.user.set('authTokenExpiration', Date.now() + self.tokenExpirationTimeOut);
                callback();
            },
            error: _.bind(self.setStage2errorCode, self, 'Failed to get Hint access token: ')
        });
    },

    /**
     * Will save the domain and the name of the account so we could reuse it later for getting news.
     * The domain will be checked if it exists in the following sources
     * and retrieved from the first source found; website, primary email, any email.
     *
     * @param {bean} bean The fetched bean.
     */
    saveCompanyInfoForNews: function(bean) {
        var domain = bean.get('website');

        if (domain && domain.trim() !== '') {
            domain = domain.replace(/^https?\:\/\//i, '');
        } else if (!_.isEmpty(bean.get('email'))) {
            var email = _.findWhere(bean.get('email'), {
                primary_address: true
            });

            email = !email ? bean.get('email')[0].email_address : email.email_address;

            if (email.indexOf('@') > 0) {
                var mailDomain = email.split('@')[1].trim();
                if (!_.isEmpty(mailDomain)) {
                    domain = mailDomain;
                }
            }
        }

        this.companyInfo = {
            domain: domain || '',
            name: bean.module === 'Accounts' ? bean.get('name') : bean.get('account_name')
        };

        // At this point, all of our 3 dependencies (data enrichment URL, access token, company info)
        // have been successfully set.
        this.initNewsRequest();
    },

    /**
     * The third and last dependency of the news request.
     * Retrieves information about the source of the news to be fetched.
     * We also reset the news already loaded since the context is going to be changed.
     *
     * @param {Bean} model The parent model, which for example could be an account or a contact model.
     */
    getCompanyInfo: function(model) {
        var bean = app.data.createBean(model.module, {
            id: model.id
        });

        this.news = [];
        delete this.companyInfo;

        bean.fetch({
            success: _.bind(this.saveCompanyInfoForNews, this),
            error: function(error) {
                app.logger.error('Failed to fetch: ' + JSON.stringify(error));
            }
        });
    },

    /**
     * Will load all 3 news dependencies. _withValidAuthentication() will ensure that we have
     * a valid data enrichment URL and a non-expired access token (our first 2 dependencies).
     * We then fetch company info as our final dependency step.
     * Without a context we will not be able to define what kind of news should be loaded.
     * information regarding the source of the news.
     */
    getDependencies: function() {
        var self = this;
        if (self.context.parent) {
            var previewModel = self.context.parent.get('model');
            self.modelId = previewModel.get('id');
            self._withValidAuthentication(function() {
                self.getCompanyInfo(previewModel);
            });
        }
    },

    /**
     * Checks if we have the necessary information regarding the news' source.
     * Company information is valid if there is an assigned domain and a name to identify by.
     *
     * @return {boolean} True is the company information is valid.
     */
    hasValidCompanyInfo: function() {
        var info = this.companyInfo;
        if (info != null) {
            if (info.domain != null && info.domain.trim() !== '') {
                return true;
            } else if (info.name != null && info.name.trim() !== '') {
                return true;
            }
        }
        return false;
    },

    /**
     * Ensures we have the data enrichment URL and a valid auth token before retrieving news.
     * If then token is expired, we fetch a new access token and update the local token expiration timer.
     * We then invoke the provided callback function once we have the URL and token.
     */
    _withValidAuthentication: function(callback) {
        var self = this;
        if (!self.stage2url) {
            self.getStage2Url(function() {
                self._withValidAuthentication(callback);
            });
            return;
        }
        if (self.isTokenExpired()) {
            self.getStage2AccessToken(function() {
                self._withValidAuthentication(callback);
            });
            return;
        }
        callback();
    },

    /**
     * Once we have valid company data we call getNews() to retrieve the latest 50 news articles
     */
    initNewsRequest: function() {
        if (this.hasValidCompanyInfo()) {
            this.getNews();
        } else {
            this.isHintRequestLoading = false;
            this.render();
        }
    },

    /**
     * Ensures that we have a valid access token
     */
    isTokenExpired: function() {
        var authTokenExpiration = SUGAR.App.user.get('authTokenExpiration');
        return (!authTokenExpiration || authTokenExpiration < Date.now());
    },

    /**
     * If there is no active request for getting news it will send out a request.
     */
    getNews: function() {
        var self = this;
        if (self.disposed === true) {
            return;
        }
        if (self.activeRequest) {
            self.activeRequest.abort();
        }

        self._withValidAuthentication(function() {
            self.activeRequest = $.ajax({
                type: 'GET',
                data: self.getNewsRequestData(),
                url: self.stage2url.concat('/company-news'),
                headers: {
                    authToken: SUGAR.App.user.get('authToken'),
                },
                success: _.bind(self.loadNews, self),
                error: _.bind(self.handleFailedNewsFetch, self)
            });
        });
    },

    /**
     * Composes a list of necessary parameters in order to be able to retrieve news.
     *
     * @return {Object} Hold details about the source of the news and metrics.
     */
    getNewsRequestData: function() {
        if (this.context) {
            return {
                companyInfo: JSON.stringify({
                    country: undefined,
                    tickerSymbol: undefined,
                    name: this.companyInfo.name,
                    domain: this.companyInfo.domain
                }),
                moduleName: this.context.get('module'),
                metricsToken: app.user.get('hintMetricsToken')
            };
        }
    },

    /**
     * Retry news request
     */
    retryNewsRequest: function() {
        if (this.newsRetryCounter <= 0) {
            this.isHintRequestLoading = false;
            this.newsRetryCounter = 3;
            this.render();
        } else if (this.newsRetryCounter > 0) {
            this.getNews();
            app.logger.debug('News fetch retry #'.concat(3 - this.newsRetryCounter));
        }
    },

    /**
     * Error handler for the news request. Error should be handled only if the
     * request was not aborted manually. Also if the retrieval fails it will try
     * to fetch the news again for a limited number of times.
     */
    handleFailedNewsFetch: function(error) {
        this.activeRequest = null;
        if (error && error.statusText !== 'abort') {
            app.logger.error('Failed to fetch news on Hint: ' + JSON.stringify(error));
            this.newsRetryCounter--;
            this.retryNewsRequest();
        }
    },

    /**
     * Each article should receive the following information:
     * an id, used for searching the news titles for a specific value
     * hide flag, used to show/hide news on the page - initially all news are hidden
     * type, used for the fixed filter categories
     * Additionally we create a map of the news' titles for the case when
     * we would like to filter them by a custom word.
     *
     * @param {Array} news A list of news articles.
     */
    extendNews: function(news) {
        _.each(news, function(article, i) {
            article.id = i;
            article.hide = true;
            article.type = this.filterMap[article.category];
        }, this);
        this.news = news;
    },

    /**
     * All the news will be marked as hidden.
     * Used when applying a filter/search term.
     */
    markNewsAsHidden: function() {
        _.each(this.news, function(news) {
            news.hide = true;
        });
    },

    /**
     * This is where the actual search is happening. The searchResults will hold a list of news,
     * these news all contain the search term in their titles. Based on the searchResults
     * we will be able to tell, which  articles need to be marked visible.
     * Important note: here we make the search on ALL available news, however we display none,
     * it is the responsibility of `toggleNews` to display news that are found in the results saved here.
     *
     * @param {string} searchTerm A phrase or a single word.
     */
    searchNews: function(searchTerm) {
        this.searchResults = [];
        _.each(this.news, function(article) {
            if (article.title.toLowerCase().indexOf(searchTerm.toLowerCase()) > -1) {
                this.searchResults.push(article);
            }
        }, this);
    },

    /**
     * Checks if the given string is a predefined category. If it isn't, it must be a search term.
     *
     * @param {string|null} filter The value of the filter. `Null` means no filter.
     * @return {boolean} True of the filter is in fact a search term.
     */
    isSearchFilter: function(filter) {
        return filter && _.values(this.filterMap).indexOf(filter) === -1;
    },

    /**
     * We check if the given filter is set by the user.
     * In the case the user did not set a filter yet, the value will be undefined.
     *
     * @param {string|null} filter The value of the filter.
     * @return {boolean} True if the filter is set by the user.
     */
    hasUserSetFilter: function(filter) {
        return !!(filter || filter === null);
    },

    /**
     * If the user did filter/search already the news assigned to the current context
     * we reapply it on the list. Note that `null` means that the user desires to see all news.
     */
    applyExistingFilter: function() {
        var filter = this.readFilter();
        if (this.hasUserSetFilter(filter)) {
            app.events.trigger('hint-news-panel-filter:set', filter);
        }

        if (this.isSearchFilter(filter)) {
            this.searchNews(filter);
        } else {
            this.filterNews(filter);
        }
        this.toggleNews();
    },

    /**
     * Initializes the search/filter process when the user changes the assigned field.
     *
     * @param {string|null} filter
     */
    applyFilter: function(filter) {
        if (this.news.length && this.readFilter() !== filter) {
            this.loadMore = false;
            this.scrollPosition = 0;
            this.markNewsAsHidden();
            this.writeFilter(filter);

            if (this.isSearchFilter(filter)) {
                this.searchNews(filter);
            } else {
                this.filterNews(filter);
            }
            this.toggleNews();
        }
    },

    /**
     * News request success handler. If we managed to retrieve news,
     * they need to be processed, and displayed. Only a limited number of news will be displayed.
     * The rest of the news will get rendered on scroll. Render will happen through filtering.
     *
     * @param {Object} data The response to the news request.
     */
    loadNews: function(data) {
        this.activeRequest = null;
        this.newsRetryCounter = 3;

        if (!this.disposed && data && data.news) {
            this.isHintRequestLoading = false;
            if (data.news.length === 0) {
                app.events.trigger('hint-news-panel-filter:set', null);
                this.render();
            } else {
                this.extendNews(data.news);
                this.applyExistingFilter();
            }
        }
    },

    /**
     * @return {string} A unique id for identifying the filter for the current context.
     */
    getFilterKey: function() {
        return 'news-filter-option*' + this.modelId;
    },

    /**
     * Retrieves the filter applied by the user the last time.
     */
    readFilter: function() {
        return app.user.lastState.get(this.getFilterKey());
    },

    /**
     * Saves the filter value as a user preference. `Null` means no filter.
     *
     * @param {string|null} filter
     */
    writeFilter: function(filter) {
        app.user.lastState.set(this.getFilterKey(), filter);
    },

    /**
     * This method may returns 2 kind of lists of news.
     * One is returned upon scrolling:
     * we need to apply the current filter on the news to be displayed.
     * The other just on searching/filtering:
     * we apply the search term/filter on all the news.
     *
     * @return {Array} A list of news.
     */
    getNextSegmentForFilter: function() {
        var start = this.loadMore ? this.lastDisplayedNewsIndex : 0;
        this.lastDisplayedNewsIndex += this.loadMore ? this.loadThreshold : 0;
        return this.searchResults.slice(start, this.lastDisplayedNewsIndex);
    },

    /**
     * News are filtered here. The searchResults will hold a list of news based on the selected category.
     * Important note: here we do the filter on ALL available news, however we display none.
     * It is the responsibility of `toggleNews` to display news that are found in the results saved here.
     *
     * @param {string|null} filter A news category.
     */
    filterNews: function(filter) {
        this.searchResults = [];
        _.each(this.news, function(article) {
            if (!filter || article.type === filter) {
                this.searchResults.push(article);
            }
        }, this);
    },

    /**
     * News articles will be marked as visible.
     * Applying a render will show/hide the corresponding news.
     */
    toggleNews: function() {
        var segment = this.getNextSegmentForFilter();
        _.each(segment, function(article) {
            if (_.findWhere(this.searchResults, {id: article.id})) {
                article.hide = false;
            }
        }, this);
        this.render();
    },

    /**
     * Scroll handler on the news container. When we reach the end of the container we "load" more news.
     * What happens in fact, is that we take the next couple of hidden news and render the visible
     * according to the current filter/search term applied.
     *
     * @param {EventObject} event Scroll event.
     */
    verifyScrollPosition: function(event) {
        var target = event.target;

        if (target.offsetHeight + target.scrollTop == target.scrollHeight) {
            var delay = 750;
            var delayedTrigger = _.debounce(_.bind(this.triggerFakeLoad, this), delay);
            delayedTrigger(target.scrollTop);
        }
    },

    /**
     * This is a fake load that happens on scroll. No new request will be made,
     * but a batch of hidden news will be processed.
     *
     * @param {number} newScrollTop The amount of scrolling we already did.
     */
    triggerFakeLoad: function(newScrollTop) {
        if (this.lastDisplayedNewsIndex < this.searchResults.length) {
            this.loadMore = true;
            this.scrollPosition = newScrollTop;
            this.toggleNews();
        }
    },

    /**
     * If the parent context's model changes we need to refresh the news.
     *
     * @param {Component} ctx The parent context.
     * @param {Bean} model The parent context's model.
     */
    refreshNews: function(ctx, model) {
        this.loadMore = true;
        this.scrollPosition = 0;
        this.modelId = model.get('id');
        this.lastDisplayedNewsIndex = 0;
        this.isHintRequestLoading = true;
        this.getCompanyInfo(model);
    },

    /**
     * Verifies if there are any news marked as visible among the news that have been already loaded.
     */
    checkNewsToDisplay: function() {
        this.displayNews = _.find(this.searchResults.slice(0, this.lastDisplayedNewsIndex), function(article) {
            return article.hide === false;
        });
    },

    /**
     * @inheritdoc
     * Additionally checks if there are any news to be displayed.
     * Attaches scroll event handler to the news container (can be done after the first render).
     * Also applies any scrolling done already (important why filtering/searching).
     */
    _render: function(options) {
        this.checkNewsToDisplay();
        this._super('_render', [options]);
        var newsArea = this.$('#newsarea');
        if (!newsArea.attr('hasScrollEvent')) {
            newsArea.on('scroll', _.bind(this.verifyScrollPosition, this));
        }
        if (this.scrollPosition) {
            newsArea.scrollTop(this.scrollPosition);
        }
    },

    /**
     * @inheritdoc
     * Detach event handlers.
     */
    _dispose: function() {
        this.$('#newsarea').off('scroll', _.bind(this.verifyScrollPosition, this));
        app.events.off('hint-news-panel:filter', this.applyFilter, this);
        this._super('_dispose');
    },

    /**
     * Tracks which news has been opened by the user.
     *
     * @param {EventObject} event Event information
     */
    trackNewsSelect: function(event) {
        var self = this;
        self._withValidAuthentication(function() {
            $.ajax({
                type: 'POST',
                data: {
                    clickType: 'news',
                    origin: self.context.get('module'),
                    clickedURL: event.currentTarget.href,
                    title: event.currentTarget.innerText,
                    metricsToken: app.user.get('hintMetricsToken')
                },
                url: self.stage2url.concat('/url-click'),
                headers: {
                    authToken: SUGAR.App.user.get('authToken')
                },
                error: function(err) {
                    app.logger.error('Failed to record news click event: ' + JSON.stringify(err));
                }
            });
        });
    }
}) },
"vcard-import": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.VcardImportView
 * @alias SUGAR.App.view.views.BaseVcardImportView
 * @extends View.View
 */
({
	// Vcard-import View (base) 

    /**
     * @inheritdoc
     * Imports a vcf file and creates a record based on person type
     */
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        this.context.on('vcard:import:finish', this.importVCard, this);
        this.on('render', this._setFileField, this);
    },

    /**
     * Sets up the file field to edit mode
     *
     * @param {View.Field} field
     * @private
     */
    _setFileField: function() {
        var field = this.getField('vcard_import');
        field.setMode('edit');
    },

    /**
     * Event to trigger the uploading of the vcf and record creation
     */
    importVCard: function() {
        var vcardFieldName = 'vcard_import',
            $vcardFile = this.$('[name=vcard_import]');

        if (_.isEmpty($vcardFile.val())) {
            app.alert.show('error_validation_vcard', {
                level: 'error',
                messages: 'LBL_EMPTY_VCARD'
            });
        } else {
            var ajaxParams = {
                    temp: false,
                    deleteIfFails: false
                },
                fields = {},
                field = this.getField(vcardFieldName);

            fields[vcardFieldName] = field.def;

            this.context.trigger('vcard:import-finish-button:toggle', false);
            app.alert.show('vcard_importing', {
                level: 'process',
                title: app.lang.get('LBL_SAVING', this.module)
            });
            this.model.uploadFile(vcardFieldName, $vcardFile, {
                success: _.bind(this._doValidateFileSuccess, this),
                error: _.bind(this._doValidateFileError, this)
            }, ajaxParams);
        }
    },

    /**
     * Success callback for the {@link #importVCard} function.
     *
     * @param {Object} data File data returned from the successful file upload.
     */
    _doValidateFileSuccess: function(data) {
        var route = app.router.buildRoute(this.module, data.vcard_import);
        app.router.navigate(route, {trigger: true});
        app.alert.dismiss('vcard_importing');
        app.alert.show('vcard-import-saved', {
            level: 'success',
            messages: app.lang.get('LBL_IMPORT_VCARD_SUCCESS', this.module),
            autoClose: true
        });
    },

    /**
     * Error callback for the {@link #importVCard} function.
     *
     * @param {Object} error Error object returned from the API.
     */
    _doValidateFileError: function(error) {
        this.context.trigger('vcard:import-finish-button:toggle', true);
        app.alert.dismiss('vcard_importing');
        app.alert.show('error_validation_vcard', {
            level: 'error',
            messages: app.lang.get('TPL_IMPORT_VCARD_FAILURE', this.module, {module: this.module})
        });
    }
}) },
"create-no-cancel-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.CreateNoCancelButtonView
 * @alias SUGAR.App.view.views.BaseCreateNoCancelButtonView
 * @extends View.Views.Base.CreateView
 */
({
	// Create-no-cancel-button View (base) 

    extendsFrom: 'CreateView',
}) },
"history-summary-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HistorySummaryHeaderpaneView
 * @alias SUGAR.App.view.views.BaseHistorySummaryHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// History-summary-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click a[name=cancel_button]': 'cancel'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.model = this.context.parent && this.context.parent.get('model') || this.model;
    },

    /**
     * @override
     */
    _formatTitle: function(title) {
        var parent = this._getParentModel();
        var recordName = app.utils.getRecordName(parent);
        if (recordName) {
            return app.lang.get('TPL_HISTORICAL_SUMMARY', parent.module, {name: recordName});
        } else if (title) {
            return app.lang.get(title, this.module);
        } else {
            return '';
        }
    },

    /**
     * Gets the parent model of this historical summary view.
     *
     * @return {Data.Bean} The parent model.
     * @private
     */
    _getParentModel: function() {
        return this.context.parent.get('model');
    },

    /**
     * Gets the name of the parent model.
     *
     * @return {string} The parent model name.
     * @protected
     * @deprecated Deprecated since 8.0. Please use App.utils.getRecordName(parent)
     */
    _getParentModelName: function() {
        app.logger.warn('The function ' +
            '`View.Views.Base.HistorySummaryHeaderpaneView._getParentModelName`' +
            ' is deprecated since 8.0 and will be removed in the near future.' +
            'Please use `App.utils.getRecordName` instead.');

        var parent = this._getParentModel();
        return app.utils.formatNameModel(parent.module, parent.attributes) || parent.get('name');
    },

    /**
     * Cancel and close the drawer
     */
    cancel: function() {
        app.drawer.close();
    }
}) },
"error": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ErrorView
 * @alias SUGAR.App.view.views.BaseErrorView
 * @extends View.View
 */
({
	// Error View (base) 

    className: 'error-page',

    cubeOptions: {spin: false},

    events: {
        'click .sugar-cube': 'spinCube'
    },

    initialize: function(options) {
        // Adds the metadata for the Error module
        app.metadata.set(this._metadata);
        app.data.declareModels();

        // Reprepare the context because it was initially prepared without metadata
        app.controller.context.prepare(true);

        // Attach the metadata to the view
        options.meta = this._metadata.modules[options.module].views[options.type].meta;
        this._super('initialize', [options]);
    },
    _render: function() {
        if(this.context.get('errorType')) {
            var attributes = this.getErrorAttributes();
            this.model.set(attributes);
        }
        app.view.View.prototype._render.call(this);
    },
    getErrorAttributes: function() {
        var errorType = this.context.get('errorType'),
            attributes;

        switch (errorType) {
            case '400':
                attributes = {
                    title: 'ERR_HTTP_400_TITLE',
                    type: 'ERR_HTTP_400_TYPE',
                    messages: ['ERR_HTTP_400_TEXT_LINE1', 'ERR_HTTP_400_TEXT_LINE2'],
                    linkText: app.lang.get('ERR_HTTP_400_ACTION')
                };
                break;
            case '404':
                attributes = {
                    title: 'ERR_HTTP_404_TITLE',
                    type: 'ERR_HTTP_404_TYPE',
                    messages: ['ERR_HTTP_404_TEXT_LINE1', 'ERR_HTTP_404_TEXT_LINE2'],
                    linkText: app.lang.get('ERR_HTTP_404_ACTION')
                };
                break;
            case '422':
                attributes = {
                    title: 'ERR_HTTP_DEFAULT_TEXT',
                    type: error.status || 'ERR_HTTP_DEFAULT_TYPE',
                    messages: ['ERR_CONTACT_TECH_SUPPORT'],
                    linkText: app.lang.get('ERR_HTTP_DEFAULT_ACTION')
                };
                break;
            case '500':
                attributes = {
                    title: 'ERR_HTTP_500_TITLE',
                    type: 'ERR_HTTP_500_TYPE',
                    messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2'],
                    linkText: app.lang.get('ERR_HTTP_500_ACTION')
                };
                break;
            case '502':
                attributes = {
                    title: 'ERR_HTTP_502_TITLE',
                    type: 'ERR_HTTP_502_TYPE',
                    messages: ['ERR_HTTP_502_TEXT_LINE1', 'ERR_HTTP_502_TEXT_LINE2']
                };
                break;
            case '503':
                attributes = {
                    title: 'ERR_HTTP_503_TITLE',
                    type: 'ERR_HTTP_503_TYPE',
                    messages: ['ERR_HTTP_503_TEXT_LINE1', 'ERR_HTTP_503_TEXT_LINE2']
                };
                break;
            default:
                var error = this.context.get('error') || {};
                var title = null;
                if (error.status && error.errorThrown) {
                    title = 'HTTP: ' + error.status + ' ' + error.errorThrown;
                }
                attributes = {
                    title: title || 'ERR_HTTP_DEFAULT_TITLE',
                    type: error.status || 'ERR_HTTP_DEFAULT_TYPE',
                    messages: [error.message || 'ERR_HTTP_DEFAULT_TEXT']
                };
                break;
        }
        return attributes;
    },

    _metadata : {
        "modules": {
            "Error": {
                "views": {
                    "error": {
                        "meta": {}
                    }
                },
                "layouts": {
                    "error": {
                        "meta": {
                            "type": "simple",
                            "components": [
                                {view: "error"}
                            ]
                        }
                    }
                }
            }
        },
        'module_tab_map': {
            'Error': ''
        }
    },

    spinCube: function() {
        this.cubeOptions.spin = !this.cubeOptions.spin;
        this.render();
    }
}) },
"merge-duplicates-progress": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MergeDuplicatesProgressView
 * @alias SUGAR.App.view.views.BaseMergeDuplicatesProgressView
 * @extends View.Views.Base.MassupdateProgressView
 */
({
	// Merge-duplicates-progress View (base) 

    extendsFrom: 'MassupdateProgressView',

    plugins: ['editable'],

    /**
     * @inheritdoc
     */
    _labelSet: {
        TITLE: 'LBL_MERGE_DUPLICATES_TITLE',
        PROGRESS_STATUS: 'TPL_MERGE_DUPLICATES_PROGRESS_STATUS',
        FAIL_TO_ATTEMPT: 'TPL_MERGE_DUPLICATES_FAIL_TO_ATTEMPT',
        FAIL: 'TPL_MERGE_DUPLICATES_FAIL'
    },

    /**
     * @property {Number} processedCount Number of processed elements.
     */
    processedCount: 0,

    /**
     * @property {Number} failsCount Number of fails.
     */
    failsCount: 0,

    /**
     * @inheritdoc
     */
    initLabels: function() {
        this.LABELSET = this._labelSet;
    },

    /**
     * Reset view parameters.
     */
    reset: function() {
        this.processedCount = 0;
        this.failsCount = 0;
        this.totalRecord = 0;
    },

    /**
     * @inheritdoc
     *
     * There are no conditions to check.
     */
    checkAvailable: function() {
        return true;
    },

    /**
     * @inheritdoc
     *
     * No estimate used.
     */
    getEstimate: function() {
        return 0;
    },

    /**
     * Set number of total elements for progress.
     *
     * @param {Number} total Number of total records.
     */
    setTotalRecords: function(total) {
        this.totalRecord = total;
    },

    /**
     * @inheritdoc
     */
    getTotalRecords: function() {
        return this.totalRecord;
    },

    /**
     * @inheritdoc
     */
    getRemainder: function() {
        return '';
    },

    /**
     * Setup count of processed elements.
     *
     * @param {Number} count Count of processed elements.
     */
    setProgressSize: function(count) {
        this.processedCount;
    },

    /**
     * Increments count of processed elements.
     */
    incrementProgressSize: function() {
        this.processedCount = this.processedCount + 1;
    },

    /**
     * @inheritdoc
     */
    getProgressSize: function() {
        return this.processedCount;
    },

    /**
     * @inheritdoc
     *
     * @param {Object} context Object to check errors.
     */
    checkError: function(context) {
        if (_.isUndefined(context) || _.isUndefined(context.attempt)) {
            return;
        }

        if (context.attempt === 0 ||
            context.attempt > (context.maxAllowAttempt || 3)
        ) {
            return;
        }

        app.alert.dismiss('check_error_message');
        app.alert.show('check_error_message', {
            level: 'warning',
            messages: app.lang.get(this.LABELSET['FAIL_TO_ATTEMPT'], this.module, {
                objectName: context.objectName || '',
                num: context.attempt,
                total: (context.maxAllowAttempt || 3)
            }),
            autoClose: true,
            autoCloseDelay: 8000
        });
    },

    /**
     * Handler for drawer `reset` event.
     * @return {boolean}
     */
    _onDrawerReset: function() {
        this.showProgress();
        return false;
    },

    /**
     * @inheritdoc
     *
     * Setup handler for drawer to prevent closing it.
     * We need it b/ the operation an be too long and in this time
     * token can be expired.
     */
    showProgress: function() {
        app.drawer.before('reset', this._onDrawerReset, this);
        this._super('showProgress');
    },

    /**
     * Update the progress view when the job is paused.
     * Triggers `massupdate:pause:completed` event on model.
     */
    pauseProgress: function() {
        var stopButton = this.getField('btn-stop');
        if (stopButton) {
            stopButton.setDisabled(true);
        }
        this.$holders.bar.removeClass('active');
        this.model.trigger('massupdate:pause:completed');
    },

    /**
     * Update the progress view when the job is resumed.
     * Triggers `massupdate:resume:completed` event on model.
     */
    resumeProgress: function() {
        var stopButton = this.getField('btn-stop');
        if (stopButton) {
            stopButton.setDisabled(false);
        }
        this.model.trigger('massupdate:resume:completed');
    },

    /**
     * Update the progress view when the job is stopped.
     * Triggers `massupdate:stop:completed` event on model.
     */
    stopProgress: function() {
        this.model.trigger('massupdate:stop:completed');
    },

    /**
     * @inheritdoc
     *
     * Dismiss alerts:
     * 1. `stop_confirmation` - confirmation on pause
     * 2. `check_error_message` - check errors status alert
     * Triggers `massupdate:end:completed` event on model.
     * Removes handler for drawer.
     */
    hideProgress: function() {
        app.drawer.offBefore('reset', this._onDrawerReset, this);
        this.hide();
        app.alert.dismiss('stop_confirmation');
        app.alert.dismiss('check_error_message');
        this.model.trigger('massupdate:end:completed');
    },

    /**
     * Called with new item is processed.
     *
     * Increments number of processed elements and
     * calls {@link View.MergeDuplicatesProgressView#updateProgress}.
     * Triggers `massupdate:item:processed:completed` event on model.
     */
    onItemProcessed: function() {
        this.incrementProgressSize();
        this.updateProgress();
        this.model.trigger('massupdate:item:processed:completed');
    },

    /**
     * Called when item go to next attemp.
     * Triggers `massupdate:item:attempt:completed` event on model.
     *
     * @param {Object} context Object that triggered event.
     */
    onNextAttept: function(context) {
        this.checkError(context);
        this.model.trigger('massupdate:item:attempt:completed');
    },

    /**
     * Called when item cannot be processed after a few attemps.
     *
     * Shows error message.
     * Triggers `massupdate:item:fail:completed` event on model.
     *
     * @param {Object} context Object that triggered event.
     */
    onItemFail: function(context) {
        this.failsCount = this.failsCount + 1;
        this.$holders.bar
            .removeClass('progress-info')
            .addClass('progress-danger');

        app.alert.dismiss('fail_message');
        app.alert.show('fail_message', {
            level: 'error',
            messages: app.lang.get(this.LABELSET['FAIL'], this.module, {
                objectName: context.objectName || ''
            })
        });
        this.model.trigger('massupdate:item:fail:completed');
    },

    /**
     * @inheritdoc
     *
     * Use model to listen events insted of collection.
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }
        this.on('render', this.initHolders, this);
        this.before('start', this.checkAvailable, this);
        this.model.on('massupdate:always', this.updateProgress, this);
        this.model.on('massupdate:start', this.showProgress, this);
        this.model.on('massupdate:end', this.hideProgress, this);
        this.model.on('massupdate:fail', this.checkError, this);
        this.model.on('massupdate:resume', this.resumeProgress, this);
        this.model.on('massupdate:pause', this.pauseProgress, this);
        this.model.on('massupdate:stop', this.stopProgress, this);
        this.model.on('massupdate:item:processed', this.onItemProcessed, this);
        this.model.on('massupdate:item:attempt', this.onNextAttept, this);
        this.model.on('massupdate:item:fail', this.onItemFail, this);
    }
}) },
"forgotpassword": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Forgot password form view.
 *
 * @class View.Views.Base.ForgotpasswordView
 * @alias SUGAR.App.view.views.BaseForgotpasswordView
 * @extends View.View
 */
({
	// Forgotpassword View (base) 

    plugins: ['ErrorDecoration'],

    events: {
        'click [name=cancel_button]': 'cancel',
        'click [name=forgotPassword_button]': 'forgotPassword',
        'change select[name=country]': 'render'
    },

    /**
     * Get the fields metadata from panels and declare a Bean with the metadata
     * attached.
     *
     * {@link View.Views.Base.LoginView}
     *
     * @param {Object} meta The view's metadata supplied.
     * @private
     */
    _declareModel: function(meta) {
        meta = meta || {};

        var fields = {};
        _.each(_.flatten(_.pluck(meta.panels, "fields")), function(field) {
            fields[field.name] = field;
        });
        /**
         * Fields metadata needs to be converted to this format for App.data.declareModel
         *  {
          *     "first_name": { "name": "first_name", ... },
          *     "last_name": { "name": "last_name", ... },
          *      ...
          * }
         */
        app.data.declareModel('Forgotpassword', {fields: fields});
    },

    /**
     * @override
     * @param options
     */
    initialize: function(options) {
        // Declare a Bean so we can process field validation
        this._declareModel(options.meta);

        // Reprepare the context because it was initially prepared without metadata
        options.context.prepare(true);

        app.view.View.prototype.initialize.call(this, options);
        this._showResult = false;
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        if (!(app.config && app.config.forgotpasswordON === true)) {
            return;
        }
        if (app.config.idmModeEnabled === true) {
            window.location.href = app.config.cloudConsoleForgotPasswordUrl;
        }
        this.logoUrl = app.metadata.getLogoUrl(app.utils.isDarkMode());
        app.view.View.prototype._render.call(this);

        return this;
    },

    /**
     * Basic cancel button
     */
    cancel: function() {
        app.router.goBack();
    },

    /**
     * Handles forgot password request
     */
    forgotPassword: function() {
        var self = this;

        self.model.doValidate(null, function(isValid) {
            if (isValid) {

                // a robot has reached into the honey pot. do not submit
                if (app.config.honeypot_on && app.config.honeypot_on === true &&
                    (self.$('input[name="first_name"]').val() || self.model.get('first_name'))) return;

                app.$contentEl.hide();
                app.alert.show('forgotPassword', {level: 'process', title: app.lang.get('LBL_LOADING'), autoClose: false});

                var emails = self.model.get('email');
                var params = {
                    username: self.model.get('username')
                };

                if (emails && emails[0] && emails[0].email_address) {
                    params.email =  emails[0].email_address;
                }

                var url = app.api.buildURL('password/request','',{},params);
                app.api.call('READ', url,{},{
                    success: function(response){
                        // result flags
                        self._showSuccess = true;
                        self._showResult = true;
                        self.resultLabel = "LBL_PASSWORD_REQUEST_SENT";
                        self.model.clear();
                        if (!self.disposed) {
                            self.render();
                        }
                    },
                    error: function(err){
                        // result flags
                        self._showSuccess = false;
                        self._showResult = true;

                            self.resultLabel = err.message || 'LBL_PASSWORD_REQUEST_ERROR';

                        if (!self.disposed) {
                            self.render();
                        }
                    },
                    complete: function() {
                        app.alert.dismiss('forgotPassword');
                        app.$contentEl.show();
                    }
                })
            }
        }, self);
    },

    /**
     * Really basic metadata for the Back button displayed on password reset
     */
    _backButton: [
        {
            name: 'cancel_button',
            type: 'button',
            label: 'LBL_BACK',
            value: 'forgotPassword',
            primary: false
        }
    ]
}) },
"product-catalog": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ProductCatalogView
 * @alias SUGAR.App.view.views.BaseProductCatalogView
 * @extends View.View
 */
({
	// Product-catalog View (base) 

    plugins: ['CanvasDataRenderer'],

    events: {
        'keyup .product-catalog-search-term': 'onSearchTermChange'
    },

    /**
     * The JSTree Object reference
     */
    jsTree: undefined,

    /**
     * The data for the JSTree Object
     */
    jsTreeData: undefined,

    /**
     * If we are actively fetching data from the server
     */
    isFetchActive: false,

    /**
     * Holds placeholder text for the search input
     */
    searchText: undefined,

    /**
     * Holds the previous search term to prevent duplicate fetches
     */
    previousSearchTerm: undefined,

    /**
     * Keeps track of how many fetches are active
     */
    activeFetchCt: undefined,

    /**
     * Keeps track of the MouseWheel event name for phaser create and dispose
     */
    wheelEventName: undefined,

    /**
     * The PhaserIO game object reference
     */
    phaser: undefined,

    /**
     * Flag if the Phaser Lib has finished loading
     */
    phaserReady: undefined,

    /**
     * Flag if the data has finished loading
     */
    dataLoaded: undefined,

    /**
     * The current search filter term the user is searching for
     */
    currentFilterTerm: undefined,

    /**
     * The main Tree-level module to use when fetching data for the dashlet
     */
    treeModule: undefined,

    /**
     * The config settings and variables for the hierarchy tree
     */
    treeConfig: undefined,

    /**
     * The SpriteSheet object containing id, imagePath, and dataPath
     */
    spriteSheetManifest: undefined,

    /**
     * Whether or not the user has access to the product catalog and product categories
     */
    hasAccess: false,

    /**
     * Height to be set on the canvas element
     */
    canvasHeight: null,

    /**
     * Width to be set on the canvas element
     */
    canvasWidth: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.activeFetchCt = 0;
        this.searchText = this.getSearchTextPlaceholder();

        this.dataLoaded = false;
        this.phaserReady = false;

        this.initializeProviderModules();
        this.treeConfig = this.getTreeStateConfigSettings();
        this.spriteSheetManifest = this.getSpriteSheetManifestObject();

        this.context.on('phaserio:ready', function() {
            this.phaserReady = true;
            this.checkBuildPhaser();
        }, this);

        this.hasAccess = this._checkAccess();
    },

    /**
     * Check whether the user has access to ProductCategories and ProductTemplates
     * @return boolean true if the user has access
     * @private
     */
    _checkAccess: function() {
        return app.acl.hasAccess('list', 'ProductCategories') && app.acl.hasAccess('list', 'ProductTemplates');
    },

    /**
     * Returns the placeholder string for the Search text input
     * @return {string}
     */
    getSearchTextPlaceholder: function() {
        return app.lang.get('LBL_SEARCH_CATALOG_PLACEHOLDER', 'ProductTemplates');
    },

    /**
     * Initializes any modules needed for data fetching
     */
    initializeProviderModules: function() {
        this.treeModule = 'ProductTemplates';
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        var sidebarLayout;

        this._super('bindDataChange');

        // adding PC Dashlet just return
        if (this.isConfig) {
            return;
        }

        let closestComp = this._getClosestComponent();
        if (closestComp) {
            // need to trigger on app.controller.context because of contexts changing between
            // the PCDashlet, and Opps create being in a Drawer, or as its own standalone page
            // app.controller.context is the only consistent context to use
            app.controller.context.on(closestComp.cid + ':productCatalogDashlet:add:complete',
                this._onProductDashletAddComplete, this);
        }

        $(window).on('resize', _.bind(_.debounce(this._resizePhaserCanvas, 200), this));

        sidebarLayout = this.closestComponent('sidebar');
        if (sidebarLayout) {
            sidebarLayout.on('sidebar:state:changed', this.onSidebarStateChanged, this);
        }
    },

    /**
     * Handles when the sidebar is toggled open or closed.
     *
     * @param {string} sidebarState The state of the sidebar: 'open' or 'close'
     */
    onSidebarStateChanged: function(sidebarState) {
        if (sidebarState === 'open' && this.phaser) {
            this.checkBuildPhaser();
        }
    },

    /**
     * Gets the search term from the text input
     */
    onSearchTermChange: _.debounce(function(evt) {
        var term = $(evt.target).val().trim();

        if (term !== this.previousSearchTerm) {
            this.previousSearchTerm = term;
            this.loadData({
                searchTerm: term
            });
        }
    }, 500),

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        if (!this.hasAccess) {
            return;
        }

        var callbacks;
        var url;
        var term = options && options.searchTerm;
        var method = 'read';
        var payload = {};

        url = this.treeModule + '/tree';

        if (term) {
            method = 'create';
            payload.filter = term;
            this.currentFilterTerm = term;
        } else {
            this.currentFilterTerm = undefined;
        }

        this.$('.product-catalog-no-results').addClass('hidden');

        url = app.api.buildURL(url, method);

        this.toggleLoading(true);

        callbacks = {
            context: this,
            success: this._onCatalogFetchSuccess,
            complete: _.bind(function() {
                if (this.disposed) {
                    return;
                }
                // when complete, remove the spinning refresh icon from the cog
                // and add back the cog icon
                this.toggleLoading(false);
            }, this)
        };

        this.activeFetchCt++;
        app.api.call(method, url, payload, null, callbacks);
    },

    /**
     * Toggles the spinning Loading icon on the header bar
     *
     * @param {boolean} startLoading If we should start the spinning icon or hide it
     */
    toggleLoading: function(startLoading) {
        if (startLoading) {
            this.$('.loading-icon').show();
        } else {
            this.$('.loading-icon').hide();
        }
    },

    /**
     * Handles the ProductTemplates/tree endpoint response
     * and parses data to be used by the tree
     *
     * @param response
     * @protected
     */
    _onCatalogFetchSuccess: function(response) {
        this.jsTreeData = response;
        this.activeFetchCt--;

        if (this.disposed) {
            return;
        }

        if (this.activeFetchCt === 0) {
            if (this.jsTreeData.records.length === 0) {
                this.$('.product-catalog-no-results').removeClass('hidden');
            } else {
                this.$('.product-catalog-no-results').addClass('hidden');
                this.$('.product-catalog-search-term').removeClass('hidden');
            }
        }

        this.dataLoaded = true;

        if (_.isUndefined(this.phaser)) {
            this.checkBuildPhaser();
        } else {
            this.phaser.events.onSetTreeData.dispatch(this.jsTreeData);
        }
    },

    /**
     * Checks if data has been loaded and Phaser is ready to be run
     */
    checkBuildPhaser: function() {
        if (this.dataLoaded && this.phaserReady) {
            this._createPhaser();
        }
    },

    /**
     * @inheritdoc
     *
     * Hides the view if the user does not have access to the necessary modules
     * @override
     */
    render: function() {
        if (this.hasAccess) {
            this._super('render');
            this.checkBuildPhaser();
        } else {
            this.template = app.template.get(this.name + '.noaccess');
            this._super('render');
        }
    },

    /**
     * When the DOM MouseEvent wheel scroll happens,
     * this function handles it and passes the delta info to Phaser
     *
     * @param {MouseEvent} mouseEvent The mouse scroll wheel event
     * @protected
     */
    _onMouseWheelChange: function(mouseEvent) {
        var delta;
        if (mouseEvent.type === 'mousewheel') {
            delta = mouseEvent.originalEvent.wheelDelta / 20;
        } else if (this.phaser.device.firefox) {
            //for firefox the scrollamount is reduced considerably (around 30 times);
            // in order to have an immersive scroll behavior the delta has to be corrected
            delta = mouseEvent.originalEvent.deltaY * 30;
        } else {
            delta = mouseEvent.originalEvent.deltaY;
        }
        mouseEvent.preventDefault();
        this.phaser.events.onScrollWheel.dispatch(delta);
    },

    /**
     * Event listener for when the Phaser "Tree" State triggers its onTreeReady event
     */
    onPhaserTreeReadyHandler: function() {
        this.phaser.events.onSetTreeData.dispatch(this.jsTreeData);
    },

    /**
     * Wraps getting spritesheets
     *
     * @return {{atlasJSONHash: (*|{imagePath: string, id: string, dataPath: string}[])}}
     */
    getSpriteSheetManifestObject: function() {
        return {
            atlasJSONHash: this._getSpriteSheets()
        };
    },

    /**
     * Returns an array of SpriteSheet location objects and ids for each spritesheet
     *
     * @return {{imagePath: string, id: string, dataPath: string}[]}
     * @protected
     */
    _getSpriteSheets: function() {
        return [{
            id: 'prodCatTS',
            imagePath: 'clients/base/views/product-catalog/product-catalog-ss.png',
            dataPath: 'clients/base/views/product-catalog/product-catalog-ss.json'
        }];
    },

    /**
     * Returns the Hex-value color to use for the node
     *
     * @param {string} itemType The Item type of the node
     * @param {Object} node The Phaser node we need an icon name
     * @return {string}
     * @protected
     */
    _getTreeNodeTextColor: function(itemType, node) {
        var textColor = '';
        if (itemType === 'category') {
            textColor = this.treeConfig.categoryColor;
        } else if (itemType === 'product' || itemType === 'showMore') {
            textColor = this.treeConfig.itemColor;
        }

        return textColor;
    },

    /**
     * Returns the icon name to use for the node
     *
     * @param {string} itemType The Item type of the node
     * @param {Object} node The Phaser node we need an icon name
     * @return {string}
     * @protected
     */
    _getTreeNodeIconName: function(itemType, node) {
        var iconName = '';
        if (itemType === 'category') {
            iconName = node.state === 'closed' ?
                this._getTreeIconClosedStateName() :
                this._getTreeIconOpenStateName();
        } else if (itemType === 'product') {
            iconName = 'list-alt';
        } else if (itemType === 'showMore') {
            iconName = 'empty';
        } else if (itemType === 'preview') {
            iconName = 'preview';
        }

        return iconName;
    },

    /**
     * Returns the open icon name for the open state of a folder
     *
     * @return {string}
     * @protected
     */
    _getTreeIconOpenStateName: function() {
        return 'folder-open-o';
    },

    /**
     * Returns the closed icon name for the closed state of a folder
     *
     * @return {string}
     * @protected
     */
    _getTreeIconClosedStateName: function() {
        return 'folder';
    },

    /**
     * Extensible function to allow Icon Height to be tweaked based on the icon or node
     *
     * @param {string} iconName
     * @param {Object} node The Phaser node we need an icon height
     * @return {number}
     * @protected
     */
    _getTreeIconHeight: function(iconName, node) {
        return iconName === 'list-alt' ? 12 : this.treeConfig.iconHeight;
    },

    /**
     * Extensible function to allow Icon Height to be tweaked based on the icon or node
     *
     * @param {string} iconName
     * @param {Object} node The Phaser node we need an icon height
     * @return {number}
     * @protected
     */
    _getTreeIconWidth: function(iconName, node) {
        return this.treeConfig.iconWidth;
    },

    /**
     *
     * @param {string} itemType The Item type of the node
     * @param {string} iconName The name of the icon
     * @param {Object} node The Phaser node we need an icon name
     * @return {string} The ID of the SpriteSheet to use
     * @protected
     */
    _getTreeNodeSpriteSheetId: function(itemType, iconName, node) {
        return 'prodCatTS';
    },

    /**
     * Handles when any item on the stage is clicked.
     * This is inside the Phaser conxtext, not the view
     *
     * @param {Phaser.Image|Phaser.Text} target The Phaser text or icon that was clicked
     * @protected
     */
    _onTreeNodeItemClicked: function(target) {
        var isIcon = target instanceof Phaser.Image;

        if (target._itemType === 'category' || target._itemType === 'showMore') {
            this.game._view._onTreeNodeCategoryClicked(target, isIcon);
        } else {
            if (isIcon) {
                if (target._itemAction === 'preview') {
                    this.game._view._onTreeNodePreviewClicked(target);
                } else {
                    this.game._view._onTreeNodeIconClicked(target);
                }
            } else {
                this.game._view._onTreeNodeNameClicked(target);
            }
        }
    },

    /**
     * Handles when a Product Category or "Show More" is clicked
     * This is the View context, not Phaser
     *
     * @param {Phaser.Image|Phaser.Text} target The Phaser text or icon that was clicked
     * @param {boolean} isIcon If the `target` is an image/icon or Text
     * @protected
     */
    _onTreeNodeCategoryClicked: function(target, isIcon) {
        var changeYDelta;
        var isVisible;
        var icon = isIcon ? target : target.parent._icon;
        var isShowMore = target._itemType === 'showMore';
        var openName = this._getTreeIconOpenStateName();
        var closedName = this._getTreeIconClosedStateName();
        var newFrameName = icon.frameName === closedName ? openName : closedName;
        var currentState = this.phaser.state.getCurrentState();

        if (isIcon) {
            icon = target;
            target = _.find(target.parent.children, function(item) {
                return item instanceof Phaser.Text && item._itemId === target._itemId;
            });
        } else {
            icon = _.find(target.parent.children, function(item) {
                return item instanceof Phaser.Image && item._itemId === target._itemId;
            });
        }

        if (target._isFetching) {
            return;
        }

        if (isShowMore || newFrameName === openName) {
            currentState._getMoreRecords(target, icon, isShowMore);
        } else {
            icon.frameName = newFrameName;
            // subtract the group height from the game world height and update
            currentState.gameWorldHeight -= target.parent.childGroup.height;
            currentState._updateGameWorldSize();
        }

        if (target.parent.childGroup) {
            isVisible = !target.parent.childGroup.visible;
            target.parent.childGroup.visible = isVisible;
            changeYDelta = target.parent.childGroup.height;

            if (!isVisible) {
                changeYDelta = -changeYDelta;
            }

            target.parent._events.onChangeY.dispatch(changeYDelta, target.parent);
        }
    },

    /**
     * When a tree item's card icon gets clicked
     *
     * @param {Phaser.Image} target The card icon that was clicked
     * @protected
     */
    _onTreeNodeIconClicked: function(target) {
        this._onTreeNodeNameClicked(target);
    },

    /**
     * When a tree item's name gets clicked
     *
     * @param {Phaser.Text} target The text label that was clicked
     * @protected
     */
    _onTreeNodeNameClicked: function(target) {
        // We could show a loading message here, but not all views do something with the PC data. Trigger an event to
        // let individual views decide what to do when the tree name is clicked
        var closestComp = this._getClosestComponent();
        if (!_.isUndefined(closestComp)) {
            app.controller.context.trigger(closestComp.cid + ':productCatalogDashlet:add:loading');
        }

        // Fetch the record data and send it to the applicable context
        this._fetchRecord(target._itemId, {
            success: _.bind(this._sendItemToRecord, this),
            complete: _.bind(function() {
                if (!_.isUndefined(closestComp)) {
                    app.controller.context.trigger(`${closestComp.cid}:productCatalogDashlet:add:loaded`);
                }
            }, this)
        });
    },

    /**
     * When a tree item's preview icon gets clicked
     *
     * @param {Phaser.Image} target The preview icon that was clicked
     * @private
     */
    _onTreeNodePreviewClicked: function(target) {
        // Show loading alert
        app.alert.show('fetching_product_catalog_preview', {
            level: 'process',
            title: app.lang.get('LBL_LOADING'),
            autoClose: false
        });

        // Fetch the record data and display it in a drawer
        this._fetchRecord(target._itemId, {
            success: _.bind(function(data) {
                this._openItemInDrawer(data);

                // Fixes issue with Phaser not making the preview icon disappear if the cursor was still over the
                // preview button when the drawer opened
                target.visible = false;
            }, this),
            complete: _.bind(function() {
                app.alert.dismiss('fetching_product_catalog_preview');
            }, this)
        });
    },

    /**
     * Returns an EventHub object containing any event Signals the tree will use
     *
     * @return {EventHub} The Event Hub to use with Phaser
     */
    getPhaserEventHub: function() {
        var EventHub = function() {};
        EventHub.prototype = {

            /**
             * Event called outside Phaser to pass tree data into Phaser for parsing/rendering
             */
            onSetTreeData: new Phaser.Signal(),

            /**
             * Event dispatched by Phaser when the Tree State has finished it's create function
             * and is ready for data
             */
            onTreeReady: new Phaser.Signal(),

            /**
             * Event called outside Phaser to pass mouse scroll wheel data into Phaser
             * to know how much to move the camera up or down
             */
            onScrollWheel: new Phaser.Signal(),

            /**
             * Event called outside Phaser to trigger re-drawing UI
             */
            onResize: new Phaser.Signal(),

            /**
             * Handles disposing any Signal events and listeners
             */
            destroy: function() {
                for (var eventName in this) {
                    if (this.hasOwnProperty(eventName) && _.isFunction(this[eventName].dispose)) {
                        this[eventName].dispose();
                    }
                }
            }
        };
        return EventHub;
    },

    /**
     * Returns the canvas ID name Phaser should use
     *
     * @return {string}
     * @protected
     */
    _getPhaserCanvasId: function() {
        return 'product-catalog-canvas-' + this.cid;
    },

    /**
     * Returns the Phaser game config
     *
     * @return {Object}
     */
    getPhaserGameConfig: function() {
        var elIdName = this._getPhaserCanvasId();
        var $el = this.$('#' + elIdName);
        this._calculateCanvasSizes($el);
        var gameConfig = {
            height: this.canvasHeight,
            parent: elIdName,
            renderer: Phaser.CANVAS,
            transparent: true,
            width: this.canvasWidth
        };

        return this._getPhaserGameConfig(gameConfig);
    },

    /**
     * Extensible function to tweak anything in the game config before sending it to Phaser
     *
     * @param {Object} gameConfig
     * @return {Object}
     * @protected
     */
    _getPhaserGameConfig: function(gameConfig) {
        return gameConfig;
    },

    /**
     * This function creates the actual PhaserIO game object
     *
     * @protected
     */
    _createPhaser: function() {
        var gameConfig = this.getPhaserGameConfig();
        var EventHub = this.getPhaserEventHub();
        var states;

        // remove the phaser console log
        window.PhaserGlobal = {
            hideBanner: true
        };

        if (this.phaser) {
            this.phaser.events.destroy();
            this.phaser.destroy();
        }

        this.phaser = new Phaser.Game(gameConfig);

        this.phaser._view = this;

        this.wheelEventName = 'onwheel' in document.createElement('div') ? 'wheel' : // Modern browsers support "wheel"
            document.onmousewheel !== undefined ? 'mousewheel' : // Webkit and IE support at least "mousewheel"
                'DOMMouseScroll'; // let's assume that remaining browsers are older Firefox

        this.$('.product-catalog-container-' + this.cid).off(this.wheelEventName);
        this.$('.product-catalog-container-' + this.cid).on(
            this.wheelEventName,
            _.bind(this._onMouseWheelChange, this)
        );

        this.phaser.events = new EventHub();
        this.phaser.events.onTreeReady.add(this.onPhaserTreeReadyHandler, this);

        states = this.getStates();
        _.each(states, function(state, index) {
            this.phaser.state.add(index, state);
        }, this);

        this.phaser.state.start('boot');
    },

    /**
     * Gets the states needed to be added to Phaser
     *
     * @return {Object} The states to add to Phaser
     */
    getStates: function() {
        var states = {
            boot: this._getBootState(),
            load: this._getLoadState(),
            tree: this._getTreeState()
        };

        return this._getAdditionalStates(states);
    },

    /**
     * Returns the Phaser.State object for the Boot state
     *
     * @protected
     */
    _getBootState: function() {
        return {
            /**
             * Preload is called as the BootState initializes and lets us set any flags we need later.
             * This is the place for setting any Phaser variables we might need at runtime.
             */
            preload: function() {
                this.game.hasTreeData = false;
            },

            /**
             * After the BootState is done preloading, this function calls the LoadState
             */
            create: function() {
                this.game.state.start('load');
            }
        };
    },

    /**
     * Returns the Phaser.State object for the Load state
     *
     * @protected
     */
    _getLoadState: function() {
        return {
            /**
             * Preload is called as the LoadState initializes and lets us load any assets we'll use later.
             * This would also be the place to add preloading progressbar
             */
            preload: function() {
                // loop over anything in the manifest and load it
                _.each(this.game._view.spriteSheetManifest, function(itemsToLoad, key) {
                    if (!_.isEmpty(itemsToLoad)) {
                        _.each(itemsToLoad, function(item) {
                            switch (key) {
                                case 'json':
                                case 'image':
                                    this.game.load[key](item.id, item.path);
                                    break;

                                case 'atlasJSONHash':
                                case 'bitmapFont':
                                    this.game.load[key](item.id, item.imagePath, item.dataPath);
                                    break;
                            }
                        }, this);
                    }
                }, this);
            },

            /**
             * After the LoadState is done preloading assets, this function calls the TreeState
             */
            create: function() {
                this.game.state.start('tree');
            }
        };
    },

    getTreeStateConfigSettings: function() {
        const isDarkMode = app.utils.isDarkMode();

        var config = {
            categoryColor: isDarkMode ? '#E5EAED' : '#2B2D2E',
            itemColor: isDarkMode ? '#E5EAED' : '#2B2D2E',
            iconColor: isDarkMode ? 0x9BA1A6 : 0x6F777B,
            iconHoverColor: isDarkMode ? 0xFFFFFF : 0x0679C8,
            itemFont: '12px open sans',
            iconTextPadding: 5,
            iconWidth: 16,
            iconHeight: 16,
            iconWidthHalf: this.iconWidth >> 1,
            iconScale: 0.25,
            iconStartX: 5,
            iconYOffset: 8,
            itemRowYPadding: 21,
            childRowYPadding: 10,
            containerRowStartY: 0,
            showMoreNode: {
                data: app.lang.get('LBL_SHOW_MORE'),
                type: 'showMore'
            },
            showMoreNodeIconName: 'folder-open-o',
            scrollBarBkgdBorderLineSize: 1,
            scrollBarBkgdWidth: 15,
            scrollBarBkgdBorderColor: isDarkMode ? 0x2B2D2E : 0xE8E8E8,
            scrollBarBkgdFill: isDarkMode ? 0x2B2D2E : 0xFAFAFA,
            scrollBarBkgdFillIE: isDarkMode ? 0x2B2D2E : 0xF0F0F0,
            scrollThumbWidth: 8,
            scrollThumbHeight: 16,
            scrollThumbFillColor: isDarkMode ? 0x4D5154 : 0xC1C1C1,
            scrollThumbFillHoverColor: isDarkMode ? 0x6F777B : 0x7D7D7D,
            scrollThumbTopBottomPadding: 3
        };

        return this._getTreeStateConfigSettings(config);
    },

    /**
     * Extensible function if anything needs to be added or removed from cfg
     *
     * @param cfg
     * @return {Object}
     * @protected
     */
    _getTreeStateConfigSettings: function(cfg) {
        return cfg;
    },

    /**
     * Returns the Phaser.State object for the Tree state
     *
     * @protected
     */
    _getTreeState: function() {
        var treeConfig = this.treeConfig = this.getTreeStateConfigSettings();
        var treeState = {
            isLoading: false,
            groups: undefined,
            rootGroup: undefined,
            dashletHeight: undefined,
            gameWorldHeight: undefined,
            gameWorldWidth: undefined,
            cameraY: undefined,
            GroupEventHub: undefined,
            scrollBarImg: undefined,
            scrollBarThumbImg: undefined,
            scrollThumbHoverImg: undefined,
            scrollThumbImg: undefined,
            previousScrollThumbY: 0,
            scrollPercentHeight: 0,
            scrollThumbHoverInTween: undefined,
            scrollThumbHoverOutTween: undefined,
            maxScrollY: undefined,
            useScrollbar: true,
            isLangRTL: false,

            /**
             * Preload is called as the TreeState initializes and lets us setup any vars we need for the state
             */
            preload: function() {
                var $el = this.game._view.$('#' + this.game._view._getPhaserCanvasId());

                this.groups = [];
                this.gameWorldHeight = 0;
                this.gameWorldWidth = $el.width();
                this.dashletHeight = $el.height();
                this.cameraY = 0;
                this.isLoading = false;
                this.isLangRTL = app.lang.direction === 'rtl';

                this.game.events.onSetTreeData.add(this._setTreeData, this);
                this.game.events.onScrollWheel.add(this._onScrollWheel, this);
                this.game.events.onResize.add(this._onResize, this);

                this.GroupEventHub = function() {
                    return {
                        onChangeY: new Phaser.Signal(),
                        destroy: function() {
                            for (var eventName in this) {
                                if (this.hasOwnProperty(eventName) && _.isFunction(this[eventName].dispose)) {
                                    this[eventName].dispose();
                                }
                            }
                        }
                    };
                };

                // Restrict IE and Safari to have a scrollbar while
                // moving the scrollbar with the mouse is not supported
                this.useScrollbar = !(this.game.device.ie || this.game.device.safari);

                if (this.game.hasTreeData) {
                    this._setTreeData(this.game.treeData);
                }
            },

            /**
             * After preload is done, create runs and lets us let the Sugar.App know our tree is ready
             */
            create: function() {
                this._updateGameWorldSize();
                this.game.events.onTreeReady.dispatch();
            },

            /**
             * Handles the Mouse ScrollWheel event being passed from the DOM to Phaser.
             * The yDelta value gets added to `this.cameraY` so that the next game "tick" event
             * that happens during the state's `update` function, we can move the
             * game's camera object up or down.
             *
             * @param yDelta
             * @private
             */
            _onScrollWheel: function(yDelta) {
                // update the camera position by the yDelta
                this.game.camera.y += yDelta;

                // only need to update scrollbar if it exists
                if (this.scrollBarThumbImg) {
                    this._updateScrollThumbToCamera();
                }
            },

            /**
             * Re-orients the scroll thumb to the camera position in the world.
             * This allows the camera and thumb to stay in sync after a Show More event.
             *
             * @private
             */
            _updateScrollThumbToCamera: function() {
                var percentCameraGameHeightDiff = this.game.camera.y / this.gameWorldHeight;
                var newScrollY = percentCameraGameHeightDiff * this.dashletHeight;

                // update the scrollbar thumb
                this.scrollBarThumbImg.cameraOffset.y = newScrollY;

                // make sure we're not out of bounds
                this._checkBounds(this.scrollBarThumbImg);
            },

            /**
             * Handles the Phaser onResize event and updates the game world and scrollbar
             * @private
             */
            _onResize: function() {
                this._updateGameWorldSize();
            },

            /**
             * This event is triggered when a user clicks to expand or collapse a Group.
             * yDelta will be positive (the group needs to expand) or negative (the group is being hidden)
             *
             * @param {number} yDelta The amount to change the Y value of Groups
             * @private
             */
            _onChangeY: function(yDelta) {
                var rowIndex;
                var groups;
                var groupLen;

                if (this.parent.parent instanceof Phaser.Stage) {
                    // once we hit the "rootGroup" group level
                    // just return and break out of this event loop
                    return;
                }

                // we need to move all groups that come after this group
                // get the next index for any items we need to move after this group
                rowIndex = this._rowIndex + 1;

                // get all of the Phaser.Groups at "this" level (this.parent.children)
                groups = _.filter(this.parent.children, function(child) {
                    return child instanceof Phaser.Group;
                });

                // get the length of the groups
                groupLen = groups.length;

                // loop over each group after "this" group and move it up/down by the yDelta
                for (rowIndex; rowIndex < groupLen; rowIndex++) {
                    groups[rowIndex].y += yDelta;
                }

                // update the parent group with the correct yOffset to apply to its children
                this.parent._yOffset += yDelta;

                // cause the event to "bubble" up to the next level
                this.parent._events.onChangeY.dispatch(yDelta, this);
            },

            /**
             * Sets the main tree data and starts building the levels and nodes.
             * This is called when the page loads and when a user types in to search for data.
             *
             * @param treeData
             * @private
             */
            _setTreeData: function(treeData) {
                var groupIndex = 0;
                var elIdName = this.game._view._getPhaserCanvasId();
                var $el = this.game._view.$('#' + elIdName);

                this.dashletHeight = $el.height();
                this.gameWorldWidth = $el.width();
                this.gameWorldHeight = 0;
                this.cameraY = 0;
                this.game.camera.y = 0;

                if (this.rootGroup) {
                    if (this.rootGroup.childGroup) {
                        this.rootGroup.childGroup._events.destroy();
                        this.rootGroup.childGroup.destroy();
                    }

                    this.rootGroup._events.destroy();
                    this.rootGroup.destroy();
                }

                this.rootGroup = this.game.add.group();
                this.rootGroup.name = 'rootGroup';
                this.rootGroup._groupIndex = -1;
                this.rootGroup._events = new this.GroupEventHub();
                this.rootGroup._events.onChangeY.add(this._onChangeY, this.rootGroup);
                this.rootGroup.childGroup = this._createGroupObject(-1, 0);

                _.each(treeData.records, function(node, index) {
                    this._createLevel(this.rootGroup.childGroup, node, groupIndex, index);
                }, this);

                if (treeData.next_offset !== -1) {
                    let showMorePos = this.rootGroup.childGroup.length;
                    this._createLevel(this.rootGroup.childGroup, this.showMoreNode, groupIndex, showMorePos);
                }

                this._updateGameWorldSize();
                // reset the camera back to the top 0 position
                this.game.camera.y = 0;
            },

            /**
             * Creates a Phaser.Group and sets some default properties
             *
             * @private
             * @return {Phaser.Group} group The newly created group
             */
            _createGroupObject: function(groupIndex, rowIndex) {
                var group = this.game.add.group();

                // set the group's name and some other indexes to help keep track
                // of where this group exists in its parents hierarchy
                group.name = 'group-' + groupIndex + '-' + rowIndex;
                group._groupIndex = groupIndex;
                group._rowIndex = rowIndex;
                group._yOffset = 0;

                // add an Events hub on this group to pass events
                group._events = new this.GroupEventHub();
                group._events.onChangeY.add(this._onChangeY, group);

                return group;
            },

            /**
             * Creates a "level" including category and any children
             *
             * @param {Phaser.Group} parentGroup The parent group to add this category and children to
             * @param {Object} node The JSON Object data from the tree for this node level
             * @param {number} groupIndex The Group level index from rootGroup
             * @param {number} rowIndex The specific row level index of this node inside its Group
             *                  groups pushing this group down
             * @private
             */
            _createLevel: function(parentGroup, node, groupIndex, rowIndex) {
                var group = this._createGroupObject(groupIndex, rowIndex);
                var groupYOffset = parentGroup._yOffset || 0;

                // create the group's icon and text label
                this._createNode(group, node, groupIndex, rowIndex);

                // update the overall game world height
                this.gameWorldHeight += this.itemRowYPadding;

                // add this new group to the parent
                parentGroup.add(group);

                if (parentGroup._groupIndex !== -1 && parentGroup.parent._groupIndex !== -1) {
                    group.parentGroup = parentGroup.parent;
                } else {
                    group.parentGroup = parentGroup;
                }

                if (node.type === 'showMore') {
                    group.parentGroup._nextOffset = rowIndex;
                }

                if (this.isLangRTL) {
                    group.x = 0;
                } else {
                    group.x = groupIndex === 0 ? 0 : this.iconWidth + this.iconStartX;
                }
                group.y = this.containerRowStartY + (this.itemRowYPadding * rowIndex) + groupYOffset;
            },

            /**
             * This function creates the actual Icon and Text label and adds them to the Group
             *
             * @param {Phaser.Group} group
             * @param {Object} node The JSON Object data from the tree for this node level
             * @param {number} groupIndex The Group level index from rootGroup
             * @param {number} rowIndex The specific row level index of this node inside its Group
             * @private
             */
            _createNode: function(group, node, groupIndex, rowIndex) {
                var icon;
                var text;
                var iconName;
                var textColor;
                var itemType = node.type;
                var itemId = node.id;
                var itemName = node.data;
                var startX;
                var startY;
                var gameView = this.game._view;
                var iconSpriteSheetId;

                textColor = gameView._getTreeNodeTextColor(itemType, node);
                iconName = gameView._getTreeNodeIconName(itemType, node);
                iconSpriteSheetId = gameView._getTreeNodeSpriteSheetId(itemType, iconName, node);

                // Create the Product/Category card icon and add it to the group
                startX = this.iconStartX + 8;
                startY = this.iconYOffset;

                if (this.isLangRTL) {
                    startX = this.gameWorldWidth - (startX * (groupIndex + 1)) - (this.iconWidthHalf * groupIndex);
                }

                icon = this._createNodeIcon(node,{
                    startX: startX,
                    startY: startY,
                    iconSpriteSheetId: iconSpriteSheetId,
                    iconName: iconName,
                    itemName: itemName,
                    itemId: itemId,
                    itemType: itemType
                });
                group.add(icon);

                // Create the Product/Category text and add it to the group
                if (this.isLangRTL) {
                    startX -= (this.iconWidth + this.iconTextPadding);
                } else {
                    startX = this.iconStartX + this.iconWidth + this.iconTextPadding;
                }
                text = this._createNodeText(node, {
                    startX: startX,
                    startY: 0,
                    display: {
                        font: this.itemFont,
                        fill: textColor
                    },
                    itemName: itemName,
                    itemId: itemId,
                    itemType: itemType
                });
                group.add(text);

                // If this is a product, also create the Product preview icon
                if (itemType === 'product') {
                    if (this.isLangRTL) {
                        startX -= (this.iconWidth + (2 * this.iconTextPadding) + text.width);
                    } else {
                        startX = this.iconStartX + this.iconWidth + (2 * this.iconTextPadding) + text.width;
                    }

                    // Create the preview icon object and add it to the group
                    var preview = this._createNodePreview(node, {
                        startX: startX,
                        startY: startY,
                        iconSpriteSheetId: iconSpriteSheetId,
                        iconName: gameView._getTreeNodeIconName('preview', node),
                        itemName: itemName,
                        itemId: itemId,
                        itemType: itemType
                    });
                    group.add(preview);

                    // Create an invisible element and add it to the group. This will give us a row-size place
                    // to put a hover listener to show the preview icon
                    if (this.isLangRTL) {
                        startX -= (this.iconWidth + this.iconTextPadding);
                    } else {
                        startX = this.iconStartX + 8;
                    }

                    var hoverElem = this._createNodeHoverElem(node, group, {
                        startX: startX,
                        startY: 0,
                        iconName: ''
                    });
                    hoverElem.width += preview.width;
                    group.addAt(hoverElem, 0);

                    // Add the listeners for preview icon visibility on all elements in the group
                    group.onChildInputOver.add(function() {
                        preview.visible = true;
                    });
                    group.onChildInputOut.add(function() {
                        preview.visible = false;
                    });
                }

                // Finish setting up the group
                group.name = `${group.name}-${itemName}`;
                group._itemName = itemName;
                group._itemId = itemId;
                group._itemType = itemType;
                group._icon = icon;
                group._text = text;
            },

            /**
             * Creates the icon for the tree node
             *
             * @param {Object} node The JSON Object data from the tree for this node level
             * @param {Object} params the parameters to use for the icon
             * @return {Phaser.Image} the Phaser icon image object
             * @private
             */
            _createNodeIcon: function(node, params) {
                var gameView = this.game._view;
                var iconName = params.iconName || '';

                // Create the icon object
                var icon = this.game.add.image(
                    params.startX || 0,
                    params.startY || 0,
                    params.iconSpriteSheetId || '',
                    iconName
                );

                // Give the icon the proper dimensions
                icon.height = gameView._getTreeIconHeight(iconName, node);
                icon.width = gameView._getTreeIconWidth(iconName, node);

                // Give the icon the proper anchor
                icon.anchor.setTo(0.5, 0.5);

                // Give the icon data to store
                icon._itemName = params.itemName || '';
                icon._itemId = params.itemId || '';
                icon._itemType = params.itemType || '';

                icon.tint = gameView.treeConfig.iconColor;

                // Give tween to the icon
                icon._tween = this.game.add.tween(icon).to({
                    angle: 360
                }, 3600, null, false, 0, -1);

                // Add event handling to the icon
                icon.inputEnabled = true;
                icon.events.onInputDown.add(gameView._onTreeNodeItemClicked, this);
                icon.input.useHandCursor = true;

                return icon;
            },

            /**
             * Creates the text for the tree node
             *
             * @param {Object} node The JSON Object data from the tree for this node level
             * @param {Object} params the parameters to use for the text
             * @return {Phaser.Text} the Phaser text object
             * @private
             */
            _createNodeText: function(node, params) {
                var gameView = this.game._view;

                // Create the text object
                var text = this.game.add.text(
                    params.startX || 0,
                    params.startY || 0,
                    node.data || {},
                    params.display || {}
                );

                // Give the text the proper anchor
                if (this.isLangRTL) {
                    text.anchor.setTo(1, 0);
                }

                // Give the text data to store
                text._itemName = params.itemName || '';
                text._itemId = params.itemId || '';
                text._itemType = params.itemType || '';

                // Add event handling to the text
                text.inputEnabled = true;
                text.events.onInputDown.add(gameView._onTreeNodeItemClicked, this);
                text.input.useHandCursor = true;

                return text;
            },

            /**
             * Creates the preview button for the tree node
             *
             * @param {Object} node The JSON Object data from the tree for this node level
             * @param {Object} params the parameters to use for the preview button
             * @return {Phaser.Image} the Phaser image object
             * @private
             */
            _createNodePreview: function(node, params) {
                var gameView = this.game._view;
                var iconName = params.iconName || '';

                // Create the preview object
                var preview = this.game.add.image(
                    params.startX || 0,
                    params.startY || 0,
                    params.iconSpriteSheetId || '',
                    iconName
                );

                // Give the preview icon the proper dimensions
                preview.height = gameView._getTreeIconHeight(iconName, node);
                preview.width = gameView._getTreeIconWidth(iconName, node);

                // Give the preview icon the proper anchor
                preview.anchor.setTo(-0.2, 0.5);

                // Give the preview data to store
                preview._itemName = params.itemName || '';
                preview._itemId = params.itemId || '';
                preview._itemType = params.itemType || '';
                preview._itemAction = 'preview';

                // The preview icon is invisible by default
                preview.visible = false;

                // Add event handling to the preview icon. By default, the preview icon is black. On hover over the
                // icon, "tint" its color with white so that its true blue color shows. Off hover, "tint" its color back
                // to black so it no longer looks highlighted. On click, call the on click handler
                preview.inputEnabled = true;
                preview.input.useHandCursor = true;
                preview.tint = gameView.treeConfig.iconColor;
                preview.events.onInputOver.add(_.bind(function() {
                    preview.tint = gameView.treeConfig.iconHoverColor;
                }, this));
                preview.events.onInputOut.add(_.bind(function() {
                    preview.tint = gameView.treeConfig.iconColor;
                }, this));
                preview.events.onInputDown.add(gameView._onTreeNodeItemClicked, this);

                return preview;
            },

            /**
             * Creates an invisible game object spanning the length and width of the row group, used
             * for creating a row-wide hover listener
             *
             * @param {Object} node The JSON Object data from the tree for this node level
             * @param {Object} params the parameters to use for the preview button
             * @return {Phaser.Image} the Phaser image object
             * @private
             */
            _createNodeHoverElem: function(node, group, params) {
                // Create an invisible object that spans the width and height of the entire row group
                var hoverElem = this.game.add.image(
                    params.startX || this.iconStartX + 8,
                    params.startY || 0,
                    ''
                );
                hoverElem.width = group.width + this.iconTextPadding;
                hoverElem.height = group.height;
                hoverElem.inputEnabled = true;

                return hoverElem;
            },

            /**
             * Handles fetching more records for the target root item
             *
             * @param {Phaser.Image|Phaser.Text} target The Phaser text or icon that was clicked
             * @param {Phaser.Image} icon The icon image object for the clicked item
             * @private
             */
            _getMoreRecords: function(target, icon, isShowMore) {
                var offset;
                var itemId = target._itemId;

                if (isShowMore && target.parent.parentGroup && target.parent.parentGroup._nextOffset !== -1) {
                    offset = target.parent.parentGroup._nextOffset;
                    itemId = target.parent.parentGroup._itemId;
                }

                if (_.isUndefined(target.parent.childGroup) || (!_.isUndefined(offset) && offset !== -1)) {
                    icon.frameName = 'refresh';
                    icon._tween.start();
                    target._isFetching = true;
                    icon._isFetching = true;

                    this.game._view._fetchMoreRecords(
                        itemId,
                        offset,
                        isShowMore,
                        _.bind(this._setMoreRecordsData, this, target, icon, isShowMore)
                    );
                } else {
                    icon.frameName = this.game._view._getTreeIconOpenStateName();
                    // add the group height to the game world height and update
                    this.gameWorldHeight += target.parent.childGroup.height;
                    this._updateGameWorldSize();
                }
            },

            /**
             * Updates Phaser's bounds and world size with the current gameWorldHeight
             *
             * @private
             */
            _updateGameWorldSize: function() {
                var $el = this.game._view.$('#product-catalog-canvas-' + this.game._view.cid);

                this.dashletHeight = $el.height();
                this.gameWorldWidth = $el.width();

                this.scrollPercentHeight = this.dashletHeight / this.gameWorldHeight;

                this.game.world.setBounds(0, 0, this.gameWorldWidth, this.gameWorldHeight);
                this.game.world.resize(this.gameWorldWidth, this.gameWorldHeight);
                this.game.camera.setBoundsToWorld();

                this.scrollThumbHeight = Math.floor(this.scrollPercentHeight * this.dashletHeight);

                if (this.useScrollbar) {
                    // only need to worry about this stuff if we're using scrollbar
                    if (this.scrollPercentHeight < 1) {
                        // the gameWorldHeight is greater than dashletHeight so we need a scrollbar
                        this.drawScrollbar();

                        this.scrollCheckTimerEvent = this.game.time.events.repeat(500, 40, this._checkScrollbar, this);
                    } else if (this.scrollBarThumbImg) {
                        // we no longer need a scrollbar, and this.scrollBarImg exists, so we need to remove it
                        this.scrollBarImg.destroy();
                        this.scrollThumbImg.destroy();
                        this.scrollBarThumbImg.destroy();
                    }
                }
            },

            /**
             * TimerEvent handler to check and see if the game world width has changed since last time
             * @private
             */
            _checkScrollbar: function() {
                var $el;

                if (this.game._view.disposed) {
                    this.game.time.events.remove(this.scrollCheckTimerEvent);
                    this.scrollCheckTimerEvent = null;
                    return;
                }

                $el = this.game._view.$('#product-catalog-canvas-' + this.game._view.cid);
                if ($el.width() !== this.gameWorldWidth) {
                    this.game.time.events.remove(this.scrollCheckTimerEvent);
                    this.scrollCheckTimerEvent = null;

                    this._updateGameWorldSize();
                }
            },

            /**
             * Draws the Scrollbar line and rectangle
             */
            drawScrollbar: function() {
                var scrollX = this.isLangRTL ? this.scrollBarBkgdWidth : this.gameWorldWidth - this.scrollBarBkgdWidth;
                var xOffset = this.game.device.ie ? 0 : 4;

                if (this.scrollBarImg) {
                    this.scrollBarImg.destroy();
                    this.scrollThumbImg.destroy();
                    this.scrollBarThumbImg.destroy();
                }

                // draw the scrollbar background image
                this.scrollBarImg = this.game.add.image(scrollX, 0, this._drawScrollBkgdBar());
                this.scrollBarImg.fixedToCamera = true;

                // draw the parent scroll thumb container
                this.scrollBarThumbImg = this.game.add.image(scrollX + xOffset, 0);

                // draw the scroll thumb image
                this.scrollThumbImg = this.game.add.image(
                    0,
                    this.scrollThumbTopBottomPadding,
                    this._drawScrollThumb(this.scrollThumbFillColor)
                );

                // draw the scroll thumb hover image
                this.scrollThumbHoverImg = this.game.add.image(
                    0,
                    this.scrollThumbTopBottomPadding,
                    this._drawScrollThumb(this.scrollThumbFillHoverColor)
                );

                // add the scroll thumb and hover image to the main scrollbar thumb
                this.scrollBarThumbImg.addChild(this.scrollThumbImg);
                this.scrollBarThumbImg.addChild(this.scrollThumbHoverImg);

                this.scrollThumbHoverInTween = this.game.add.tween(this.scrollThumbHoverImg).to({alpha: 1}, 100);
                this.scrollThumbHoverOutTween = this.game.add.tween(this.scrollThumbHoverImg).to({alpha: 0}, 100);

                this.scrollThumbHoverImg.alpha = 0;

                this.scrollBarThumbImg.inputEnabled = true;
                this.scrollBarThumbImg.input.enableDrag();
                // only allow the thumb vertical drag
                this.scrollBarThumbImg.input.allowHorizontalDrag = false;
                this.scrollBarThumbImg.events.onDragStart.add(this._checkDragThumbBounds, this);
                this.scrollBarThumbImg.events.onDragUpdate.add(this._checkDragThumbBounds, this);
                this.scrollBarThumbImg.events.onDragStop.add(this._checkDragThumbBounds, this);
                this.scrollBarThumbImg.fixedToCamera = true;

                this.scrollBarThumbImg.events.onInputOver.add(function() {
                    this.scrollThumbHoverInTween.start();
                }, this);
                this.scrollBarThumbImg.events.onInputOut.add(function() {
                    this.scrollThumbHoverOutTween.start();
                }, this);

                this.maxScrollY = this.dashletHeight - this.scrollThumbHeight;

                if (this.game.camera.y !== 0) {
                    this._updateScrollThumbToCamera();
                }
            },

            /**
             * Draws the scrollbar background well
             *
             * @return {Phaser.Texture}
             * @private
             */
            _drawScrollBkgdBar: function() {
                var bar = this.game.make.graphics();
                var bkgdFill = this.game.device.ie ? this.scrollBarBkgdFillIE : this.scrollBarBkgdFill;

                bar.lineStyle(this.scrollBarBkgdBorderLineSize, this.scrollBarBkgdBorderColor, 1);
                bar.beginFill(bkgdFill, 1);
                bar.drawRect(0, 0, this.scrollBarBkgdWidth, this.dashletHeight);
                return bar.generateTexture();
            },

            /**
             * Draws the actual scrollbar thumb
             *
             * @return {Phaser.Texture}
             * @private
             */
            _drawScrollThumb: function(fillColor) {
                var thumb = this.game.make.graphics();
                thumb.lineStyle(0);
                thumb.beginFill(fillColor, 1);

                if (this.game.device.ie) {
                    thumb.drawRect(0, 0, this.scrollBarBkgdWidth, this.scrollThumbHeight);
                } else {
                    thumb.drawRoundedRect(
                        0,
                        0,
                        this.scrollThumbWidth,
                        this.scrollThumbHeight - this.scrollThumbTopBottomPadding - this.scrollThumbTopBottomPadding,
                        5
                    );
                }

                return thumb.generateTexture();
            },

            /**
             * Checks the bounds of `sprite` to make sure the Y value
             * is between 0 and the height of the dashlet
             *
             * @param {Phaser.Image} image The Phaser Image to check bounds
             * @private
             */
            _checkBounds: function(image) {
                if (image.cameraOffset.y < 0) {
                    image.cameraOffset.y = 0;
                }
                if (image.cameraOffset.y > this.maxScrollY) {
                    image.cameraOffset.y = this.maxScrollY;
                }
            },

            /**
             * Handles checking bounds of the scrollbar thumb
             * @param image
             * @private
             */
            _checkDragThumbBounds: function(image) {
                var scrollbarDashletDiff;

                this._checkBounds(image);

                if (this.previousScrollThumbY !== image.cameraOffset.y) {
                    // only update camera if scroll thumb changed Y pos

                    // get the percent difference between how far down the scrollbar has moved
                    // and the height of the dashlet
                    scrollbarDashletDiff = image.cameraOffset.y / this.dashletHeight;
                    // multiply that percent diff by the total game world height
                    this.game.camera.y = scrollbarDashletDiff * this.gameWorldHeight;

                    // set the previous to the current camera offset
                    this.previousScrollThumbY = image.cameraOffset.y;
                }
            },

            /**
             * Handles when a user clicks a new category or Show More
             *
             * @param {Phaser.Image|Phaser.Text} target The Phaser text or icon that was clicked
             * @param {Phaser.Image} icon The icon image object for the clicked item
             * @param {boolean} isIcon If the `target` is an image/icon or Text
             * @param {Object} data The server data with records and offset
             * @private
             */
            _setMoreRecordsData: function(target, icon, isShowMore, data) {
                var childGroup;
                var triggerParent;
                var groupIndex = target.parent._groupIndex;
                var isVisible;
                var changeYDelta;
                var nextRowIndex = 0;

                target._isFetching = false;
                icon._isFetching = false;

                if (isShowMore) {
                    // in the case where a user searches for a term, the root group is the parentGroup
                    // and there is no childGroup on that parentGroup
                    childGroup = target.parent.parentGroup.childGroup || target.parent.parentGroup;
                    // set the next row index to whatever the offset is
                    nextRowIndex = target.parent.parentGroup._nextOffset;
                    // the correct parent to trigger changeY on
                    triggerParent = target.parent.parentGroup;
                } else {
                    childGroup = target.parent.childGroup;
                    // only increment the group's index if this is not a "Show More" group situation
                    groupIndex++;
                    // the correct parent to trigger changeY on
                    triggerParent = target.parent;
                }

                if (!childGroup) {
                    childGroup = this._createGroupObject(groupIndex, 0);

                    target.parent.childGroup = childGroup;
                    target.parent.add(childGroup);
                }

                childGroup._previousHeight = childGroup.height;

                _.each(data.records, function(node, index) {
                    this._createLevel(childGroup, node, groupIndex, nextRowIndex + index);
                }, this);

                if (data.next_offset !== -1) {
                    let showMorePos = nextRowIndex + data.records.length;
                    this._createLevel(childGroup, this.showMoreNode, groupIndex, showMorePos);
                }

                icon.frameName = this.showMoreNodeIconName;
                icon.angle = 0;
                icon._tween.stop();

                if (isShowMore) {
                    // shrink game world as we remove Show More later
                    this.gameWorldHeight -= this.itemRowYPadding;

                    // remove the parent container for the text from its parent
                    target.parent.parent.remove(target.parent);
                    // remove the icon and text from the parent
                    target.parent.remove(icon);
                    target.parent.remove(target);
                    icon.destroy();
                    target.destroy();
                } else {
                    childGroup.y = this.itemRowYPadding;
                    childGroup._nextOffset = data.next_offset;
                }

                isVisible = childGroup.visible;
                changeYDelta = childGroup.height - childGroup._previousHeight;

                if (!isVisible) {
                    changeYDelta = -changeYDelta;
                }

                triggerParent._events.onChangeY.dispatch(changeYDelta, triggerParent);

                this._updateGameWorldSize();
            },
        };

        return $.extend({}, treeConfig, treeState);
    },

    /**
     * Extensible function to add any additional states needed
     *
     * @param {Object} states
     * @return {Object}
     * @protected
     */
    _getAdditionalStates: function(states) {
        return states;
    },

    /**
     * Fetches additional records from the database for a given node id and offset
     *
     * @param {string} id The parent hash id for the record
     * @param {int} offset
     * @param callback
     * @protected
     */
    _fetchMoreRecords: function(id, offset, isShowMore, callback) {
        var callbacks;
        var method = 'create';
        var url = app.api.buildURL(this.treeModule + '/tree', method);
        var payload = {};

        if (!_.isUndefined(id)) {
            payload.root = id;
        }

        if (!_.isUndefined(offset)) {
            payload.offset = offset;
        }

        if (isShowMore && !_.isUndefined(this.currentFilterTerm)) {
            payload.filter = this.currentFilterTerm;
        }

        this.toggleLoading(true);

        callbacks = {
            context: this,
            success: callback,
            complete: _.bind(function() {
                this.activeFetchCt--;
                // when complete, remove the spinning refresh icon from the cog
                // and add back the cog icon
                this.toggleLoading(false);
            }, this)
        };

        this.activeFetchCt++;
        app.api.call(method, url, payload, null, callbacks);
    },

    /**
     * Fetchs a Record given the ID, and sends the response data to `callbacks.success`
     *
     * @param {string} id The ProductTemplate ID Hash to fetch
     * @param {Object} callbacks The callback object with any success/error/complete handler functions
     * @protected
     */
    _fetchRecord: function(id, callbacks) {
        var module = this.getFetchRecordModule();
        var url = app.api.buildURL(module + '/' + id, 'read');
        app.api.call('read', url, null, null, callbacks);
    },

    /**
     * Returns the module name to use for fetching records
     * before sending them to the drawer or record
     *
     * @return {string}
     */
    getFetchRecordModule: function() {
        return this.treeModule;
    },

    /**
     * Gets the closest component to the dashlet
     * @return {Object|null}
     * @private
     */
    _getClosestComponent: function() {
        let componentNames = ['record', 'create', 'convert', 'records', 'side-drawer', 'omnichannel-dashboard'];
        for (let componentName of componentNames) {
            let component = this.closestComponent(componentName);
            if (component) {
                return component;
            }
        }
        return null;
    },

    /**
     * Sends the ProductTemplate data item to the record
     *
     * @param {Object} data The ProductTemplate data
     * @protected
     */
    _sendItemToRecord: function(data) {
        this._massageDataBeforeSendingToRecord(data);

        let closestComp = this._getClosestComponent();
        // need to trigger on app.controller.context because of contexts changing between
        // the PCDashlet, and Opps create being in a Drawer, or as its own standalone page
        // app.controller.context is the only consistent context to use
        if (closestComp && closestComp.triggerBefore('productCatalogDashlet:add:allow')) {
            app.controller.context.trigger(closestComp.cid + ':productCatalogDashlet:add', data);
        }
    },

    /**
     * Allows `data` to be manipulated and updated before sending to the record
     *
     * @param {Object} data The data we're sending to the Record
     * @protected
     */
    _massageDataBeforeSendingToRecord: function(data) {
        // copy Template's id and name to where the QLI expects them
        data.product_template_id = data.id;
        data.product_template_name = data.name;
        data.assigned_user_id = app.user.id;

        // remove ID/etc since we dont want Template ID to be the record id
        delete data.id;
        delete data.status;
        delete data.date_entered;
        delete data.date_modified;
        delete data.pricing_formula;
        delete data.my_favorite;
        delete data.sync_key;
    },

    /**
     * Sends the ProductTemplate data item to a Drawer layout
     *
     * @param {Object} data The ProductTemplate data
     * @protected
     */
    _openItemInDrawer: function(data) {
        var model = app.data.createBean('ProductTemplates', data);
        let closestComp = this._getClosestComponent();
        model.viewId = closestComp.cid;
        app.drawer.open({
            layout: 'product-catalog-dashlet-drawer-record',
            context: {
                module: 'ProductTemplates',
                model: model,
                closestComponent: closestComp
            }
        });
    },

    /**
     * Handles when sending ProductTemplate data has been complete and we can enable the tree again
     *
     * @protected
     */
    _onProductDashletAddComplete: function() {
        this.isFetchActive = false;
        this.$('#product-catalog-container-' + this.cid).removeClass('disabled');
    },

    /**
     * Resizes the Phaser Canvas width and height when the window is resized
     *
     * @protected
     */
    _resizePhaserCanvas: function() {
        var $el = this.$('.product-catalog-container-' + this.cid);

        if (this.phaser && $el.length && this.phaser.scale) {
            this._calculateCanvasSizes($el);
            this.phaser.scale.setGameSize(this.canvasWidth, this.canvasHeight);
            this.phaser.events.onResize.dispatch();
        }
    },

    /**
     * Calculate height and width to be set on the canvas
     * @param $el Canvas element
     * @private
     */
    _calculateCanvasSizes: function($el) {
        let dashletEl = $el.closest('div.dashlet-content');
        let searchBarHeight = dashletEl.find('div.product-catalog-search').innerHeight();
        this.canvasHeight = dashletEl.height() - searchBarHeight;
        this.canvasWidth = dashletEl.find('div.product-catalog-container').width();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        var sidebarLayout = this.closestComponent('sidebar');
        if (sidebarLayout) {
            sidebarLayout.off('sidebar:state:changed', null, this);
        }
        this.context.off('phaserio:ready', null, this);

        // If Phaser exists, destroy it
        if (this.phaser) {
            this.phaser.events.destroy();
            // async the phaser destroy event so it
            // has a chance to finish its update before destroy
            _.delay(_.bind(function() {
                this.phaser.destroy();
            }, this), 25);

        }

        // any cleanup
        this.$('.product-catalog-container-' + this.cid).off(this.wheelEventName);
        // remove window resize event
        $(window).off('resize');
        if (app.controller && app.controller.context) {
            if (this.isConfig) {
                this._super('_dispose');
                return;
            }

            let closestComp = this._getClosestComponent();
            if (closestComp) {
                app.controller.context.off(closestComp.cid + ':productCatalogDashlet:add:complete', null, this);
            }
        }
        this._super('_dispose');
    }
}) },
"multi-selection-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The MultiSelectionListView extends SelectionListView and adds the ability to
 * select multiple records in the list and get the selected items as the output.
 * The way to use it is similar to the SelectionListView.
 *
 * It adds the following properties which have to be set in the context:
 *
 * - `maxSelectedRecords` The max number of records the user can select in the
 *    case of multiselect selection list.
 * - `independentMassCollection` {boolean} `true` if the selected records should
 *   be handled independently from the view collection. If `false` selected
 *   records are tied to the view collection, which means they are reset if the
 *   view collection is reset.
 *
 * @class View.Views.Base.MultiSelectionListView
 * @alias SUGAR.App.view.views.BaseMultiSelectionListView
 * @extends View.Views.Base.SelectionListView
 */
({
	// Multi-selection-list View (base) 

    extendsFrom: 'SelectionListView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, ['MassCollection']);

        /**
         * Maximum number of records a user can select.
         *
         * @property {number}
         */
        this.maxSelectedRecords = options.context.get('maxSelectedRecords');

        /**
         * Boolean to know whether the selected records called `mass collection`
         * should be tied to the view collection or independent.
         *
         * If tied, selected records would have to be in the current view collection.
         * As soon as the view collection is reset, the mass collection would be
         * reset.
         *
         * @property {boolean} `true` for an independent mass collection. `false`
         *   for the mass collection to be tied to the view collection.
         */
        this.independentMassCollection = options.context.get('independentMassCollection') || true;
        // if no metadata defined for `multi-selection-list`, use `selection-list`
        options.meta = _.extend({}, app.metadata.getView(options.module, 'selection-list'), options.meta);
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     * FIXME: SC-4075 will remove this method.
     */
    setSelectionMeta: function(options) {
        options.meta.selection = {
            type: 'multi',
            isSearchAndSelectAction: true,
            disable_select_all_alert: !!this.maxSelectedRecords
        };
    },

    /**
     * Sets up events.
     *
     * @override
     */
    initializeEvents: function() {
        this.context.on('selection:select:fire', this._validateSelection, this);
    },

    /**
     * Closes the drawer passing the selected models attributes to the callback.
     *
     * @protected
     */
    _validateSelection: function() {
        var selectedModels = this.context.get('mass_collection');
        if (selectedModels.length > this.maxSelectedRecords) {
            this._showMaxSelectedRecordsAlert();
            return;
        }
        app.drawer.close(this._getCollectionAttributes(selectedModels));
    },

    /**
     * Displays error message since the number of selected records exceeds the
     * maximum allowed.
     *
     * @private
     */
    _showMaxSelectedRecordsAlert: function() {
        var msg = app.lang.get('TPL_FILTER_MAX_NUMBER_RECORDS', this.module, {
            maxRecords: this.maxSelectedRecords
        });
        app.alert.show('too-many-selected-records', {
            level: 'error',
            messages: msg,
            autoClose: false
        });
    },

    /**
     * Returns an array of attributes given a collection.
     *
     * @param {Data.BeanCollection} collection A collection of records.
     * @return {Object[]} attributes An array containing the attribute object of
     *   each model.
     *
     * @private
     */
    _getCollectionAttributes: function(collection) {
        var attributes = _.map(collection.models, this._getModelAttributes, this);
        return attributes;
    }
}) },
"filtered-search": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.FilteredSearchView
 * @alias SUGAR.App.view.views.BaseFilteredSearchView
 * @extends View.View
 */
({
	// Filtered-search View (base) 

    events: {
        'keyup [data-searchfield]': 'searchFired'
    },

    /**
     * @inheritdoc
     *
     * Update searchable fields.
     */
    bindDataChange: function() {
        this.context.on('filteredlist:filter:set', this.setFilter, this);
    },

    /**
     * Update quick search placeholder to display searchable fields.
     * @param {Array} filter List of field name.
     */
    setFilter: function(filter) {
        var label = app.lang.get('LBL_SEARCH_BY') + ' ' + filter.join(', ') + '...';
        this.$('[data-searchfield]').attr('placeholder', label);
    },

    /**
     * Updated current typed search term.
     */
    searchFired: _.debounce(function(evt) {
        var value = $(evt.currentTarget).val();
        this.context.trigger('filteredlist:search:fired', value);
    }, 100)
}) },
"maps-widget-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Maps widget Top view
 *
 * @class View.Views.Base.MapsWidgetListView
 * @alias SUGAR.App.view.views.BaseMapsWidgetListView
 * @extends View.Views.Base.SubpanelListView
 */
({
	// Maps-widget-list View (base) 

    extendsFrom: 'SubpanelListView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._beforeInit(options);
        this._super('initialize', [options]);

        this._initProperties();
        this._registerEvents();
    },

    /**
     * Before init properties
     */
    _beforeInit: function(options) {
        options.module = app.controller.context.get('module');
    },

    /**
     * Init custom properties
     */
    _initProperties: function() {
        if (this._hasMetaPanels()) {
            this._defaultMetaFields = _.chain(this.meta.panels)
                                    .pluck('fields')
                                    .flatten()
                                    .value();
        }

        this._updateCollectionFilter();
    },

    /**
     * @inheritdoc
     */
    _initOrderBy: function() {
        const orderBy = {
            field: 'maps_distance',
            direction: 'asc'
        };

        return orderBy;
    },

    /**
     * Register custom events
     */
    _registerEvents: function() {
        this.listenTo(this.model, 'change:modules', this._updateCollectionFilter, this);
        this.listenTo(this.model, 'change:filterBy', this._updateCollectionFilter, this);
        this.listenTo(this.model, 'change:unitType', this._updateCollectionFilter, this);
        this.listenTo(this.model, 'change:radius', this._updateCollectionFilter, this);
        this.listenTo(
            this.layout,
            'maps:subpanel:filter:collection:fetched',
            this._updateCollectionFilter,
            this
        );
        this.listenTo(
            this.context,
            'subpanel:massdirectionsfromrecorddraw:fire',
            this.handleDrawDirectionsFromRecord,
            this
        );
        this.listenTo(
            this.context,
            'subpanel:massdirectionsfromuserdraw:fire',
            this.handleDrawDirectionsFromUser,
            this
        );
        this.listenTo(
            this.context,
            'subpanel:massmapdraw:fire',
            this.handleDrawMap,
            this
        );
        this.listenTo(
            this,
            'list:reorder:columns',
            this.reorderMetaFields,
            this
        );
    },

    /**
     * @inheritdoc
     */
    _render: function(options) {
        this._super('_render', [options]);

        this.$('.sortable-row-header-arrows').hide();
        this.$('[data-fieldname="maps_distance"]').find('.sortable-row-header-arrows').show();
    },

    /**
     * Updates collection fields from fields meta
     *
     * @param {Array} newFieldsMeta
     */
    _updateCollectionFields: function(newFieldsMeta) {
        let fields = [];

        if (this._hasMetaPanels()) {
            fields = _.chain(newFieldsMeta)
                    .pluck('name')
                    .filter(function removeDistance(fieldName) {
                        return fieldName !== 'distance';
                    })
                    .value();
        }

        const moduleMeta = app.metadata.getModule(this.model.get('modules'));
        let requiredFields = [];

        if (moduleMeta) {
            requiredFields = _.chain(newFieldsMeta)
                            .filter(function getRelated(field) {
                                return field.type === 'relate';
                            })
                            .map(function getRequirements(field) {
                                return moduleMeta.fields[field.name].id_name;
                            }, this)
                            .value();
        }

        fields.push('my_favorite');
        fields = fields.concat(requiredFields);

        this.context.set('fields', fields);

        this.collection.setOption('fields', fields);
        this.collection.setOption('limit', this.limit);
    },

    /**
     * Checks wether panels are initialized
     *
     * @return {boolean}
     */
    _hasMetaPanels: function() {
        if (!this.meta) {
            return false;
        }

        if (!this.meta.panels) {
            return false;
        }

        return true;
    },

    /**
     * Build and apply collection filter
     */
    _updateCollectionFilter: function(model) {
        const module = this.model.get('modules');
        const filterBy = this.model.get('filterBy');
        const unitType = this.model.get('unitType');
        const radius = this.model.get('radius');
        const contextModel = app.controller.context.get('model');
        const recordId = contextModel.get('id');
        const recordModule = contextModel.module;
        const mapsModule = `${module}/maps`;

        if (!module) {
            const nextOffsetKey = 'next_offset';

            this.collection.reset();
            this.collection.dataFetched = true;
            this.collection[nextOffsetKey] = -1;

            if (model) {
                this.layout.getComponent('list-bottom').render();
                this._tryChangeMetaFields(true);
            }

            return;
        }

        // trigger render only when module has been changed
        const shouldRerender = model && _.has(model, 'changed') && _.has(model.changed, 'modules');

        this._tryChangeMetaFields(shouldRerender);

        let filtersDef = [
            {
                '$distance': {
                    '$in_radius_from_record': {
                        unitType,
                        radius,
                        recordId,
                        recordModule,
                        requiredFields: this.collection.getOption('fields'),
                    }
                }
            }
        ];

        const moduleFiltersDef = this.layout.getComponent('maps-widget-dropdowns').getAvailableFilters();

        if (moduleFiltersDef && filterBy) {
            const filterModel = _.find(moduleFiltersDef.models, function find(filterModel) {
                const filterLabel = app.lang.get(filterModel.get('name'), null, {module});

                return filterLabel === filterBy;
            });

            if (filterModel) {
                const filterDef = filterModel.get('filter_definition');

                filtersDef = filtersDef.concat(filterDef);
            }
        }

        this.collection.module = mapsModule;

        const newModuleCollection = app.data.createBeanCollection(module);

        this.collection.model = newModuleCollection.model;
        this.collection.filterDef = filtersDef;
        this.collection.fetch({
            success: _.bind(function success() {
                const isPanelCollapsed = this.context.get('collapsed');
                const isCollectionEmpty = this.collection.length === 0;

                if (isPanelCollapsed && isCollectionEmpty) {
                    this.$el.parent().find('.block-footer').toggleClass('hide', true);
                }
            }, this)
        });
    },

    /**
     * Changes panels' fields and rerenders view on need
     *
     * @param {boolean} rerender
     */
    _tryChangeMetaFields: function(rerender) {
        if (!this._hasMetaPanels()) {
            return;
        }

        const module = this.model.get('modules');
        const currentMapsModuleSettings = app.config.maps.modulesData;

        let newFieldsMeta = [];

        _.each(this.meta.panels, function addFieldToPanel(panel) {
            panel.fields = app.utils.deepCopy(this._defaultMetaFields);

            let subpanelConfig = [];

            if (_.has(currentMapsModuleSettings[module], 'subpanelConfig')) {
                subpanelConfig = currentMapsModuleSettings[module].subpanelConfig;
            }

            _.each(subpanelConfig, function addFieldToMeta(field) {
                if (_.pluck(panel.fields, 'name').includes(field.fieldName)) {
                    return;
                }

                const moduleFields = app.metadata.getModule(module).fields;
                const fieldMeta = moduleFields[field.fieldName];
                const mapType = app.metadata.fieldTypeMap;
                const widgetType = mapType[fieldMeta.type] ? mapType[fieldMeta.type] : fieldMeta.type;

                panel.fields.push({
                    name: fieldMeta.name,
                    type: widgetType,
                    label: field.label
                });
            }, this);

            newFieldsMeta = panel.fields;
        }, this);

        this.module = module ? module : this.module;

        this._allListViewsFieldListKey = app.user.lastState.buildKey('field-list', 'list-views', this.module);
        this._thisListViewFieldListKey = app.user.lastState.key('visible-fields', this);

        this._fields = this.parseFields();

        const mapsDistanceField = _.find(this._fields.visible, function getDistanceField(field) {
            return field.name === 'maps_distance';
        });
        mapsDistanceField.expectedWidth = 'small';

        this._updateCollectionFields(newFieldsMeta);
        this.orderBy = this._initOrderBy();
        this.collection.orderBy = this.orderBy;

        if (rerender) {
            if (this.orderBy) {
                this.orderBy.field = 'maps_distance';
                this.orderBy.direction = 'asc';
            }

            this.render();
        }
    },

    /**
     * Updates admin meta config with the new columns order
     *
     * @param {Array} fields
     * @param {Array} newOrder
     */
    reorderMetaFields: function(fields, newOrder) {
        const module = this.model.get('modules');
        const currentMapsModuleSettings = app.config.maps.modulesData;

        if (!_.has(currentMapsModuleSettings[module], 'subpanelConfig')) {
            return;
        }

        let subpanelConfig = currentMapsModuleSettings[module].subpanelConfig;
        let newSubpanelOrder = [];
        let startPos = 0;

        _.each(newOrder, function reorder(fieldName) {
            let fieldData = _.filter(subpanelConfig, function getField(field) {
                return field.fieldName === fieldName;
            })[0];

            if (fieldData) {
                fieldData.position = startPos;
                startPos++;

                newSubpanelOrder.push(fieldData);
            }
        });

        app.user.lastState.set(this._thisListViewFieldListKey + ':admin:config', newSubpanelOrder);
    },

    /**
     * @inheritdoc
     */
    setOrderBy: function(event) {

        if (event.currentTarget.dataset.fieldname !== 'maps_distance') {
            return;
        }

        this._super('setOrderBy', [event]);
    },

    /**
     * Trigger map creation and show optimal route
     *
     * @param {Object} startPoint
     */
    handleDrawMap: function(startPoint) {
        app.drawer.open({
            layout: 'subpanel-map',
            context: this.context,
            showDirections: false,
        });
    },

    /**
     * Trigger map creation and show optimal route
     *
     * @param {Object} startPoint
     */
    _handleDrawDirections: function(startPoint) {
        app.drawer.open({
            layout: 'subpanel-map',
            context: this.context,
            showDirections: true,
            startPoint
        });
    },

    /**
     * Draw directions from user
     *
     * @param {UIEvent} e
     */
    handleDrawDirectionsFromUser: function(e) {
        this._handleDrawDirections({
            module: 'Users',
            id: app.user.id
        });
    },

    /**
     * Draw directions from record
     *
     * @param {UIEvent} e
     */
    handleDrawDirectionsFromRecord: function(e) {
        const model = app.controller.context.get('model');
        const id = model.get('id');
        const module = model.module;

        this._handleDrawDirections({
            id,
            module,
        });
    },
}) },
"activity-card-menu": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivityCardMenuView
 * @alias SUGAR.App.view.views.BaseActivityCardMenuView
 * @extends View.Views.Base.CabmenuView
 */
({
	// Activity-card-menu View (base) 

    extendsFrom: 'CabmenuView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.template = app.template.getView('cabmenu');
        this.setActivityModel();
    },

    /**
     * Return card-menu metadata for current module
     *
     * @return {Array}
     */
    getCabMeta: function() {
        var metaViewName = this.getViewNameForMeta();
        var modulesMeta = this.getActivitiesMeta(metaViewName);
        var meta = _.find(modulesMeta.activity_modules, _.bind(function(activityModule) {
            return activityModule.module === this.module;
        }, this));

        if (meta && meta.card_menu) {
            return meta.card_menu;
        }

        return [];
    },

    /**
     * Return activity-timeline metadata for current module
     *
     * @param {string} metaViewName name of the view for which metadata should be fetched
     * @return {Array}
     */
    getActivitiesMeta: function(metaViewName) {
        return app.metadata.getView(this.context.get('module'), metaViewName);
    },

    /**
     * Get the name of the timeline view
     */
    getViewNameForMeta: function() {
        return this.getActivityCardLayout().getTimelineType();
    },

    /**
     * Get the activity-card layout
     *
     * @return {Object}
     */
    getActivityCardLayout: function() {
        return this.closestComponent('activity-card');
    },

    /**
     * Set the activity model from the activity-card layout
     */
    setActivityModel: function() {
        var layout = this.getActivityCardLayout();

        if (layout && layout.model) {
            this.model = layout.model;
        }
    },

    /**
     * Get context model for email actions.
     * @return {Bean}
     */
    getContextModel: function() {
        return this.model;
    },

    /**
     * Reload dashlet content
     */
    reloadData: function() {
        this.$el.closest('.dashlet').find('[data-dashletaction=reloadData]').trigger('click');
    },
}) },
"active-subscriptions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActiveSubscriptionsView
 * @alias SUGAR.App.view.views.BaseActiveSubscriptionsView
 * @extends View.View
 */
({
	// Active-subscriptions View (base) 


    plugins: ['Dashlet'],

    /**
     * The module name to show active subscriptions for.
     *
     * @property {string}
     */
    baseModule: null,

    overallSubscriptionStartDate: 0,

    overallSubscriptionEndDate: 0,

    overallDaysDifference: 0,

    endDate: '',

    expiryComingSoon: false,

    /**
     * Object representing the initial state of our dropdown.
     *
     * @property {Object}
     */
    _defaultSettings: {
        linked_subscriptions_account_field: null,
    },

    /**
     * Flag indicating Purchases module is enabled.
     *
     * @property {bool}
     */
    purchasesModule: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.currentModule = this._currentModule();
        this.module = 'Purchases';
        this.moduleName = {'module_name': app.lang.getModuleName(this.module, {'plural': true})};
        this.baseModule = 'Accounts';

        if (!_.isUndefined(app.metadata.getModule('Purchases'))) {
            this.purchasesModule = true;
        }

        this.linkToDocumentation = this._buildDocumentationUrl();
    },

    /**
     * Set up collection when init dashlet.
     *
     * @param {string} viewName Current view
     */
    initDashlet: function(viewName) {
        this._initSettings();

        this._mode = viewName;

        // Builds our dynamic dropdown list, but also populates the Account field in case it is not already set,
        // for example on upgrade.
        this._buildFieldsList();

        this._initCollection();
    },

    _buildDocumentationUrl: function() {
        var serverInfo = app.metadata.getServerInfo();
        var language = app.lang.getLanguage();
        var module = 'activesubscriptionsdashlet';
        var route = app.controller.context.get('layout');

        let products = app.user.getProductCodes();
        products = products ? products.join(',') : '';

        var params = {
            edition: serverInfo.flavor,
            version: serverInfo.version,
            lang: language,
            module: module,
            route: route
        };
        if (!_.isEmpty(products)) {
            params.products = products;
        }

        return 'https://www.sugarcrm.com/crm/product_doc.php?' + $.param(params);
    },

    /**
     * Get base model from parent context.
     *
     * @deprecated Since 10.2.0. Does not support non-Account module support.
     * @private
     */
    _getBaseModel: function() {
        var baseModule = this.context.get('module');
        var currContext = this.context;

        if (baseModule !== this.baseModule) {
            return;
        }

        while (currContext) {
            var contextModel = currContext.get('rowModel') || currContext.get('model');

            if (contextModel && contextModel.get('_module') === baseModule) {
                this.baseModel = contextModel;

                var parentHasRowModel = currContext.parent && currContext.parent.has('rowModel');
                if (!parentHasRowModel) {
                    break;
                }
            }

            currContext = currContext.parent;
        }
    },

    /**
     * Build our settings object, based on defaults and the metadata, to be used throughout the controller.
     *
     * @private
     */
    _initSettings: function() {
        var settings = _.extend({}, this._defaultSettings, this.settings.attributes);

        this.settings.set(settings);

        return this;
    },

    /**
     * Fetches the metadata object that needs to be updated with the dynamically generated dropdown options.
     *
     * @private
     */
    _getDashletConfigField: function(fieldName) {
        var configPanelMetadata = this.dashletConfig.panels;
        var fieldMetadata = null;

        _.each(configPanelMetadata, function(p) {
            if (_.has(p, 'fields')) {
                _.each(p.fields, function(f) {
                    if (f.name === fieldName) {
                        fieldMetadata = f;
                        return;
                    }
                });
            }
        });

        return fieldMetadata;
    },

    /**
     * When the SugarLive is open we want to consider the context of the activeTab of the dashboard
     * rather than what is open behind the SugarLive
     *
     * @return {string}
     * @private
     */
    _currentModule: function() {
        if (app.omniConsoleConfig && app.omniConsoleConfig.isConfigPaneExpanded) {
            var configDashboard = app.omniConsoleConfig.getComponent('omnichannel-dashboard-config');
            var activeTab = configDashboard.tabModels[configDashboard.activeTab];
            return activeTab.module;
        } else if (app.omniConsole && app.omniConsole.isExpanded()) {
            var activeContact = app.omniConsole.getComponent('omnichannel-ccp').getActiveContact();
            if (activeContact) {
                var dashboard = app.omniConsole.getComponent('omnichannel-dashboard-switch')
                    .getDashboard(activeContact.contactId).getComponent('dashboard');
                var tabs = dashboard.context.get('tabs');
                var activeTab = tabs[dashboard.context.get('activeTab')];
                return activeTab.module;
            }
        }
        return this.context.get('module');
    },

    /**
     * Create the dynamic dropdown options for the dashlet config page.
     *
     * @private
     */
    _buildFieldsList: function() {
        var configPanel = this._getDashletConfigField('linked_subscriptions_account_field');
        var configPanelOptions = {};

        if (this.currentModule === this.baseModule) {
            // If this dashlet is being added to the Accounts module record view, use the default ID field in the
            // Account module
            configPanelOptions.id = 'ID';
        } else {
            configPanelOptions = this._getRelationshipFields();
        }

        if (_.keys(configPanelOptions).length > 0) {
            // Populate dropdown with relationship field options
            configPanel.options = configPanelOptions;

            // If we don't have any existing field selected, or the previously selected field is no longer present
            if (
                !this.settings.get('linked_subscriptions_account_field') ||
                !configPanelOptions[this.settings.get('linked_subscriptions_account_field')]
            ) {
                this.settings.set({linked_subscriptions_account_field: _.first(Object.keys(configPanelOptions))});
            }
        }
    },

    /**
     * Grabs the 1:* Account-related fields on our current module and returns them in the enum dropdown format.
     *
     * @private
     */
    _getRelationshipFields: function() {
        var relFieldsForDropdown = {};

        // Grab the view metadata that has all of the available fields
        var currentModuleFields = app.metadata.getModule(this.currentModule, 'fields');

        // Grab all the 1:* Account relationship (link) and Account relate fields on the current module
        _.each(currentModuleFields, _.bind(function(f) {
            // Relationship logic
            var isRelationship = f.type === 'link';
            var rel = app.metadata.getRelationship(f.relationship);
            var isLinkedToAccounts = rel && (rel.lhs_module === this.baseModule || rel.rhs_module === this.baseModule);

            // Relate field logic
            var isRelateField = f.type === 'relate';
            var isRelatedToAccounts = f.module === this.baseModule;

            // Stores the current field that metadata is fetched for
            var relField = null;

            if (isRelationship && isLinkedToAccounts) {
                var fieldKey = null;

                var hasLeftJoinKey = _.has(rel, 'join_key_lhs') && rel.join_key_lhs !== null;
                var hasRightJoinKey = _.has(rel, 'join_key_rhs') && rel.join_key_rhs !== null;
                // Determine where to grab the account_id field based on the relationship
                if (hasLeftJoinKey && hasRightJoinKey) {
                    fieldKey = rel.lhs_module === this.baseModule ? 'join_key_lhs' : 'join_key_rhs';
                } else {
                    fieldKey = rel.lhs_module === this.baseModule ? 'rhs_key' : 'lhs_key';
                }

                relField = app.metadata.getField({name: rel[fieldKey], module: this.currentModule});

                if (_.has(relField, 'name')) {
                    relFieldsForDropdown[relField.name] = app.lang.get(relField.vname, this.currentModule);
                }
            }

            if (isRelateField && isRelatedToAccounts) {
                // Relate fields stemming from the above relationship fields can be in our list, we want to filter
                // those out by checking there isn't an existing entry in our dropdown options.
                if (!relFieldsForDropdown[f.id_name] && _.has(f, 'id_name')) {
                    relFieldsForDropdown[f.id_name] = app.lang.get(f.vname, this.currentModule);
                }
            }
        }, this));

        return relFieldsForDropdown;
    },

    /**
     * Gets the account ID from the model
     *
     * @param settingsAccountField
     * @return {string}
     * @private
     */
    _getAccountId: function(settingsAccountField) {
        var linkedAccountField = this.settings.get(settingsAccountField);
        if (!linkedAccountField) {
            return null;
        }

        // Normally, we get the field from the context's model. On focus drawer or
        // console dashboards or from SugarLive, we need to get the field from the parent context's rowModel
        var rowModelLayouts = ['focus', 'multi-line', 'omnichannel'];
        var linkField = _.contains(rowModelLayouts, this.context.get('layout')) ?
            this.context.parent.get('rowModel').get(linkedAccountField) :
            this.context.get('model').get(linkedAccountField);
        return linkField || '';
    },

    /**
     * Initialize collection.
     *
     * @private
     */
    _initCollection: function() {
        if (this._mode === 'config' || !this.purchasesModule) {
            return;
        }

        var accountId = this._getAccountId('linked_subscriptions_account_field');

        var today = app.date().formatServer(true);
        var filter = [
            {
                'account_id': {
                    '$equals': accountId,
                }
            },
            {
                'service': {
                    '$equals': 1,
                },
            },
            {
                'start_date': {
                    '$lte': today
                }
            },
            {
                'end_date': {
                    '$gte': today
                }
            }
        ];
        var options = {
            'fields': this.dashletConfig.fields || [],
            'filter': filter,
            'limit': app.config.maxRecordFetchSize || 1000,
            'success': _.bind(function() {
                if (this.disposed) {
                    return;
                }
                var self = this;
                // Render here only when the model empty, else render after the bulk call is resolved.
                if (!this.collection.models.length) {
                    this.render();
                }
                _.each(this.collection.models, function(model) {
                    // add 1 day to display remaining time correctly
                    var nextDate = app.date(model.get('end_date')).add('1', 'day');
                    model.set('service_remaining_time', nextDate.fromNow());
                    var collections = model.get('pli_collection');
                    // create the payload
                    var bulkSaveRequests = self._createBulkCollectionsPayload(collections);
                    // send the payload
                    self._sendBulkCollectionsUpdate(bulkSaveRequests);
                });
            }, this),
        };
        this.collection = app.data.createBeanCollection(this.module, null, options);
        this.collection.fieldsMeta = {
            'total_amount': {
                'name': 'total_amount',
                'type': 'currency',
                'convertToBase': true,
                'currency_field': 'currency_id',
                'base_rate_field': 'base_rate'
            }
        };
    },

    /**
     * Load active subscriptions.
     *
     * @param {Object} options Call options
     */
    loadData: function(options) {
        if (this._mode === 'config' || !this.purchasesModule) {
            return;
        }
        this.collection.fetch(options);
    },

    _render: function(options) {
        this._super('_render', [options]);

        if (!this.settings.get('linked_subscriptions_account_field')) {
            // If we don't have any available fields, replace the dropdown with a label.
            this.template = app.template.get(this.name + '.unavailable');
            this._super('_render', [options]);
        }
    },

    /**
     * Utility method to create the payload that will be sent to the server via the bulk api call
     * to fetch the related PLIs for a purchase
     *
     * @param {Array} collections
     * @private
     */
    _createBulkCollectionsPayload: function(collections) {
        // loop over all the collections and create the requests
        var bulkSaveRequests = [];
        var url;
        collections.each(function(element) {
            // if the element is new, don't try and save it
            if (!element.isNew()) {
                // create the update url
                url = app.api.buildURL(element.module, 'read', {
                    id: element.get('id')
                });

                // get request on each PLI
                bulkSaveRequests.push({
                    // app.api.buildURL() in app.api.call() calls the rest endpoint with the following request
                    // remove rest from the url here
                    url: url.substr(4),
                    method: 'GET',
                });
            }
        });

        return bulkSaveRequests;
    },

    /**
     * Send the payload via the bulk api
     *
     * @param {Array} bulkSaveRequests
     * @private
     */
    _sendBulkCollectionsUpdate: function(bulkSaveRequests) {
        if (!_.isEmpty(bulkSaveRequests)) {
            app.api.call(
                'create',
                app.api.buildURL(null, 'bulk'),
                {
                    requests: bulkSaveRequests
                },
                {
                    success: _.bind(this._onBulkCollectionsUpdateSuccess, this)
                }
            );
        }
    },

    /**
     * Update the bundles when the results from the bulk api call
     *
     * @param {Array} bulkResponses
     * @private
     */
    _onBulkCollectionsUpdateSuccess: function(bulkResponses) {
        var purchaseId = _.first(bulkResponses).contents.purchase_id;
        var model = _.first(this.collection.models.filter(function(ele) {
            return ele.id === purchaseId;
        }));
        var collectionIndex = this.collection.models.indexOf(model);
        var currentSubscription = 0;
        var collections = model.get('pli_collection');
        var element;
        var quantity = 0;
        var totalAmount = 0;

        _.each(bulkResponses, function(record) {
            element = collections.get(record.contents.id);
            if (element) {
                var startDate = app.date(record.contents.service_start_date);
                var endDate = app.date(record.contents.service_end_date);
                var today = app.date().startOf('day');
                if (startDate <= today && endDate >= today) {
                    currentSubscription++;
                    quantity += record.contents.quantity;
                    totalAmount += parseFloat(app.currency.convertWithRate(parseFloat(record.contents.total_amount),
                        record.contents.base_rate));
                }
            }
        }, this);
        model.set('quantity', quantity);
        model.set('total_amount', totalAmount);
        if (currentSubscription === 0) {
            this.collection.models.splice(collectionIndex, 1);
        }
        this._caseComparator();
        this._daysDifferenceCalculator();
        this.render();
    },

    /**
     * Calculates the upper and lower bounds for the timeline Graph calculating the earliest
     * Start Date and End Date for all the records.
     */
    _caseComparator: function() {
        if (this.collection) {
            var daysPast = moment('1970-01-01');
            var min = Number.MAX_VALUE;
            var max = 0;
            var start;
            var end;
            var modelArray = this.collection.models;
            modelArray.forEach(function(model) {
                start = model.get('start_date');
                start = this.moment(start);
                start = start.diff(daysPast, 'days');
                end = model.get('end_date');
                end = this.moment(end);
                end = end.diff(daysPast, 'days');
                if (max < end) {
                    max = end;
                }
                if (min > start) {
                    min = start;
                }
            });
            this.overallSubscriptionEndDate = max;
            this.overallSubscriptionStartDate = min;
        }
    },

    /**
     * Calculates the width for the graph by adjusting in to the 60% width
     * and sets width for the subscription time past and subscription time left
     * to fit into 60% width.
     */
    _daysDifferenceCalculator: function() {
        var daysPast = moment('1970-01-01');
        var today = moment();
        if (this.collection) {
            var overallSubscriptionStartDate = this.overallSubscriptionStartDate;
            var overallDaysDifference = this.overallSubscriptionEndDate - overallSubscriptionStartDate;
            var start = null;
            var end = null;
            var startDate = null;
            var endDate = null;
            var activeTimelineWidth = null;
            var activePastTimelineWidth = null;
            var timelineOffset = 40;
            today = today.diff(daysPast, 'days');

            _.each(this.collection.models, function(model) {
                start = model.get('start_date');
                start = this.moment(start);
                start = start.diff(daysPast, 'days');
                startDate = ((start - overallSubscriptionStartDate) / overallDaysDifference).toFixed(2) * 100;

                end = model.get('end_date');
                end = this.moment(end);
                this.endDate = end;
                end = end.diff(daysPast, 'days');
                endDate = ((end - overallSubscriptionStartDate) / overallDaysDifference).toFixed(2) * 100;

                activeTimelineWidth = ((end - start) / overallDaysDifference) * 60;
                timelineOffset = timelineOffset + startDate * 0.6;
                activeTimelineWidth = (activeTimelineWidth + timelineOffset) > 100 ? (100 - timelineOffset)
                    : activeTimelineWidth;
                activePastTimelineWidth = ((today - start) / (end - start)) * 100;
                activePastTimelineWidth = activePastTimelineWidth >= 100 ? activePastTimelineWidth - 1
                    : activePastTimelineWidth;
                this.expiryComingSoon = (activePastTimelineWidth) >= 90 ? true : false;
                timelineOffset = isNaN(timelineOffset) ? 40 : timelineOffset;
                activeTimelineWidth = isNaN(activeTimelineWidth) ? 60 : activeTimelineWidth;
                activePastTimelineWidth = isNaN(activePastTimelineWidth) ? 99 : activePastTimelineWidth;
                activeTimelineWidth = (activeTimelineWidth === 0) ? 100 - activePastTimelineWidth : activeTimelineWidth;
                model.set({
                    startDate: _.first(app.date(model.get('start_date')).formatUser().split(' ')),
                    endDate: _.first(app.date(model.get('end_date')).formatUser().split(' ')),
                    expiration: this.endDate.fromNow(),
                    timelineOffset: timelineOffset,
                    subscriptionValidityActive: activeTimelineWidth.toFixed(2),
                    subscriptionActiveWidth: activePastTimelineWidth.toFixed(2),
                    expiryComingSoon: this.expiryComingSoon
                });
                timelineOffset = 40;
            });
        }
    },
}) },
"casessummary": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.CasessummaryView
 * @alias SUGAR.App.view.views.BaseCasessummaryView
 * @extends View.View
 */
({
	// Casessummary View (base) 

    events: {
        'shown.bs.tab a[data-toggle="tab"]': 'resize',
    },

    plugins: ['Dashlet', 'Chart'],
    className: 'cases-summary-wrapper',

    tabData: null,
    tabClass: '',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.tooltipTemplate = app.template.getField('chart', 'singletooltiptemplate', this.module);
        this.locale = SUGAR.charts.getSystemLocale();

        this.chart = sucrose.charts.pieChart()
                .margin({top: 0, right: 0, bottom: 0, left: 0})
                .donut(true)
                .donutLabelsOutside(true)
                .donutRatio(0.447)
                .rotateDegrees(0)
                .arcDegrees(360)
                .maxRadius(110)
                .hole(this.total)
                .showTitle(false)
                .tooltips(true)
                .showLegend(false)
                .direction(app.lang.direction)
                .colorData('data')
                .tooltipContent(_.bind(function(eo, properties) {
                    var point = {};
                    point.key = this.chart.getKey()(eo);
                    point.label = app.lang.get('LBL_CHART_COUNT');
                    point.value = this.chart.getValue()(eo);
                    point.percent = sucrose.utility.numberFormatPercent(point.value, properties.total, this.locality);
                    return this.tooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
                }, this))
                .strings({
                    noData: app.lang.get('LBL_CHART_NO_DATA'),
                    noLabel: app.lang.get('LBL_CHART_NO_LABEL')
                })
                .locality(this.locale);

        this.locality = this.chart.locality();
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }

        // Set value of label inside donut chart
        this.chart.hole(this.total);
        d3sugar.select(this.el).select('svg#' + this.cid)
            .datum(this.chartCollection)
            .transition().duration(500)
            .call(this.chart);

        this.chart_loaded = _.isFunction(this.chart.update);
        this.displayNoData(!this.chart_loaded);
    },

    /**
     * Build content with favorite fields for content tabs
     */
    addFavs: function() {
        var self = this;
        //loop over metricsCollection
        _.each(this.tabData, function(tabGroup) {
            if (tabGroup.models && tabGroup.models.length > 0) {
                _.each(tabGroup.models, function(model) {
                    var field = app.view.createField({
                            def: {type: 'favorite'},
                            model: model,
                            meta: {view: 'detail'},
                            viewName: 'detail',
                            view: self
                        });
                    field.setElement(self.$('[data-model-id="' + model.id + '"]'));
                    field.render();
                });
            }
        });
    },

    /* Process data loaded from REST endpoint so that d3 chart can consume
     * and set general chart properties
     */
    evaluateResult: function(data) {
        this.total = data.models.length;

        var countClosedCases = data.where({status: 'Closed'})
                .concat(data.where({status: 'Rejected'}))
                .concat(data.where({status: 'Duplicate'})).length,
            countOpenCases = this.total - countClosedCases;

        this.chartCollection = {
            data: [],
            properties: {
                title: app.lang.get('LBL_CASE_SUMMARY_CHART'),
                value: 3,
                label: this.total
            }
        };
        this.chartCollection.data.push({
            key: app.lang.get('LBL_DASHLET_CASESSUMMARY_CLOSE_CASES'),
            classes: 'sc-fill-green',
            value: countClosedCases
        });
        this.chartCollection.data.push({
            key: app.lang.get('LBL_DASHLET_CASESSUMMARY_OPEN_CASES'),
            classes: 'sc-fill-red',
            value: countOpenCases
        });

        if (!_.isEmpty(data.models)) {
            this.processCases(data);
        }
    },

    /**
     * Build tab related data and set tab class name based on number of tabs
     * @param {data} object The chart related data.
     */
    processCases: function(data) {
        this.tabData = [];

        var status2css = {
                'Rejected': 'label-success',
                'Closed': 'label-success',
                'Duplicate': 'label-success'
            },
            stati = _.uniq(data.pluck('status')),
            statusOptions = app.metadata.getModule('Cases', 'fields').status.options || 'case_status_dom';

        _.each(stati, function(status, index) {
            if (!status2css[status]) {
                this.tabData.push({
                    index: index,
                    status: status,
                    statusLabel: app.lang.getAppListStrings(statusOptions)[status],
                    models: data.where({'status': status}),
                    cssClass: status2css[status] ? status2css[status] : 'label-important'
                });
            }
        }, this);

        this.tabClass = ['one', 'two', 'three', 'four', 'five'][this.tabData.length] || 'four';
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var self = this,
            oppID,
            accountBean,
            relatedCollection;
        if (this.meta.config) {
            return;
        }
        oppID = this.model.get('account_id');
        if (oppID) {
            accountBean = app.data.createBean('Accounts', {id: oppID});
        }
        relatedCollection = app.data.createRelatedCollection(accountBean || this.model, 'cases');
        relatedCollection.fetch({
            relate: true,
            success: function(data) {
                self.evaluateResult(data);
                if (!self.disposed) {
                    // we have to rerender the entire dashlet, not just the chart,
                    // because the HBS file is dependant on processCases completion
                    self.render();
                    self.addFavs();
                }
            },
            error: _.bind(function() {
                this.displayNoData(true);
            }, this),
            complete: options ? options.complete : null,
            limit: -1,
            fields: this.getFieldNames()
        });
    },

    /**
     * Get the list of field names to render the dashlet correctly
     * @return {string[]} The list of fields we need to fetch
     * @override
     */
    getFieldNames: function() {
        // FIXME TY-920: we shouldn't have to override this per-dashlet
        return this.dashletConfig && this.dashletConfig.dashlets[0].fields || [];
    }
}) },
"selection-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The SelectionListView provides an easy way to select a record from a list.
 * It's designed to be used in a drawer. The model attributes of the selected
 * record will be passed to the drawer callback.
 *
 * The SelectionListView has a generic implementation and can be overriden for
 * particular uses.
 *
 * It has to be opened passing the following data in the drawer's context:
 *
 * - `module` {String} The module the list is related to.
 * - `fields` {Array} The fields to be displayed.
 * - `filterOptions` {Object} the filter options for the list view.
 *
 *  Example of usage:
 *
 *     app.drawer.open({
	// Selection-list View (base) 

 *              layout: 'selection-list',
 *               context: {
 *                   module: this.getSearchModule(),
 *                   fields: this.getSearchFields(),
 *                   filterOptions: this.getFilterOptions(),
 *               }
 *           }, _.bind(this.setValue, this));
 *     },
 *
 * @class View.Views.Base.SelectionListView
 * @alias SUGAR.App.view.views.BaseSelectionListView
 * @extends View.Views.Base.FlexListView
 */
({
    extendsFrom: 'FlexListView',

    dataView: 'selection-list',

    initialize: function(options) {
        // Since list.js only fetches list view metadata, we need to build our
        // own metadata to send to the parent.
        var viewMeta = app.metadata.getView(options.module, options.name) ||
                       app.metadata.getView(options.module, this.dataView) || {};
        this.plugins = _.union(this.plugins, ['ListColumnEllipsis', 'ListRemoveLinks']);
        //setting skipFetch to true so that loadData will not run on initial load and the filter load the view.
        options.context.set('skipFetch', true);
        options.meta = _.extend(viewMeta, options.meta || {});
        this.setSelectionMeta(options);
        this._super('initialize', [options]);

        // set list back to flex-list
        this.tplName = 'flex-list';

        this.events = _.extend({}, this.events, {
            'click .search-and-select .single': 'triggerCheck'
        });
        this.initializeEvents();
    },

    /**
     * Sets metadata proper to selection-list.
     *
     * @param {Object} options
     *
     * FIXME: SC-4075 will remove this method.
     */
    setSelectionMeta: function(options) {
        options.meta.selection = {
            type: 'single',
            label: 'LBL_LINK_SELECT',
            isSearchAndSelectAction: true
        };
    },

    /**
     * Checks the `[data-check=one]` element when the row is clicked.
     *
     * @param {Event} event The `click` event.
     */
    triggerCheck: function(event) {
        //Ignore inputs and links/icons, because those already have defined effects
        if (!($(event.target).is('a,i,input'))) {
            var checkbox = $(event.currentTarget).find('[data-check=one]');
            checkbox[0].click();
        }
    },

    /**
     * Sets up events.
     */
    initializeEvents: function() {
        this.context.on('change:selection_model selection-list:select', this._selectAndClose, this);
    },

    /**
     * Closes the drawer passing the selected model attributes to the callback.
     *
     * @param {object} context
     * @param {Data.Bean} selectedModel The selected record.
     *
     * @protected
     */
    _selectAndClose: function(context, selectedModel) {
        if (selectedModel) {
            this.context.unset('selection_model', {silent: true});
            app.drawer.close(this._getModelAttributes(selectedModel));
        }
    },

    /**
     * Returns attributes given a model with ACL check.
     *
     * @param {Data.bean} model
     * @return {object} attributes
     *
     * @private
     */
    _getModelAttributes: function(model) {
        var attributes = {
            id: model.id,
            value: model.get('name')
        };

        //only pass attributes if the user has view access
        _.each(model.attributes, function(value, field) {
            if (app.acl.hasAccessToModel('view', model, field)) {
                attributes[field] = attributes[field] || model.get(field);
            }
        }, this);

        return attributes;
    },

    /**
     * Adds Preview button on the actions column on the right.
     */
    addActions: function() {
        this._super('addActions');
        if (this.meta.showPreview !== false) {
            this.rightColumns.push({
                type: 'preview-button',
                css_class: 'btn',
                tooltip: 'LBL_PREVIEW',
                event: 'list:preview:fire',
                icon: 'sicon-preview',
                acl_action: 'view'
            });
        } else {
            this.rightColumns.push({});
        }
    }
}) },
"panel-top": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Header section for Subpanel layouts.
 *
 * @class View.Views.Base.PanelTopView
 * @alias SUGAR.App.view.views.BasePanelTopView
 * @extends View.View
 */
({
	// Panel-top View (base) 

    /**
     * @inheritdoc
     */
    className: 'subpanel-header',

    /**
     * @inheritdoc
     */
    attributes: {
        'data-sortable-subpanel': 'true'
    },

    /**
     * @inheritdoc
     */
    events: {
        'click': 'togglePanel',
        'click a[name=create_button]:not(".disabled")': 'createRelatedClicked',
        'keydown [data-a11y=toggle]': '_handleKeyClick'
    },

    plugins: ['LinkedModel'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // FIXME: SC-3594 will address having child views extending metadata
        // from its parent.
        options.meta = _.extend(
            {},
            app.metadata.getView(null, 'panel-top'),
            app.metadata.getView(options.module, 'panel-top'),
            options.meta
        );

        this._super('initialize', [options]);

        // This is in place to get the lang strings from the right module. See
        // if there is a better way to do this later.
        this.parentModule = this.context.parent.get('module');

        // Listen to the context for collapsed attribute to change
        // and toggle the aria-expanded attribute on the button element
        this.listenTo(this.context, 'change:collapsed', this._toggleAria);

        // FIXME: Revisit with SC-4775.
        this.on('linked-model:create', function() {
            this.context.set('skipFetch', false);
            this.context.reloadData();
        }, this);
    },

    /**
     * Event handler for the create button.
     *
     * @param {Event} event The click event.
     */
    createRelatedClicked: function(event) {
        this.createRelatedRecord(this.module);
    },

    /**
    * Event handler that toggles the subpanel layout when the SubpanelHeader is
    * clicked.
    *
    * Triggers the `panel:toggle` event to toggle the subpanel.
    *
    * @param {Event} The `click` event.
    */
    togglePanel: function(evt) {
        if (_.isNull(this.$el)) {
            return;
        }

        var $target = this.$(evt.target),
            isLink = $target.closest('a, button').length;

        if (isLink) {
            return;
        }

        this.context.set('collapsed', !this.context.get('collapsed'));
    },

    /**
     * Sets the subpanel header accessibility class 'aria-expanded' to true or false
     * depending on if the subpanel is open or closed.
     *
     * @private
     */
    _toggleAria: function(context, collapsed) {
        this.$('[data-a11y=toggle]')
            .attr('aria-expanded', !collapsed);
    },

    /**
     * Triggers the click event when the data-a11y toggle element has focus
     * and the spacebar or enter keydown event occurs
     *
     * @private
     */
    _handleKeyClick: function(evt) {
        app.accessibility.handleKeyClick(evt, this.$el);
    }
}) },
"hint-data-enrichment-drawer-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Hint-data-enrichment-drawer-header View (base) 

    plugins: ['Stage2CssLoader'],

    events: {
        'click [name=cancel_button]': 'closeDrawer',
        'click [name=save_button]': function() {
            app.events.trigger('hint:config:save');
        }
    },

    /**
     * {@inheritdoc}
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.title = this.context.get('title');
    },

    /**
     * Close drawer
     */
    closeDrawer: function() {
        app.drawer.close();
        app.router.navigate(this.module, {trigger: true});
    }
}) },
"stage2-account-change": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Stage2-account-change View (base) 

    plugins: ['Stage2CssLoader'],

    events: {
        'change input[name=select]': 'isSelected',
        'click .save': 'savePrimary',
        'click .cancel': 'cancel',
        'mouseenter [rel="tooltip"]': 'showTooltip',
        'mouseleave [rel="tooltip"]': 'hideTooltip'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.context.set('forceNew', true);
        this._super('initialize', [options]);
        this._moduleSingular = app.lang.getModuleName(this.context.get('module'));
        this._domainCollection = options.context.get('_domainCollection');

        if (this.layout) {
            this.layout.on('app:view:stage2-account-change', function() {
                this._domainCollection = this.context.get('_domainCollection');
                this._domains = _.uniq(_.pluck(this._domainCollection, 'domain'));
                this.render();
            }, this);
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this.$('.modal').modal({
            backdrop: 'static'
        });
        this.$('.modal').modal('show');
        $('.datepicker').css('z-index', '20000');
        app.$contentEl.attr('aria-hidden', true);
        $('.modal-backdrop').insertAfter($('.modal'));
        $('.save').prop('disabled', true);
    },

    /**
     * Check if is selected
     *
     * @param {Object} e
     */
    isSelected: function(e) {
        var self = this;
        var $btn = $(e.currentTarget);
        this._newDomain = $btn.attr('value');

        if (!this._newDomain) {
            $('.save').prop('disabled', true);
        } else {
            $('.save').prop('disabled', false);
        }
    },

    /**
     * Disable buttons
     *
     * @param {boolean} flag
     */
    _disableButtons: function(flag) {
        $('[data-name="btn"]').prop('disabled', flag);
        $('input[name=select]').prop('disabled', flag);
    },

    /**
     * Save primary
     */
    savePrimary: function() {
        var self = this;
        if (!this._newDomain) {
            app.alert.show('message-id', {
                level: 'error',
                messages: app.lang.get('LBL_HINT_NO_ACCOUNT_SELECTED'),
                autoClose: true
            });
        } else {
            this._disableButtons(true);
            var emails = this.model.get('email');
            var email = _.findWhere(this._domainCollection, {
                domain: this._newDomain
            }).address;

            emails.unshift({
                email_address: email,
                invalid_email: false,
                opt_out: false,
                primary_address: true,
                reply_to_address: false,
            });
            this.model.set({
                email: emails
            });

            this._disableButtons(false);
            this.layout.trigger('app:preview:popup-close');
            app.$contentEl.removeAttr('aria-hidden');
            this._disposeView();
        }
    },

    /**
     * Dispose the view
     */
    _disposeView: function() {
        /**Find the index of the view in the components list of the layout*/
        var index = _.indexOf(this.layout._components, _.findWhere(this.layout._components, {
            name: 'stage2-account-change'
        }));
        if (index > -1) {
            /** dispose the view so that the evnets, context elements etc created by it will be released*/
            this.layout._components[index].dispose();
            /**remove the view from the components list**/
            this.layout._components.splice(index, 1);
        }
    },

    /**
     * Remove aria hidden on cancel button and dispose the view
     */
    cancel: function() {
        app.$contentEl.removeAttr('aria-hidden');
        this._disposeView();
    }
}) },
"quicksearch-tags": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchTagsView
 * @alias SUGAR.App.view.views.BaseQuicksearchTagsView
 * @extends View.View
 */

({
	// Quicksearch-tags View (base) 

    events: {
        'click .qs-tag a': 'handleTagSelection'
    },

    initialize: function(options) {
        this._super('initialize', [options]);

        // Initialize tag collections (search results and selected tags)
        this.tagCollection = [];
        this.selectedTags = this.layout.selectedTags || [];
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        /**
         * Stores the index of the currently highlighted list element.
         * This is used for keyboard navigation.
         * @{number} {null}
         */
        this.activeIndex = null;

        // If the layout has `quicksearch:close` called on it, that means the
        // whole thing is hidden
        this.layout.on('quicksearch:close quicksearch:results:close', function() {
            this.activeIndex = null;
            this.$('.active').removeClass('active');
            this.disposeKeyEvents();
            this.close();
        }, this);

        this.collection.on('sync', this.quicksearchHandler, this);

        //Listener for receiving focus for up/down arrow navigation:
        this.on('navigate:focus:receive', function() {
            this.activeIndex = 0;
            this._highlightActive();
            this.attachKeyEvents();
        }, this);

        //Listener for losing focus for up/down arrow navigation:
        this.on('navigate:focus:lost', function() {
            this.activeIndex = null;
            this.$('.active').removeClass('active');
            this.disposeKeyEvents();
        }, this);
    },

    /**
     * Handles the layout event indicating quicksearch fire
     * @param collection
     */
    quicksearchHandler: function(collection) {
        var selectedTags = this.selectedTags;

        if (collection && collection.tags) {
            // Filter out tags that already exist in selectedTags
            this.tagCollection = _.filter(collection.tags, function(tag) {
                return _.isUndefined(_.find(selectedTags, function(selectedTag) {
                    return selectedTag.name === tag.name;
                }));
            });
            this.render();
            if (this.tagCollection.length) {
                this.open();
            } else {
                this.close();
            }
        } else {
            this.close();
        }
    },

    /**
     * Highlight the active element and unhighlight the rest of the elements.
     */
    _highlightActive: function() {
        if (_.isNull(this.activeIndex)) {
            return;
        }

        this.$('.active').removeClass('active');
        this.$('.qs-tag:eq(' + this.activeIndex + ')')
            .addClass('active')
            .find('a').focus();
    },

    /**
     * Handler for tag selection
     * @param {Event} e
     */
    handleTagSelection: function(e) {
        if (e.target && e.target.text) {
            var self = this;
            var selectedTag = _.find(this.tagCollection, function(tag) {
                return tag.name === e.target.text;
            });

            this.layout.trigger('quicksearch:bar:clear:term');
            this.layout.trigger('quicksearch:tag:add', selectedTag);

            // Focus back to quicksearch-bar after tag selection. Defer it to prevent enter key-up
            // from navigating away
            _.defer(function() {
                self.layout.trigger('navigate:to:component', 'quicksearch-bar')
            });
        }
    },

    /**
     * Return true if tag view contains any tags. False if not
     * @return boolean
     */
    isFocusable: function() {
        return this.tagCollection &&
            this.tagCollection.length;
    },

    /**
     * Show the tag ribbon
     */
    open: function() {
        this.layout.trigger('quicksearch:tag:open');
        this.$('.quicksearch-tags').show();
    },

    /**
     * Hide the tag ribbon
     */
    close: function() {
        this.layout.trigger('quicksearch:tag:close');
        this.$('.quicksearch-tags').hide();
    },

    /**
     * Handle when the user uses their keyboard to try to navigate outside of the view. This handles both the top and
     * bottom boundaries.
     * @param {boolean} next - If true, we are checking the next element. If false, we are checking the previous.
     * @private
     */
    _handleBoundary: function(next) {
        var event = 'navigate:next:component';
        if (!next) {
            event = 'navigate:previous:component';
        }
        if (this.layout.triggerBefore(event)) {
            this.disposeKeyEvents();
            this.$('.active').removeClass('active');
            this.layout.trigger(event);
        }
    },

    moveDown: function() {
        this._handleBoundary(true);
    },

    moveRight: function() {
        var maxIndex = this.tagCollection.length;
        if (this.activeIndex < --maxIndex) {
            this.activeIndex++;
            this._highlightActive();
        }
    },

    moveLeft: function() {
        if (this.activeIndex > 0) {
            this.activeIndex--;
            this._highlightActive();
        }
    },

    moveUp: function() {
        this._handleBoundary(false);
    },

    /**
     * Handle the keydown events.
     * @param {Event} e
     */
    keydownHandler: function(e) {
        switch (e.keyCode) {
            case 40: // down arrow
                this.moveDown();
                break;
            case 39: // right arrow
                this.moveRight();
                break;
            case 38: // up arrow
                this.moveUp();
                break;
            case 37: // left arrow
                this.moveLeft();
                break;
            case 13: //enter
                e.preventDefault();
                e.stopImmediatePropagation();
                break;
        }
    },

    keyupHandler: function(e) {
        switch (e.keyCode) {
            case 13: //enter
                this.handleTagSelection(e);
                break;
        }
    },

    /**
     * Attach the keydown events for the view.
     */
    attachKeyEvents: function() {
        this.$el.on('keydown', _.bind(this.keydownHandler, this));
        this.$el.on('keyup', _.bind(this.keyupHandler, this));
    },

    /**
     * Dispose the keydown events for the view.
     */
    disposeKeyEvents: function() {
        this.$el.off('keydown keyup');
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.disposeKeyEvents();
        this._super('unbind');
    }
}) },
"sweetspot-config-list-row": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SweetspotConfigListRowView
 * @alias SUGAR.App.view.views.BaseSweetspotConfigListRowView
 * @extends View.View
 */
({
	// Sweetspot-config-list-row View (base) 

    tagName: 'tr',

    className: 'config-list-row',

    events: {
        'click [data-action=add]': 'addRow',
        'click [data-action=remove]': 'removeRow'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.model = app.data.createBean();
        this._super('initialize', [options]);
        this.prepareActionDropdown();
        this.collection.add(options.model);
    },

    /**
     * This method adds all possible Sweet Spot actions to the `action` enum
     * field, so they can be configured by the user.
     */
    prepareActionDropdown: function() {
        var field = _.find(this.meta.fields, function(field) {
            return field.name === 'action';
        });
        var actions = app.metadata.getSweetspotActions();
        var options = {};
        _.each(actions, function(action, id) {
            options[id] = action.name;
        });
        field.options = options;
    },

    /**
     * Adds a {@link View.Views.Base.SweetspotConfigListRowView row view} to the
     * layout.
     */
    addRow: function() {
        this.context.trigger('sweetspot:config:addRow', this);
    },

    /**
     * Removes and disposes this row view from the
     * {@link View.Views.Base.SweetspotConfigListLayout list layout}
     */
    removeRow: function() {
        this.context.trigger('sweetspot:config:removeRow', this);
    }
}) },
"user-locale-wizard-page": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * User Locale wizard page for the FirstLoginWizard.
 *
 * @class View.Views.Base.UserLocaleWizardPageView
 * @alias SUGAR.App.view.views.BaseUserLocaleWizardPageView
 * @extends View.Views.Base.UserWizardPageView
 */
({
	// User-locale-wizard-page View (base) 

    extendsFrom: "UserWizardPageView",
    TIME_ZONE_KEY: 'timezone',
    TIME_PREF_KEY: 'timepref',
    DATE_PREF_KEY: 'datepref',
    NAME_FORMAT_KEY: 'default_locale_name_format',

    /**
     * @override
     * @param options
     */
    initialize: function(options) {
        var self = this;
        options.template = app.template.getView('wizard-page');
        this._super('initialize', [options]);
        // Preset the user prefs for formats
        if (this.model) {
            this.model.set(this.TIME_ZONE_KEY, (app.user.getPreference(this.TIME_ZONE_KEY) || ''));
            this.model.set(this.TIME_PREF_KEY, (app.user.getPreference(this.TIME_PREF_KEY) || ''));
            this.model.set(this.DATE_PREF_KEY, (app.user.getPreference(this.DATE_PREF_KEY) || ''));
            this.model.set(this.NAME_FORMAT_KEY, (app.user.getPreference(this.NAME_FORMAT_KEY) || ''));
        }
        this.action = 'edit';
    },

    _render: function(){
        var self = this;
        // Prepare the metadata so we can prefetch select2 locale options
        this._prepareFields(function() {
            if (!self.disposed) {
                self.fieldsToValidate = self._fieldsToValidate(self.meta);
                self._super("_render");
            }
        });
    },
    _prepareFields: function(callback) {
        var self = this;
        // Fixme this doesn't belong in user. See TY-526.
        app.user.loadLocale(function(localeOptions) {
            // Populate each field def of type enum with returned locale options and use user's pref as displayed
            _.each(self.meta.panels[0].fields, function(fieldDef) {
                var opts = localeOptions[fieldDef.name];
                if (opts) {
                    fieldDef.options = opts;
                }
            });
            callback();
        });
    },
    /**
     * Called before we allow user to proceed to next wizard page. Does the validation and locale update.
     * @param {Function} callback The callback to call once HTTP request is completed.
     * @override
     */
    beforeNext: function(callback) {
        this.getField("next_button").setDisabled(true);  //temporarily disable
        this.model.doValidate(this.fieldsToValidate,
            _.bind(function(isValid) {
                var self = this;
                if (isValid) {
                    var payload = this._prepareRequestPayload();
                    app.alert.show('wizardlocale', {
                        level: 'process',
                        title: app.lang.get('LBL_LOADING'),
                        autoClose: false
                    });
                    // 'ut' is, historically, a special flag in user's preferences that is
                    // generally marked truthy upon timezone getting saved. It's also used
                    // to semantically represent "is the user's instance configured"
                    payload['ut'] = true;
                    app.user.updatePreferences(payload, function(err) {
                        app.alert.dismiss('wizardlocale');
                        self.updateButtons();  //re-enable buttons
                        if (err) {
                            app.logger.debug("Wizard locale update failed: " + err);
                            callback(false);
                        } else {
                            callback(true);
                        }
                    });
                } else {
                    callback(false);
                }
            }, this)
        );
    }

}) },
"filter-filter-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for the filter dropdown.
 *
 * Part of {@link View.Layouts.Base.FilterLayout}.
 *
 * @class View.Views.Base.FilterFilterDropdownView
 * @alias SUGAR.App.view.views.BaseFilterFilterDropdownView
 * @extends View.View
 */
({
	// Filter-filter-dropdown View (base) 

    tagName: 'span',
    className: 'table-cell',

    events: {
        'click .choice-filter.choice-filter-clickable': 'handleEditFilter',
        'keydown .choice-filter.choice-filter-clickable': 'handleEditFilter',
        'click .choice-filter-close': 'handleClearFilter',
        'keydown .choice-filter-close': 'handleClearFilter',
    },

    /**
     * These labels are used in the filter dropdown
     *  - labelDropdownTitle        label used as the dropdown title. ie `Filter`
     *  - labelCreateNewFilter      label for create new filter action. ie `Create`
     *  - labelAllRecords           label used on record view when all related modules are selected. ie `All Records`
     *
     *  - labelAllRecordsFormatted  label used when all records are selected. ie `All <Module>s`
     *
     *                              It is set to null because already defined per module. However, some views are
     *                              allowed to override it because of the context. For instance, `dupecheck-list` view
     *                              wants to display `All duplicates` instead of `All <Module>s`
     */
    labelDropdownTitle: 'LBL_FILTER',
    labelCreateNewFilter: 'LBL_FILTER_CREATE_NEW',
    labelAllRecords: 'LBL_FILTER_ALL_RECORDS',
    labelAllRecordsFormatted: null,
    /**
     * @override
     * @param {Object} opts
     */
    initialize: function(opts) {
        app.view.View.prototype.initialize.call(this, opts);

        //Load partials
        this._select2formatSelectionTemplate = app.template.get('filter-filter-dropdown.selection-partial');
        this._select2formatResultTemplate = app.template.get('filter-filter-dropdown.result-partial');

        this.listenTo(this.layout, 'filter:select:filter', this.handleSelect);
        this.listenTo(this.layout, 'filter:change:module', this.handleModuleChange);
        this.listenTo(this.layout, 'filter:render:filter', this._renderHtml);
        this.listenTo(this.layout, 'filter:create:close', this.formatSelection);
        this.listenTo(this.context, 'filter:collapse', this.formatSelection);
    },

    /**
     * Truthy when filter dropdown is enabled.  Updated whenever the filter module changes.
     */
    filterDropdownEnabled: true,

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        if (!this.layout.filters) {
            return;
        }
        this._super('_renderHtml');
        this.getModelFilter();
        this.filterList = this.getFilterList();
        this._renderDropdown(this.filterList);
    },

    /**
     * Adds the actual filter to the dropdown
     *
     * @param {Object} model
     * */
    addModelFilterToLayoutFilters: function(model) {
        if (!_.isUndefined(this.layout) && !_.isEmpty(this.layout.filters)) {
            this.layout.filters.collection.add(model);
            this.layout.filters.collection.sort();
        }
        this.layout.selectFilter(model.id);
    },

    /**
     * When the filters collection not contains the model filter, fetch and add it to the collection
     */
    getModelFilter: function() {
        var modelFilterId = this.model && this.model.get('filter_id');

        if (modelFilterId) {
            var modelFilter = this.layout.filters.collection.findWhere({id: modelFilterId});

            if (!modelFilter) {
                var url = app.api.buildURL('Filters/' + modelFilterId, null, null);
                app.api.call('read', url, null, {
                    success: _.bind(this.addModelFilterToLayoutFilters, this),
                    error: function() {
                        app.logger.error('Filter can not be read, thus is not shared. Filter id: ' + filterId);
                    }
                });
            }
        }
    },

    /**
     * Get the list of filters from layout.filters.collection for the dropdown
     *
     * @return {Array}
     * */
    getFilterList: function() {
        var filters = [];
        if (this.layout.canCreateFilter()) {
            filters.push({id: 'create', text: app.lang.get(this.labelCreateNewFilter)});
        }

        if (this.layout.filters && this.layout.filters.collection) {
            var allRecordsFilter = this.layout.filters.collection.get('all_records');
            if (allRecordsFilter && this.labelAllRecordsFormatted) {
                allRecordsFilter.set('name', this.labelAllRecordsFormatted);
                this.layout.filters.collection.sort();
            }
            // This flag is used to determine when we have to add the border top (to separate categories)
            var firstNonEditable = false;
            this.layout.filters.collection.each(function(model) {
                var creator = model.get('created_by');
                var filterApp = model.get('app');
                var isCreator = !creator || creator === app.user.get('id');
                var isPortal = app.controller.context.get('layout') === 'portaltheme-config' ||
                    app.config.platform === 'portal';
                // if filterApp is empty, show this filter in both portal and main app
                var isPortalFilter = filterApp === 'portal' || !filterApp;
                var isMainAppFilter = filterApp === 'base' || !filterApp;
                var isFilterValid = this._isFilterModelValid(model, false);

                // show only current user's filters in main app
                // show all portal filters in portal and portal config page
                if (((!isPortal && isMainAppFilter && isCreator) || (isPortal && isPortalFilter)) && isFilterValid) {
                    var opts = {
                        id: model.id,
                        text: this.layout.filters.collection._getTranslatedFilterName(model)
                    };
                    if (model.get('editable') === false && !firstNonEditable) {
                        opts.firstNonUserFilter = true;
                        firstNonEditable = true;
                    }
                    filters.push(opts);
                }
            }, this);
        }

        return filters;
    },

    /**
     * Validation checks against filter model
     *
     * @param {Data.Bean} model
     * @param {boolean} reset
     *
     * @private
     *
    * @return {boolean}
     */
    _isFilterModelValid: function(model, reset) {
        const hasDistanceFilter = !_.chain(model.get('filter_definition'))
            .pluck('$distance')
            .compact()
            .isEmpty()
            .value();

        if (!app.user.hasMapsLicense() && hasDistanceFilter) {
            if (reset) {
                this._fallbackToDefaultFilters();
            }

            return false;
        }

        return true;
    },

    /**
     * Reset filters to default
     *
     * @private
     */
    _fallbackToDefaultFilters: function() {
        this.layout.clearLastFilter(this.layout.layout.currentModule, this.layout.layoutType);
    },

    /**
     * Render select2 dropdown
     *
     * This function may be called even when this.render() is not because of
     * the "filter:render:filter" event listener.
     *
     * @private
     */
    _renderDropdown: function(data) {
        var self = this;
        this.filterNode = this.$('.search-filter');

        this.filterNode.select2({
            data: data,
            multiple: false,
            minimumResultsForSearch: 7,
            formatSelection: _.bind(this.formatSelection, this),
            formatResult: _.bind(this.formatResult, this),
            formatResultCssClass: _.bind(this.formatResultCssClass, this),
            dropdownCss: {width: 'auto'},
            dropdownCssClass: 'search-filter-dropdown',
            initSelection: _.bind(this.initSelection, this),
            escapeMarkup: function(m) {
                return m;
            },
            shouldFocusInput: function() {
                // We return false here so that we do not refocus on the field once
                // it has been blurred. If we return true, blur needs to happen
                // twice before it is really blurred.
                return false;
            },
            width: 'off'
        });

        // the shortcut keys need to be registered anytime this function is
        // called, not just on render
        app.shortcuts.register({
            id: 'Filter:Create',
            keys: ['f c', 'mod+alt+8'],
            component: this,
            description: 'LBL_SHORTCUT_FILTER_CREATE',
            handler: function() {
                // trigger the change event to open the edit filter drawer
                this.filterNode.select2('val', 'create', true);
            }
        });
        app.shortcuts.register({
            id: 'Filter:Edit',
            keys: 'f e',
            component: this,
            description: 'LBL_SHORTCUT_FILTER_EDIT',
            handler: function() {
                this.$('.choice-filter.choice-filter-clickable').click();
            }
        });
        app.shortcuts.register({
            id: 'Filter:Show',
            keys: 'f m',
            component: this,
            description: 'LBL_SHORTCUT_FILTER_SHOW',
            handler: function() {
                this.filterNode.select2('open');
            }
        });

        if (!this.filterDropdownEnabled) {
            this.filterNode.select2('disable');
        }

        this.filterNode.off('change');
        this.filterNode.on('change',
            /**
             * Called when the user selects a filter in the dropdown
             *
             * @triggers filter:change:filter on filter layout to indicate a new
             *   filter has been selected.
             *
             * @param {Event} e The `change` event.
             */
            function(e) {
                self.layout.trigger('filter:change:filter', e.val);
            }
        );
    },

    /**
     * This handler is useful for other components that trigger
     * `filter:select:filter` in order to select the dropdown value.
     *
     * @param {String} id The id of the filter to select in the dropdown.
     */
    handleSelect: function(id) {
        this.filterNode.select2('val', id, true);
    },

    /**
     * Get the dropdown labels for the filter
     *
     * @param {Object} el
     * @param {Function} callback
     * */
    initSelection: function(el, callback) {
        var data;
        var model;
        var val = el.val();

        if (val === 'create') {
            //It should show `Create`
            data = {id: 'create', text: app.lang.get(this.labelCreateNewFilter)};

        } else {
            model = this.layout.filters.collection.get(val);

            //Fallback to `all_records` filter if not able to retrieve selected filter
            if (!model || !this._isFilterModelValid(model, true)) {
                data = {id: 'all_records', text: app.lang.get(this.labelAllRecords)};

            } else if (val === 'all_records') {
                data = this.formatAllRecordsFilter(null, model);
            } else {
                data = {id: model.id, text: this.layout.filters.collection._getTranslatedFilterName(model)};
            }
        }

        callback(data);
    },

    /**
     * Update the text for the selected filter and returns template
     *
     * @param {Object} item
     * @return {string}
     * */
    formatSelection: function(item) {
        var ctx = {};
        var safeString;
        var a11yLabel = app.lang.get('LBL_FILTER_CREATE_FILTER');
        var a11yTabindex = 0;

        //Don't remove this line. We want to update the selected filter name but don't want to change to the filter
        //name displayed in the dropdown
        item = _.clone(item);

        this.toggleFilterCursor(this.isFilterEditable(item.id));

        if (item.id === 'all_records') {
            item = this.formatAllRecordsFilter(item);
        }

        //Escape string to prevent XSS injection
        safeString = Handlebars.Utils.escapeExpression(item.text);
        if (item.id !== 'all_records') {
            if (this.isFilterEditable(item.id)) {
                a11yTabindex = 0;
                a11yLabel = app.lang.get('LBL_FILTER_EDIT_FILTER') + ' ' + safeString;
            } else {
                a11yTabindex = -1;
                a11yLabel = safeString + ' ' + app.lang.get('LBL_FILTER');
            }
        } else {
            a11yTabindex = this.isFilterEditable(item.id) ? 0 : -1;
        }

        // Update the text for the selected filter.
        this.$('.choice-filter-label')
            .html(safeString)
            .attr('aria-label', a11yLabel)
            .attr('tabindex', a11yTabindex);

        this.$('.choice-filter-close').toggle(item.id !== 'all_records');
        this.$('.choice-filter').toggleClass('with-close', item.id !== 'all_records');

        ctx.label = app.lang.get(this.labelDropdownTitle);
        ctx.enabled = this.filterDropdownEnabled;

        return this._select2formatSelectionTemplate(ctx);
    },

    /**
     * Returns template
     *
     * @param {Object} option
     * @return {string}
     * */
    formatResult: function(option) {
        if (option.id === this.layout.getLastFilter(this.layout.layout.currentModule, this.layout.layoutType)) {
            option.icon = 'sicon-check';
        } else if (option.id === 'create') {
            option.icon = 'sicon-plus';
        } else {
            option.icon = undefined;
        }
        return this._select2formatResultTemplate(option);
    },

    /**
     * Adds a class to the `Create Filter` item (to add border bottom)
     * and a class to first user custom filter (to add border top)
     *
     * @param {Object} item
     * @return {string} css class to attach
     */
    formatResultCssClass: function(item) {
        if (item.id === 'create') {return 'select2-result-border-bottom';}
        if (item.firstNonUserFilter) {return 'select2-result-border-top';}
    },

    /**
     * Determine if a filter is editable
     *
     * @param {String} id
     * @return {boolean} `true` if filter is editable, `false` otherwise
     */
    isFilterEditable: function(id) {
        if (!this.layout.canCreateFilter() || !this.filterDropdownEnabled || this.layout.showingActivities) {
            return false;
        }
        if (id === 'create' || id === 'all_records') {
            return true;
        } else {
            var filterModel = this.layout.filters.collection.get(id);
            if (filterModel) {
                var isEditable = filterModel.get('editable') !== false;
                var creator = filterModel.get('created_by');
                var hasOwnership = creator ? creator === app.user.get('id') : true;
                return isEditable && hasOwnership;
            } else {
                return true;
            }
        }
    },

    /**
     * Toggles cursor depending if the filter is editable or not.
     *
     * @param {boolean} active `true` for a pointer cursor, `false` for a not allowed cursor
     */
    toggleFilterCursor: function(editable) {
        this.$('.choice-filter')
            .css('cursor', editable ? 'pointer' : 'not-allowed')
            .toggleClass('choice-filter-clickable', editable);
    },

    /**
     * Formats label for `all_records` filter. When showing all subpanels, we expect `All records`
     *
     * @param {Object} item
     * @return {Object} item with formatted label
     */
    formatAllRecordsFilter: function(item, model) {
        item = item || {id: 'all_records'};

        //SP-1819: Seeing "All Leads" instead of "All Records" in sub panel
        //For the record view our Related means all subpanels (so should show `All Records`)
        var allRelatedModules = _.indexOf([this.module, 'all_modules'], this.layout.layout.currentModule) > -1;

        //If ability to create a filter
        if (this.isFilterEditable(item.id)) {
            item.text = app.lang.get(this.labelCreateNewFilter);
        } else if (this.layout.layoutType === 'record' && allRelatedModules) {
            item.text = app.lang.get(this.labelAllRecords);
            this.toggleFilterCursor(false);
        } else if (model) {
            item.text = this.layout.filters.collection._getTranslatedFilterName(model);
        }
        return item;
    },

    /**
     * Handler for when the user selects a filter in the filter bar,
     * or user clicks the filter button to create or edit.
     */
    handleEditFilter: function(evt) {
        if (evt && evt.type === 'keydown') {
            if (evt.keyCode !== $.ui.keyCode.SPACE && evt.keyCode !== $.ui.keyCode.ENTER) {
                return;
            }
            // Prevent scrolling page with space
            evt.preventDefault();
            evt.stopPropagation();
        }

        var filterId = this.filterNode.val();
        var filterModel;
        var a11yTabindex = 0;

        if (filterId === 'all_records') {
            // Figure out if we have an edit state.
            // This would mean user was editing the filter so we want him to retrieve
            // the filter form in the state he left it.
            this.layout.trigger('filter:select:filter', 'create');
            a11yTabindex = 0;
        } else {
            this.layout.trigger('filter:select:filter', filterId);
            filterModel = this.layout.filters.collection.get(filterId);
            a11yTabindex = -1;
        }

        if (filterModel && filterModel.get('editable') !== false) {
            this.layout.trigger('filter:create:open', filterModel);
            a11yTabindex = 0;
        }

        this.$('.choice-filter-label')
            .attr('aria-label', app.lang.get('LBL_FILTER_EDIT_FILTER'))
            .attr('tabindex', a11yTabindex);
    },

    /**
     * Handler for when the user selects a module in the filter bar.
     */
    handleModuleChange: function(linkModuleName, linkName) {
        this.filterDropdownEnabled = (linkName !== 'all_modules');
    },

    /**
     * When a click happens on the close icon, clear the last filter and trigger reinitialize
     *
     * @param {Event} evt
     * */
    handleClearFilter: function(evt) {
        if (evt && evt.type === 'keydown' &&
            !(evt.keyCode === $.ui.keyCode.ENTER || evt.keyCode === $.ui.keyCode.SPACE)) {
            return;
        }

        //This event is fired within .choice-filter and another event is attached to .choice-filter
        //We want to stop propagation so it doesn't bubble up.
        evt.stopPropagation();
        this.layout.clearLastFilter(this.layout.layout.currentModule, this.layout.layoutType);
        var filterId;
        if (this.context.get('currentFilterId') === this.layout.filters.collection.defaultFilterFromMeta) {
            filterId = 'all_records';
        } else {
            filterId = this.layout.filters.collection.defaultFilterFromMeta;
        }
        this.layout.trigger('filter:select:filter', filterId);
    },

    /**
     * @override
     * @private
     */
    _dispose: function() {
        if (!_.isEmpty(this.filterNode)) {
            this.filterNode.select2('destroy');
        }
        app.view.View.prototype._dispose.call(this);
    }
}) },
"resolve-conflicts-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ResolveConflictsListView
 * @alias SUGAR.App.view.views.BaseResolveConflictsListView
 * @extends View.Views.Base.FlexListView
 */
({
	// Resolve-conflicts-list View (base) 

    extendsFrom: 'FlexListView',
    plugins: ['ListColumnEllipsis', 'ListRemoveLinks'],

    initialize: function (options) {
        // set as single select list
        options.meta = options.meta || {};
        options.meta.selection = {type: 'single', label: 'LBL_LINK_SELECT'};

        //FIXME: This will be moved out as part of SC-5449.
        options.meta.template = 'flex-list';

        this._super('initialize', [options]);

        // do not fetch on initial load
        this.context._fetchCalled = true;

        this._buildList();
    },

    /**
     * Do not build default list columns.
     */
    parseFields: function () {},

    /**
     * Populate the list with data from the client and the server.
     * @private
     */
    _buildList: function() {
        var dataInDb = this.context.get('dataInDb'),
            modelToSave = this.context.get('modelToSave'),
            modelInDb, copyOfModelToSave, originalId;

        if (!_.isEmpty(dataInDb) && !_.isEmpty(modelToSave)) {
            modelInDb = app.data.createBean(modelToSave.module, dataInDb);
            copyOfModelToSave = app.data.createBean(modelToSave.module);
            originalId = modelToSave.get('id');

            //cannot use bean.copy() because we need date_modified
            copyOfModelToSave.set(app.utils.deepCopy(modelToSave.attributes));

            this._buildFieldDefinitions(copyOfModelToSave, modelInDb);

            // set IDs to be different so that backbone collection can recognize that they're not the same
            copyOfModelToSave.set('id', originalId + '-client');
            modelInDb.set('id', originalId + '-database');

            // indicate which model is from the client and the server
            copyOfModelToSave.set('_dataOrigin', 'client');
            modelInDb.set('_dataOrigin', 'database');

            // set the person who modified the data
            copyOfModelToSave.set('_modified_by', app.lang.get('LBL_YOU'));
            modelInDb.set('_modified_by', modelInDb.get('modified_by_name'));

            this._populateMissingDataFromDatabase(copyOfModelToSave, modelInDb);
            this.collection.add([copyOfModelToSave, modelInDb]);
        }
    },

    /**
     * Build columns to be displayed to the user.
     * @param {Bean} modelToSave
     * @param {Bean} modelInDb
     * @private
     */
    _buildFieldDefinitions: function(modelToSave, modelInDb) {
        var fieldsThatDiffer,
            fieldDefinition,
            modifiedByColumnDef = {
                name: '_modified_by',
                type: 'base',
                label: 'LBL_MODIFIED',
                sortable: false
            };

        // determine which fields have different values
        fieldsThatDiffer = app.utils.compareBeans(modelToSave, modelInDb);

        // remove modified_by_name if exists
        fieldsThatDiffer = _.filter(fieldsThatDiffer, function(name) {
            return name !== 'modified_by_name';
        });

        // get field view definitions
        fieldDefinition = this._getFieldViewDefinition(fieldsThatDiffer);

        // insert modified by column
        fieldDefinition = _.union([modifiedByColumnDef], fieldDefinition);

        this._fields = this._createCatalog(fieldDefinition);
    },

    /**
     * @inheritdoc
     */
    _patchField: function(fieldMeta, i) {
        var isVisible = (fieldMeta.name !== 'date_modified');
        return _.extend({
            sortable: false,
            selected: isVisible,
            position: ++i
        }, fieldMeta, {
            sortable: false
        });
    },

    /**
     * Get field view definition from the record view, given field names.
     * @param fieldNames
     * @return {Array}
     * @private
     */
    _getFieldViewDefinition: function(fieldNames) {
        var fieldDefs = [],
            moduleViewDefs = app.metadata.getView(this.module, 'record'),
            addFieldDefinition = function(definition) {
                if (definition.name && (_.indexOf(fieldNames, definition.name) !== -1)) {
                    fieldDefs.push(app.utils.deepCopy(definition));
                }
            };

        _.each(moduleViewDefs.panels, function(panel) {
            _.each(panel.fields, function(field) {
                if (field.fields && _.isArray(field.fields)) {
                    // iterate through fieldsets to get the field view definition
                    _.each(field.fields, function(field) {
                        addFieldDefinition(field);
                    });
                } else {
                    addFieldDefinition(field);
                }
            });
        });

        return fieldDefs;
    },

    /**
     * Populate missing values on the client's bean from the database data.
     * @param {Bean} modelToSave
     * @param {Bean} modelInDb
     * @private
     */
    _populateMissingDataFromDatabase: function(modelToSave, modelInDb) {
        _.each(modelInDb.attributes, function(value, attribute) {
            if (!modelToSave.has(attribute) || !app.utils.hasDefaultValueChanged(attribute, modelToSave)) {
                modelToSave.set(attribute, value);
            }
        })
    },

    /**
     * Trigger preview event when the preview is clicked. Preview needs to render without activity
     * stream and pagination.
     */
    addPreviewEvents: function () {
        this._super("addPreviewEvents");

        this.context.off('list:preview:fire', null, this);
        this.context.on('list:preview:fire', function (model) {
            app.events.trigger('preview:render', model, this.collection, false, model.id, false);
            app.events.trigger('preview:pagination:hide');
        }, this);
    },

    /**
     * Add Preview button on the actions column on the right.
     */
    addActions: function() {
        this._super("addActions");

        this.rightColumns.push({
            type: 'rowaction',
            css_class: 'btn',
            tooltip: 'LBL_PREVIEW',
            event: 'list:preview:fire',
            icon: 'sicon-preview'
        });
    }
}) },
"search-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * List view for the {@link View.Layouts.Base.SearchLayout
 * Search layout}.
 *
 * @class View.Views.Base.SearchListView
 * @alias SUGAR.App.view.views.BaseSearchListView
 * @extends View.View
 */
({
	// Search-list View (base) 

    plugins: ['Pagination'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        /**
         * The fields metadata for this view per module.
         *
         * @property
         * @private
         */
        this._fieldsMeta = {};
        this.addPreviewEvents();
    },

    /**
     * Parses models when collection resets and renders the view.
     *
     * @override
     */
    bindDataChange: function() {
        this.collection.on('sync', function(collection) {
            if (this.disposed) {
                return;
            }
            var isCollection = (collection instanceof App.BeanCollection);
            if (!isCollection) {
                return;
            }
            this.parseModels(this.collection.models);
            if (this._previewed) {
                app.events.trigger('preview:close');
            }
            this.render();
        }, this);
    },

    /**
     * Parses models to generate primary fields and secondary fields based on
     * the metadata and data sent by the globalsearch API. This is used to
     * render them properly in the template.
     *
     * @param {Data.Bean[]} models The models to parse.
     */
    parseModels: function(models) {
        var gsUtils = app.utils.GlobalSearch;
        _.each(models, function(model) {
            var moduleMeta = this._fieldsMeta[model.module] || gsUtils.getFieldsMeta(model.module);
            this._fieldsMeta[model.module] = moduleMeta;

            model.primaryFields = gsUtils.highlightFields(model, moduleMeta.primaryFields);
            model.secondaryFields = gsUtils.highlightFields(model, moduleMeta.secondaryFields, true);
            model.viewAccess = app.acl.hasAccessToModel('view', model);

            this._rejectEmptyFields(model, model.secondaryFields);

            model.primaryFields = this._sortHighlights(model.primaryFields);
            model.secondaryFields = this._sortHighlights(model.secondaryFields);

            model.rowactions = moduleMeta.rowactions;
        }, this);
    },

    /**
     * Converts a hash of field names and their definitions into an array of
     * field definitions sorted such as:
     *
     *  - avatar field(s) is(are) first (in theory there should be only one),
     *  - highlighted fields are second,
     *  - non highlighted fields are third.
     *
     * @param {Object} fieldsObject The object to transform.
     * @return {Array} fieldsArray The sorted array of objects.
     * @private
     */
    _sortHighlights: function(fieldsObject) {
        var fieldsArray = _.values(fieldsObject);
        fieldsArray = _.sortBy(fieldsArray, function(field) {
            if (field.type === 'avatar') {
                return 0;
            }
            return field.highlighted ? 1 : 2;
        });
        return fieldsArray;
    },

    /**
     * Removes fields that have an empty value.
     *
     * @param {Data.Bean} model The model.
     * @param {Object} viewDefs The viewDefs of the fields.
     * @private
     */
    _rejectEmptyFields: function(model, viewDefs) {
        _.each(viewDefs, function(field) {
            var fieldValue = model.get(field.name);
            // _.isEmpty() returns true for any number, so checking for _.isNumber() as well
            if (_.isEmpty(fieldValue) && !_.isNumber(fieldValue)) {
                delete viewDefs[field.name];
            }
        });
    },

    /**
     * Adds event listeners related to preview.
     */
    addPreviewEvents: function() {
        this.context.on('list:preview:fire', function(model) {
            app.events.trigger('preview:render', model, this.collection, true);
        }, this);

        //When switching to next/previous record from the preview panel, we need
        //to update the highlighted row.
        app.events.on('list:preview:decorate', this.decorateRow, this);
        if (this.layout) {
            this.layout.on('list:paginate:success', function() {
                //When fetching more records, we need to update the preview
                //collection.
                app.events.trigger('preview:collection:change', this.collection);
                // If we have a model in preview, redecorate the row as previewed
                if (this._previewed) {
                    this.decorateRow(this._previewed);
                }
            }, this);
        }
    },

    /**
     * Decorates the row in the list that is being shown in Preview.
     *
     * @param {Data.Bean} model The model corresponding to the row to be
     *   decorated. Pass a falsy value to clear decoration.
     */
    decorateRow: function(model) {
        this._previewed = model;
        this.$('li.highlighted').removeClass('highlighted current');
        if (model) {
            var curr = this.$('[data-id="' + model.id + '"]');
            curr.addClass('current highlighted');
        }
    },

    /**
     * Add the tags and facets options to the paginate query.
     * Please see the {@link Pagination#getNextPagination} for detail.
     *
     * @return {Object} Pagination fetch options.
     */
    getPaginationOptions: function() {
        var selectedFacets = this.context.get('selectedFacets');
        var tagFilters = _.pluck(this.context.get('tags'), 'id');
        var options = null;
        if (selectedFacets || tagFilters) {
            options = {
                apiOptions: {
                    data: {},
                    fetchWithPost: true,
                    useNewApi: true
                }
            };
        }
        if (selectedFacets) {
            options.apiOptions.data.agg_filters = selectedFacets;
        }
        if (tagFilters) {
            options.apiOptions.data.tag_filters = tagFilters;
        }

        return options;
    }
}) },
"quickcreate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuickcreateView
 * @alias SUGAR.App.view.views.BaseQuickcreateView
 * @extends View.View
 */
({
	// Quickcreate View (base) 

    plugins: ['Dropdown'],

    /**
     * @param {Object} options
     * @inheritdoc
     */
    initialize: function(options) {
        app.events.on("app:sync:complete", this.render, this);
        app.view.View.prototype.initialize.call(this, options);

        //shortcut keys
        app.shortcuts.registerGlobal({
            id: 'Quickcreate:Toggle',
            keys: 'c',
            component: this,
            description: 'LBL_SHORTCUT_QUICK_CREATE',
            handler: function() {
                this.$('[data-toggle=dropdown]').click();
            }
        });
    },

    /**
     * @inheritdoc
     * @private
     */
    _renderHtml: function() {
        if (!app.api.isAuthenticated() || app.config.appStatus == 'offline') {
            return;
        }
        // loadAdditionalComponents fires render before the private metadata is ready, check for this
        if (app.isSynced) {
            this.createMenuItems = this._getMenuMeta(
                app.metadata.getModuleNames({filter: ['visible', 'quick_create'], access: 'create'})
            );
            app.view.View.prototype._renderHtml.call(this);
        }
    },

    /**
     * Retrieve the quickcreate metadata from each module in the list
     * Uses the visible flag on the metadata to determine if admin has elected to hide the module from the list
     *
     * @param {Array} module The module names
     * @return {Array} list of visible menu item metadata
     */
    _getMenuMeta: function(modules) {
        var returnList = [];
        _.each(modules, function(name) {
            var meta = app.metadata.getModule(name);
            if (meta && meta.menu && meta.menu.quickcreate) {
                var menuItem = _.clone(meta.menu.quickcreate.meta);
                if (menuItem.visible === true) {
                    menuItem.module = name;
                    menuItem.type = menuItem.type || 'quickcreate';
                    // apply default icon for compatibility with customizations from previous versions
                    // but leave the possibility to turn icon off by specifying empty value
                    if (!("icon" in menuItem)) {
                        menuItem.icon = 'sicon sicon-plus';
                    }
                    //TODO: refactor sidecar field hbs helper so it can accept the module name directly
                    menuItem.model = app.data.createBean(name);
                    returnList.push(menuItem);
                }
            }
        }, this);
        return this._sortByOrder(returnList);
    },

    /**
     * Sorts the module list based upon the value of the order attribute.
     *
     * @param {Array} moduleList
     * @return {Array}
     * @private
     */
    _sortByOrder: function(moduleList) {
        return moduleList.sort(function(a, b) {
            var order = a['order'] - b['order'];
            return (order == 0) ? (a['label'] > b['label']) : order;
        });
    }
}) },
"omnichannel-dashboard": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.OmnichannelDashboardView
 * @alias SUGAR.App.view.views.BaseOmnichannelDashboardView
 * @extends View.Views.Base.TabbedDashboardView
 */
({
	// Omnichannel-dashboard View (base) 

    extendsFrom: 'TabbedDashboardView',

    /**
     * @inheritdoc
     * @param options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.template = app.template.getView('tabbed-dashboard');
    },

    /**
     * @inheritdoc
     *
     * Checks to see if we need to set the initial active tab
     *
     * @param {Object} [options] Tab options.
     * @private
     */
    _setTabs: function(options) {
        var omniDashboardLayout = this.layout && this.layout.layout;
        if (omniDashboardLayout && _.isNumber(omniDashboardLayout.initActiveTab)) {
            options.activeTab = omniDashboardLayout.initActiveTab;
            omniDashboardLayout.initActiveTab = null;
        }

        this._super('_setTabs', [options]);
        omniDashboardLayout.activeTab = options.activeTab;
    }
}) },
"mobile-action": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MobileActionView
 * @alias SUGAR.App.view.views.BaseMobileActionView
 * @extends View.View
 */
({
	// Mobile-action View (base) 

    tagName: 'span',
    events: {
        'click [data-action=mobile]': 'navigateToMobile'
    },
    navigateToMobile: function () {
        if (document.cookie.indexOf('sugar_mobile=') !== -1) {
            // kill sugar_mobile=0 cookie
            document.cookie = 'sugar_mobile=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
        }
        // navigate to the same route of mobile site
        window.location = app.utils.buildUrl('mobile/') + window.location.hash;
    }
}) },
"history-summary-list-bottom": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HistorySummaryListBottomView
 * @alias SUGAR.App.view.views.BaseHistorySummaryListBottomView
 * @extends View.Views.Base.ListBottomView
 */
({
	// History-summary-list-bottom View (base) 

    extendsFrom: 'ListBottomView',

    /**
     * Assigns label for "More history..." since History isn't
     * a proper module and doesn't fetch lang strings
     * @override
     */
    setShowMoreLabel: function() {
        this.showMoreLabel = app.lang.get('LBL_MORE_HISTORY');
    }
}) },
"pmse-case": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Pmse-case View (base) 

    extendsFrom: 'RecordView',

    events: {
        'click .record-edit-link-wrapper': 'handleEdit'
    },

    /**
     * @deprecated Since 7.8. Will be removed in 7.10.
     * @param options
     */
    initialize: function(options) {
        app.logger.warn('View.Views.Base.PmseCaseView is deprecated and will be removed in 7.10');
        this.case = options.context.get('case');
        this.plugins = _.union(this.plugins || [], ['ProcessActions']);
        options.meta = _.extend({}, app.metadata.getView(options.module, 'record'), options.meta);
        options.meta.hashSync = _.isUndefined(options.meta.hashSync) ? true : options.meta.hashSync;
        options.meta.buttons = this.case.buttons;
        this._super('initialize', [options]);
        this.context.set("layout", "record");
        this.buttons = {};
        this.createMode = this.context.get('create') ? true : false;
        this.action = 'detail';
        this.context.on('change:record_label', this.setLabel, this);
        this.context.set('viewed', true);
        this.context.set('dataView', 'record');
        this.model.on('duplicate:before', this.setupDuplicateFields, this);
        this.on('editable:keydown', this.handleKeyDown, this);
        this.on('editable:mousedown', this.handleMouseDown, this);
        this.on('field:error', this.handleFieldError, this);
        this.context.on('button:cancel_button:click', this.cancelClicked, this);
        //event register for preventing actions
        // when user escapes the page without confirming deleting
        app.routing.before('route', this.beforeRouteDelete, this);
        $(window).on('beforeunload.delete' + this.cid, _.bind(this.warnDeleteOnRefresh, this));

        if (this.createMode) {
            this.model.isNotEmpty = true;
        }

        this.noEditFields = [];
        // properly namespace SHOW_MORE_KEY key
        this.MORE_LESS_KEY = app.user.lastState.key(this.MORE_LESS_KEY, this);
        this.adjustHeaderpane = _.bind(_.debounce(this.adjustHeaderpane, 50), this);
        $(window).on('resize.' + this.cid, this.adjustHeaderpane);

        $(window).on('resize.' + this.cid, _.bind(this.overflowTabs, this));

        // initialize tab view after the component is attached to DOM
        this.on('append', function() {
            this.overflowTabs();
            this.handleActiveTab();
        }, this);

    },

    validationComplete: function(isValid) {
        if (isValid) {
            this.setButtonStates(this.STATE.VIEW);
            this.handleSave();
        }
    },

    delegateButtonEvents: function() {
        this.context.on('button:edit_button:click', this.editClicked, this);

        this.context.on('case:cancel', this.cancelCase, this);
        this.context.on('case:claim', this.caseClaim, this);
        this.context.on('case:approve', this.caseApprove, this);
        this.context.on('case:reject', this.caseReject, this);
        this.context.on('case:route', this.caseRoute, this);

        this.context.on('case:history', this.caseHistory, this);
        this.context.on('case:status', this.caseStatus, this);
        this.context.on('case:add:notes', this.caseAddNotes, this);
        this.context.on('case:change:owner', this.caseChangeOwner, this);
        this.context.on('case:reassign', this.caseReassign, this);
    },

    cancelCase: function () {
        this.redirectCase();
    },

    caseClaim: function () {
        app.alert.show('upload', {level: 'process', title: 'LBL_LOADING', autoclose: false});
        var frm_action = 'Claim';
        var value = this.model.attributes;
        value.moduleName = this.case.flow.cas_sugar_module;
        value.beanId = this.case.flow.cas_sugar_object_id;
        value.cas_id = this.case.flow.cas_id;
        value.cas_index = this.case.flow.cas_index;
        value.taskName = this.case.title.activity;
        var self = this;
        var pmseInboxUrl = app.api.buildURL('pmse_Inbox/engine_claim','',{},{});
        app.api.call('update', pmseInboxUrl, value,{
            success: function (){
                app.alert.dismiss('upload');
                self.redirectCase(frm_action);
            }
        });
    },

    caseApprove: function () {
        this.model.doValidate(this.getFields(this.module), _.bind(this.validationCompleteApprove, this));
    },

    validationCompleteApprove: function (isValid) {
        if (isValid) {
            app.alert.show('confirm_approve', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PA_PROCESS_APPROVE_QUESTION', 'pmse_Inbox'),
                onConfirm: _.bind(function () {
                    app.alert.show('upload', {level: 'process', title: 'LBL_LOADING', autoclose: false});
                    var value = this.model.attributes;
                    value.frm_action = 'Approve';
                    value.idFlow = this.case.flowId;
                    value.idInbox = this.case.inboxId;
                    value.cas_id = this.case.flow.cas_id;
                    value.cas_index = this.case.flow.cas_index;
                    value.moduleName = this.case.flow.cas_sugar_module;
                    value.beanId = this.case.flow.cas_sugar_object_id;
                    value.taskName = this.case.title.activity;
                    var self = this;
                    var pmseInboxUrl = app.api.buildURL('pmse_Inbox/engine_route', '', {}, {});
                    app.api.call('update', pmseInboxUrl, value, {
                        success: function () {
                            app.alert.show('success_approve', {
                                level: 'success',
                                messages: app.lang.get('LBL_PA_PROCESS_APPROVED_SUCCESS', 'pmse_Inbox'),
                                autoClose: true
                            });
                            self.model.setSyncedAttributes(self.model.attributes);
                            self.redirectCase();
                        }
                    });
                }, this),
                onCancel: $.noop
            });
        }
    },

    caseReject: function () {
        this.model.doValidate(this.getFields(this.module), _.bind(this.validationCompleteReject, this));
    },

    validationCompleteReject: function (isValid) {
        if (isValid) {
            app.alert.show('confirm_reject', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PA_PROCESS_REJECT_QUESTION', 'pmse_Inbox'),
                onConfirm: _.bind(function () {
                    app.alert.show('upload', {level: 'process', title: 'LBL_LOADING', autoclose: false});
                    var value = this.model.attributes;
                    value.frm_action = 'Reject';
                    value.idFlow = this.case.flowId;
                    value.idInbox = this.case.inboxId;
                    value.cas_id = this.case.flow.cas_id;
                    value.cas_index = this.case.flow.cas_index;
                    value.moduleName = this.case.flow.cas_sugar_module;
                    value.beanId = this.case.flow.cas_sugar_object_id;
                    value.taskName = this.case.title.activity;
                    var self = this;
                    var pmseInboxUrl = app.api.buildURL('pmse_Inbox/engine_route', '', {}, {});
                    app.api.call('update', pmseInboxUrl, value, {
                        success: function () {
                            app.alert.show('success_reject', {
                                level: 'success',
                                messages: app.lang.get('LBL_PA_PROCESS_REJECTED_SUCCESS', 'pmse_Inbox'),
                                autoClose: true
                            });
                            self.model.setSyncedAttributes(self.model.attributes);
                            self.redirectCase();
                        }
                    });
                }, this),
                onCancel: $.noop
            });
        }
    },

    caseRoute: function () {
        this.model.doValidate(this.getFields(this.module), _.bind(this.validationCompleteRoute, this));
    },

    validationCompleteRoute: function (isValid) {
        if (isValid) {
            app.alert.show('confirm_route', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PA_PROCESS_ROUTE_QUESTION', 'pmse_Inbox'),
                onConfirm: _.bind(function () {
                    var value = this.model.attributes;
                    value.frm_action = 'Route';
                    value.idFlow = this.case.flowId;
                    value.idInbox = this.case.inboxId;
                    value.cas_id = this.case.flow.cas_id;
                    value.cas_index = this.case.flow.cas_index;
                    value.moduleName = this.case.flow.cas_sugar_module;
                    value.beanId = this.case.flow.cas_sugar_object_id;
                    value.taskName = this.case.title.activity;
                    if (this.case.taskContinue) {
                        value.taskContinue = true;
                    }
                    var self = this;
                    var pmseInboxUrl = app.api.buildURL('pmse_Inbox/engine_route', '', {}, {});
                    app.api.call('update', pmseInboxUrl, value, {
                        success: function () {
                            app.alert.show('success_route', {
                                level: 'success',
                                messages: app.lang.get('LBL_PA_PROCESS_ROUTED_SUCCESS', 'pmse_Inbox'),
                                autoClose: true
                            });
                            self.redirectCase();
                        }
                    });
                }, this),
                onCancel: $.noop
            });
        }
    },

    redirectCase: function(isRoute){
        app.alert.dismiss('upload');
        switch(isRoute){
            case 'Claim':
                window.location.reload();
                break;
            default:
                app.router.list("Home");
                break;
        };
    },

    /**
     * Shows a window with current history of the record
     *
     */
    caseHistory: function () {
        this.getHistory(this.case.flow.cas_id);
    },

    /**
     * Shows window with picture of current status of the process
     *
     */
    caseStatus: function() {
        this.showStatus(this.case.flow.cas_id);
    },

    /**
     * Shows window with notes of current process
     *
     */
    caseAddNotes: function () {
        this.showNotes(this.case.flow.cas_id, this.case.flow.cas_index);
    },

    caseChangeOwner: function () {
        var value = this.model.attributes;
        value.moduleName = this.case.flow.cas_sugar_module;
        value.beanId = this.case.flow.cas_sugar_object_id;
        showForm(this.case.flow.cas_id, this.case.flow.cas_index, this.case.flowId, this.case.inboxId, this.case.title.activity, value, 'adhoc', this.model);
    },

    caseReassign: function () {
        var value = this.model.attributes;
        value.moduleName = this.case.flow.cas_sugar_module;
        value.beanId = this.case.flow.cas_sugar_object_id;
        showForm(this.case.flow.cas_id, this.case.flow.cas_index, this.case.flowId, this.case.inboxId, this.case.title.activity, value, 'reassign', this.model);
    },

    setEditableFields: function() {
        delete this.editableFields;
        this.editableFields = [];
        var previousField, firstField;
        _.each(this.fields, function(field) {
            if(this.checkReadonly(field)){
                field.def.readonly = true;
            }
            if (field.fields && _.isArray(field.fields)) {
                var that = this;
                var basefield = field;
                _.each(field.fields, function (field) {
                    if (that.checkReadonly(field)) {
                        field.action = "disabled";
                        // Some fields use shouldDisable to enable readonly property,
                        // like 'body' in KBContents
                        if (!_.isUndefined(field.shouldDisable)) {
                            field.setDisabled(true);
                            basefield.def.readonly = true;
                        }
                        return;
                    }
                    // If the field is not readonly, verify if it's required
                    if (that.checkRequired(field)) {
                        field.def.required = true;
                    }
                });
            }
            var readonlyField = field.def.readonly ||
                _.indexOf(this.noEditFields, field.def.name) >= 0 ||
                field.parent || (field.name && this.buttons[field.name]);

            if (readonlyField) {
                // exclude read only fields
                return;
            }
            if(this.checkRequired(field)){
                field.def.required = true;
            }
            if (previousField) {
                previousField.nextField = field;
                field.prevField = previousField;
            } else {
                firstField = field;
            }
            previousField = field;
            this.editableFields.push(field);

        }, this);

        if (previousField) {
            previousField.nextField = firstField;
            firstField.prevField = previousField;
        }

    },

    handleSave: function() {
        this.inlineEditMode = false;

        this._saveModel();
        self.$('.record-save-prompt').hide();
        if (!self.disposed) {
            self.render();
        }
    },
    toggleViewButtons: function(isEdit) {
        this.$('.headerpane span[data-type="badge"]').toggleClass('hide', isEdit);
        this.$('.headerpane span[data-type="favorite"]').toggleClass('hide', isEdit);
        this.$('.headerpane span[data-type="follow"]').toggleClass('hide', isEdit);
        this.$('.headerpane .btn-group-previous-next').toggleClass('hide', isEdit);
    },

    _saveModel: function() {
        var options,
            successCallback = _.bind(function() {
                // Loop through the visible subpanels and have them sync. This is to update any related
                // fields to the record that may have been changed on the server on save.
                _.each(this.context.children, function(child) {
                    if (child.get('isSubpanel') && !child.get('hidden')) {
                        if (child.get('collapsed')) {
                            child.resetLoadFlag({recursive: false});
                        } else {
                            child.reloadData({recursive: false});
                        }
                    }
                });
                if (this.createMode) {
                    app.navigate(this.context, this.model);
                } else if (!this.disposed) {
                    this.render();
                }
            }, this);

        //Call editable to turn off key and mouse events before fields are disposed (SP-1873)
        this.turnOffEvents(this.fields);

        options = {
            showAlerts: true,
            success: successCallback,
            error: _.bind(function(model, error) {
                if (error.status === 412 && !error.request.metadataRetry) {
                    this.handleMetadataSyncError(error);
                } else if (error.status === 409) {
                    app.utils.resolve409Conflict(error, this.model, _.bind(function(model, isDatabaseData) {
                        if (model) {
                            if (isDatabaseData) {
                                successCallback();
                            } else {
                                this._saveModel();
                            }
                        }
                    }, this));
                } else {
                    this.editClicked();
                }
            }, this),
            lastModified: this.model.get('date_modified'),
            viewed: true
        };

        options = _.extend({}, options, this.getCustomSaveOptions(options));

        this.model.save({}, options);
    },


    _buildGridsFromPanelsMetadata: function(panels) {
        var lastTabIndex = 0;
        this.noEditFields = [];

        _.each(panels, function(panel) {
            // it is assumed that a field is an object but it can also be a string
            // while working with the fields, might as well take the opportunity to check the user's ACLs for the field
            _.each(panel.fields, function(field, index) {
                if(this.checkReadonly(field)){
                    field.readonly = true;
                }
                if (_.isString(field)) {
                    panel.fields[index] = field = {name: field};
                }

                var keys = _.keys(field);

                // Make filler fields readonly
                if (keys.length === 1 && keys[0] === 'span')  {
                    field.readonly = true;
                }

                // disable the pencil icon if the user doesn't have ACLs
                if (field.type === 'fieldset') {
                    if (field.readonly || _.every(field.fields, function(field) {
                        return !app.acl.hasAccessToModel('edit', this.model, field.name);
                    }, this)) {
                        this.noEditFields.push(field.name);
                    }
                } else if (field.readonly || !app.acl.hasAccessToModel('edit', this.model, field.name)) {
                    this.noEditFields.push(field.name);
                }
            }, this);

            // Set flag so that show more link can be displayed to show hidden panel.
            if (panel.hide) {
                this.hiddenPanelExists = true;
            }

            // labels: visibility for the label
            if (_.isUndefined(panel.labels)) {
                panel.labels = true;
            }

            if (_.isFunction(this.getGridBuilder)) {
                var options = {
                        fields: panel.fields,
                        columns: panel.columns,
                        labels: panel.labels,
                        labelsOnTop: panel.labelsOnTop,
                        tabIndex: lastTabIndex
                    },
                    gridResults = this.getGridBuilder(options).build();

                panel.grid = gridResults.grid;
                lastTabIndex = gridResults.lastTabIndex;
            }
        }, this);
    },


    getFieldNames: function(module) {

        var fields = app.view.View.prototype.getFieldNames.call(this, module);
        var favorite = _.find(this.meta.panels, function(panel) {
             return _.find(panel.fields, function(field) {
                 return field.type === 'favorite';
             });
        });
        var follow = _.find(this.meta.panels, function(panel) {
             return _.find(panel.fields, function(field) {
                 return field.type === 'follow';
             });
        });
        if (favorite) {
            fields = _.union(fields, ['my_favorite']);
        }
        if (follow) {
            fields = _.union(fields, ['following']);
        }
        return fields;
    },


    checkReadonly: function(field){
        var isReadonly = false;
        _.each(this.case.readonly, function(caseField){
            if(field.name=== caseField){
                isReadonly = true;
            }
        }, this);
        return isReadonly;
    },

    checkRequired: function(field){
        var isRequired = false;
        _.each(this.case.required, function(caseField){
            if(field.name=== caseField){
                isRequired = true;
            }
        }, this);
        return isRequired;
    },

    /**
     * @override
     */
    bindDataChange: function() {
        this.model.on('change', function() {
            if (this.model.isNotEmpty !== true) {
                this.model.isNotEmpty = true;
                if (!this.disposed) {
                    this.render();
                }
            }
        }, this);
    }

}) },
"finish-impersonation": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Views.Base.FinishImpersonation
 * @alias SUGAR.App.view.views.FinishImpersonation
 * @extends View.View
 */
({
	// Finish-impersonation View (base) 


    cache: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.cache = app[app.config.authStore || 'cache'];
        this._super('initialize', [options]);
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        this.finishImpersonation();
    },

    /**
     * Finishing impersonation sesssion.
     */
    finishImpersonation: function() {
        let self = this;
        app.bwc.logout(
            function(data) {
                self.cache.cut('ImpersonationFor');

                self.cache.set('AuthAccessToken', self.cache.get('OriginAuthAccessToken'));
                self.cache.set('AuthRefreshToken', self.cache.get('OriginAuthRefreshToken'));

                self.cache.cut('OriginAuthAccessToken');
                self.cache.cut('OriginAuthRefreshToken');

                // Have to login to BWC after admin token has been switched back
                app.bwc.login(null, function() {
                    if (window.opener) {
                        window.close();
                    } else {
                        window.location.replace(self.getComeBackUrl());
                    }
                });
            }
        );
    },

    /**
     * Generate come back url.
     * @return {string}
     */
    getComeBackUrl: function() {
        return this.meta.comeBackUrl +
            '&user_hint=' +
            encodeURIComponent(app.utils.createUserSrn(app.cache.get('ImpersonationFor')));
    }

}) },
"mass-link": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MassLinkView
 * @alias SUGAR.App.view.views.BaseMassLinkView
 * @extends View.Views.Base.MassupdateView
 */
({
	// Mass-link View (base) 

    extendsFrom: 'MassupdateView',
    massUpdateViewName: 'masslink-progress',
    _defaultLinkSettings: {
        mass_link_chunk_size: 20
    },

    initialize: function(options) {
        this._super('initialize', [options]);

        var configSettings = (app.config.massActions && app.config.massActions.massLinkChunkSize) ?
                {mass_link_chunk_size: app.config.massActions.massLinkChunkSize} :
                {};

        this._settings = _.extend(
            {},
            this._defaultLinkSettings,
            configSettings,
            this.meta && this.meta.settings || {}
        );
    },

    /**
     * Overrides parent. Sets mass link related events
     */
    delegateListFireEvents: function() {
        this.layout.on('list:masslink:fire', _.bind(this.beginMassLink, this));
    },

    /**
     * Link multiple records in chunks
     */
    beginMassLink: function(options) {
        var parentModel = this.context.get('recParentModel'),
            link = this.context.get('recLink'),
            massLink = this.getMassUpdateModel(this.module),
            progressView = this.getProgressView();

        massLink.setChunkSize(this._settings.mass_link_chunk_size);

        //Extend existing model with a link function
        massLink = _.extend({}, massLink, {
            maxLinkAllowAttempt: options && options.maxLinkAllowAttempt || this.maxAllowAttempt,
            link: function(options) {
                //Slice a new chunk of models from the mass collection
                this.updateChunk();
                var model = this,
                    apiMethod = 'create',
                    linkCmd = 'link',
                    parentData = {
                        id: parentModel.id
                    },
                    url = app.api.buildURL(parentModel.module, linkCmd, parentData),
                    linkData = {
                        link_name: link,
                        ids: _.pluck(this.chunks, 'id')
                    },
                    callbacks = {
                        success: function(data, response) {
                            model.attempt = 0;
                            model.updateProgress();
                            if (model.length === 0) {
                                model.trigger('massupdate:end');
                                if (_.isFunction(options.success)) {
                                    options.success(model, data, response);
                                }
                            } else {
                                model.trigger('massupdate:always');
                                model.link(options);
                            }
                        },
                        error: function() {
                            model.attempt++;
                            model.trigger('massupdate:fail');
                            if (model.attempt <= this.maxLinkAllowAttempt) {
                                model.link(options);
                            } else {
                                app.alert.show('error_while_mass_link', {
                                    level: 'error',
                                    title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                                    messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                                });
                            }
                        }
                    };
                app.api.call(apiMethod, url, linkData, callbacks);
            }
        });

        progressView.initCollection(massLink);
        massLink.link({
            success: _.bind(function(model, data, response) {
                this.layout.trigger('list:masslink:complete', model, data, response);
            }, this)
        });
    }
}) },
"config-panel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ConfigPanelView
 * @alias SUGAR.App.view.views.BaseConfigPanelView
 * @extends View.View
 */
({
	// Config-panel View (base) 

    /**
     * Holds the changing date value for the title
     */
    titleSelectedValues: '',

    /**
     * Holds the view's title name
     */
    titleViewNameTitle: '',

    /**
     * Holds the collapsible toggle title template
     */
    toggleTitleTpl: {},

    /**
     * Holds the vars for the title template
     * <pre><code>
     * {
     *  title: this.titleViewNameTitle,
     *  selectedValues: this.titleSelectedValues,
     *  viewName: this.name
     * }
     * <pre><code>
     */
    titleTemplateVars: {},

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.toggleTitleTpl = app.template.getView('config-panel.title');

        if (this.meta.label) {
            this.titleViewNameTitle = app.lang.get(this.meta.label, this.module);
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        this.on('config:panel:hide', this.onConfigPanelHide, this);
        this.on('config:panel:show', this.onConfigPanelShow, this);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        // add accordion-group class to wrapper $el div
        this.$el.addClass(this.name + '-group accordion-group');

        // update the title every render
        this.updateTitle();
    },

    /**
     * Updates the accordion toggle title
     */
    updateTitle: function() {
        // update the title values
        this._updateTitleValues();
        // update the title template vars
        this._updateTitleTemplateVars();

        // then inject them into the template
        this.$('#' + this.name + 'Title').html(this.toggleTitleTpl(this.titleTemplateVars));
    },

    /**
     * Updates `this.titleSelectedValues` before updating title so child classes
     * can set up how the title should be displayed
     * @private
     */
    _updateTitleValues: function() {
        this.titleSelectedValues = this.model.get(this.name);
    },

    /**
     * Updates `this.titleTemplateVars` before updating title so child classes
     * can set up how the title should be displayed
     * @private
     */
    _updateTitleTemplateVars: function() {
        this.titleTemplateVars = {
            title: this.titleViewNameTitle,
            selectedValues: this.titleSelectedValues,
            viewName: this.name
        };
    },

    /**
     * Handles when the config panel is hidden
     */
    onConfigPanelHide: function() {
    },

    /**
     * Handles when the config panel is shown
     */
    onConfigPanelShow: function() {
    }
}) },
"subpanel-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Custom RecordlistView used within Subpanel layouts.
 *
 * @class View.Views.Base.SubpanelListView
 * @alias SUGAR.App.view.views.BaseSubpanelListView
 * @extends View.Views.Base.RecordlistView
 */
({
	// Subpanel-list View (base) 

    extendsFrom: 'RecordlistView',
    fallbackFieldTemplate: 'list',
    plugins: [
        'SugarLogic',
        'ResizableColumns',
        'ReorderableColumns',
        'ListColumnEllipsis',
        'ErrorDecoration',
        'Editable',
        'Pagination',
        'MassCollection',
        'ActionButton',
        'DocumentMerge',
    ],

    contextEvents: {
        "list:editall:fire": "toggleEdit",
        "list:editrow:fire": "editClicked",
        "list:unlinkrow:fire": "warnUnlink"
    },

    /**
     * @override
     * @param {Object} options
     */
    initialize: function(options) {
        // `dataView` corresponds to the list of fields the API should retrieve.
        // Inherit from the layout unless not defined.
        this.dataView = (options.layout && options.layout.dataView) || options.name || 'subpanel-list';

        this._super("initialize", [options]);

        // Setup max limit on collection's fetch options for this subpanel's context
        var limit = this.context.get('limit') || app.config.maxSubpanelResult;

        if (limit) {
            this.context.set('limit', limit);
            //supanel-list extends indirectly ListView, and `limit` determines # records displayed
            this.limit = limit;
        }

        //Override the recordlist row template
        this.rowTemplate = app.template.getView('recordlist.row');

        //event register for preventing actions
        //when user escapes the page without confirming deletion
        app.routing.before("route", this.beforeRouteUnlink, this);
        $(window).on("beforeunload.unlink" + this.cid, _.bind(this.warnUnlinkOnRefresh, this));

        this._thisListViewFieldSizesKey = this._buildWidthKey();
    },

    /**
     * When parent recordlist's initialize is invoked (above), this will get called
     * and populate our the list's meta with the proper view subpanel metadata.
     *
     * @private
     * @param {Object} options
     * @return {Object} The view metadata for this module's subpanel.
     */
    _initializeMetadata: function(options) {
        return  _.extend({},
            app.metadata.getView(null, 'subpanel-list'),
            app.metadata.getView(options.module, 'record-list'),
            app.metadata.getView(options.module, 'subpanel-list')
        );
    },

    /**
     * Unlink (removes) the selected model from the list view's collection
     */
    unlinkModel: function() {
        var self = this,
            model = this._modelToUnlink;

        model.destroy({
            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': {
                    messages: self.getUnlinkMessages(self._modelToUnlink).success
                }
            },
            relate: true,
            success: function() {
                var redirect = self._targetUrl !== self._currentUrl;
                self._modelToUnlink = null;
                var options = {
                    previousModels: _.clone(self.collection.models),
                    context: self.context
                };
                self.collection.remove(model, { silent: redirect });

                if (redirect) {
                    self.unbindBeforeRouteUnlink();
                    //Replace the url hash back to the current staying page
                    app.router.navigate(self._targetUrl, {trigger: true});
                    return;
                }

                // We trigger reset after removing the model so that
                // panel-top will re-render and update the count.
                self.collection.offset--;
                self.collection.trigger('reset', self.collection, options);
                self.render();
            }
        });
    },

    /**
     * Pre-event handler before current router is changed
     *
     * @return {Boolean} true to continue routing, false otherwise
     */
    beforeRouteUnlink: function () {
        if (this._modelToUnlink) {
            this.warnUnlink(this._modelToUnlink);
            return false;
        }
        return true;
    },

    /**
     * Formats the messages to display in the alerts when unlinking a record.
     *
     * @param {Data.Bean} model The model concerned.
     * @return {Object} The list of messages.
     * @return {string} return.confirmation Confirmation message.
     * @return {string} return.success Success message.
     */
    getUnlinkMessages: function(model) {
        var messages = {};
        var context = this.getMessageContext(model);

        messages.confirmation = app.utils.formatString(app.lang.get('NTC_UNLINK_CONFIRMATION_FORMATTED'), [context]);
        messages.success = app.utils.formatString(app.lang.get('NTC_UNLINK_SUCCESS'), [context]);
        return messages;
    },

    /**
     * Get part of the message related to the Record Name
     *
     * @override
     * @param {Data.Bean} model The model concerned.
     * @return {string}
     */
    getMessageContext: function(model) {
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        return app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;
    },

    /**
     * Popup dialog message to confirm unlink action
     *
     * @param {Backbone.Model} model the bean to unlink
     */
    warnUnlink: function(model) {
        var self = this;
        this._modelToUnlink = model;

        self._targetUrl = Backbone.history.getFragment();
        //Replace the url hash back to the current staying page
        if (self._targetUrl !== self._currentUrl) {
            app.router.navigate(this._currentUrl, {trigger: false, replace: true});
        }

        this.showUnlinkMessage(model);
    },

    /**
     * Show the alert in the time of unlinking a record.
     *
     * @param {Data.Bean} model The model concerned.
     */
    showUnlinkMessage: function(model) {
        var self = this;

        app.alert.show('unlink_confirmation', {
            level: 'confirmation',
            messages: self.getUnlinkMessages(model).confirmation,
            onConfirm: _.bind(self.unlinkModel, self),
            onCancel: function() {
                self._modelToUnlink = null;
            }
        });
    },

    /**
     * Popup browser dialog message to confirm unlink action
     *
     * @return {String} the message to be displayed in the browser alert
     */
    warnUnlinkOnRefresh: function() {
        if (this._modelToUnlink) {
            return this.getUnlinkMessages(this._modelToUnlink).confirmation;
        }
    },

    /**
     * Detach the event handlers for warning unlink
     */
    unbindBeforeRouteUnlink: function() {
        app.routing.offBefore("route", this.beforeRouteUnlink, this);
        $(window).off("beforeunload.unlink" + this.cid);
    },

    /**
     * @override
     * @private
     */
    _dispose: function() {
        this.unbindBeforeRouteUnlink();
        this._super('_dispose');
    },

    /**
     * Uniquely ID subpanel column widths by parent module to allow different
     * widths for subpanels placed on different parent module record view
     * @return {string} Unique key for this subpanel/parent module combination
     * @private
     */
    _buildWidthKey: function() {
        return app.user.lastState.buildKey(this._thisListViewFieldSizesKey, this.context.get('parentModule'));
    },
}) },
"dashletselect-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletselectHeaderpaneView
 * @alias SUGAR.App.view.views.BaseDashletselectHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Dashletselect-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        "click a[name=cancel_button]": "close"
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //shortcut keys
        app.shortcuts.register({
            id: 'Dashlet:Select:Cancel',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $cancelButton = this.$('a[name=cancel_button]');
                if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                    $cancelButton.click();
                }
            }
        });
    },

    /**
     * Closes the drawer.
     */
    close: function() {
        app.drawer.close();
    }
}) },
"hint-preview-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HintPreviewHeaderView
 * @alias SUGAR.App.view.views.BaseHintPreviewHeaderView
 * @extends View.Views.Base.PreviewHeaderView
 */
({
	// Hint-preview-header View (base) 

    extendsFrom: 'PreviewHeaderView'
}) },
"find-duplicates-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.FindDuplicatesHeaderpaneView
 * @alias SUGAR.App.view.views.BaseFindDuplicatesHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Find-duplicates-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click a[name=cancel_button]': 'cancel',
        'click a[name=merge_duplicates_button]:not(".disabled")': 'mergeDuplicatesClicked'
    },

    plugins: ['MergeDuplicates'],

    /**
     * Wait for the mass_collection to be set up so we can add listener
     */
    bindDataChange: function() {
        this._super("bindDataChange");
        this.on('mergeduplicates:complete', this.mergeComplete, this);
        this.context.on('change:mass_collection', this.addMassCollectionListener, this);
    },

    /**
     * @inheritdoc
     * Dispose safe for mass_collection
     */
    unbindData: function() {
        var massCollection = this.context.get('mass_collection');

        if (massCollection) {
            massCollection.off(null, null, this);
        }
        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * Set up `add`, `remove` and `reset` listeners on the `mass_collection` so
     * we can enable/disable the merge button whenever the collection changes.
     */
    addMassCollectionListener: function() {
        var massCollection = this.context.get('mass_collection');
        massCollection.on('add remove reset', this.toggleMergeButton, this);
    },

    /**
     * Enable the merge button when a duplicate has been checked
     * Disable when all are unchecked
     */
    toggleMergeButton: function() {
        var disabled;
        if (this.context.get('mass_collection').length > 0) {
            disabled = false;
        } else {
            disabled = true;
        }
        this.$("[name='merge_duplicates_button']").toggleClass('disabled', disabled);
    },

    /**
     * Cancel and close the drawer
     */
    cancel: function() {
        app.drawer.close();
    },

    /**
     * Close the current drawer window by passing merged primary record
     * once merge process is complete.
     *
     * @param {Backbone.Model} primaryRecord Primary Record.
     */
    mergeComplete: function(primaryRecord) {
        app.drawer.closeImmediately(true, primaryRecord);
    },

    /**
     * Merge records handler.
     */
    mergeDuplicatesClicked: function() {
        this.mergeDuplicates(this.context.get('mass_collection'), this.collection.dupeCheckModel);
    }
}) },
"marketing-extras": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MarketingExtrasView
 * @alias SUGAR.App.view.views.BaseMarketingExtrasView
 * @extends View.View
 */
({
	// Marketing-extras View (base) 

    /**
     * The URL for marketing content
     */
    marketingContentUrl: '',

    /**
     * Have we forced a static fetch?
     */
    staticFetched: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.fetchMarketingContentUrl();

        app.events.on('app:locale:change', function() {
            app.router.refresh();
        }, this);
    },

    /**
     * Fetch the marketing content URL
     *
     * @param {boolean} forceStatic - flag to force retrieving static content URL
     */
    fetchMarketingContentUrl: function(forceStatic) {
        forceStatic = forceStatic || false;
        if (forceStatic) {
            this.staticFetched = true;
        }
        var language = app.user.getLanguage();
        var url = app.api.buildURL('login/marketingContentUrl', null, null, {
            selected_language: language,
            static: forceStatic
        });
        app.api.call('read', url, null, {
            success: _.bind(function(response) {
                this.marketingContentUrl = response;
                this.render();
            }, this),
        });
    },

    _render: function() {
        this._super('_render');
        try {
            this.$el.find('iframe').attr('src', this.marketingContentUrl);
        } catch (e) {
            app.logger.warn(e);
            if (!this.staticFetched) {
                this.fetchMarketingContentUrl(true);
            }
        }
    }
}) },
"dupecheck-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckListView
 * @alias SUGAR.App.view.views.BaseDupecheckListMenuView
 * @extends View.Views.Base.FlexListView
 */
({
	// Dupecheck-list View (base) 

    extendsFrom: 'FlexListView',
    plugins: ['ListColumnEllipsis', 'ListDisableSort', 'ListRemoveLinks', 'Pagination'],
    collectionSync: null,
    additionalTableClasses: null,

    /**
     * @inheritdoc
     *
     * The metadata used is the default `dupecheck-list` metadata, extended by
     * the module specific `dupecheck-list` metadata, extended by subviews
     * metadata.
     */
    initialize: function(options) {
        var dupeListMeta = app.metadata.getView(null, 'dupecheck-list') || {},
            moduleMeta = app.metadata.getView(options.module, 'dupecheck-list') || {};

        options.meta = _.extend({}, dupeListMeta, moduleMeta, options.meta || {});

        this._super('initialize', [options]);
        this.context.on('dupecheck:fetch:fire', this.fetchDuplicates, this);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.collection.on('reset', function() {
            this.context.trigger('dupecheck:collection:reset');
        }, this);
        this._super('bindDataChange');
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        var classesToAdd = 'duplicates highlight';
        this._super('_renderHtml');
        if (this.additionalTableClasses) {
            classesToAdd = classesToAdd + ' ' + this.additionalTableClasses;
        }
        this.$('table.table-striped').addClass(classesToAdd);
    },

    /**
     * Fetch the duplicate collection.
     *
     * @param {Backbone.Model} model Duplicate check model.
     * @param {Object} options Fetch options.
     */
    fetchDuplicates: function(model, options) {
        this.collection.dupeCheckModel = model;
        this.collection.fetch(options);
    }
}) },
"vcard-import-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.VcardImportHeaderpaneView
 * @alias SUGAR.App.view.views.BaseVcardImportHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Vcard-import-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click [name=vcard_cancel_button]': 'initiateCancel'
    },

    /**
     * Add listener for toggling the disabled state of the finish button
     *
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.context.on('vcard:import-finish-button:toggle', this._toggleFinishButton, this);
    },

    /**
     * Toggle the state of the finish button (enabled/disabled)
     *
     * @param {boolean} enabled Whether the button should be enabled
     * @private
     */
    _toggleFinishButton: function(enabled) {
        this.getField('vcard_finish_button').setDisabled(!enabled);
    },

    /**
     * Handle cancel action - closing the drawer
     */
    initiateCancel: function() {
        app.drawer.close();
    }
}) },
"rssfeed": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * RSS Feed dashlet consumes an RSS Feed URL and displays it's content as a list
 * of entries.
 * 
 * The following items are configurable.
 *
 * - {number} limit Limit imposed to the number of records pulled.
 * - {number} refresh How often (minutes) should refresh the data collection.
 *
 * @class View.Views.Base.RssfeedView
 * @alias SUGAR.App.view.views.BaseRssfeedView
 * @extends View.View
 */
({
	// Rssfeed View (base) 

    plugins: ['Dashlet'],

    /**
     * Default options used when none are supplied through metadata.
     *
     * Supported options:
     * - timer: How often (minutes) should refresh the data collection.
     * - limit: Limit imposed to the number of records pulled.
     *
     * @property {Object}
     * @protected
     */
    _defaultOptions: {
        limit: 5,
        auto_refresh: 0
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        this._super('initialize', [options]);
        this.loadData(options.meta);
    },

    /**
     * Init dashlet settings
     */
    initDashlet: function() {
        // We only need to handle this if we are NOT in the configure screen
        if (!this.meta.config) {
            var options = {};
            var self = this;
            var refreshRate;

            // Get and set values for limits and refresh
            options.limit = this.settings.get('limit') || this._defaultOptions.limit;
            this.settings.set('limit', options.limit);

            options.auto_refresh = this.settings.get('auto_refresh') || this._defaultOptions.auto_refresh;
            this.settings.set('auto_refresh', options.auto_refresh);

            // There is no default for this so there's no pointing in setting from it
            options.feed_url = this.settings.get('feed_url');

            // Set the refresh rate for setInterval so it can be checked ahead
            // of time. 60000 is 1000 miliseconds times 60 seconds in a minute.
            refreshRate = options.auto_refresh * 60000;

            // Only set up the interval handler if there is a refreshRate higher
            // than 0
            if (refreshRate > 0) {
                if (this.timerId) {
                    clearInterval(this.timerId);
                }
                this.timerId = setInterval(_.bind(function() {
                    if (self.context) {
                        self.context.resetLoadFlag();
                        self.loadData(options);
                    }
                }, this), refreshRate);
            }
        }

        // Validation handling for individual fields on the config
        this.layout.before('dashletconfig:save', function() {
            // Fields on the metadata
            var fields = _.flatten(_.pluck(this.meta.panels, 'fields'));

            // Grab all non-valid fields from the model
            var notValid = _.filter(fields, function(field) {
                return field.required && !this.dashModel.get(field.name);
            }, this);

            // If there no invalid fields we are good to go
            if (notValid.length === 0) {
                return true;
            }

            // Otherwise handle notification of invalidation
            _.each(notValid, function(field) {
                 var fieldOnView = _.find(this.fields, function(comp, cid) { 
                    return comp.name === field.name;
                 });

                 fieldOnView.model.trigger('error:validation:' + field.name, {required: true});
            }, this);

            // False return tells the drawer that it shouldn't close
            return false;
        }, this);
    },

    /**
     * Handles the response of the feed consumption request and sets data from 
     * the result
     * 
     * @param {Object} data Response from the rssfeed API call
     */
    handleFeed: function (data) {
        if (this.disposed) {
            return;
        }

        // Load up the template
        _.extend(this, data);
        this.render();
    },

    /**
     * Loads an RSS feed from the RSS Feed endpoint.
     * 
     * @param {Object} options The metadata that drives this request
     */
    loadData: function(options) {
        if (options && options.feed_url) {
            var callbacks = {success: _.bind(this.handleFeed, this), error: _.bind(this.handleFeed, this)},
                limit = options.limit || this._defaultOptions.limit,
                params = {feed_url: options.feed_url, limit: limit},
                apiUrl = app.api.buildURL('rssfeed', 'read', '', params);

            app.api.call('read', apiUrl, {}, callbacks);
        }
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model:
     *
     * - {Boolean} overdue True if record is prior to now.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        if (typeof this.feed !== 'undefined') {
            whiteList = app.config.allowedLinkSchemes;
            if (!_.isEmpty(this.feed.link)) {
                this.feed.isClickable = false;
                for (let i = 0; i < whiteList.length; i++) {
                    if (this.feed.link.substring(0, whiteList[i].length + 1) === whiteList[i] + ':') {
                        this.feed.isClickable = true;
                        break;
                    }
                }
            }
            this.feed.entries.forEach(function(el) {
                el.isClickable = false;
                for (let i = 0; i < whiteList.length; i++) {
                    if (el.link.substring(0, whiteList[i].length + 1) === whiteList[i] + ':') {
                        el.isClickable = true;
                        break;
                    }
                }
            });
        }
        this._super('_renderHtml');
    }
}) },
"filter-quicksearch": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for doing a quick search.
 *
 * Part of {@link View.Layouts.Base.FilterLayout}.
 *
 * @class View.Views.Base.FilterQuicksearchView
 * @alias SUGAR.App.view.views.BaseFilterQuicksearchView
 * @extends View.View
 */
({
	// Filter-quicksearch View (base) 

    events: {
        'keyup': 'throttledSearch',
        'paste': 'throttledSearch'
    },

    className: 'table-cell full-width',

    /**
     * @override
     * @param {Object} opts
     */
    initialize: function(opts) {
        app.view.View.prototype.initialize.call(this, opts);
        this.listenTo(this.layout, 'filter:clear:quicksearch', this.clearInput);
        this.listenTo(this.layout, 'filter:change:module', this.updatePlaceholder);

        /**
         * The previous search string. This is used to prevent searches from
         * being triggered on keyup if the search string is not changed.
         *
         * @type {string}
         */
        this.currentSearch = '';

        //shortcut keys
        app.shortcuts.register({
            id: 'Filter:Search',
            keys: ['f i','mod+alt+9'],
            component: this,
            description: 'LBL_SHORTCUT_FILTER_SEARCH',
            handler: function() {
                if (this.$el.is(':visible')) {
                    this.$el.focus();
                }
            }
        });
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.context.on('filter:clear', this.clearFilter, this);
        this._super('bindDataChange');
    },

    /**
     * Clears out the filter search text for the layout
     */
    clearFilter: function() {
        this.currentSearch = '';
        this.toggleInput();
        this.$el.val('');
    },

    /**
     * @inheritdoc
     *
     * Changes `this.$el` to point to the `<input>` element.
     */
    _renderHtml: function() {
        this._super('_renderHtml');
        this.setElement(this.$('input'));
    },

    /**
     * For customers with large datasets, allow customization to disable
     * the automatic filtering in the omnibar.
     *
     * @inheritdoc
     */
    delegateEvents: function(events) {
        if (app.config.disableOmnibarTypeahead) {
            // Remove the keyup and paste events from this.events.
            // This is before the call to this._super('delegateEvents'),
            // so they have not been registered.
            delete this.events.keyup;
            delete this.events.paste;

            // On enter key press, apply the quicksearch.
            this.events.keydown = _.bind(function(evt) {
                // Enter key code is 13
                if (evt.keyCode === 13) {
                    this.applyQuickSearch();
                }
            }, this);
        }
        this._super('delegateEvents', [events]);
    },

    /**
     * Fires the quick search.
     * @param {Event} [event] A keyup event.
     */
    throttledSearch: _.debounce(function(event) {
        this.applyQuickSearch();
    }, 400),

    /**
     * Update quick search placeholder to Search by Field1, Field2, Field3 when the module changes
     * @param string linkModuleName
     * @param string linkModule
     */
    updatePlaceholder: function(linkModuleName, linkModule) {
        var label;
        this.toggleInput();
        if (!this.$el.hasClass('hide') && linkModule !== 'all_modules') {
            var filtersBeanPrototype = app.data.getBeanClass('Filters').prototype,
                fields = filtersBeanPrototype.getModuleQuickSearchMeta(linkModuleName).fieldNames,
                fieldLabels = app.utils.getFieldLabels(linkModuleName, fields);
            label = app.lang.get('LBL_SEARCH_BY') + ' ' + fieldLabels.join(', ').toLowerCase() + '...';
        } else {
            label = app.lang.get('LBL_BASIC_QUICK_SEARCH');
        }
        var input = this.$el.attr('placeholder', label);
        this.$el.attr('aria-label', label);
    },

    /**
     * Hide input if on Activities
     */
    toggleInput: function() {
        this.$el.toggleClass('hide', !!this.layout.showingActivities);
    },

    /**
     * Clear input
     */
    clearInput: function() {
        this.toggleInput();
        var input = this.$el.val('');
        this.applyQuickSearch(true);
    },

    /**
     * Invokes the `filter:apply` event with the current value on the
     * quicksearch field.
     *
     * @param {boolean} [force] `true` to always trigger the `filter:apply`
     *   event, `false` otherwise. Defaults to `false`.
     */
    applyQuickSearch: function(force) {
        force = !_.isUndefined(force) ? force : false;
        var newSearch = this.$el.val();
        if (force || this.currentSearch !== newSearch) {
            this.currentSearch = newSearch;
            this.layout.trigger('filter:apply', newSearch);
        }
    }
}) },
"maps-widget-top": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Maps widget Top view
 *
 * @class View.Views.Base.MapsWidgetTopView
 * @alias SUGAR.App.view.views.BaseMapsWidgetTopView
 * @extends View.Views.Base.PanelTopView
 */
 ({
	// Maps-widget-top View (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'PanelTopView',
}) },
"opportunity-metrics": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.OpportunityMetricsView
 * @alias SUGAR.App.view.views.BaseOpportunityMetricsView
 * @extends View.View
 */
({
	// Opportunity-metrics View (base) 

    plugins: ['Dashlet', 'Chart'],
    className: 'opportunity-metrics-wrapper',

    metricsCollection: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.tooltipTemplate = app.template.getField('chart', 'singletooltiptemplate', this.module);
        this.locale = SUGAR.charts.getSystemLocale();

        this.chart = sucrose.charts.pieChart()
                .margin({top: 0, right: 0, bottom: 5, left: 0})
                .donut(true)
                .donutLabelsOutside(true)
                .donutRatio(0.447)
                .rotateDegrees(0)
                .arcDegrees(360)
                .maxRadius(110)
                .hole(this.total)
                .showTitle(false)
                .tooltips(true)
                .showLegend(false)
                .colorData('data')
                .direction(app.lang.direction)
                .tooltipContent(_.bind(function(eo, properties) {
                    var point = {};
                    point.key = this.chart.getKey()(eo);
                    point.label = app.lang.get('LBL_CHART_COUNT');
                    point.value = this.chart.getValue()(eo);
                    point.percent = sucrose.utility.numberFormatPercent(point.value, properties.total, this.locality);
                    return this.tooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
                }, this))
                .fmtValue(_.bind(function(d) {
                    return this._valueFormat(d);
                }, this))
                .fmtKey(_.bind(function(d) {
                    return this._labelFormat(d);
                }, this))
                .strings({
                    noData: app.lang.get('LBL_CHART_NO_DATA'),
                    noLabel: app.lang.get('LBL_CHART_NO_LABEL')
                })
                .locality(this.locale);

        this.locality = this.chart.locality();
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }

        // Set value of label inside donut chart
        this.chart.hole(this.total);

        d3sugar.select(this.el).select('svg#' + this.cid)
            .datum(this.chartCollection)
            .transition().duration(500)
            .call(this.chart);

        this.chart_loaded = _.isFunction(this.chart.update);
        this.displayNoData(!this.chart_loaded);
    },

    /* Process data loaded from REST endpoint so that d3 chart can consume
     * and set general chart properties
     */
    evaluateResult: function(data) {
        var total = 0,
            userConversionRate = 1 / app.metadata.getCurrency(app.user.getPreference('currency_id')).conversion_rate,
            userCurrencyPreference = app.user.getPreference('currency_id'),
            stageLabels = app.lang.getAppListStrings('opportunity_metrics_dom'),
            convertedAmount;

        _.each(data, function(value, key) {
            convertedAmount = app.currency.convertWithRate(value.amount_usdollar, userConversionRate);
            // parse currencies, format to user preference and attach the correct delimiters/symbols etc
            data[key].formattedAmount = app.currency.formatAmountLocale(convertedAmount, userCurrencyPreference, 0);
            data[key].icon = key === 'won' ? 'caret-up' : (key === 'lost' ? 'caret-down' : 'minus');
            data[key].cssClass = key === 'won' ? 'won' : (key === 'lost' ? 'lost' : 'active');
            data[key].dealLabel = key;
            data[key].stageLabel = stageLabels[key] || key;
            total += value.count;
        });

        this.total = total;
        this.metricsCollection = data;

        this.chartCollection = {
            data: _.map(this.metricsCollection, function(value, key) {
                return {
                    key: value.stageLabel,
                    value: value.count,
                    classes: key
                };
            }),
            properties: {
                title: app.lang.get('LBL_DASHLET_OPPORTUNITY_NAME'),
                value: 3,
                label: total,
                yDataType: 'numeric',
                xDataType: 'string'
            }
        };
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var self = this,
            url;
        if (this.meta.config) {
            return;
        }
        url = app.api.buildURL(this.model.module, 'opportunity_stats', {
            id: this.model.get('id')
        });
        app.api.call('read', url, null, {
            success: function(data) {
                self.evaluateResult(data);
                if (!self.disposed) {
                    // we have to rerender the entire dashlet, not just the chart,
                    // because the HBS file is dependant on metricsCollection
                    self.render();
                }
            },
            error: _.bind(function() {
                this.displayNoData(true);
            }, this),
            complete: options ? options.complete : null
        });
    },

    /**
     * This method is called by the chart model in initialize
     *
     * @param {number} d  The numeric value to be formatted
     * @return {string}  A number formatted with SI units if needed
     * @private
     */
    _valueFormat: function(d) {
        var val = d.series ? this.chart.getValue()(d.series) : d;
        return sucrose.utility.numberFormatSI(val, 2, false);
    },

    /**
     * This method is called by the chart model in initialize
     *
     * @param {Object|string} d  The data to extract the label from
     * @return {string}  A label formatted as needed
     * @private
     */
    _labelFormat: function(d) {
        var val = d.series ? this.chart.getKey()(d.series) : d;
        return val;
    }
}) },
"flex-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.FlexListView
 * @alias SUGAR.App.view.views.BaseFlexListView
 * @extends View.Views.Base.ListView
 */
({
	// Flex-list View (base) 

    extendsFrom: 'ListView',
    className: 'flex-list-view',
    // Model being previewed (if any)
    _previewed: null,

    /**
     * Property to determine if the user is on Safari so we can appropriately handle action dropdowns.
     * See SS-1078 (https://sugarcrm.atlassian.net/browse/SS-1078).
     *
     * @property
     */
    _isSafariBrowser: null,

    /**
     * Array of view types where frozen columns feature should not be applied
     */
    blockFrozenColumnList: [
        'compose-varbook-list',
        'history-summary'
    ],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //Store left column fields
        this.leftColumns = [];
        //Store right column fields
        this.rightColumns = [];
        this.addActions();

        this.template = app.template.getView('flex-list');
        this.events = _.clone(this.events);

        /**
         * The last state key that contains the full list of fields displayable
         * in list views of this module.
         *
         * @property {string}
         * @protected
         */
        this._allListViewsFieldListKey = app.user.lastState.buildKey('field-list', 'list-views', this.module);

        /**
         * The last state key that contains the visible state of the fields and
         * their position in the table for this specific view.
         *
         * @property {string}
         * @protected
         */
        this._thisListViewFieldListKey = app.user.lastState.key('visible-fields', this);

        if (this.meta.sticky_resizable_columns) {
            /**
             * The last state key that contains the user defined column widths
             * for this specific view.
             *
             * @property {string}
             * @protected
             */
            this._thisListViewFieldSizesKey = app.user.lastState.key('width-fields', this);
        }

        this._fields = this.parseFields();

        this.addPreviewEvents();

        //add debounce in initialize so that subclasses will not all use the same prototype function
        this.resize = _.bind(_.debounce(this.resize, 200), this);
        this.bindResize();

        this._isSafariBrowser = app.userAgent.browserEngine === 'webkit';

        var rightColumnsEvents = {};
        //add an event delegate for right action dropdown buttons onclick events
        if (this.rightColumns.length) {
            rightColumnsEvents = {
                'hidden.bs.dropdown .actions': 'resetDropdownDelegate',
                'shown.bs.dropdown .actions': 'delegateDropdown',
                'shown.bs.dropdown .morecol': '_toggleAria',
                'hidden.bs.dropdown .morecol': '_toggleAria'
            };
        }

        this.events = _.extend(rightColumnsEvents, this.events, {
            'click [data-widths=reset]': 'resetColumnWidths',
            'click [data-columns-order=reset]': 'resetColumnOrder',
            'click [data-action=freeze-first-column]': 'freezeFirstColumn'
        });

        this.allowFreezeFirstColumn = !_.isUndefined(app.config.allowFreezeFirstColumn) ?
            app.config.allowFreezeFirstColumn : true;
        if (this.allowFreezeFirstColumn && !this.blockFrozenColumnList.includes(this.type)) {
            // The last state key that contains the user configs
            // for this specific view.
            this._thisListViewUserConfigsKey = app.user.lastState.key('user-configs', this);
            let userConfigs = app.user.lastState.get(this._thisListViewUserConfigsKey) || {};
            this.isFirstColumnFreezed = _.isUndefined(userConfigs.freezeFirstColumn) || userConfigs.freezeFirstColumn;
        } else {
            this.isFirstColumnFreezed = false;
        }
        this.hasFirstColumnBorder = false;

        this.on('list:reorder:columns', this.reorderCatalog, this);
        this.on('list:toggle:column', this.saveCurrentState, this);
        this.on('list:save:laststate', this.saveCurrentState, this);
        this.on('list:column:resize:save', this.saveCurrentWidths, this);
        this.on('list:scrollLock', this.scrollLock, this);
    },

    /**
     * Freeze/unfreeze first column.
     * @param {Object} event jquery event object
     */
    freezeFirstColumn: function(event) {
        event.stopPropagation();
        let freeze = $(event.currentTarget).is(':checked');
        this.isFirstColumnFreezed = freeze;
        app.user.lastState.set(this._thisListViewUserConfigsKey, {freezeFirstColumn: freeze});
        let firstColumnIndex = this.leftColumns.length + 1;
        let $firstColumns = this.$('table tbody tr td:nth-child(' + firstColumnIndex +
            '), table thead tr th:nth-child(' + firstColumnIndex + ')');
        if (freeze) {
            $firstColumns.addClass('sticky-column stick-first' +
            (this.leftColumns.length ? '' : ' no-left-column'));
        } else {
            $firstColumns.removeClass('sticky-column stick-first no-border' +
            (this.leftColumns.length ? '' : ' no-left-column'));
        }
        this.showFirstColumnBorder();
    },

    /**
     * Show a border when scrolling horizontally if the first column is freezed.
     */
    showFirstColumnBorder: function() {
        if (!this.isFirstColumnFreezed) {
            this.hasFirstColumnBorder = false;
            return;
        }
        let scrollPanel = this.$('.flex-list-view-content')[0];
        let firstColumnIndex = this.leftColumns.length + 1;
        let firstColumnSelector = 'table tbody tr td:nth-child(' + firstColumnIndex +
            '), table thead tr th:nth-child(' + firstColumnIndex + ')';
        if (scrollPanel.scrollLeft === 0) {
            this.$(firstColumnSelector).addClass('no-border');
            this.hasFirstColumnBorder = false;
        } else if (!this.hasFirstColumnBorder) {
            this.$(firstColumnSelector).removeClass('no-border');
            this.hasFirstColumnBorder = true;
        }
    },

    // fn to turn off event listeners and reenable tooltips
    resetDropdownDelegate: function(e) {
        this.$el.removeClass('no-touch-scrolling');
        var $b = this.$(e.currentTarget).first();
        $b.parent().closest('.list').removeClass('open');

        // Remove open class on Safari
        if (this._isSafariBrowser) {
            var stickyColumn = $b.parent().closest('td');
            stickyColumn.removeClass('open');

            // Remove the position property to fix z-index issues with subpanel header when there are less
            // than 3 records.
            if (this.collection.length <= 3) {
                stickyColumn.addClass('sticky-column');
            }
        }

        $b.off('resetDropdownDelegate.right-actions');
    },

    delegateDropdown: function(e) {
        var $buttonGroup = this.$(e.currentTarget).first(); // the button group

        this.$el.addClass('no-touch-scrolling');
        // add open class to parent list to elevate absolute z-index for iOS
        $buttonGroup.parent().closest('.list').addClass('open');

        // If the user is on Safari change the z-index of the opened dropdown's parent column to push to top
        if (this._isSafariBrowser) {
            var stickyColumn = $buttonGroup.parent().closest('.sticky-column');
            stickyColumn.addClass('open');

            // Remove the position property to fix z-index issues with subpanel header when there are less
            // than 3 records.
            if (this.collection.length <= 3) {
                stickyColumn.removeClass('sticky-column');
            }
        }

        // detect window bottom collision
        $buttonGroup.toggleClass('dropup', this.needsDropupClass($buttonGroup));
        // listen for delegate reset
        $buttonGroup.on('resetDropdownDelegate.right-actions', this.resetDropdownDelegate);
        // add a listener to scrolling container
        $buttonGroup.parents('.main-pane')
            .on('scroll.right-actions', _.bind(_.debounce(function() {
                // detect window bottom collision on scroll
                $buttonGroup.toggleClass('dropup', this.needsDropupClass($buttonGroup));
            }, 30), this));
    },

    /**
     * A utility method to determine when a dropdown menu is going to collide with the bottom of the screen.
     */
    needsDropupClass: function($b) {
        var menuHeight = $b.height() + $b.children('ul').first().height();
        // TODO fix (SS-1078) | height of window less padding
        var windowHeight = document.documentElement.clientHeight - 65;
        // The total displacement needed for dropdown to expand + distance from top of screen
        var dropdownDisplacement = $b.offset().top + menuHeight;

        /**
         * Special handling for Safari as the menu cannot overlay table content due to -webkit-sticky positioning
         * and associated z-index behaviour.
         */
        if (this._isSafariBrowser && this.collection.length > 3) {
            // Height of visible viewport (page height inside browser window)
            windowHeight = document.documentElement.clientHeight;
            var table = $b.parent().closest('.dataTable');
            var tableHeight = table.height();
            var tableOffsetTop = table.offset().top;

            // The displacement of the table, using table height and it's distance from the top of the page
            var tableOffset = windowHeight - tableHeight - Math.abs(tableOffsetTop);

            /**
             * There are 3 cases to check here:
             * 1. If only the first subset of records are loaded and the table is shorter than the height of the table
             * (on page load for list view).
             * 2. If more records have been loaded, making the table height larger than screen size, and the user
             * scrolls to the new bottom of the table and opens the right action dropdown.
             * 3. If more records have been loaded and the users selects the right action dropdown somewhere before
             * the bottom of the page.
             */
            if (tableHeight < windowHeight && tableOffsetTop > 0) {
                return (tableHeight + tableOffsetTop) < dropdownDisplacement;
            } else if ((tableHeight - Math.abs(tableOffsetTop) < dropdownDisplacement)) {
                return true;
            } else {
                var footerHeight = $('#footer').children('footer').first().height();
                return (windowHeight - footerHeight) < dropdownDisplacement;
            }
        }

        return windowHeight < dropdownDisplacement;
    },

    /**
     * Sets a button accessibility class 'aria-expanded' to true or false
     * depending on if the dropdown menu is open or closed.
     *
     * @param {Event} provides the needed currentTarget
     * @private
     */
    _toggleAria: function(e) {
        var $tableHeader = this.$(e.currentTarget);
        var $dropdown = $tableHeader.find('.dropdown');
        var $button = $dropdown.find('[data-toggle="dropdown"]');

        // Allow the dropdown for table header to pop over the top, remove position: -webkit-sticky property
        if (this._isSafariBrowser) {
            $tableHeader.toggleClass('sticky-column');
        }

        $button.attr('aria-expanded', $dropdown.hasClass('open'));
    },

    addPreviewEvents: function () {
        //When clicking on eye icon, we need to trigger preview:render with model&collection
        this.context.on("list:preview:fire", function (model) {
            app.events.trigger("preview:render", model, this.collection, true);
        }, this);

        //When switching to next/previous record from the preview panel, we need to update the highlighted row
        app.events.on("list:preview:decorate", this.decorateRow, this);
        if (this.layout) {
            this.layout.on("list:sort:fire", function () {
                //When sorting the list view, we need to close the preview panel
                app.events.trigger("preview:close");
            }, this);
            this.layout.on("list:paginate:success", function () {
                //When fetching more records, we need to update the preview collection
                app.events.trigger("preview:collection:change", this.collection);
                // If we have a model in preview, redecorate the row as previewed
                if (this._previewed) {
                    this.decorateRow(this._previewed);
                }
            }, this);
        }
    },

    /**
     * Parse fields to identify which fields are visible and which fields are
     * hidden.
     *
     * In practice, it creates a catalog that lists the fields that are
     * visible (user configuration if exists, otherwise default metadata
     * configuration) and all the fields (no matter their visible state) used to
     * populate the ellipsis dropdown.
     *
     * By default the catalog is sorted by the order defined in the metadata. If
     * user configuration is found, the catalog is sorted per user preference.
     *
     * @return {Object} The catalog object.
     */
    parseFields: function() {
        var fields = _.flatten(_.pluck(this.meta.panels, 'fields'));

        /**
         * The default order of the fields.
         *
         * @property {string[]}
         * @private
         */
        this._defaultFieldOrder = _.pluck(fields, 'name');
        var catalog = this._createCatalog(fields);

        /**
         * The custom order of the fields.
         *
         * See {@link #_getFieldsLastState}.
         *
         * @property {string[]}
         * @private
         */
        this._thisListViewFieldList = this._getFieldsLastState();

        if (this._thisListViewFieldList) {
            catalog = this._toggleFields(catalog, this._thisListViewFieldList, false);
            catalog = this.reorderCatalog(catalog, this._thisListViewFieldList.position, false);
        }
        return catalog;
    },

    /**
     * Retrieves the user configuration from the cache.
     *
     * The cached value changed in 7.2. In an entry is found in the local
     * storage and is at the wrong format, the value is converted to the new
     * format. If no entry found, or the entry has an unexpected format, it
     * throws an exception and return undefined.
     *
     * @return {Object/undefined} An object whom keys are field names, and
     * values are an object containing the position and the visible state,
     * or `undefined` in case of failure.
     *
     * @private
     */
    _getFieldsLastState: function() {
        if (!this._thisListViewFieldListKey) {
            return;
        }
        var data = app.user.lastState.get(this._thisListViewFieldListKey);
        if (_.isUndefined(data)) {
            return;
        }
        if (!_.isArray(data) || _.isEmpty(data)) {
            app.logger.error('The format of "' + this._thisListViewFieldListKey + '" is unexpected, skipping.');
            return;
        }
        if (_.isString(data[0])) {
            // Old format detected.
            return this._convertFromOldFormat(data);
        }
        return this._decodeCacheData(data);
    },

    /**
     * Create an object that contains 2 keys. Each key is associated to an array
     * that contains the field metadata.
     * List of keys:
     * - `visible` lists fields user wants to see,
     * - `all` lists all the fields, with a `selected` attribute that indicates
     * their visible state (used to populate the ellipsis dropdown).
     *
     * @param {Array} fields The list of field definition for this view.
     * @return {Object} The catalog object.
     * @private
     */
    _createCatalog: function(fields) {
        var catalog = {};
        catalog._byId = {};
        catalog.visible = [];
        catalog.all = [];

        _.each(fields, function(fieldMeta, i) {
            catalog._byId[fieldMeta.name] = this._patchField(fieldMeta, i);
        }, this);
        catalog.all = _.toArray(catalog._byId);
        catalog.visible = _.where(catalog.all, { selected: true });
        return catalog;
    },

    /**
     * Patch a field metadata for this list view.
     *
     * Note that {@link View.FlexListView requires the attributes `selected` and
     * `position`} in order to work properly.
     *
     * @param {Object} fieldMeta The field metadata.
     * @param {Number} index The index of the field in the field list.
     * @return {Object} The patched metadata.
     * @private
     */
    _patchField: function(fieldMeta, index) {
        var isVisible = (fieldMeta['default'] !== false);
        return _.extend({
            selected: isVisible,
            position: index + 1
        }, fieldMeta);
    },

    /**
     * Take the existing catalog and toggle field visibility based on the last
     * state found in the cache.
     *
     * If for some reason, the field is not found at all in the cached data, it
     * fallbacks to the default visible state of that field (defined in the
     * metadata).
     *
     * @param {Object} catalog The catalog of fields.
     * @param {Object} fields The decoded cached data that contains fields
     * wanted visible and fields wanted hidden.
     * @param {Boolean} saveLastState(optional) `true` to save last state,
     * `false` otherwise. `true` by default.
     * @return {Object} The catalog with visible state of fields based on user
     * preference.
     * @private
     */
    _toggleFields: function(catalog, fields, saveLastState) {
        if (_.isEmpty(fields) || (_.isEmpty(fields.visible) && _.isEmpty(fields.hidden))) {
            return catalog;
        }
        saveLastState = _.isUndefined(saveLastState) ? true : saveLastState;
        _.each(fields.visible, function(fieldName) {
            var f = catalog._byId[fieldName];
            if (f) {
                f.selected = true;
            }
        }, this);
        _.each(fields.hidden, function(fieldName) {
            var f = catalog._byId[fieldName];
            if (f) {
                f.selected = false;
            }
        }, this);
        catalog.all = _.sortBy(_.toArray(catalog._byId), function(f) {
            return f.position;
        });
        catalog.visible = _.where(catalog.all, { selected: true });

        if (saveLastState) {
            this.trigger('list:save:laststate');
        }

        return catalog;
    },

    /**
     * Sort the catalog of fields per the list of field names passed as
     * argument.
     *
     * @param {Object} catalog Field definitions listed in 2 categories:
     * `visible` / `all`.
     * @param {Array} order Array of field names used to sort the catalog.
     * @param {Boolean} saveLastState(optional) `true` to save last state,
     * `false` otherwise. `true` by default.
     * @return {Object} catalog The catalog of fields entirely sorted.
     */
    reorderCatalog: function(catalog, order, saveLastState) {
        saveLastState = _.isUndefined(saveLastState) ? true : saveLastState;

        order = _.union(order, _.pluck(catalog.all, 'name'));

        _.each(order, function(fieldName, i) {
            var f = catalog._byId[fieldName];
            if (f) {
                f.position = ++i;
            }
        });
        catalog.all = _.sortBy(_.toArray(catalog._byId), function(f) {
            return f.position;
        });
        catalog.visible = _.where(catalog.all, { selected: true });

        if (saveLastState) {
            this.trigger('list:save:laststate');
        }

        return catalog;
    },

    /**
     * Takes the minimized value stored into the cache and decode it to make
     * it more readable and more manipulable.
     *
     *     @example
     *     If field storage entry is:
     *     <pre><code>
     *     [
     *         'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'
     *     ]
     *     </code></pre>
     *     And encoded data is:
     *     <pre><code>
     *     [
     *         0, [1,5], [1,2], 0, [0,1], [1,3], 0, [1,4]
     *     ]
     *     </code></pre>
     *     The decoded data will be:
     *     <pre><code>
     *     {
     *         visible: ['B', 'C', 'F', 'H'],
     *         hidden: ['E'],
     *         position: ['E', 'C', 'B', 'F', 'H']
     *     }
     *     </code></pre>
     *     `visible` contains the list of visible fields,
     *     `hidden` contains the list of hidden fields,
     *     `position` is the order of fields,
     *     indexes whom value is `0` are skipped (fields not displayable).
     *
     * @param {Array} encodedData The minimized data.
     * @return {Object} The decoded data.
     * @private
     */
    _decodeCacheData: function(encodedData) {
        var decodedData = {
            visible: [],
            hidden: [],
            position: []
        };

        var fieldList = this._appendFieldsToAllListViewsFieldList();
        _.each(encodedData, function(fieldArray, i) {
            if (!_.isArray(fieldArray)) {
                return;
            }
            var name = fieldList[i];
            if (fieldArray[0]) {
                decodedData.visible.push(name);
            } else {
                decodedData.hidden.push(name);
            }
            decodedData.position[fieldArray[1]] = name;
        });
        decodedData.position = _.difference(decodedData.position, [undefined]);
        return decodedData;
    },

    /**
     * Takes the decoded data and minimize it to save cache size.
     *
     *     @example
     *     If field storage entry is:
     *     <pre><code>
     *     [
     *         'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'
     *     ]
     *     </code></pre>
     *     And decoded data is:
     *     <pre><code>
     *     {
     *         visible: ['B', 'C', 'F', 'H'],
     *         hidden: ['E'],
     *         position: ['E', 'C', 'B', 'F', 'H']
     *     }
     *     </code></pre>
     *     The encoded data will be:
     *     <pre><code>
     *     [
     *         0, [1,5], [1,2], 0, [0,1], [1,3], 0, [1,4]
     *     ]
     *     </code></pre>
     *     `0` means the field is not displayable. (i.e: `A`, `D`, `G`),
     *     the first item is the visible state: `1` visible, `0` hidden,
     *     the second item of the array is the position of the field.
     *
     * @param {Object} decodedData The decoded data.
     * @return {Array} The minimized data.
     * @private
     */
    _encodeCacheData: function(decodedData) {
        var encodedData = [];

        var fieldList = this._appendFieldsToAllListViewsFieldList();
        _.each(fieldList, function(fieldName) {
            var value = 0;
            if (_.contains(decodedData.position, fieldName)) {
                value = [
                    _.contains(decodedData.visible, fieldName) ? 1 : 0,
                    _.indexOf(decodedData.position, fieldName) + 1
                ];
            }
            encodedData.push(value);
        });
        return encodedData;
    },

    /**
     * Takes the decoded data and minimize it to save cache size.
     *
     * For example, if the field's storage entry is:
     *
     *     ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
     *
     * And the decoded data is:
     *
     *     {
     *         visible: ['B', 'C', 'E', 'F', 'H'],
     *         widths: [125, 50, 60, 150, 200]
     *     }
     *
     * The encoded data will be:
     *
     *     [0, 125, 50, 0, 60, 150, 0, 200]
     *
     * `0` means the field has no user defined width. (i.e: `A`, `D`, `G`)
     * This is either because the column is hidden, or not displayable in this
     * list view.
     *
     * @param {Object} decodedData The decoded data.
     * @return {Array} The encoded data.
     * @private
     */
    _encodeCacheWidthData: function(decodedData) {
        var encodedData = [];

        var fieldList = this._appendFieldsToAllListViewsFieldList();
        var visibleIndex;
        var value;
        _.each(fieldList, function(fieldName) {
            value = 0;
            visibleIndex = _.indexOf(decodedData.visible, fieldName);
            if (visibleIndex !== -1) {
                value = decodedData.widths[visibleIndex];
            }
            encodedData.push(value);
        });
        return encodedData;
    },

    /**
     * Takes the minimized value stored in the cache and decodes it to make it
     * more readable and easier to manipulate.
     *
     * If the field's storage entry is:
     *
     *     ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
     *
     * And the encoded data is:
     *
     *     [0, 125, 50, 0, 60, 150, 0, 200]
     *
     * The decoded data will be:
     *
     *     {
     *         visible: ['B', 'C', 'F', 'H'],
     *         widths: [125, 50, 60, 150, 200]
     *     }
     *
     * - `visible` contains the list of visible fields,
     * - `widths` is the widths of fields, indexes whose value is `0` are
     * skipped (fields not being displayed).
     *
     * @param {Array} encodedData The minimized data.
     * @return {Object} The decoded data.
     * @private
     */
    _decodeCacheWidthData: function(encodedData) {
        var decodedData = {
            'visible': [],
            'widths': []
        };

        var fieldList = this._appendFieldsToAllListViewsFieldList();
        _.each(_.pluck(this._fields.visible, 'name'), function(fieldName) {
            var index = _.indexOf(fieldList, fieldName);
            var width = encodedData[index] || 0;
            decodedData.visible.push(fieldName);
            decodedData.widths.push(width);
        });
        return decodedData;
    },

    /**
     * Append the list of fields defined in the metadata that are missing in the
     * field storage cache entry.
     *
     * We initially used `_.uniq` to guarantee the unicity of fields. It appears
     * that this `underscore` method is slow, unlike `Lo-Dash` one. Meanwhile a
     * potential migration to Lo-Dash, it is faster to build an object whom keys
     * are field names.
     *
     * @return {Array} The list of all the fields that are displayable in list
     * views of this module.
     * @private
     */
    _appendFieldsToAllListViewsFieldList: function() {
        this._allListViewsFieldList = app.user.lastState.get(this._allListViewsFieldListKey) || [];
        var obj = {};
        _.each(this._allListViewsFieldList, function(fieldName) {
            obj[fieldName] = fieldName;
        });

        _.each(this.meta.panels, function(panel) {
            _.each(panel.fields, function(fieldMeta, i) {
                obj[fieldMeta.name] = fieldMeta.name;
            }, this);
        }, this);
        this._allListViewsFieldList = _.keys(obj);
        app.user.lastState.set(this._allListViewsFieldListKey, this._allListViewsFieldList);
        return this._allListViewsFieldList;
    },

    /**
     * Converts the old localStorage data for fields visibility to the new
     * decoded format.
     *
     * {@link View.FlexListView#_encodeCacheData To see how the new format looks like.}
     *
     *     @example Only visible fields used to be stored. Example of data stored:
     *     <pre><code>
     *     [
     *         'B', 'C', 'F', 'H'
     *     ]
     *     </code></pre>
     *     If the list of fields defined in the metadata was:
     *     <pre><code>
     *     [
     *         'E', 'C', 'B', 'F', 'H'
     *     ]
     *     </code></pre>
     *     The decoded data would be:
     *     <pre><code>
     *     {
     *         visible: ['B', 'C', 'F', 'H'],
     *         hidden: ['E'],
     *         position: ['E', 'C', 'B', 'F', 'H']
     *     }
     *     </code></pre>
     *
     * @return {Array} The data converted to the new decoded format.
     * @private
     */
    _convertFromOldFormat: function(visibleFieldList) {
        var thisViewFieldList = _.reduce(_.map(this.meta.panels, function(panel) {
            return _.pluck(panel.fields, 'name');
        }), function(memo, field) {
            return memo.concat(field);
        }, []);

        var decoded = {
            visible: [],
            hidden: [],
            position: []
        };
        _.each(thisViewFieldList, function(fieldName, i) {
            if (_.contains(visibleFieldList, fieldName)) {
                decoded.visible.push(fieldName);
            } else {
                decoded.hidden.push(fieldName);
            }
            decoded.position.push(fieldName);
        });
        app.user.lastState.set(this._thisListViewFieldListKey, this._encodeCacheData(decoded));
        return decoded;
    },

    /**
     * Save to the cache the current order of fields, and their visible state.
     *
     *     @example Example of value stored in the cache:
     *     <pre><code>
     *     [
     *         ['A', 'B', 'D', 'C'],
     *         [0, 1, 0, 1]
     *     ]
     *     </code></pre>
     * Means the current order is `ABDC`, and only `B` and `C` are visible
     * fields.
     */
    saveCurrentState: function() {
        if (!this._thisListViewFieldListKey) {
            return;
        }
        var allFields = _.pluck(this._fields.all, 'name'),
            visibleFields = _.pluck(this._fields.visible, 'name');
        var decoded = {
            visible: visibleFields,
            hidden: _.difference(allFields, visibleFields),
            position: allFields
        };
        app.user.lastState.set(this._thisListViewFieldListKey, this._encodeCacheData(decoded));
        this._thisListViewFieldList = this._getFieldsLastState();
    },

    /**
     * Add actions to left and right columns
     */
    addActions: function() {
        var meta = this.meta;
        if (_.isObject(meta.selection)) {
            this.isSearchAndSelectAction = meta.selection.isSearchAndSelectAction;
            switch (meta.selection.type) {
                case 'single':
                    this.addSingleSelectionAction();
                    break;
                case 'multi':
                    this.addMultiSelectionAction();
                    break;
                default:
                    break;
            }
        }
        if (meta && _.isObject(meta.rowactions)) {
            this.addRowActions();
        }
    },
    /**
     * Add single selection field to left column
     */
    addSingleSelectionAction: function () {
        var _generateMeta = function (name, label) {
            return {
                'type': 'selection',
                'name': name,
                'sortable': false,
                'label': label || ''
            };
        };
        var def = this.meta.selection;
        this.leftColumns.push(_generateMeta(def.name || this.module + '_select', def.label));
    },
    /**
     * Add multi selection field to left column
     */
    addMultiSelectionAction: function() {
        var _generateMeta = _.bind(function(buttons, disableSelectAllAlert) {
            return {
                'type': 'fieldset',
                'fields': [
                    {
                        'type': 'actionmenu',
                        'buttons': buttons || [],
                        'disable_select_all_alert': !!disableSelectAllAlert,
                        'is_list_pagination': !!this.context.get('isUsingListPagination')
                    }
                ],
                'value': false,
                'sortable': false
            };
        }, this);
        var buttons = this.meta.selection.actions;
        var disableSelectAllAlert = !!this.meta.selection.disable_select_all_alert;
        this.leftColumns.push(_generateMeta(buttons, disableSelectAllAlert));
    },
    /**
     * Add fieldset of rowactions to the right column
     */
    addRowActions: function() {
        var _generateMeta = function(label, css_class, buttons) {
            return {
                'type': 'fieldset',
                'fields': [
                    {
                        'type': 'rowactions',
                        'label': label || '',
                        'css_class': css_class,
                        'buttons': buttons || []
                    }
                ],
                'value': false,
                'sortable': false
            };
        };
        var def = this.meta.rowactions;
        this.rightColumns.push(_generateMeta(def.label, def.css_class, def.actions));
    },
    /**
     * Decorate a row in the list that is being shown in Preview
     * @param model Model for row to be decorated.  Pass a falsy value to clear decoration.
     */
    decorateRow: function (model) {
        // If there are drawers, make sure we're updating only list views on active drawer.
        if (_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)) {
            this._previewed = model;
            this.$('.btn.rowaction.active').removeClass('active').attr('aria-pressed', false);
            this.$('tr.highlighted').removeClass('highlighted current');
            if (model) {
                var rowName = model.module + "_" + model.id;
                var curr = this.$('tr[name="' + rowName + '"]');
                curr.addClass('current highlighted');
                this.$('tr.current .btn.rowaction[data-event="list:preview:fire"]')
                    .addClass('active')
                    .attr('aria-pressed', true);
            }
        }
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this.colSpan = this._fields.visible.length || 0;
        if (this.leftColumns.length) {
            this.colSpan++;
        }
        if (this.rightColumns.length) {
            this.colSpan++;
        }
        if (this.colSpan < 2) {
            this.colSpan = null;
        }
        this._super('_renderHtml');

        if (this.leftColumns.length) {
            this.$el.addClass('left-actions');
        }
        if (this.rightColumns.length) {
            this.$el.addClass('right-actions');
        }

        var displayWidthSetting = !!(this._thisListViewFieldSizes ||
            !_.isUndefined(app.user.lastState.get(this._thisListViewFieldSizesKey)));
        var displayOrderSetting = false;
        if (this._thisListViewFieldList) {
            var customOrder = _.union(this._thisListViewFieldList.position, this._defaultFieldOrder);
            displayOrderSetting = !_.isEqual(customOrder, this._defaultFieldOrder);
        }
        this._toggleSettings('widths', displayWidthSetting);
        this._toggleSettings('order', displayOrderSetting);

        this.resize();
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        // FIXME SC-3484 Testing `this.closestComponent('sidebar')` is required
        // to make unit tests pass.
        if (this.closestComponent('sidebar') && !(app.drawer.count())) {
                this._setHelperScrollBar();
        }
        if (this.allowFreezeFirstColumn) {
            this.$('.flex-list-view-content').on('scroll', _.bind(this.showFirstColumnBorder, this));
        }
    },

    /**
     * Sets up the helper scrollbar.
     *
     * It first sets the helper `scrollWidth` and `width`. Then it adds
     * listeners on the spy and helper scrollbars to make them follow each
     * other.
     * Then it adds a listener on the vertical scrolling to watch when the
     * bottom of the table is visible, and when it is, to hide the helper since
     * the scrollbar at the bottom of the table is visible.
     *
     * @private
     */
    _setHelperScrollBar: function() {
        /**
         * The 'helper' scrollbar is the horizontal scrollbar fixed to the
         * bottom of the screen.
         *
         * @property {jQuery}
         */
        this.$helper = this.$('[data-scroll-spy]');

        // if no helper was found, just go about our way and not produce any javascript errors
        if (this.$helper.length === 0) {
            return;
        }

        /**
         * The `spy` is the list container element.
         *
         * @property {jQuery}
         */
        this.$spy = this.$('.' + this.$helper.data('scrollSpy'));

        this.$helper.find('div').width(this.$spy.get(0).scrollWidth);
        this._updateHelperWidth();
        this.listenTo(this.closestComponent('sidebar'), 'sidebar:toggle', _.bind(this._updateHelperWidth, this));

        this.$helper.on('scroll.' + this.cid, _.bind(function() {
            this.$spy.scrollLeft(this.$helper.scrollLeft());
        }, this));
        this.$spy.on('scroll.' + this.cid, _.bind(function() {
            this.$helper.scrollLeft(this.$spy.scrollLeft());
        }, this));

        // `#content` is the scrolling element in responsive view.
        $('#content').on('scroll.' + this.cid, _.bind(function() {
            this._toggleScrollHelper();
        }, this));

        // `.main-pane` is the scrolling element in desktop view.
        $('.main-pane').on('scroll.' + this.cid, _.bind(function() {
            this._toggleScrollHelper();
        }, this));
    },

    /**
     * Toggles the helper scroll bar.
     *
     * If the spy's `width` is greater than its `scrollWidth` (the screen is
     * large enough) OR if the footer is higher than the table (the table is not
     * visible on the screen), we hide the helper scrollbar.
     * Also, we hide it if the bottom of the table is higher than the footer
     * (the natural scroll bar is present).
     *
     * @private
     */
    _toggleScrollHelper: function() {
        if (this.$spy.get(0).scrollWidth <= this.$spy.width() ||
            this.$('tbody').offset().top + this.$helper.height() > $('footer').offset().top
        ) {
            this.$helper.toggle(false);
            return;
        }

        this.$helper.toggle(!(this.$('.scrollbar-landmark').offset().top < $('footer').offset().top));
        if (this.$helper.css('display') !== 'none') {
            this.$helper.scrollLeft(this.$spy.scrollLeft());
        }
    },

    /**
     * Updates the helper scrollbar width depending on whether dashboard is
     * open or not.
     *
     * @private
     */
    _updateHelperWidth: function() {
        if (this.$helper.length === 0) {
            return;
        }
        this.$helper.toggleClass('dash-collapsed', !$('.side.sidebar-content').is(':visible'));
    },

    /**
     * Saves the current field widths in {@link #_thisListViewFieldSizes}.
     *
     * If the stickiness is enabled, it also saves the widths into the cache,
     * so that the next time the view is loaded, the user retrieves his
     * preferred widths.
     *
     * Example of a value stored in the cache:
     *
     *     [125, 0, 52, 115, 0, 0, 51]
     *
     * Represents the current widths of fields `ABCDEF`, but no width has been
     * defined for fields `B`, `E` and `F` (because they were hidden or not
     * displayable).
     *
     * @param {Array} columns The widths of the current visible fields.
     */
    saveCurrentWidths: function(columns) {
        // Needed in order to fix the scroll helper whenever the widths change.
        this.resize();
        if (!this._thisListViewFieldListKey) {
            return;
        }
        var visibleFields = _.pluck(this._fields.visible, 'name');
        var decoded = {
            visible: visibleFields,
            widths: columns
        };
        var encoded = this._encodeCacheWidthData(decoded);
        this._toggleSettings('widths', true);

        /**
         * The list of user defined column widths for this specific view.
         *
         * @property {Array}
         * @protected
         */
        this._thisListViewFieldSizes = encoded;

        if (this._thisListViewFieldSizesKey) {
            app.user.lastState.set(this._thisListViewFieldSizesKey, encoded);
        }
    },

    /**
     * Resets the column widths to the default settings.
     *
     * If the stickiness is enabled, it also removes the entry from the cache.
     */
    resetColumnWidths: function() {
        this._thisListViewFieldSizes = null;
        if (this._thisListViewFieldSizesKey) {
            app.user.lastState.remove(this._thisListViewFieldSizesKey);
        }
        if (!this.disposed) {
            this.render();
            this._toggleSettings('widths', false);
        }
    },

    /**
     * Resets the column order to the default settings.
     */
    resetColumnOrder: function() {
        var fields = _.flatten(_.pluck(this.meta.panels, 'fields'));
        this._fields = this._createCatalog(fields);
        this.saveCurrentState();
        if (this.disposed) {
            return;
        }
        this.render();
    },

    /**
     * Shows, or hides, the reset setting option from the settings dropdown.
     *
     * @param {string} category The setting to show or hide.
     * @param {boolean} show `true` to show it, `false` to hide it.
     * @private
     */
    _toggleSettings: function(category, show) {
        this.$('li[data-settings-li=' + category + ']').toggle(show);
    },

    /**
     * Gets the list of widths for each visible field in the list view.
     *
     * If the stickiness is enabled, it will look for the entry in the cache.
     *
     * @return {Array} The list of widths if found, `undefined` otherwise.
     */
    getCacheWidths: function() {
        var encodedData = this._thisListViewFieldSizes ||
            app.user.lastState.get(this._thisListViewFieldSizesKey);
        if (!encodedData) {
            return;
        }
        return this._decodeCacheWidthData(encodedData).widths;
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        $('#content, .main-pane').off('scroll.' + this.cid);
        $(this).parents('.main-pane').off('scroll.right-actions');
        this.$('.flex-list-view .actions').trigger('resetDropdownDelegate.right-actions');
        $(window).off('resize.flexlist-' + this.cid);

        if (this.$helper) {
            this.$helper.off('scroll.' + this.cid);
        }
        if (this.$spy) {
            this.$spy.off('scroll.' + this.cid);
        }

        this._super('unbind');
    },

    bindResize: function() {
        $(window).on("resize.flexlist-" + this.cid, _.bind(this.resize, this));
    },

    /**
     * Temporarily overwrites the css from the .scroll-width class so that
     * row field dropdown menues aren't clipped by overflow-x property.
     */
    scrollLock: function(lock) {
        var $content = this.$('.flex-list-view-content');
        if (lock) {
            $content.css({'overflow-y': 'visible', 'overflow-x': 'hidden'});
        } else {
            $content.removeAttr('style');
        }
    },

    /**
     * Updates the class of this flex list as scrollable or not, and
     * adjusts/toggles the scroll helper.
     */
    resize: function() {
        if (this.disposed) {
            return;
        }
        var $content = this.$('.flex-list-view-content');
        if (!$content.length) {
            return;
        }
        var toggle = $content.get(0).scrollWidth > $content.width() + 1;
        this.$el.toggleClass('scroll-width', toggle);

        if (this.$helper && this.$helper.length > 0) {
            this.$helper.find('div').width(this.$spy.get(0).scrollWidth);
            this._toggleScrollHelper();
        }
    }
}) },
"module-menu": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Module menu provides a reusable and easy render of a module Menu.
 *
 * This also helps doing customization of the menu per module and provides more
 * metadata driven features.
 *
 * @class View.Views.Base.ModuleMenuView
 * @alias SUGAR.App.view.views.BaseModuleMenuView
 * @extends View.View
 */
({
	// Module-menu View (base) 

    tagName: 'span',

    events: {
        'click [data-event]': 'handleMenuEvent',
        'click [data-route]': 'handleRouteEvent',
        'shown.bs.dropdown': 'populateMenu'
    },

    /**
     * The possible actions that this module menu provides.
     *
     * This comes from the metadata files, like:
     *
     * - {custom}/modules/&lt;Module&gt;/clients/base/menus/header/header.php
     */
    actions: [],

    /**
     * Default settings used when none are supplied through metadata.
     *
     * Supported settings:
     * - {Number} favorites Number of records to show on the favorites
     *   container. Pass 0 if you don't want to support favorites.
     * - {Number} recently_viewed Number of records to show on the recently
     *   viewed container. Pass 0 if you don't want to support recently viewed.
     *
     * Example:
     * ```
     * // ...
     * 'settings' => array(
     *     'favorites' => 5,
     *     'recently_viewed' => 9,
     *     //...
     * ),
     * //...
     * ```
     *
     * @protected
     */
    _defaultSettings: {
        favorites: 3,
        recently_viewed: 3
    },

    /**
     * Settings after applied metadata settings on top of
     * {@link View.Views.BaseModuleMenuView#_defaultSettings default settings}.
     *
     * @protected
     */
    _settings: {},

    /**
     * @inheritdoc
     *
     * Adds listener for bootstrap drop down show event (`shown.bs.dropdown`).
     * This will trigger menuOpen method.
     */
    initialize: function(options) {

        options.meta = _.extend(
            {},
            options.meta,
            app.metadata.getView(null, options.name),
            app.metadata.getView(options.module, options.name)
        );

        this._super('initialize', [options]);
        this._initSettings();

        /**
         * The internal array of collections for favorites and recent.
         * The collections shouldn't be reused with different filters when
         * fetching in parallel.
         *
         * @property {Object}
         * @private
         */
        this._collections = {};
    },


    /**
     * Initialize settings, default settings are used when none are supplied
     * through metadata.
     *
     * @return {View.Views.BaseModuleMenuView} Instance of this view.
     * @protected
     */
    _initSettings: function() {

        this._settings = _.extend({},
            this._defaultSettings,
            this.meta && this.meta.settings || {}
        );

        return this;
    },

    /**
     * @inheritdoc
     *
     * Retrieves possible menus from the metadata already inSync.
     * Filters all menu actions based on ACLs to prevent user to click them and
     * get a `403` after click.
     */
    _renderHtml: function() {
        var meta = app.metadata.getModule(this.module) || {};

        this.actions = this.filterByAccess(meta.menu && meta.menu.header && meta.menu.header.meta);

        this._super('_renderHtml');

        if (!this.meta.short) {
            this.$el.addClass('btn-group p-2');
        }
    },

    /**
     * Filters menu actions by ACLs for the current user.
     *
     * @param {Array} meta The menu metadata to check access.
     * @return {Array} Returns only the list of actions the user has access.
     */
    filterByAccess: function(meta) {

        var result = [];

        _.each(meta, function(menuItem) {
            if (app.acl.hasAccess(menuItem.acl_action, menuItem.acl_module)) {
                result.push(menuItem);
            }
        });

        return result;
    },

    /**
     * Method called when a `show.bs.dropdown` event occurs.
     *
     * Populate the favorites and recently viewed records every time we open
     * the menu. This is only supported on modules that have fields.
     */
    populateMenu: function() {

        var meta = app.metadata.getModule(this.module) || {};

        if (_.isEmpty(_.omit(meta.fields, '_hash'))) {
            return;
        }

        if (meta.favoritesEnabled) {
            this.populate('favorites', [{
                '$favorite': ''
            }], this._settings.favorites);
        }

        this.populate('recently-viewed', [{
            '$tracker': '-7 DAY'
        }], this._settings.recently_viewed);
    },


    /**
     * Return `true` if this menu is open, `false` otherwise.
     * @return {Boolean} `true` if this menu is open, `false` otherwise.
     */
    isOpen: function() {
        return !!this.$el.hasClass('open');
    },

    /**
     * Populates records templates based on filter given.
     *
     * @param {String} tplName The template to use to populate data.
     * @param {String} filter The filter to be applied.
     * @param {Number} limit The number of records to populate. Needs to be an
     *   integer `> 0`.
     */
    populate: function(tplName, filter, limit) {
        if (limit <= 0) {
            return;
        }

        this.getCollection(tplName).fetch({
            'showAlerts': false,
            'fields': ['id', 'name'],
            // TODO SC-3696 this filter can be initialized once in the
            // getCollection() and be metadata driven.
            'filter': filter,
            'limit': limit,
            'success': _.bind(function() {
                this._renderPartial(tplName);
            }, this)
        });
    },

    /**
     * Get the collection for the partial (favorites or recently viewed).
     *
     * @param {string} tplName The name of the partial template that will use
     *   this collection.
     * @return {Data.BeanCollection} The collection of this module.
     */
    getCollection: function(tplName) {
        if (!this._collections[tplName]) {
            this._collections[tplName] =
                app.data.createBeanCollection(this.module, [], {params: {erased_fields: true}});
            // TODO SC-3696 create the initial filter based on metadata for the
            // partials
        }

        return this._collections[tplName];
    },

    /**
     * Renders the data in the partial template given.
     *
     * The partial template can receive more data from the options parameter.
     *
     * @param {String} tplName The template to use to render the partials.
     * @param {Object} [options] Other optional data to pass to the template.
     * @protected
     */
    _renderPartial: function(tplName, options) {
        if (this.disposed || !this.isOpen()) {
            return;
        }
        options = options || {};

        var tpl = app.template.getView(this.name + '.' + tplName, this.module) ||
            app.template.getView(this.name + '.' + tplName);

        var self = this;
        var collection = this.getCollection(tplName);
        _.each(collection.models, function(model) {
            if (app.utils.isNameErased(model)) {
                model.set('erased', true);
                model.set('erasedText', app.lang.get('LBL_VALUE_ERASED'));
            }
        });

        var $placeholder = this.$('[data-container="' + tplName + '"]');
        var $old = $placeholder.nextUntil('.divider');

        //grab the focused element's route (if exists) for later re-focusing
        var focusedRoute = $old.find(document.activeElement).data('route');

        //replace the partial using newly updated collection
        $old.remove();
        $placeholder.after(tpl(_.extend({'collection': collection}, options)));

        //if there was a focused element previously, restore its focus
        if (focusedRoute) {
            var $new = $placeholder.nextUntil('.divider');
            var focusSelector = '[data-route="' + focusedRoute + '"]';
            var $newFocus = $new.find(focusSelector);
            if ($newFocus.length > 0) {
                $newFocus.focus();
            }
        }
    },

    /**
     * This gives support to any events that might exist in the menu actions.
     *
     * Out of the box we don't have any use case for actions that are event
     * driven. Since it was already provided since 7.0.0 we will keep it util
     * further notice.
     *
     * @param {Event} evt The event that triggered this (normally a click
     *   event).
     */
    handleMenuEvent: function(evt) {
        var $currentTarget = this.$(evt.currentTarget);
        app.events.trigger($currentTarget.data('event'), this.module, evt);
    },

    /**
     * This triggers router navigation on both menu actions and module links.
     *
     * Since we normally trigger the drawer for some actions, we prevent it
     * when using the click with the `ctrlKey` (or `metaKey` in Mac OS).
     * We also prevent the routing to be fired when this happens.
     *
     * When we are triggering the same route that we already are in, we just
     * trigger a {@link Core.Routing#refresh}.
     *
     * @param {Event} event The event that triggered this (normally a click
     *   event).
     */
    handleRouteEvent: function(event) {
        var currentRoute,
            $currentTarget = this.$(event.currentTarget),
            route = $currentTarget.data('route');

        event.preventDefault();
        if ((!_.isUndefined(event.button) && event.button !== 0) || event.ctrlKey || event.metaKey || $currentTarget.data('openwindow') === true) {
            event.stopPropagation();
            window.open(route, '_blank');
            return false;
        }

        currentRoute = '#' + Backbone.history.getFragment();
        (currentRoute === route) ? app.router.refresh() : app.router.navigate(route, {trigger: true});
    }

}) },
"sweetspot-config-theme": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SweetspotConfigThemeView
 * @alias SUGAR.App.view.views.BaseSweetspotConfigThemeView
 * @extends View.View
 */
({
	// Sweetspot-config-theme View (base) 

    className: 'columns',

    // FIXME: Change this to 'UnsavedChanges' when SC-4167 gets merged.
    plugins: ['Editable'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = this._getMeta(options);
        this._super('initialize', [options]);
        this._bindEvents();
    },

    /**
     * Merges the base metadata with custom view metadata.
     *
     * @protected
     * @param {Object} options The options hash containing the custom
     *   metadata.
     * @return {Object} The metadata this view should use.
     */
    _getMeta: function(options) {
        return  _.extend({},
            app.metadata.getView(null, 'sweetspot-config-theme'),
            app.metadata.getView(this.module, 'sweetspot-config-theme'),
            options.meta
        );
    },

    /**
     * Binds the events that this layout uses.
     *
     * @protected
     */
    _bindEvents: function() {
        this.context.on('sweetspot:ask:configs', this.generateConfig, this);
    },


    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this._super('_renderHtml');
        this._initTheme();
    },

    /**
     * Initializer function that ensures the correct theme is checked when the
     * view is rendered.
     *
     * @protected
     */
    _initTheme: function() {
        var prefs = app.user.getPreference('sweetspot');
        var theme = prefs && prefs.theme;

        this.model.set('theme', theme);
    },

    /**
     * Generates an object that the
     * {@link View.Layouts.Base.SweetspotConfigLayout config layout} uses to
     * save configurations to the user preferences.
     *
     * @return {undefined} Returns `undefined` if the default theme is selected.
     */
    generateConfig: function() {
        var theme = this._getSelectedTheme();

        // The default configuration should not be defined in user prefs.
        if (!theme) {
            return;
        }
        var data = this._formatForUserPrefs(theme);
        this.context.trigger('sweetspot:receive:configs', data);
    },

    /**
     * This method prepares the attributes payload for the call to
     * {@link Core.User#updatePreferences}.
     *
     * @protected
     * @param {string} theme The configured theme name.
     * @return {Object} The prepared configuration data.
     */
    _formatForUserPrefs: function(theme) {
        return {theme: theme};
    },

    /**
     * Returns the currently selected theme from this view.
     *
     * @protected
     * @return {string|undefined} The currently selected theme. Returns
     *   `undefined` if the default theme is selected.
     */
    _getSelectedTheme: function() {
        var theme = this.model.get('theme');

        // The default configuration should be empty in user prefs.
        if (theme === 'default') {
            return;
        }

        return theme;
    },

    /**
     * Compare with the user preferences and return true if the checkbox
     * contains changes.
     *
     * This method is called by {@link app.plugins.Editable}.
     *
     * @return {boolean} `true` if current collection contains unsaved changes,
     *   `false` otherwise.
     */
    hasUnsavedChanges: function() {
        var prefs = app.user.getPreference('sweetspot');
        var oldConfig = prefs && prefs.theme;
        var newConfig = this._getSelectedTheme();
        var isChanged = !_.isEqual(oldConfig, newConfig);

        return isChanged;
    }
}) },
"dashlet-toolbar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletToolbarView
 * @alias SUGAR.App.view.views.BaseDashletToolbarView
 * @extends View.View
 */
({
	// Dashlet-toolbar View (base) 

    className: 'dashlet-header flex flex-row items-center m-0.75',
    cssIconDefault: 'sicon sicon-settings',
    cssIconRefresh: 'sicon sicon-refresh sicon-is-spinning',
    defaultActions: {
        'dashlet:edit:clicked' : 'editClicked',
        'dashlet:viewReport:clicked': 'viewReportClicked',
        'dashlet:refresh:clicked' : 'refreshClicked',
        'dashlet:delete:clicked' : 'removeClicked',
        'dashlet:toggle:clicked' : 'toggleMinify'
    },
    events: {
        'shown.bs.dropdown': '_toggleAria',
        'hidden.bs.dropdown': '_toggleAria'
    },

    /**
     * Button states.
     */
    _STATE: {
        EDIT: 'edit',
        VIEW: 'view'
    },

    /**
     * List of fields to display in the header.
     *
     * @property {Object[]|null}
     */
    headerFields: null,

    initialize: function(options) {
        _.extend(options.meta, app.metadata.getView(null, 'dashlet-toolbar'), options.meta.toolbar);
        app.view.View.prototype.initialize.call(this, options);
        var model = this.closestComponent('dashboard') ?
            this.closestComponent('dashboard').model : this.model;

        /**
         * A flag to indicate if the dashlet is editable.
         *
         * @type {boolean}
         */
        this.canEdit = app.acl.hasAccessToModel('edit', model) || false;

        this.buttons = this.meta.buttons;
        this.isChart = !_.isEmpty(this.buttons) && this.buttons[0].is_chart || false;
        this.adjustHeaderPaneTitle = _.bind(_.debounce(this.adjustHeaderPaneTitle, 50), this);
        $(window).on('resize.' + this.cid, this.adjustHeaderPaneTitle);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.context.on('dashlet:toolbar:change', function(headerFields, headerButtons, dashletModel, dashlet) {
            this.headerFields = headerFields;
            this.buttons = _.union(headerButtons, this.meta.buttons);
            if (dashletModel) {
                this.dashletModel = dashletModel;
            }
            if (dashlet) {
                this.dashlet = dashlet;
            }
            this.render();
        }, this);
    },

    /**
     * Adjust header pane dashlet title such that the field is ellipsified.
     */
    adjustHeaderPaneTitle: function() {
        // this is required due to _.debounce adding a setTimeout.
        if (this.disposed) {
            return;
        }

        var isDataTypeFullName = _.contains(_.pluck(this.headerFields, 'type'), 'fullname');
        if (isDataTypeFullName) {
            // Left side sibling record-cells width.
            var recordCellsWidth = 0;
            this.$('.record-cell').each(function() {
                recordCellsWidth += $(this).outerWidth(true);
            });
            // Right side buttons width.
            var btnGroupWidth = this.$('.pull-right').outerWidth(true);
            // Parent header panel width.
            var headerPaneWidth = this.$el.closest('.dashlet-header').width();
            // Dashlet record title is positioned as the child element of the second record-cell.
            // Calculate title width by subtracting the record-cell and btn-group width from parent headerPane width.
            var titleWidth = headerPaneWidth - btnGroupWidth - recordCellsWidth;

            this.$('.dashlet-open-container').css({'max-width': titleWidth + 'px'});
        }
    },

    /**
     * @inheritdoc
     *
     * Handle the record state if this is a toolbar for a dashablerecord.
     */
    _render: function() {
        this._super('_render');
        this.adjustHeaderPaneTitle();
        if (this.dashlet) {
            this._handleRecordState(this.dashlet && this.dashlet.action);
        }
    },

    /**
     * Handle changes between edit/detail mode (for record view dashlets).
     *
     * @param {string} action Action name.
     * @private
     */
    _handleRecordState: function(action) {
        if (action === 'edit' && _.isFunction(this.toggleEdit)) {
            this.setButtonStates(this._STATE.EDIT);
            this.toggleEdit(true);
        } else {
            this.setButtonStates(this._STATE.VIEW);
        }
    },

    /**
     * Show/hide buttons depending on the state defined for each buttons in the
     * metadata.
     *
     * @param {string} state The {@link #_STATE} of the current view.
     */
    setButtonStates: function(state) {
        this.currentState = state;

        _.each(this.buttons, function(field) {
            field = this.getField(field.name);
            if (!field) {
                return;
            }
            var showOn = field.def && field.def.showOn;
            if (_.isUndefined(showOn) || (showOn === state)) {
                field.show();
            } else {
                field.hide();
            }
        }, this);

        this.toggleButtons(true);
    },

    /**
     * Enables or disables the action buttons that are currently shown on the
     * page. Toggles the `.disabled` class by default.
     *
     * @param {boolean} [enable=false] Whether to enable or disable the action
     *   buttons. Defaults to `false`.
     */
    toggleButtons: function(enable) {
        var state = !_.isUndefined(enable) ? !enable : false;

        _.each(this.buttons, function(button) {
            button = this.getField(button.name);
            if (!button) {
                return;
            }

            var showOn = button.def && button.def.showOn;
            if (_.isUndefined(showOn) || this.currentState === showOn) {
                button.setDisabled(state);
            }
        }, this);
        this.adjustHeaderPaneTitle();
    },

    /**
     * Change to the spinning icon to indicate that loading process is triggered
     */
    refreshClicked: function() {
        var $el = this.$('[data-action=loading]');
        var self = this;
        var options = {};
        if ($el.length > 0) {
            $el.removeClass(this.cssIconDefault).addClass(this.cssIconRefresh);
            options.complete = function() {
                if (self.disposed) {
                    return;
                }
                $el.removeClass(self.cssIconRefresh).addClass(self.cssIconDefault);
            };
        }
        this.layout.reloadDashlet(options);
    },

    /**
     * Remove a dashlet.
     *
     * @param {Event} evt Mouse event.
     */
    removeClicked: function(evt) {
        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_REMOVE_DASHLET_CONFIRM', this.module),
            onConfirm: _.bind(function() {
                this.layout.removeDashlet();
            }, this)
        });
    },

    /**
     * View report.
     *
     * @param {Event} evt Mouse event.
     */
    viewReportClicked: function(evt) {
        this.layout.viewReport();
    },

    /**
     * Edit the dashlet.
     *
     * @param {Event} evt The click event.
     */
    editClicked: function(evt) {
        this.layout.editDashlet();
    },

    /**
     * Toggle current dashlet frame when user clicks the toolbar action
     *
     * @param {Event} mouse event.
     */
    toggleClicked: function(evt) {
        var $btn = $(evt.currentTarget);
        var expanded = _.isUndefined($btn.data('expanded')) ? true : $btn.data('expanded');
        var label = expanded ? 'LBL_DASHLET_MAXIMIZE' : 'LBL_DASHLET_MINIMIZE';

        $btn.html(app.lang.get(label, this.module));
        this.layout.collapse(expanded);
        $btn.data('expanded', !expanded);
    },

    /**
     * Toggle current dashlet frame when user clicks chevron icon
     *
     * @param {Window.Event} mouse event.
     */
    toggleMinify: function(evt) {
        var $el = this.$('.dashlet-toggle > i');
        var collapsed = $el.is('.sicon-chevron-up');
        this.layout.collapse(collapsed);
        //firing an event to notify dashlet expand / collapse
        this.layout.trigger('dashlet:collapse', collapsed);
    },

    /**
     * Sets a button accessibility class 'aria-expanded' to true or false
     * depending on if the dropdown menu is open or closed.
     *
     * @private
     */
    _toggleAria: function() {
        var $button = this.$('[data-toggle=dropdown]');
        var $group = $button.parent();
        $button.attr('aria-expanded', $group.hasClass('open'));
    },

    /**
     * Remove event listeners on dispose
     * @private
     */
    _dispose: function() {
        $(window).off('resize.' + this.cid);
        this._super('_dispose');
    }

}) },
"massaddtolist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MassaddtolistView
 * @alias SUGAR.App.view.views.BaseMassaddtolistView
 * @extends View.Views.Base.MassupdateView
 */
({
	// Massaddtolist View (base) 

    extendsFrom: 'MassupdateView',
    addToListFieldName: 'prospect_lists',
    listModule: 'ProspectLists',
    massUpdateViewName: 'massaddtolist-progress',
    className: 'extend',

    initialize: function(options) {
        var additionalEvents = {};
        additionalEvents['click .btn[name=create_button]'] = 'createAndSelectNewList';
        this.events = _.extend({}, this.events, additionalEvents);
        this._super("initialize", [options]);
    },

    /**
     * Listen for just the massaddtolist event from the list view
     */
    delegateListFireEvents: function() {
        this.layout.on("list:massaddtolist:fire", this.show, this);
        this.layout.on("list:massaction:hide", this.hide, this);
    },

    /**
     * Pull out the target list link field from the field list and treat it like a relate field for later rendering
     * @param options
     */
    setMetadata: function(options) {
        var moduleMetadata = app.metadata.getModule(options.module);

        if (!moduleMetadata) {
            return;
        }

        var addToListField = _.find(moduleMetadata.fields, function(field) {
            return field.name === this.addToListFieldName;
        }, this);

        if (addToListField) {
            addToListField = app.utils.deepCopy(addToListField);
            addToListField.id_name = this.addToListFieldName + '_id';
            addToListField.name = this.addToListFieldName + '_name';
            addToListField.label = addToListField.label || addToListField.vname;
            addToListField.type = 'relate';
            addToListField.required = true;
            this.addToListField = addToListField;
        }
    },

    /**
     * Hide the view if we were not able to find the appropriate list field and somehow render is triggered
     */
    _render: function() {
        var result = this._super("_render");

        if(_.isUndefined(this.addToListField)) {
            this.hide();
        }
        return result;
    },

    /**
     * There is only one field for this view, so it is the default as well
     */
    setDefault: function() {
        this.defaultOption = this.addToListField;
    },

    /**
     * When adding to a target list, the API is expecting an array of IDs
     */
    getAttributes: function() {
        var attributes = {};
        attributes[this.addToListFieldName] = [
            this.model.get(this.addToListField.id_name)
        ];
        return attributes;
    },

    /**
     * Build dynamic success messages to be displayed if the API call is successful
     * Overridden to build different success messages from massupdate
     *
     * @param massUpdateModel - contains the attributes of what records are being updated
     */
    buildSaveSuccessMessages: function(massUpdateModel) {
        var doneLabel = 'TPL_MASS_ADD_TO_LIST_SUCCESS',
            queuedLabel = 'TPL_MASS_ADD_TO_LIST_QUEUED',
            listName = this.model.get(this.addToListField.name),
            listId = this.model.get(this.addToListField.id_name),
            listUrl = '#' + app.router.buildRoute(this.listModule, listId);

        return {
            done: app.lang.get(doneLabel, null, {
                listName: listName,
                listUrl: listUrl
            }),
            queued: app.lang.get(queuedLabel, null, {
                listName: listName,
                listUrl: listUrl
            })
        };
    },

    /**
     * Create a new target list and select it in the list
     */
    createAndSelectNewList: function() {
        app.drawer.open({
            layout: 'create-nodupecheck',
            context: {
                create: true,
                module: this.listModule
            }
        }, _.bind(this.selectNewlyCreatedList, this));
    },

    /**
     * Callback for create new target list - sets relate field with newly created list
     * @param context
     * @param model newly created target list model
     */
    selectNewlyCreatedList: function(context, model) {
        var relateField = this.getField('prospect_lists_name');
        if (relateField) {
            model.value = model.get('name');
            relateField.setValue(model);
        }
    }
}) },
"history-summary": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HistorySummaryView
 * @alias SUGAR.App.view.views.BaseHistorySummaryView
 * @extends View.Views.Base.FlexListView
 */
({
	// History-summary View (base) 

    extendsFrom: 'FlexListView',

    /**
     * Array of module names to fetch history
     */
    activityModules: [],

    /**
     * An array of default activity modules to fetch
     */
    allActivityModules: [
        'Calls',
        'Emails',
        'Meetings',
        'Notes',
        'Tasks'
    ],

    /**
     * Module name of the record we're coming from
     */
    baseModule: '',

    /**
     * Record ID of the record we're coming from
     */
    baseRecord: '',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, ['ReorderableColumns', 'ResizableColumns', 'ListColumnEllipsis']);

        if (options.context.parent) {
            this.baseModule = options.context.parent.get('module');
            this.baseRecord = options.context.parent.get('modelId');
        }

        this.setActivityModulesToFetch();

        var HistoryCollection = app.MixedBeanCollection.extend({
            module: 'history',
            activityModules: this.activityModules,
            buildURL: _.bind(function(params) {
                params = params || {};

                var url = app.api.serverUrl + '/'
                    + this.baseModule + '/'
                    + this.baseRecord + '/'
                    + 'link/history';

                params.module_list = this.activityModules.join(',');
                params = $.param(params);
                if (params.length > 0) {
                    url += '?' + params;
                }
                return url;
            }, this),
            sync: function(method, model, options) {
                options = app.data.parseOptionsForSync(method, model, options);
                if (options.params.fields) {
                    delete options.params.fields;
                }
                var url = this.buildURL(options.params),
                    callbacks = app.data.getSyncCallbacks(method, model, options);

                app.api.call(method, url, options.attributes, callbacks);
            }
        });

        options.collection = new HistoryCollection();

        this._super('initialize', [options]);

        //override the flex-list template
        this.template = app.template.getView(this.meta.template);

        this.context.set({
            collection: this.collection
        });

        $('html').addClass('print-drawer');
    },

    /**
     * @override
     *
     * This view doesn't use the regular {@link Utils.Utils#isSortable} to check
     * whether the field is sortable.
     */
    _initOrderBy: function() {
        var lastStateOrderBy = app.user.lastState.get(this.orderByLastStateKey) || {},
            lastOrderedFieldMeta = this.getFieldMeta(lastStateOrderBy.field);

        if (_.isEmpty(lastOrderedFieldMeta) || !lastOrderedFieldMeta.isSortable) {
            lastStateOrderBy = {};
        }

        return _.extend({
                field: '',
                direction: 'desc'
            },
            this.meta.orderBy,
            lastStateOrderBy
        );
    },

    /**
     * Sets the activityModules array which the collection sends to the endpoint
     * Override this function in child views to set a custom list of modules to fetch
     */
    setActivityModulesToFetch: function() {
        this.activityModules = this.allActivityModules;
    },

    /***
     * @inheritdoc
     *
     * Sets the field properly depending on the field name
     */
    _renderField: function(field) {
        var fieldName = field.name,
            fieldModule = field.model.get('_module'),
            fieldType = field.def.type || 'default';

        // check the fieldName and set the proper values
        if (fieldName === 'name') {
            // set the model's module to be the field's model's module
            // for the name link to be the proper ID
            field.model.module = fieldModule;
        } else if (fieldName === 'module') {
            field.model.set({
                module: field.model.get('moduleNameSingular')
            });
        } else if (fieldName === 'related_contact') {
            var contact,
                contactId;
            field.model.module = 'Contacts';
            switch (fieldModule) {
                case 'Emails':
                    // Emails does not have a related Contact/ID
                    contact = '';
                    contactId = '';
                    break;

                case 'Notes':
                case 'Calls':
                case 'Meetings':
                case 'Tasks':
                    contact = field.model.get('contact_name');
                    contactId = field.model.get('contact_id');
                    break;
            }
            field.model.set({
                related_contact: contact,
                related_contact_id: contactId
            });
        } else if (fieldName === 'status' && fieldModule === 'Emails') {
            // if this is the Status field and an Emails row,
            // translate the email status
            var fieldStatus = field.model.get('status'),
                emailStatusDom = app.lang.getAppListStrings('dom_email_status');

            // If this field is rendering again (like after "More history..." has been clicked)
            // it's 'status' will have already been run through the dom object
            if(!_.contains(emailStatusDom, fieldStatus)) {
                // if it hasn't already been translated, do it, do it now!
                fieldStatus = emailStatusDom[fieldStatus]
            }
            field.model.set({
                status: fieldStatus
            });
        }

        this._super('_renderField', [field]);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this._sanitizeModels();
    },

    /**
     * Sets `model.module` to be in accordance with
     * model's `_module` attribute for each model.
     *
     * @private
     */
    _sanitizeModels: function() {
        this.collection.each(function(model) {
            model.module = model.get('_module');
        });
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        $('html').removeClass('print-drawer');
        this._super('_dispose');
    }
}) },
"dashlet-search-controls": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletSearchControlsView
 * @alias SUGAR.App.view.views.BaseDashletSearchControlsView
 * @extends View.View
 */
({
	// Dashlet-search-controls View (base) 

    events: {
        'click .add-on.sicon-close': 'clearQuickSearch',
        'keyup .search-name': 'throttledSearch',
        'paste .search-name': 'throttledSearch',
    },

    /**
     * Sort dropdown items
     *
     * @property {Array}
     */
    sortItems: null,

    /**
     * Current sort order
     *
     * @property {integer}
     */
    currentSortOrder: null,

    /**
     * Placeholder string for the search field
     *
     * @property {string}
     */
    searchFieldPlaceholder: null,

    /**
     * String that was last searched for
     *
     * @property {string}
     */
    currentSearch: '',

    /**
     * @inheritdoc
     * @param options
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.sortItems = options.sortItems;
        this.searchFieldPlaceholder = options.searchFieldPlaceholder;
        if (!_.isEmpty(this.sortItems)) {
            this.currentSortOrder = _.first(this.sortItems).id;
        }
    },

    /**
     * Fires the quick search.
     * @param {Event} event A keyup event.
     */
    throttledSearch: _.debounce(function() {
        this.applyQuickSearch();
    }, 400),

    /**
     * Handler for clearing the quick search bar
     *
     * @param {Event} event A click event on the close button of search bar
     */
    clearQuickSearch: function(event) {
        this.$('input.search-name').val('');
        this.applyQuickSearch();
    },

    /**
     * Show or hide an icon to the quicksearch input so the user can clear the search easily
     * @param {boolean} show TRUE if you want show the clear icon, FALSE to hide
     */
    toggleClearQuickSearchIcon: function(show) {
        this.$('.sicon-close.add-on').toggle(show);
    },

    /**
     * Applies an updated filterdef with the current value on the quicksearch field.
     */
    applyQuickSearch: function() {
        var searchElem = this.$('input.search-name');
        var newSearch = searchElem.val();

        if (this.currentSearch !== newSearch) {
            this.currentSearch = newSearch;

            this.layout.trigger('dashlet:controls:search', newSearch);
            this.toggleClearQuickSearchIcon(!_.isEmpty(this.currentSearch));
        }
    },

    /**
     * Render the sort dropdown
     * @private
     */
    _renderSortDropdown: function() {
        var sortDropdown = this.$('.dashlet-controls-sort-field');

        sortDropdown.select2({
            data: this.sortItems,
            multiple: false
        });
        sortDropdown.select2('val', this.currentSortOrder);

        sortDropdown.on('change', _.bind(function(event) {
            this.currentSortOrder = event.val;
            this.layout.trigger('dashlet:controls:sort', event.val);
        }, this));
    },

    /**
     * @inheritdoc
     * @param options
     * @private
     */
    _render: function(options) {
        this._super('_render', [options]);
        this._renderSortDropdown();
    }
}) },
"stage2-preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.RecordView
 * @alias SUGAR.App.view.views.RecordView
 */
({
	// Stage2-preview View (base) 

    extendsFrom: 'RecordView',

    plugins: ['ToggleMoreLess', 'Stage2CssLoader'],

    events: {
        'click [data-action="copy"]': 'copy',

        'click [data-action="recordLinkClick"]': '_socialLinkClicked',
        // Have to define these events and related functions for sugar7 tooltip implementation.
        'mouseenter [rel="tooltip"]': 'showTooltip',
        'mouseleave [rel="tooltip"]': 'hideTooltip'
    },

    /**
     * Show tooltip
     *
     * @param {Object} e
     */
    showTooltip: function(e) {
        this.$(e.currentTarget).tooltip('show');
    },

    /**
     * Hide tooltip
     *
     * @param {Object} e
     */
    hideTooltip: function(e) {
        this.$(e.currentTarget).tooltip('hide');
    },

    enrichFieldsOptions: [],
    containsPreAccountFields: false,
    shouldShowHintCloudLogo: false,
    previousAccountQueue: [],
    switching: false,
    isHintRequestLoading: true,
    SUGAR_INTERNAL_FIELD_SUFFIX: '',
    SUGAR_INTERNAL_FIELD_PREFIX: 'hint_',
    oldHintPreview: '',
    isListView: '',
    fieldTypeTranslations: {
        'title': 'LBL_DASHLET_CONFIGURE_TITLE',
        'hint_account_pic': 'LBL_HINT_COMPANY_LOGO',
        'hint_contact_pic': 'LBL_HINT_CONTACTS_AVATAR',
        'phone_work': 'LBL_HINT_OFFICE_PHONE',
        'phone_mobile': 'LBL_HINT_MOBILE_PHONE',
        'phone_other': 'LBL_HINT_OTHER_PHONE',
        'website': 'LBL_HINT_WEBSITE',
        'hint_education': 'LBL_HINT_EDUCATION',
        'hint_education_2': 'LBL_HINT_EDUCATION_2',
        'hint_job_2': 'LBL_HINT_JOB_2',
        'hint_facebook': 'LBL_HINT_FACEBOOK',
        'hint_twitter': 'LBL_HINT_TWITTER',
        'account_name': 'LBL_LIST_ACCOUNT_NAME',
        'description': 'LBL_HINT_COMPANY_DESCRIPTION',
        'sic_code': 'LBL_HINT_COMPANY_SIC_CODE_LABEL',
        'twitter': 'LBL_HINT_COMPANY_TWITTER',
        'hint_account_industry_tags': 'LBL_HINT_COMPANY_INDUSTRY_TAGS',
        'annual_revenue': 'LBL_HINT_COMPANY_ANNUAL_REVENUE',
        'hint_account_website': 'LBL_HINT_COMPANY_WEBSITE',
        'hint_account_size': 'LBL_HINT_COMPANY_SIZE',
        'hint_account_industry': 'LBL_HINT_COMPANY_INDUSTRY',
        'hint_account_location': 'LBL_HINT_COMPANY_LOCATION',
        'hint_account_annual_revenue': 'LBL_HINT_COMPANY_ANNUAL_REVENUE',
        'hint_account_description': 'LBL_HINT_COMPANY_DESCRIPTION',
        'hint_account_naics_code_lbl': 'LBL_HINT_COMPANY_NAICS_CODE_LABEL',
        'hint_account_sic_code_label': 'LBL_HINT_COMPANY_SIC_CODE_LABEL',
        'hint_account_fiscal_year_end': 'LBL_HINT_COMPANY_FISCAL_YEAR_END',
        'hint_account_founded_year': 'LBL_HINT_COMPANY_FOUNDED_YEAR',
        'hint_account_facebook_handle': 'LBL_HINT_COMPANY_FACEBOOK',
        'hint_account_twitter_handle': 'LBL_HINT_COMPANY_TWITTER',
        'hint_industry_tags': 'LBL_HINT_COMPANY_INDUSTRY_TAGS',
    },
    uniqueEmail: '',
    /**
     * hintPanelFields array needs to be updated when we update the fields in the hint panel view.
     */
    hintPanelFields: [
        'title',
        'phone_work',
        'phone_mobile',
        'phone_other',
        'website',
        'hint_education',
        'hint_education_2',
        'hint_job_2',
        'hint_facebook',
        'hint_twitter',
        'account_name',
        'hint_account_website',
        'hint_account_size',
        'hint_account_industry',
        'hint_account_location',
        'hint_account_annual_revenue',
        'hint_account_description',
        'hint_account_naics_code_lbl',
        'hint_account_sic_code_label',
        'hint_account_fiscal_year_end',
        'hint_account_founded_year',
        'hint_account_facebook_handle',
        'hint_account_twitter_handle',
        'hint_industry_tags'
    ],
    preFilledDataFields: [],
    modelDiffFlag: true,
    previousAccountsName: '',
    previousAccountsWebsite: '',
    cancelName: false,
    previousBeanAccountsFields: '',
    phoneFieldTypes: ['phone_work', 'phone_other', 'phone_mobile'],

    /**
     * Use this field names to send to person enrichment.
     * Why? Data exposure, we only send fields to our endpoint that it really needs
     * We don't need all the data anyway for enriching people.
     * Enriched attribute list is also extract from this list. So the item order in this list matters.
     *
     * @return {Array} [description]
     */
    getFieldNamesForSending: function() {
        if (this.moduleName === 'Accounts') {
            return [
                'annual_revenue',
                'description',
                'email1',
                'hint_account_facebook_handle',
                'hint_account_fiscal_year_end',
                'hint_account_founded_year',
                'hint_account_industry',
                'hint_account_industry_tags',
                'hint_account_location',
                'hint_account_logo',
                'hint_account_pic',
                'hint_account_naics_code_lbl',
                'hint_account_size',
                'name',
                'sic_code',
                'tag',
                'website'
            ];
        } else {
            return [
                'title',
                'phone_work',
                'email',
                'account_name',
                'hint_education',
                'hint_education_2',
                'hint_job_2',
                'hint_facebook',
                'hint_twitter',
                'hint_account_website',
                'hint_account_size',
                'hint_account_industry',
                'hint_account_location',
                'hint_account_description',
                'hint_account_founded_year',
                'hint_account_facebook_handle',
                'hint_account_twitter_handle',
                'hint_industry_tags',
                'hint_account_naics_code_lbl',
                'hint_account_sic_code_label',
                'hint_account_fiscal_year_end',
                'hint_account_annual_revenue',
                'hint_photo',
                'picture',
                'phone_other',
                'phone_home',
                'full_name',
                'phone_mobile',
                'hint_account_logo',
                'lead_source',
                'first_name',
                'last_name',
                'salutation',
                'alt_address_city',
                'alt_address_country',
                'alt_address_postalcode',
                'alt_address_state',
                'alt_address_street',
                'primary_address_city',
                'primary_address_country',
                'primary_address_postalcode',
                'primary_address_state',
                'primary_address_street',
                'twitter',
                'website',
            ];
        }
    },

    enrichLeadsAttributeList: [
        'title',
        'phone_work',
        'hint_phone_1',
        'hint_phone_2',
        'email',
        'account_name',
        'hint_education',
        'hint_education_2',
        'hint_job_2',
        'hint_facebook',
        'hint_twitter',
        'hint_account_website',
        'hint_account_size',
        'phone_mobile',
        'phone_other',
        'hint_account_industry',
        'hint_account_location',
        'hint_account_description',
        'hint_account_founded_year',
        'hint_account_facebook_handle',
        'hint_account_twitter_handle',
        'hint_industry_tags',
        'hint_account_naics_code_lbl',
        'hint_account_sic_code_label',
        'hint_account_fiscal_year_end',
        'hint_account_annual_revenue',
    ],

    enrichAccountsAttributeList: [
        'name',
        'website',
        'description',
        'sic_code',
        'annual_revenue',
        'twitter',
        'hint_account_size',
        'hint_account_location',
        'hint_account_industry',
        'hint_account_founded_year',
        'hint_account_facebook_handle',
        'hint_account_industry_tags',
        'hint_account_naics_code_lbl',
        'hint_account_fiscal_year_end',
    ],

    saveLeadsDisableAttrList: [
        'hint_account_logo',
        'hint_photo',
        'account_name'
    ],

    saveAccountsDisableAttrList: [
        'hint_account_logo',
        'name'
    ],

    /**
     * Ends with
     *
     * @param {string} string
     * @param {string} searchTerm
     * @return {boolean}
     */
    endsWith: function(string, searchTerm) {
        var position = string.length - searchTerm.length;
        var lastIndex = string.lastIndexOf(searchTerm, position);
        return lastIndex === position;
    },

    /**
     * Starts with
     *
     * @param {string} string
     * @param {string} searchTerm
     * @return {boolean}
     */
    startsWith: function(string, searchTerm) {
        return string.substr(0, searchTerm.length) === searchTerm;
    },

    // Converts the given SugarInternal bean into Stage2 bean. This is needed before invoking
    // data enrichment on Stage2.
    convertSugarBeanToHintPayload: function(siBean) {
        var stage2bean = {};
        _.each(siBean, function(value, key) {
            if (key.length > this.SUGAR_INTERNAL_FIELD_SUFFIX.length + this.SUGAR_INTERNAL_FIELD_PREFIX.length &&
                this.endsWith(key, this.SUGAR_INTERNAL_FIELD_SUFFIX) &&
                this.startsWith(key, this.SUGAR_INTERNAL_FIELD_PREFIX)) {
                // remove suffix and prefix
                var newKey = key.substr(0, key.length - this.SUGAR_INTERNAL_FIELD_SUFFIX.length);
                newKey = newKey.replace(this.SUGAR_INTERNAL_FIELD_PREFIX, '');
                stage2bean[newKey] = value;
            } else {
                stage2bean[key] = value;
            }
        }, this);

        if (this.moduleName === 'Accounts') {
            if (!_.isEmpty(siBean.email) && _.isArray(siBean.email)) {
                stage2bean.email1 = siBean.email[0].email_address;
                if (siBean.email[1] && !_.isEmpty(siBean.email[1])) {
                    stage2bean.email2 = siBean.email[1].email_address;
                }
            }
        }
        return stage2bean;
    },

    /**
     * Convert to account bean
     *
     * @param {Object} stage2bean
     * @param {Object} siBean
     * @return {Object}
     */
    _convertToAccountBean: function(stage2bean, siBean) {
        var self = this;
        // We are not enrich these fields, but they come from the returned bean.
        // To avoid inconsistence when save enrichment result, omit these fields.
        stage2bean = _.omit(stage2bean, 'billing_address_city', 'billing_address_state',
            'billing_address_postalcode', 'billing_address_country', 'billing_address_street', 'ownership',
            'ticker_symbol');

        _.each(stage2bean, function(value, key) {
            if (this.startsWith(key, 'account_')) {
                if (key === 'account_twitter_handle') {
                    siBean.twitter = 'http://www.twitter.com/' + value;
                } else {
                    //re-map the naic code
                    if (key === 'account_naics_code_label') {
                        key = 'account_naics_code_lbl';
                    } else if (key === 'account_facebook_handle') {
                        value = (value.indexOf('www.facebook.com/') > -1) ? value : 'www.facebook.com/' + value;
                    }
                    siBean[self.SUGAR_INTERNAL_FIELD_PREFIX + key + self.SUGAR_INTERNAL_FIELD_SUFFIX] = value;
                }
            } else {
                if (key === 'annual_revenue') {
                    // Since from data provider we get value in USD app.user.getPreference('currency_symbol')
                    //should always be $.
                    // Annual Revenue field value being string by default check has been applied.
                    value = (typeof value !== 'string') ? '$' + value.toLocaleString() : value;
                }
                siBean[key] = value;
            }
        }, this);
        return siBean;
    },


    /**
     * Convert to lead bean
     *
     * @param {Object} stage2bean
     * @param {Object} siBean
     * @return {Object}
     */
    _convertToLeadBean: function(stage2bean, siBean) {
        _.each(stage2bean, function(value, key) {
            switch (key) {
                case 'phone_work':
                case 'phone_mobile':
                case 'phone_other':
                    siBean = this._distributePhones(siBean, key, value);
                    break;
                case 'account_name':
                case 'title':
                    siBean[key] = value;
                    break;
                case 'account_domain':
                    if (_.isEmpty(siBean.hint_account_website) && !_.isEmpty(value)) {
                        siBean.hint_account_website = 'http://' + value;
                    }
                    break;
                case 'account_naics_code_label':
                    siBean[this.SUGAR_INTERNAL_FIELD_PREFIX + 'account_naics_code_lbl' +
                        this.SUGAR_INTERNAL_FIELD_SUFFIX] = value;
                    break;

                case 'account_annual_revenue':
                    // Since from data provider we get value in USD app.user.getPreference('currency_symbol')
                    //should always be $.
                    // Annual Revenue field value being string by default check has been applied.
                    value = (typeof value !== 'string') ? '$' + value.toLocaleString() : value;
                // fall through deliberately
                default:
                    if (key === 'account_twitter_handle') {
                        value = 'www.twitter.com/' + value;
                    } else if (key === 'account_facebook_handle') {
                        value = (value.indexOf('www.facebook.com/') > -1) ? value : 'www.facebook.com/' + value;
                    }
                    siBean[this.SUGAR_INTERNAL_FIELD_PREFIX + key + this.SUGAR_INTERNAL_FIELD_SUFFIX] = value;
            }
        }, this);

        // For erase field feature.
        if (this._erasedFields && _.contains(this._erasedFields, 'phone_work')) {
            if (siBean.hint_phone_1 && siBean.hint_phone_1 !== '' && !_.contains(this._erasedFields, 'hint_phone_1')) {
                this._erasedFields.push('hint_phone_1');
                siBean.hint_phone_1 = '';
            }
            if (siBean.hint_phone_2 && siBean.hint_phone_2 !== '' && !_.contains(this._erasedFields, 'hint_phone_2')) {
                this._erasedFields.push('hint_phone_2');
                siBean.hint_phone_2 = '';
            }
        }
        if (this.moduleName === 'Leads' && this._erasedFields && _.contains(this._erasedFields, 'website')) {
            siBean.hint_account_website = '';
            this.$('[data-name="hint_account_website"]').children('#hint_website_erased').removeClass('hidden');
        }
        if (this.moduleName === 'Contacts' && this._erasedFields && _.contains(this._erasedFields, 'account_name')) {
            siBean.account_name = '';
            siBean.hint_account_logo = '';
        }

        return siBean;
    },

    /**
     * Convert hint payload to SugarBean
     *
     * @param {Object} stage2bean
     * @return {Object}
     */
    convertHintPayloadToSugarBean: function(stage2bean) {
        if (this.moduleName !== 'Accounts') {
            if (!stage2bean.account_name && !this._originalModel.get('account_name')) {
                if (!_.contains(this._erasedFields, 'account_name')) {
                    this.$('[data-type="text"][data-name="account_name"]')
                        .append('<div class="ellipsis_inline not_found">'
                        .concat(app.lang.get('LBL_HINT_PREVIEW_NO_ACCOUNT_INFO'), '</div>'));
                }
            }
        }
        siBean = (this.moduleName === 'Accounts') ?
            this._convertToAccountBean(stage2bean, {}) : this._convertToLeadBean(stage2bean, {});
        // Skip empty (non-enriched) values.
        siBean = _.omit(siBean, function(value, key) {
            return this._isEmpty(value);
        }, this);

        if (this.moduleName === 'Accounts') {
            // Remove email1, email2 from attrs
            siBean = _.omit(siBean, function(value, key) {
                return key === 'email1' || key === 'email2' || key === 'email3' || key === 'email4';
            }, this);
        }
        return siBean;
    },

    /**
     * Distribute phones
     * Delete the enriched phone numbers also in original model and fill the rest into siBean in order.
     *
     * @param {Object} siBean
     * @param {string} key
     * @param {string} value
     * @return {Object}
     */
    _distributePhones: function(siBean, key, value) {
        siBean[key] = value ? value : '';
        return siBean;
    },

    /**
     * Track event
     *
     * @param {string} category
     * @param {string} action
     */
    _trackEvent: function(category, action) {
        if (!this.instanceId) {
            return;
        }
        var eventObject = {
            category: this.moduleName + category,
            action: action,
            label: this.instanceId
        };
        if (app.analytics && app.analytics.connector) {
            app.analytics.connector.trackEvent(eventObject);
        }
    },

    /**
     * Get the error code
     *
     * @param err
     */
    _setStage2ErrorCode: function(err) {
        if (_.isUndefined(this._stage2ErrorCode)) {
            this._stage2ErrorCode = err.status;
            this.isValidVersion = (SUGAR.App.hint.versionCompare() >= 0);
            this.oldHintPreview = SUGAR.App.hint.shouldUseOldHintPreview(this.moduleName);
            this.isListView = SUGAR.App.hint.isListView();
            this.trigger('changed:_stage2ErrorCode');
        }
    },

    /**
     * Set the field view model
     */
    _setFieldViewModel: function() {
        var self = this;
        _.each(this.metadata, function(panel) {
            _.each(panel.fields, function(field) {
                //For account fields we need set the true parent model.
                // This should be derived from metadata in the near future but trying to minimize
                // the chance of regression for the v4.0 fix.
                if (self.moduleName !== 'Accounts' &&
                    (panel.name == 'company_info' ||
                    panel.name == 'company_extended') && !/^hint_[\w]*/i.test(field.name)) {
                    if (field.type !== 'enum') {
                        field.model = self.model;
                    } else {
                        //Hint prefixed fields belong to the parent module
                        field.model = self.account_model;
                    }
                } else {
                    field.model = self.model;
                }
            });
        });
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.options = options;
        var self = this;
        this._super('initialize', [options]);
        this.isDarkMode = app.hint.isDarkMode();
        var isAccountCreateDrawerOpen = (SUGAR.App.router._currentFragment === 'Accounts/create');
        this.isValidVersion = (app.hint.versionCompare() >= 0);
        this.metadata = options.meta.panels = app.hint.getPanelMetadata(options.module);
        this.configedFields = [];
        this.preFilledDataFields = [],
            self.modelDiffFlag = true;
        _.each(options.meta.panels, function(panel) {
            _.each(panel.fields, function(field) {
                self.configedFields.push(field.name);
            });
        });

        this.dataView = 'stage2-preview';
        this._activeRequest = null;
        this._parentDataView = this.context.parent.get('dataView');
        this._delegateEvents();
        this.moduleName = this.context.get('module');
        this.isModuleAdmin = _.isUndefined(app.user.getAcls()[this.moduleName].admin);
        this.stage2CreateMode = this.context.parent.get('create');
        this.enrichAttributeList =
            (this.moduleName === 'Accounts') ? this.enrichAccountsAttributeList : this.enrichLeadsAttributeList;
        this.saveDisableAttrList =
            (this.moduleName === 'Accounts') ? this.saveAccountsDisableAttrList : this.saveLeadsDisableAttrList;
        this._originalModel = this.model;
        this.lastFetchedName = '';

        // Clears the hint pic if sugar picture is already loaded by the user.
        if (this._originalModel.get('picture')) {
            this._originalModel.save('hint_contact_pic', '');
        }

        // empties the queue which stores the previous Account Name.
        if (isAccountCreateDrawerOpen) {
            self.previousAccountQueue = [];
        }
        // The updateModel() is called to render the Accounts Module, when the saved record is about to render
        // to get the updated data from the record view.
        if (this.moduleName === 'Accounts' && !isAccountCreateDrawerOpen) {
            self._updateModel();
        }

        this.model = this.model.clone();
        this.account_model = app.data.createBean('Accounts', {});

        var leadsAttrs = self.getFieldNamesForSending();

        self.fetchNewData = this._originalModel.clone();
        self.fetchNewDataAccounts = this._originalModel.clone();

        _.each(leadsAttrs, function(field) {
            if (field !== 'email' && field !== 'first_name' && field !== 'last_name') {
                self.fetchNewData.attributes[field] = '';
            }
        });

        _.each(leadsAttrs, function(field) {
            if (field !== 'name' && field !== 'website' && !self.context.get('model').exitDropdownNoEnrich) {
                self.fetchNewDataAccounts.attributes[field] = '';
            }
        });

        this._setFieldViewModel();

        this._callRetryCounter = 0;

        if (this.moduleName === 'Leads') {
            this.saveDisableAttrList = _.without(this.saveDisableAttrList, 'account_name');
        }

        this._callStage2API('GET', 'stage2/params', {
            success: function(data) {
                self.instanceId = data.instanceId;
                if (app.analytics && app.analytics.connector) {
                    app.analytics.connector.set('&uid', data.analyticsUserId);
                    app.analytics.connector.set('dimension1', data.instanceId);
                }
            },
            error: function(err) {
                return;
            }
        });

        this.on('changed:_stage2ErrorCode', this.render, this);
        this.on('changed:_hintRequestCompleted', this.render, this);

        if (this.stage2CreateMode) {
            // Make sure the orginal model has all hint attributes.
            this._resetModel();

            app.events.on('hint:user-input', function(_keyAttrChanged) {
                if (_keyAttrChanged) {
                    self._updateModel();
                } else {
                    this.model.set(_.omit(self._originalModel.changedAttributes(), 'phone_work'));
                }
            }, this);

            this.on('hint:user-save', function() {
                this.model.set(_.omit(self._originalModel.changedAttributes(), 'phone_work'));
            }, this);
        } else {
            // On list view, if the model changed before preview called, sync already happened during change
            // So listento sync won't trigger '_updateModel', we have to call '_updateModel' directly.
            if (this._parentDataView === 'list' && !_.isEmpty(this._originalModel.changed)) {
                this._updateModel();
            } else {
                this.listenToOnce(this._originalModel, 'sync', this._updateModel);
            }
        }
    },

    /**
     * Reset model
     */
    _resetModel: function() {
        var _resetParams = {};
        _.each(this.enrichAttributeList.concat(this.saveDisableAttrList), function(item) {
            if (!this._originalModel.has(item)) {
                _resetParams[item] = '';
            }
        }, this);
        this._originalModel.set(_resetParams, {
            silent: true
        });
    },

    /**
     * Handle phones
     *
     * @param {string} phoneStr
     */
    _handlePhones: function(phoneStr) {
        if (this.moduleName === 'Leads') {
            this.model.set('hint_account_website', this._originalModel.get('website') || '');
        }
    },

    /**
     * Update model
     */
    _updateModel: function() {
        var self = this;
        self._setFieldViewModel();

        if (this.model) {
            this.model.set(this._originalModel.attributes);
            if (this.moduleName !== 'Accounts') {
                this._handlePhones(this._originalModel.get('phone_work'));
            }
            this.$('[data-name="saveAll"]').tooltip({
                title: 'Data enrichment is processing.',
                placement: 'left'
            });
            self._erasedFields = self.model.get('_erased_fields');

            // Get account ID first.
            var account = this.model.get('accounts');
            if (this.moduleName === 'Contacts' && account && account.id && !_.isEmpty(account.id)) {
                var accountBean = app.data.createBean('Accounts', {
                    id: account.id
                });
                accountBean.fetch({
                    success: function(accountBean) {
                        if (_.contains(accountBean.get('_erased_fields'), 'name')) {
                            self._erasedFields.push('account_name');
                        }
                        self.account_model = accountBean;
                        self._setFieldViewModel();
                        self._enrichModel();
                    },
                    error: function(err) {
                        app.logger.error('Failed to fetch accountBean: ' + JSON.stringify(err));
                        self._enrichModel();
                    }
                });
            } else {
                this._enrichModel();
            }
        }
    },

    /**
     * Delegate events
     */
    _delegateEvents: function() {
        app.events.on('preview:collection:change', this.showPreviousNextBtnGroup, this);
        app.events.on('preview:module:update', this.updatePreviewModule, this);
        if (this.layout) {
            this.layout.on('preview:pagination:fire', this.switchPreview, this);
        }
    },

    /**
     * Update preview module
     *
     * @param {string} module
     */
    updatePreviewModule: function(module) {
        this.previewModule = module;
    },

    /**
     * Filter collection
     */
    filterCollection: function() {
        this.collection.remove(_.filter(this.collection.models, function(model) {
            return !app.acl.hasAccessToModel('view', model);
        }, this), {
            silent: true
        });
    },

    /**
     * Set editable fields
     */
    setEditableFields: function() {
        this.editableFields = [];
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this.showPreviousNextBtnGroup();
        app.view.View.prototype._renderHtml.call(this);
    },

    /**
     * Show previous and next buttons groups on the view.
     * This gets called everytime the collection gets updated. It also depends
     * if we have a current model or layout.
     */
    showPreviousNextBtnGroup: function() {
        if (!this.model || !this.layout) {
            return;
        }

        var collection = this.collection;
        if (!collection || !collection.size()) {
            this.layout.hideNextPrevious = true;
            // Need to rerender the preview header
            this.layout.trigger('preview:pagination:update');
            return;
        }

        var recordIndex = collection.indexOf(collection.get(this.model.id));
        this.layout.previous = collection.models[recordIndex - 1] ? collection.models[recordIndex - 1] : undefined;
        this.layout.next = collection.models[recordIndex + 1] ? collection.models[recordIndex + 1] : undefined;
        this.layout.hideNextPrevious = _.isUndefined(this.layout.previous) && _.isUndefined(this.layout.next);

        // Need to rerender the preview header
        this.layout.trigger('preview:pagination:update');
    },

    /**
     * Switch model
     *
     * @param {Object} model
     */
    switchModel: function(model) {
        this.stopListening(this._originalModel);
        this._originalModel = model;
        model = model.clone();
        this.model = model;

        // Close preview when model destroyed by deleting the record
        this.listenTo(this.model, 'destroy', function() {
            // Remove the decoration of the highlighted row
            app.events.trigger('list:preview:decorate', false);
            // Close the preview panel
            app.events.trigger('preview:close');
        });

        if (this._parentDataView === 'list' && !_.isEmpty(this._originalModel.changed)) {
            this._updateModel();
        } else {
            this.listenToOnce(this._originalModel, 'sync', this._updateModel);
        }
    },

    /**
     * Switches preview to left/right model in collection.
     *
     * @param {Object} data
     * @param {string} data.direction Direction that we are switching to, either 'left' or 'right'.
     * @param index Optional current index in list
     * @param id Optional
     * @param module Optional
     */
    switchPreview: function(data, index, id, module) {
        var currID = id || this.model.get('id');
        var currIndex = index || _.indexOf(this.collection.models, this.collection.get(currID));

        if (this.switching || this.collection.models.length < 2) {
            // We're currently switching previews or we don't have enough models, so ignore any pagination click events.
            return;
        }
        this.switching = true;

        if (data.direction === 'left' && (currID === _.first(this.collection.models).get('id')) ||
            data.direction === 'right' && (currID === _.last(this.collection.models).get('id'))) {
            this.switching = false;
            return;
        } else {
            // We can increment/decrement
            data.direction === 'left' ? currIndex -= 1 : currIndex += 1;
            //Reset the preview
            app.events.trigger('preview:render', this.collection.models[currIndex], this.collection, true);
            this.switching = false;
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        var self = this;
        if (this.collection) {
            this.collection.on('reset', this.filterCollection, this);
            // when remove active model from collection then close preview
            this.collection.on('remove', function(model) {
                if (model && this.model && (this.model.get('id') == model.get('id'))) {
                    // Remove the decoration of the highlighted row
                    app.events.trigger('list:preview:decorate', false);
                    // Close the preview panel
                    app.events.trigger('preview:close');
                }
            }, this);
        }

        // Update model in list view.
        this.context.on('change:model', function(ctx, model) {
            this.switchModel(model);
            self.isHintRequestLoading = true;
            this.render();
        }, this);

        // Update model in record view.
        if (this.moduleName === 'Leads' || this.moduleName === 'Contacts' || this.moduleName === 'Accounts') {
            if (this._parentDataView === 'record') {
                self._updateModel();
            }
        }
    },

    /**
     * Check if is empty value
     *
     * @param {string} value
     * @return {Object}
     */
    _isEmpty: function(value) {
        if (_.isUndefined(value) || _.isNull(value) || _.isNaN(value)) {
            return true;
        }
        if (_.isNumber(value)) {
            return false;
        }
        if (_.isString(value)) {
            return value.trim() === '';
        }
        // Object and array.
        return _.isEmpty(value);
    },

    /**
     * Issue data enrichment request
     * Apply the data enrichment
     *
     * @param {string} type
     * @param {string} url
     * @param {Object} data
     * @param {Object} options
     */
    issueDataEnrichmentRequest: function(type, url, data, options) {
        var self = this;
        if (self._activeRequest) {
            self._activeRequest.abort();
        }
        self.isHintRequestLoading = true;
        self.isValidVersion = (SUGAR.App.hint.versionCompare() >= 0);
        self.oldHintPreview = SUGAR.App.hint.shouldUseOldHintPreview(this.moduleName);
        self.isListView = SUGAR.App.hint.isListView();
        self.trigger('changed:_hintRequestCompleted');

        if (!app.hint.isEnrichedModel(data.moduleName)) {
            return;
        }
        // it is time to apply the data enrichment
        self._activeRequest = $.ajax({
            type: type,
            url: url,
            data: data,
            headers: {
                authToken: self._stage2accessToken
            },
            success: function(data) {
                if (self.disposed === true) {
                    return;
                }
                options && options.success && options.success(data);
            },
            error: function(err) {
                options && options.error && options.error(err);
            }
        });
    },

    /**
     * Issue request
     *
     * @param {string} type
     * @param {string} url
     * @param {Object} data
     * @param {Object} options
     * @return {Object}
     */
    _issueRequest: function(type, url, data, options) {
        var self = this;
        return $.ajax({
            type: type,
            url: url,
            data: data,
            headers: {
                authToken: self._stage2accessToken
            },
            success: function(data) {
                options && options.success && options.success(data);
            },
            error: function(err) {
                options && options.error && options.error(err);
            }
        });
    },

    /**
     * Track response
     *
     * @param {Object} data
     */
    _trackResponse: function(data) {
        // Tracking enrichment request event.
        this._trackEvent(' Enrichment - List View Preview', 'Request Enrichment');
        if (data && data.enriched) {
            this._trackEvent(' Enrichment - List View Preview', 'Non-Empty Response');
        } else {
            this._trackEvent(' Enrichment - List View Preview', 'Empty Response');
        }
    },

    /**
     * Record metrics token
     * Encapsulate access to storage representation
     *
     * @param {Object} data
     */
    _recordMetricsToken: function(data) {
        app.user.set('hintMetricsToken', data.metricsToken);
    },

    /**
     * Dispose hint view
     */
    _disposeHintView: function() {
        if (this.stage2CreateMode) {
            app.events.trigger('preview:close');
            this.context.parent.trigger('app:preview:stage2-show-notification');
            return;
        }
        this.$('[data-name="saveAll"]').remove();
        if (this.moduleName !== 'Accounts') {
            if (!this._originalModel.get('account_name')) {
                this.$('[data-type="text"][data-name="account_name"]').innerHTML = ''
                    .concat(
                        '<div class="ellipsis_inline not_found">',
                        app.lang.get('LBL_HINT_PREVIEW_NO_ACCOUNT_INFO'),
                        '</div>'
                    );
            }
        }
    },

    /**
     * If the bean is the same with original model, means no data enriched.
     *
     * @param {Object} bean
     * @return {boolean}
     */
    _beanEnriched: function(bean) {
        bean = _.omit(bean, 'hint_first_name_c', 'hint_last_name_c', 'hint_full_name_c');
        var enrichedAttrs = _.pick(bean, function(value, key) {
            return this._isEmpty(this._originalModel.get(key)) && !this._isEmpty(value);
        }, this);
        return !_.isEmpty(enrichedAttrs) ? true : false;
    },

    /**
     * Called after finishing account enrichment process in the create drawer. Used to reset back to initial state
     * where we auto fill enrichment results based on the account selected from the dropdown. Only when the user
     * prematurely tabs/clicks out of the dropdown do we not want to autofill the enrichment results.
     */
    _resetEnrichAutoFillState: function() {
        var isAccountCreateDrawerOpen = (SUGAR.App.router._currentFragment === 'Accounts/create');
        if (isAccountCreateDrawerOpen && this.context) {
            this.context.get('model').exitDropdownNoEnrich = false;
            this.shouldShowHintCloudLogo = false;
        }
    },

    /**
     * Enrich model
     */
    _enrichModel: function() {
        var self = this;

        if (_.isEmpty(this.enrichFieldsOptions)) {
            this._callStage2API('read', 'hint/enrich/config', {
                success: function(data) {
                    var rawConfigData = data.response.config_data;
                    if (rawConfigData) {
                        self.enrichFieldsOptions = JSON.parse(rawConfigData);
                        self._enrichModel();
                    }
                },
                error: function(err) {
                    app.logger.error('Failed to reach hint/enrich/config' + JSON.stringify(err));
                }
            });
            return;
        }

        var isCreateDrawerAccountsOpen = SUGAR.App.router._currentFragment === 'Accounts/create';

        // Show cloud icons for downloading in two cases
        // 1. User is in the accounts create drawer and has tabbed/clicked out of the account name dropdown
        // 2. User is in the contacts/leads create drawer
        if (this.context) {
            this.shouldShowHintCloudLogo =
                isCreateDrawerAccountsOpen ? this.context.get('model').exitDropdownNoEnrich : true;
        }

        var accountsHintFields = this.enrichAccountsAttributeList;

        if ((this.moduleName === 'Leads' || this.moduleName === 'Contacts') && this._parentDataView === 'list') {
            this.fetchNewData.attributes.id = this._originalModel.attributes.id;
            this.fetchNewData.attributes.first_name = this._originalModel.attributes.first_name;
            this.fetchNewData.attributes.last_name = this._originalModel.attributes.last_name;
            this.fetchNewData.attributes.email = this._originalModel.attributes.email;
        }

        if (this._callRetryCounter > 3) {
            this._callRetryCounter = 0;
            this.$('[data-name="saveAll"]').remove();
            this._resetEnrichAutoFillState();
            return;
        } else if (this._callRetryCounter !== 0) {
            app.logger.debug('Data enrichment retry #' + this._callRetryCounter);
        }

        _.each(accountsHintFields, function(field) {
            if (field !== 'name' && field !== 'website' && self._originalModel.get(field) && self.modelDiffFlag) {
                self.containsPreAccountFields = true;
                if (!self.includes(self.preFilledDataFields, field)) {
                    self.preFilledDataFields.push(field);
                }
            }
        });

        this.modelDiffFlag =  false;

        if (_.isEmpty(self._stage2urlV2)) {
            this._callStage2API('GET', 'stage2/params', {
                success: function(data) {
                    self._enrichModel();
                },
                error: function(err) { }
            });
            return;
        }

        if (!self._stage2accessToken) {
            this._callStage2API('create', 'stage2/token', {
                success: function(data) {
                    self._stage2accessToken = data.accessToken;
                    self._subscriptionType = data.subscriptionType;
                    self._enrichModel();
                },
                error: function(err) { }
            });
            return;
        }
        var username = null;
        if (app.user && app.user.attributes) {
            username = app.user.attributes.user_name;
        }

        var instanceId = app.config.uniqueKey;

        // clearing the originalModuleAttributes, so that the SIBean will enrich all of the data.
        // checking if there are already some fields populated.
        if (isCreateDrawerAccountsOpen) {
            if (((this.previousAccountsName !== this._originalModel.get('name')) &&
                !_.isEmpty(this._originalModel.get('name'))) || this.cancelName) {
                this.cancelName = false;
                _.each(accountsHintFields, function(field) {
                    //enriches new data based on account name. It handles pre-typed data on the record view to be saved.
                    if (field !== 'name' && self._originalModel.get(field) &&
                        !self.includes(self.preFilledDataFields, field)) {
                        self.containsPreAccountFields = true;
                        if (self.preFilledDataFields.length) {
                            self.fetchNewDataAccounts.attributes[field] = '';
                        } else if (!self.shouldShowHintCloudLogo) {
                            self._originalModel.attributes[field] = '';
                        }
                    }
                });
            } else if (((this.previousAccountsWebsite !== this._originalModel.get('website')) &&
                !_.isEmpty(this._originalModel.get('website'))) || this.cancelName) {
                _.each(accountsHintFields, function(field) {
                    //enriches new data based on account website.
                    //It handles pre-typed data on the record view to be saved.
                    if (field !== 'website' && self._originalModel.get(field) &&
                    !self.includes(self.preFilledDataFields, field)) {
                        self.containsPreAccountFields = true;
                        if (self.preFilledDataFields.length) {
                            self.fetchNewDataAccounts.attributes[field] = '';
                        } else if (!self.shouldShowHintCloudLogo) {
                            self._originalModel.attributes[field] = '';
                        }
                    }
                });
            }
        }
        this.fetchNewDataAccounts.attributes.name = this._originalModel.attributes.name;
        this.fetchNewDataAccounts.attributes.website = this._originalModel.attributes.website;
        var SIBean = (this.moduleName === 'Leads' || this.moduleName === 'Contacts') ?
            JSON.stringify(this.convertSugarBeanToHintPayload(
                _.pick(this.fetchNewData.attributes, this.getFieldNamesForSending()))) :
            JSON.stringify(this.convertSugarBeanToHintPayload(
                _.pick(this.fetchNewDataAccounts.attributes, this.getFieldNamesForSending())));

        var endpoint = this.moduleName === 'Accounts' ? '/enrich-account-bean' : '/enrich-person-bean';
        this._attrsToSave = {};

        // This check is to prevent multiple API calls when the user is on the create drawer and tries to make
        // an another search for other candidate (Leads or Contacts).
        this.issueDataEnrichmentRequest('GET', this._stage2urlV2 + endpoint, {
            bean: SIBean,
            username: username,
            instanceId: instanceId,
            moduleName: self.moduleName,
            subscriptionType: self._subscriptionType
        }, {
            success: function(data) {
                if (self.disposed === true) {
                    return;
                }
                if (self.moduleName === 'Accounts' && self.isCreateDrawerAccountsOpen) {
                    // 'exitDropdownNoEnrich' will be true when the user tabs/clicks out of the name/website field (we
                    // don't want to auto enrich when tabbing/clicking out of the dropdown). Generally, when we tab out,
                    // we want to show the cloud icons for downloading. When the user tabs out of the account name from
                    // the dropdown and it's NOT the same as the account name from the previously fetched data
                    //(especially when the account to enrich was inferred from the website provided by the user),
                    //then we want to show the clouds. However, if the previous scenario were the same except that the
                    //previous account fetched was the same as the account we just tried to fetch now, then we don't
                    //show the cloud icons.
                    var previousAndCurrentNameEqual =
                        data.bean.name.toLowerCase() === self.lastFetchedName.toLowerCase();
                    if (self.context.get('model').exitDropdownNoEnrich && !previousAndCurrentNameEqual) {
                        self.shouldShowHintCloudLogo = true;
                    } else if (previousAndCurrentNameEqual) {
                        self.shouldShowHintCloudLogo = false;
                    }
                }

                self._activeRequest = null;
                self._callRetryCounter = 0;
                self._trackResponse(data);
                self._recordMetricsToken(data);
                self.isHintRequestLoading = false;
                self.trigger('changed:_hintRequestCompleted');

                if (self.$('[data-name="saveAll"]')) {
                    self.$('[data-name="saveAll"]').tooltip('destroy');
                }
                if (self.disposed || !data || !data.enriched) {
                    self._disposeHintView();
                    self._resetEnrichAutoFillState();
                    return;
                }

                var bean = self.convertHintPayloadToSugarBean(data.bean);

                var AccountName = self._originalModel.get('name') || bean.name ||  self.previousAccountsName;
                var websiteName = self._originalModel.get('website') || bean.website || self.previousAccountsWebsite;
                var previousAccountName = bean.name;

                if (previousAccountName === AccountName && !_.isEmpty(previousAccountName) &&
                    !self.shouldShowHintCloudLogo) {
                    previousAccountName = self.previousAccountQueue.pop();
                    self.previousAccountQueue.push(AccountName);
                }

                var beanAccountFields = self._getFieldsFromBean(bean);

                // this ensures the prefilled fields are cleared on successful bean enrichment.
                _.each(accountsHintFields, function(field) {
                    if (field !== 'name' && field !== 'website' && bean[field]) {
                        self.preFilledDataFields = [];
                        self.modelDiffFlag = false;
                    }
                });

                if ((self.containsPreAccountFields) && isCreateDrawerAccountsOpen && !self.shouldShowHintCloudLogo) {
                    self._warningAlertForDuplicates(self, beanAccountFields, previousAccountName);
                    self.previousBeanAccountsFields = beanAccountFields;
                } else if (isCreateDrawerAccountsOpen) {
                    // so we need to show the preview clouds on tab out, when there's already account data pre existing
                    if (!self.shouldShowHintCloudLogo) {
                        self.model.set(beanAccountFields);
                        self._originalModel.set(beanAccountFields);
                        self.previousAccountsName = self._originalModel.get('name');
                        self.previousAccountsWebsite = self._originalModel.get('website');
                        self.previousBeanAccountsFields = beanAccountFields;
                    }
                }

                var shouldAllowUserOverwrite = true;
                _.each(bean, function(value, attr) {
                    if (attr !== 'website' && attr !== 'name' && bean[attr]) {
                        shouldAllowUserOverwrite = false;
                    }
                });

                if (shouldAllowUserOverwrite) {
                    shouldAllowUserOverwrite = false;
                    self._originalModel.attributes.website = websiteName;
                    self._originalModel.attributes.name = AccountName;
                }

                if (!self._beanEnriched(bean)) {
                    self._disposeHintView();
                    self._resetEnrichAutoFillState();
                    return;
                }

                if (self.isDarkMode) {
                    self.$('[data-name="saveAll"]').removeClass('hint-preview-icon-darkmode--loading');
                } else {
                    self.$('[data-name="saveAll"]').removeClass('hint-preview-icon--loading');
                }
                self._enrichHintDashletWithBean(bean);
                self._filterFieldsBasedOnConfig();
                self._fixLengthPhoneFields();

                if (self.moduleName === 'Leads') {
                    if (self.isDarkMode) {
                        self.$('.hint-preview-icon-darkmode--cloud[data-name="' +
                            'hint_account_website' + '"]').addClass('hidden');
                    } else {
                        self.$('.hint-preview-icon--cloud[data-name="' +
                            'hint_account_website' + '"]').addClass('hidden');
                    }
                }

                // Hide other two phone fields if there is no value.
                if (self.moduleName === 'Leads' || self.moduleName === 'Contacts') {
                    if (self._isEmpty(self.model.get('hint_phone_1'))) {
                        self.$('[data-name="hint_phone_1"]').closest('.row-fluid').addClass('hidden');
                    }
                    if (self._isEmpty(self.model.get('hint_phone_2'))) {
                        self.$('[data-name="hint_phone_2"]').closest('.row-fluid').addClass('hidden');
                    }
                }
                if (!_.isEmpty(self._attrsToSave)) {
                    if (self.isDarkMode) {
                        self.$('[data-name="saveAll"]').addClass('hint-preview-icon-darkmode--cloud').tooltip({
                            title: app.lang.get('LBL_HINT_PREVIEW_TOOLTIP_TITLE'),
                            placement: 'left'
                        });
                    } else {
                        self.$('[data-name="saveAll"]').addClass('hint-preview-icon--cloud').tooltip({
                            title: app.lang.get('LBL_HINT_PREVIEW_TOOLTIP_TITLE'),
                            placement: 'left'
                        });
                    }
                }
                self._resetEnrichAutoFillState();

                // Record the last account name at the very end of of handling the enrichment response.
                // This is used to help handle the cloud download icon displaying logic.
                self.lastFetchedName = data.bean.name;
            },
            error: function(err) {
                app.logger.error('Failed to enrich data on Hint: ' + JSON.stringify(err));
                self.isHintRequestLoading = false;
                self._activeRequest = null;

                // For aborted requests don't do anything: this avoids race conditions, repeated
                // aborted data enrichments and so on.
                if (err && err.statusText === 'abort') {
                    self._resetEnrichAutoFillState();
                    return;
                }
                self._stage2accessToken = null;
                // Track when response return with error.
                self._trackEvent(' Enrichment - List View Preview', 'Error Response');
                ++self._callRetryCounter;
                self._enrichModel();
            }
        });
    },

    /**
     * Get truncated phone based on field width
     *
     * @param {string} phone
     * @param {string} phoneField
     * @return {string}
     */
    _getTruncatedPhoneBasedOnFieldWidth: function(phone, phoneField) {
        var metadataOfModule = app.metadata.getModule(this.moduleName);
        var phoneFieldMetadataLength = metadataOfModule && metadataOfModule.fields[phoneField] &&
            metadataOfModule.fields[phoneField].len;
        if (!phoneFieldMetadataLength) {
            return phone;
        }
        return phone.substring(0, phoneFieldMetadataLength);
    },

    /**
     * Fix length phone fields
     */
    _fixLengthPhoneFields: function() {
        var self = this;
        _.each(this.phoneFieldTypes, function(phoneField) {
            var recordViewPhoneNumber = self._originalModel.get(phoneField);
            var phone = self.model.get(phoneField);
            var truncatedPhoneFromHint = phone && self._getTruncatedPhoneBasedOnFieldWidth(phone, phoneField);
            if (recordViewPhoneNumber === truncatedPhoneFromHint) {
                self._attrsToSave = _.omit(self._attrsToSave, phoneField);
                if (self.isDarkMode) {
                    self.$('.hint-preview-icon-darkmode--cloud[data-name="' + phoneField + '"]').addClass('hidden');
                } else {
                    self.$('.hint-preview-icon--cloud[data-name="' + phoneField + '"]').addClass('hidden');
                }
            }
        });
    },

    /**
     * Get fields from bean
     *
     * @param {Object} bean
     * @return {Object}
     */
    _getFieldsFromBean: function(bean) {
        return {
            'name': bean.name,
            'website': bean.website,
            'description': bean.description,
            'sic_code': bean.sic_code,
            'annual_revenue': bean.annual_revenue,
            'twitter': bean.twitter,
            'hint_account_size': bean.hint_account_size,
            'hint_account_location': bean.hint_account_location,
            'hint_account_industry': bean.hint_account_industry,
            'hint_account_founded_year': bean.hint_account_founded_year,
            'hint_account_facebook_handle': bean.hint_account_facebook_handle,
            'hint_account_industry_tags': bean.hint_account_industry_tags,
            'hint_account_naics_code_lbl': bean.hint_account_naics_code_lbl,
            'hint_account_fiscal_year_end': bean.hint_account_fiscal_year_end,
            'hint_account_pic':  bean.hint_account_logo
        };
    },

    /**
     * Filter fields based on config
     */
    _filterFieldsBasedOnConfig: function() {
        var currentModule = this.moduleName;
        var self = this;
        if (this.enrichFieldsOptions && this.enrichFieldsOptions[currentModule]) {
            var enrichField = this.enrichFieldsOptions[currentModule].fields;
            _.each(enrichField, function(value, attr) {
                if (!value) {
                    var isAccountSicCodeSpecialCase =
                        currentModule === 'Accounts' && attr === 'hint_account_sic_code_label';
                    if (isAccountSicCodeSpecialCase) {
                        var sicCodeFromRecordView = self.context.get('model').attributes.sic_code;
                        self.model.set('hint_account_sic_code_label', sicCodeFromRecordView);
                        if (self.isDarkMode) {
                            self.$('.hint-preview-icon-darkmode--cloud[data-name="' + attr + '"]').addClass('hidden');
                        } else {
                            self.$('.hint-preview-icon--cloud[data-name="' + attr + '"]').addClass('hidden');
                        }
                    } else {
                        self.model.set(attr, this.context.get('model').attributes[attr]);
                        if (self.isDarkMode) {
                            self.$('.hint-preview-icon-darkmode--cloud[data-name="' + attr + '"]').addClass('hidden');
                        } else {
                            self.$('.hint-preview-icon--cloud[data-name="' + attr + '"]').addClass('hidden');
                        }
                    }
                }
            }, this);
        }
    },

    /**
     * Get the new logo
     *
     * @param {Object} bean
     * @param attr
     */
    _newLogosFound: function(bean, attr) {
        var accountsSicFieldFound = this._accountContainsSICLabel(attr);
        var accountsEnrichPhotoViaWebsite = (this.moduleName === 'Accounts' && attr === 'website');
        var otherHintModules = ['Contacts', 'Leads'];
        var enrichPhotoViaTitle = (attr === 'title' && this.includes(otherHintModules, this.moduleName));

        if (accountsSicFieldFound) {
            return this._isFieldDifferent(bean, 'sic_code');
        } else if (accountsEnrichPhotoViaWebsite) {
            var doPhotoURLsDiffer = bean.hint_account_logo != this._originalModel.attributes.hint_account_pic;
            var doWebsitesDiffer = (attr === 'website' && bean[attr] != this._originalModel.attributes.website);
            return doPhotoURLsDiffer || doWebsitesDiffer;
        } else if (enrichPhotoViaTitle) {
            var doTitlesDiffer = attr === 'title' && bean[attr] != this._originalModel.attributes.title;
            var doPhotosDiffer = bean.hint_photo && bean.hint_photo != this._originalModel.attributes.hint_contact_pic;
            return doPhotosDiffer || doTitlesDiffer;
        } else {
            return this._isFieldDifferent(bean, attr);
        }
    },

    /**
     * Enrich hint dashlet with bean
     *
     * @param {Object} bean
     */
    _enrichHintDashletWithBean: function(bean) {
        var self = this;
        _.each(bean, function(value, attr) {
            var accountsSicFieldFound = self._accountContainsSICLabel(attr);
            var newDataFound = self._newLogosFound(bean, attr);

            // It checks if its an actual overwrite with same phone numbers but different order.
            var phoneTypeFields = ['phone_work', 'phone_other', 'phone_mobile'];
            if (self.includes(phoneTypeFields, attr)) {
                var recordHintPhoneFieldsArray = self._originalModel.attributes[attr] ?
                    self._originalModel.attributes[attr].split(', ') : [];
                var newHintPhoneFieldsArray = bean[attr] ? bean[attr].split(', ') : [];
                if (recordHintPhoneFieldsArray.length === newHintPhoneFieldsArray.length) {
                    newDataFound = recordHintPhoneFieldsArray.length !==
                        _.intersection(newHintPhoneFieldsArray, recordHintPhoneFieldsArray).length;
                }
            }

            // Tracking when specific field gets enriched by stage2.
            if (_.contains(self.enrichAttributeList, attr)) {
                self._trackEvent(' Enrichment - List View Preview', attr + ' enriched');
            }

            if (accountsSicFieldFound) {
                self.model.set('sic_code', bean.sic_code);
                self.model.set(attr, value);
            }

            // Only allow enrichment of fields that have enriched value but don't have
            // an pre-existing value themselves.
            if (_.contains(self.configedFields, attr) && (self._isEmpty(self.model.get(attr)) || newDataFound) &&
                !_.contains(self._erasedFields, attr)) {
                self.model.set(attr, value);
                if (!_.contains(self.saveDisableAttrList, attr)) {
                    // If the field is not allowed to edit, set lock icon.
                    if (!app.acl.hasAccessToModel('edit', self.model, attr)) {
                        self.$('[data-name="' + attr + '"][data-action="lock"]').removeClass('hidden');
                        //Hide the default no access span
                        self.$('.noaccess').addClass('hidden');
                    } else {
                        self._attrsToSave[attr] = value;
                        if (attr === 'hint_account_website' && self.moduleName === 'Leads') {
                            self._attrsToSave.website = value;
                        }
                        self.$('[data-name="' + attr + '"][data-action="copy"]').removeClass('hidden');
                    }
                }
            }
        }, this);
    },

    /**
     * Check if is different field
     *
     * @param {Object} bean
     * @param {string} attr
     * @return {boolean}
     */
    _isFieldDifferent: function(bean, attr) {
        return (bean[attr] != this._originalModel.attributes[attr]);
    },

    /**
     * @param {Array} arrayToCheck
     * @param {string} searchValue
     * @return {boolean}
     */
    includes: function(arrayToCheck, searchValue) {
        var returnValue = false;
        var pos = arrayToCheck.indexOf(searchValue);
        if (pos >= 0) {
            returnValue = true;
        }
        return returnValue;
    },

    /**
     * This function pops a warning message if any duplicates are found in the record.
     *
     * @param {Object} self is the 'this' object for the model.
     * @param {Object} beanAccountFields field objects which we get from the hint data provider to populate fields
     * @param {Object} previousAccountName it stores the name of previous account searched when user hits cancel.
     */
    _warningAlertForDuplicates: function(self, beanAccountFields, previousAccountName) {
        var showWarningMessage = false;
        if (!this.shouldShowHintCloudLogo) {
            var duplicateAccountCheck = (!_.isEqual(beanAccountFields, self.previousBeanAccountsFields) &&
                !_.isEmpty(self.previousBeanAccountsFields)) || self.containsPreAccountFields;
            _.each(beanAccountFields, function(value, attr) {
                if (attr !== 'name' && attr !== 'website' && !_.isEmpty(value) && duplicateAccountCheck) {
                    showWarningMessage = true;
                }
            }, this);
        }

        if (showWarningMessage) {
            app.alert.show('message-id', {
                level: 'confirmation',
                messages: SUGAR.App.lang.get('LBL_HINT_MSG_TOTAL_OVERWRITE'),
                autoClose: false,
                // only enrich if the user has intended to do so (meaning they have
                // chosen a company from the dropdown list)
                onConfirm: function() {
                    if (!self.shouldShowHintCloudLogo) {
                        // reset cloud icons & enrich auto fill back to false for any future
                        // enrichment calls
                        self._resetEnrichAutoFillState();
                        self.model.set(beanAccountFields);
                        self._originalModel.set(beanAccountFields);
                        self.previousAccountsName = self._originalModel.get('name');
                        self.previousAccountsWebsite = self._originalModel.get('website');
                    }
                },
                onCancel: function() {
                    // reset cloud icons & enrich auto fill back to false for any future
                    // enrichment calls
                    self._resetEnrichAutoFillState();

                    self.cancelName = true;
                    self._originalModel.set('name', previousAccountName);
                    self.containsPreAccountFields = false;
                }
            });
        }
    },

    /**
     * Warning alert
     *
     * @param {Object} attr
     * @param {string} value
     * @param {string} msg
     */
    _warningAlert: function(attr, value, msg) {
        var self = this;
        var fieldName = SUGAR.App.lang.get(this.fieldTypeTranslations[attr]);
        var message = msg ? msg : SUGAR.App.lang.get('LBL_HINT_MSG_OVERWRITE_FIELD',
            this.module, {fieldName: fieldName});
        var accountsSicFieldFound = this._accountContainsSICLabel(attr);
        // This Flag is set when saveAll cloud icon is clicked and an alert is shown iff data in the record view
        // is not equal to the data found  by the Hint.
        var warningMessageDisplayFlag = false;
        if (typeof attr === 'object') {
            for (var key in attr) {
                if (attr.hasOwnProperty(key)) {
                    if (this._accountContainsSICLabel(key)) {
                        if (this._isValueUpdated(attr, 'sic_code')) {
                            warningMessageDisplayFlag = true;
                        }
                    } else if (this._isValueUpdated(attr, key)) {
                        warningMessageDisplayFlag = true;
                    }
                }
            }
        }

        var doIndividualFieldsDiffer = accountsSicFieldFound ?
            this._doesSICCodeExist(this.model.get('sic_code'), 'sic_code') : this._doesSICCodeExist(value, attr);

        // This check is to display warning iff an individual in the record view is not equal to the one found
        //by the Hint.
        if (warningMessageDisplayFlag || doIndividualFieldsDiffer) {
            app.alert.show('message-id', {
                level: 'confirmation',
                messages: message,
                autoClose: false,
                onConfirm: function() {
                    // Check to avoid adding duplicates in the phoneFields and completely overwrite it.
                    // Teh value parameter is of the form (oldAttrValue(From Hint record view field),
                    // newAttrValue(found by hint)).
                    const isValidAvailablePhoneField = self.isValidPhoneType(attr) &&
                        value.indexOf(self._originalModel.get(attr) + ', ') > -1;
                    if (isValidAvailablePhoneField) {
                        var truncatedValueField = value && self._getTruncatedPhoneBasedOnFieldWidth(value, attr);
                        self._originalModel.save(attr, truncatedValueField);
                    }  else if (accountsSicFieldFound) {
                        self._originalModel.save('sic_code', self.model.get('sic_code'));
                    } else {
                        self._enrichFieldsToModules(attr, value);
                    }
                },
                onCancel: function() {
                    self._resetOnCancel(attr);
                }
            });
        } else {
            // it will execute if there are no fields in the record view which needs to be overwritten
            // and hence no warning message.
            this._enrichFieldsToModules(attr, value);
        }
    },

    /**
     * Warning alert for create drawer
     *
     * @param {Object} attr
     * @param {string} value
     * @param {string} msg
     */
    _warningAlertForCreateDrawer: function(attr, value, msg) {
        var self = this;
        var fieldName = SUGAR.App.lang.get(this.fieldTypeTranslations[attr]);
        var accountsSicFieldFound = this._accountContainsSICLabel(attr);
        var hintSicViewField = accountsSicFieldFound ? this.model.get('sic_code') : this.model.get(attr);
        var recordSicViewField =
            accountsSicFieldFound ? this._originalModel.get('sic_code') : this._originalModel.get(attr);

        var message = msg ? msg : SUGAR.App.lang.get('LBL_HINT_MSG_OVERWRITE_FIELD',
            this.module, {fieldName: fieldName});
        // This Flag is set when saveAll cloud icon is clicked and an alert is shown iff data in the record view
        // is not equal to the data found  by the Hint.
        var warningMessageDisplayFlag = false;
        if (typeof attr === 'object') {
            for (var key in attr) {
                if (attr.hasOwnProperty(key)) {
                    if (this._isValueUpdated(attr, key)) {
                        warningMessageDisplayFlag = true;
                    }
                }
            }
        } else if (accountsSicFieldFound && !_.isEmpty(recordSicViewField) && hintSicViewField !== recordSicViewField) {
            warningMessageDisplayFlag = true;
        }
        var doIndividualFieldsDiffer = this._doesSICCodeExist(value, attr);

        // This check is to display warning iff an individual in the record view is not equal to the one
        //found by the Hint.
        if (warningMessageDisplayFlag || doIndividualFieldsDiffer) {
            app.alert.show('message-id', {
                level: 'confirmation',
                messages: message,
                autoClose: false,
                onConfirm: function() {
                    // Check to avoid adding duplicates in the phoneFields and completely overwrite it.
                    // The value parameter is of the form (oldAttrValue(From Hint record view field),
                    // newAttrValue(found by hint)).
                    const isValidAvailablePhoneField = self.isValidPhoneType(attr) &&
                        value.indexOf(self._originalModel.get(attr) + ', ') > -1;
                    if (isValidAvailablePhoneField) {
                        var truncatedValueField = value && self._getTruncatedPhoneBasedOnFieldWidth(value, attr);
                        self._originalModel.set(attr, truncatedValueField);
                    } else if (accountsSicFieldFound) {
                        self._originalModel.set('sic_code', self.model.get('sic_code'));
                    } else {
                        self._setFieldsInCreateDrawer(attr, value);
                    }
                },
                onCancel: function() {
                    self._enrichModel();
                }
            });
        } else {
            this._setFieldsInCreateDrawer(attr, value);
        }
    },

    /**
     * Check if the account contains SIC label
     *
     * @param {string} attr
     * @return {boolean}
     */
    _accountContainsSICLabel: function(attr) {
        return this.moduleName === 'Accounts' && attr === 'hint_account_sic_code_label';
    },

    /**
     * Is value updated
     *
     * @param {Array} attr
     * @param {string} key
     * @return {boolean}
     */
    _isValueUpdated: function(attr, key) {
        if (!_.isEmpty(this._originalModel.get(key))) {
            // REMIND: to be included for accounts as well when its implemented.
            if (key === 'title' && (this._originalModel.get('picture') !== this.model.get('hint_photo'))) {
                return true;
            }
            return attr[key] !== this._originalModel.get(key);
        }
        return false;
    },

    /**
     * Check if SIC code exist
     *
     * @param {string} value
     * @param {Object} attr
     * @return {boolean}
     */
    _doesSICCodeExist: function(value, attr) {
        return (value !== this._originalModel.get(attr) && !_.isEmpty(this._originalModel.get(attr)));
    },

    /**
     * Check if is a valid phone number
     *
     * @param {string} key
     * @return {boolean}
     */
    isValidPhoneType: function(key) {
        return _.includes(this.phoneFieldTypes, key);
    },

    /**
     * Reset on cancel
     *
     * @param attr
     */
    _resetOnCancel: function(attr) {
        var accountsLogoURL = this._originalModel.get('hint_account_pic');
        var foundNewLogo = (!_.isEmpty(accountsLogoURL) &&
            accountsLogoURL !== this.model.get('hint_account_logo'));

        var contactsLeadsPhotoURL = this._originalModel.get('hint_contact_pic');
        var contactPhotoFromHint = this.model.get('hint_photo');
        var imagePathInSugar = this._originalModel.get('picture');

        var foundNewPhoto = ((!_.isEmpty(contactsLeadsPhotoURL) &&
            contactsLeadsPhotoURL !== contactPhotoFromHint) ||
            (!_.isEmpty(imagePathInSugar) && imagePathInSugar !== contactPhotoFromHint));

        if (attr === 'title' && foundNewPhoto) {
            this._warningAlertForImageOverwrite('hint_contact_pic', true, false);
        } else if (attr === 'website' && foundNewLogo) {
            this._warningAlertForImageOverwrite('hint_account_pic', true, false);
        } else {
            // _updateModel() is called to prevent changes in model when user hits cancel
            // after save-All cloud icon is being hit.
            this._updateModel();
        }
    },

    /**
     * Warning alert for image overwrite
     *
     * @param {string} attr
     * @param {boolean} overwriteOnlyImage
     * @param {boolean} titlePhotoWaterfall
     */
    _warningAlertForImageOverwrite: function(attr, overwriteOnlyImage, titlePhotoWaterfall) {
        var self = this;
        var fieldName = SUGAR.App.lang.get(this.fieldTypeTranslations[attr]);
        var message = SUGAR.App.lang.get('LBL_HINT_MSG_OVERWRITE_FIELD', this.module, {fieldName: fieldName});
        app.alert.show('message-id', {
            level: 'confirmation',
            messages: message,
            autoClose: false,
            onConfirm: function() {
                self._saveHintsImageURL(overwriteOnlyImage);
                if (titlePhotoWaterfall) {
                    self._warningAlertForCreateDrawer('title', self.model.get('title'), '');
                }
            },
            onCancel: function() {
                self._updateModel();
            }
        });
    },

    /**
     * Enrich fields to module
     *
     * @param {Object} attr
     * @param {string} value
     */
    _enrichFieldsToModules: function(attr, value) {
        var overwriteOnlyLogo = true;
        if (this.moduleName === 'Accounts') {
            var accountsLogoURL = this._originalModel.get('hint_account_pic');
            attr.hint_account_pic = this.model.get('hint_account_logo');
            for (var key in attr) {
                if (attr.hasOwnProperty(key)) {
                    if (key === 'hint_account_sic_code_label') {
                        attr.sic_code = this.model.get('sic_code');
                    }  else if (key !== 'hint_account_pic') {
                        attr[key] = String(this.model.get(key));
                    }
                }
            }
            this._originalModel.save(attr, value);
            if (!_.isEmpty(accountsLogoURL) && accountsLogoURL !== this.model.get('hint_account_logo')) {
                // attr will be an object when both the website and account logo needs to be changed.
                if (typeof(attr) === 'object') {
                    this._saveHintsImageURL(overwriteOnlyLogo);
                } else if (attr === 'hint_account_pic') {
                    this._warningAlertForImageOverwrite('hint_account_pic', false, false);
                }
            }
        } else {
            attr.hint_contact_pic = this.model.get('hint_photo');
            for (var key in attr) {
                var isValidPhoneField = attr.hasOwnProperty(key) && this.isValidPhoneType(key);
                if (isValidPhoneField) {
                    var phone = this.model.get(key);
                    attr[key] = phone && this._getTruncatedPhoneBasedOnFieldWidth(phone, key);
                } else if (key === 'website' && this.moduleName === 'Leads') {
                    attr[key] = this.model.get('hint_account_website');
                } else if (key !== 'hint_contact_pic') {
                    attr[key] = String(this.model.get(key));
                }
            }
            this._originalModel.save(attr, value);
            var contactsLeadsPhotoURL = this._originalModel.get('picture');
            if (!_.isEmpty(contactsLeadsPhotoURL) && (contactsLeadsPhotoURL !== this.model.get('hint_photo'))) {
                // attr will be an object when both the title and profile logo needs to be changed.
                if (typeof(attr) === 'object') {
                    this._saveHintsImageURL(overwriteOnlyLogo);
                } else {
                    this._warningAlertForImageOverwrite('hint_contact_pic', false, false);
                }
            }
        }
    },

    /**
     * The attr is of type object when we try to hit saveAll cloud icon.
     *
     * @param {Object} attr
     * @param keyToCheck
     * @return {boolean}
     */
    _isValidAttrForLogoEnrich: function(attr, keyToCheck) {
        return attr === keyToCheck || typeof(attr) === 'object';
    },

    /**
     * Set fields in create drawer
     *
     * @param {Object} attr
     * @param {string} value
     */
    _setFieldsInCreateDrawer: function(attr, value) {
        if (this.moduleName === 'Accounts') {
            var accountsLogoURL = this._originalModel.get('hint_account_pic');
            var hintAccountLogoUrl = this.model.get('hint_account_logo');
            var accountsSicFieldFound = this._accountContainsSICLabel(attr);
            for (var key in attr) {
                if (attr.hasOwnProperty(key)) {
                    if (key === 'hint_account_sic_code_label') {
                        attr.sic_code = this.model.get('sic_code');
                    } else if (key === 'hint_account_logo') {
                        attr.hint_account_pic = hintAccountLogoUrl;
                    } else {
                        attr[key] = String(this.model.get(key));
                    }
                }
            }
            if (this._isValidAttrForLogoEnrich(attr, 'hint_account_logo') && (_.isEmpty(accountsLogoURL) ||
                accountsLogoURL !== hintAccountLogoUrl)) {
                this._saveHintsImageURL();
            }
            if (typeof attr === 'object') {
                this._originalModel.set(attr);
            } else if (accountsSicFieldFound) {
                this._originalModel.set('sic_code', this.model.get('sic_code'));
            } else {
                this._originalModel.set(attr, value);
            }
        } else {
            var contactsPhotoURL = this.model.get('hint_photo');
            for (var key in attr) {
                var isValidPhoneField = attr.hasOwnProperty(key) && this.isValidPhoneType(key);
                var phoneNumber = this.model.get(key);
                if (isValidPhoneField) {
                    attr[key] = phoneNumber && this._getTruncatedPhoneBasedOnFieldWidth(phoneNumber, key);
                } else if (key === 'hint_photo') {
                    attr.hint_contact_pic = contactsPhotoURL;
                }  else {
                    attr[key] = String(this.model.get(key));
                }
            }
            this._originalModel.set(attr, value);
            var contactsLeadsPhotoURL = this._originalModel.get('hint_contact_pic');
            if (this._isValidAttrForLogoEnrich(attr, 'hint_photo') && (_.isEmpty(contactsLeadsPhotoURL) ||
                contactsLeadsPhotoURL !== contactsPhotoURL)) {
                this._saveHintsImageURL();
            }
        }
    },

    /**
     * Stage2 data enrichment call
     *
     * @param {string} method
     * @param {string} api
     * @param {Object} options
     */
    _callStage2API: function(method, api, options) {
        var self = this;
        if (app.hint.isHintUser()) {
            app.api.call(method, app.api.buildURL(api), null, {
                success: function(data) {
                    if (api === 'stage2/params') {
                        self._stage2url = data.enrichmentServiceUrl;
                        self._stage2urlV2 = data.enrichmentServiceUrlV2;
                    }
                    options && options.success && options.success(data);
                },
                error: function(err) {
                    app.logger.error('Failed to get Hint param: ' + JSON.stringify(err));
                    self._setStage2ErrorCode(err);
                    options && options.error && options.error(err);
                }
            });
        } else {
            var err = {
                status: 402
            };
            self._setStage2ErrorCode(err);
        }
    },

    /**
     * Record event
     *
     * @param {string} eventType
     * @param {string} target
     */
    _recordEvent: function(eventType, target) {
        var self = this;
        if (_.isEmpty(self._stage2url)) {
            self._fetchStage2Url('GET', 'stage2/params', function(/*data*/) {
                self._recordEvent(eventType, target);
            });
            return;
        }
        this._issueRequest('POST', self._stage2url + '/event', {
            metricsToken: self._getMetricsToken(),
            eventType: eventType,
            target: target,
            origin: self.moduleName
        }, {
            success: function() { },
            error: function(err) {
                app.logger.error('Failed to record event: ' + JSON.stringify(err));
            }
        });
    },

    /**
     * Social link clicked
     *
     * @param {Object} evt
     */
    _socialLinkClicked: function(evt) {
        var clickInfo = {
            clickType: 'socialMediaLink',
            clickedURL: evt.currentTarget.href,
            metricsToken: this._getMetricsToken(),
            origin: this.context.get('module')
        };
        this._recordLinkClick(clickInfo);
    },

    /**
     * Record link click
     *
     * @param {Object} clickInfo
     */
    _recordLinkClick: function(clickInfo) {
        var self = this;
        if (_.isEmpty(self._stage2url)) {
            self._fetchStage2Url('GET', 'stage2/params', function(/*data*/) {
                self._recordLinkClick(clickInfo);
            });
            return;
        }
        this._issueRequest('POST', self._stage2url + '/url-click', clickInfo, {
            success: function() { },
            error: function(err) {
                app.logger.error('Failed to record link click event: ' + JSON.stringify(err));
            }
        });
    },

    /**
     * Encapsulate access to storage representation
     */
    _getMetricsToken: function() {
        return app.user.get('hintMetricsToken');
    },

    /**
     * Check if only accounts logo differ
     *
     * @param {Object} para1
     * @return {boolean}
     */
    _doOnlyAccountsLogosDiffer: function(para1) {
        var accountsLogoURL = this._originalModel.get('hint_account_pic');
        var doesLogoUrlDiffer = !_.isEmpty(accountsLogoURL) && accountsLogoURL !== this.model.get('hint_account_logo');
        var isWebsiteFieldSame = para1 === 'website' &&
            (this._originalModel.get('website') === this.model.get('website'));

        return isWebsiteFieldSame && doesLogoUrlDiffer;
    },

    /**
     * Check if non accounts photo url differ
     *
     * @return {boolean}
     */
    _doNonAccountsPhotoURLsDiffer: function() {
        var photoURL = this._originalModel.get('hint_contact_pic');
        var photoURLFromHint = this.model.get('hint_photo');
        var imagePathInSugar = this._originalModel.get('picture');
        return (!_.isEmpty(photoURL) && photoURL !== photoURLFromHint) ||
            (!_.isEmpty(imagePathInSugar) && imagePathInSugar !== photoURLFromHint);
    },

    /**
     * Check if only photos differ
     *
     * @param {Object} para1
     * @return {boolean}
     */
    _doOnlyPhotosDiffer: function(para1) {
        var jobTitle = this._originalModel.get('title');
        var isTitleFieldSame = para1 === 'title' && (jobTitle === this.model.get('title'));
        return isTitleFieldSame && this._doNonAccountsPhotoURLsDiffer();
    },

    /**
     * Check if non accounts create photo url differ
     *
     * @return {boolean}
     */
    _doNonAccountsCreatePhotoURLsDiffer: function() {
        var photoURL = this._originalModel.get('hint_contact_pic');
        var photoURLFromHint = this.model.get('hint_photo');
        var imagePathInSugar = this._originalModel.get('picture_guid');
        return (!_.isEmpty(photoURL) && photoURL !== photoURLFromHint) ||
            (!_.isEmpty(imagePathInSugar) && imagePathInSugar !== photoURLFromHint);
    },

    /**
     * Check if only create drawer photos differ
     *
     * @param {Object} para1
     * @return {boolean}
     */
    _doOnlyCreateDrawerPhotosDiffer: function(para1) {
        var jobTitle = this._originalModel.get('title');
        var isTitleFieldSame = para1 === 'title' && (jobTitle === this.model.get('title'));
        return isTitleFieldSame && this._doNonAccountsCreatePhotoURLsDiffer();
    },

    /**
     * Update base model
     *
     * @param {Object} para1
     * @param {Object} para2
     */
    _updateBaseModel: function(para1, para2) {
        var accountsSicFieldFound = this._accountContainsSICLabel(para1);
        var hintViewField = accountsSicFieldFound ? this.model.get('sic_code') : this.model.get(para1);
        var recordViewField =
            accountsSicFieldFound ? this._originalModel.get('sic_code') : this._originalModel.get(para1);
        var msg = SUGAR.App.lang.get('LBL_HINT_MSG_OVERWRITE_ALL');
        msg = typeof(para1) === 'object' ? msg : '';

        if (this.stage2CreateMode) {
            if (this.moduleName !== 'Accounts') {
                if (msg) {
                    this._warningAlertForCreateDrawer(para1, para2, msg);
                } else {
                    if (para1 === 'title' && this._doOnlyCreateDrawerPhotosDiffer(para1)) {
                        this._warningAlertForImageOverwrite('hint_contact_pic', true, false);
                    } else if (para1 === 'title' && this._doNonAccountsCreatePhotoURLsDiffer() &&
                        (this._originalModel.get('title') !== this.model.get('title'))) {
                        this._warningAlertForImageOverwrite('hint_contact_pic', true, true);
                    }  else if (para1 === 'title' && _.isEmpty(this._originalModel.get('hint_contact_pic'))) {
                        this._saveHintsImageURL();
                    } else if (recordViewField && (recordViewField !== hintViewField)) {
                        this._warningAlertForCreateDrawer(para1, para2, msg);
                    } else {
                        this._setFieldsInCreateDrawer(para1, para2);
                    }
                }
            } else {
                if (para1 === 'website' && _.isEmpty(this._originalModel.get('hint_account_pic'))) {
                    this._saveHintsImageURL();
                } else {
                    this._warningAlertForCreateDrawer(para1, para2, msg);
                }
            }
        } else if (msg) {
            this._warningAlert(para1, para2, msg);
        }  else if (this._doOnlyAccountsLogosDiffer(para1)) {
            this._warningAlertForImageOverwrite('hint_account_pic', true, false);
        } else if (this._doOnlyPhotosDiffer(para1)) {
            this._warningAlertForImageOverwrite('hint_contact_pic', true, false);
        } else if (recordViewField && (recordViewField !== hintViewField)) {
            this._warningAlert(para1, para2, msg);
        } else if (accountsSicFieldFound) {
            this._originalModel.save('sic_code', this.model.get('sic_code'));
        } else {
            this._saveDataInRecordField(para1, para2);
        }
    },

    /**
     * Save data in record field
     *
     * @param {Object} para1
     * @param {Object} para2
     */
    _saveDataInRecordField: function(para1, para2) {
        var needsAccountPic = para1 === 'website' && _.isEmpty(this._originalModel.get('hint_account_pic'));
        var needsContactPic = para1 === 'title' && _.isEmpty(this._originalModel.get('hint_contact_pic'));
        var enrichNewContactPicAndTitle = _.isEmpty(this._originalModel.get('title')) &&
            this._doNonAccountsPhotoURLsDiffer();

        if (needsAccountPic) {
            this._saveHintsImageURL();
        } else if (enrichNewContactPicAndTitle) {
            this._warningAlertForImageOverwrite('hint_contact_pic', false, false);
        } else if (needsContactPic) {
            this._saveHintsImageURL();
        } else if (this.isValidPhoneType(para1)) {
            var truncatedPhone = this._getTruncatedPhoneBasedOnFieldWidth(para2, para1);
            this._originalModel.save(para1, truncatedPhone);
        } else {
            this._originalModel.save(para1, para2);
        }
    },

    /**
     * Set original model
     *
     * @param {Object} para1
     * @param {Object} para2
     */
    _setOriginalModel: function(para1, para2) {
        if (this.isValidPhoneType(para1)) {
            var truncatedPhone = this._getTruncatedPhoneBasedOnFieldWidth(para2, para1);
            this._originalModel.set(para1, truncatedPhone);
        } else {
            this._originalModel.set(para1, para2);
        }
        this.trigger('hint:user-save');
    },

    /**
     * Get sidebar image field
     */
    _getSidebarImageField: function() {
        var sidebarComponent = this.layout.closestComponent('sidebar');
        return sidebarComponent && sidebarComponent._components[0] && sidebarComponent._components[0]._components[0] &&
            sidebarComponent._components[0]._components[0].getField('picture');
    },

    /**
     * Save hints image URL
     *
     * @param {boolean} overwriteOnlyImage
     */
    _saveHintsImageURL: function(overwriteOnlyImage) {
        var websiteRecordField = this._originalModel.get('website');
        var TitleRecordField = this._originalModel.get('title');
        var doEnrichWebsiteLogoDuo = !overwriteOnlyImage &&
            (_.isEmpty(websiteRecordField) || (websiteRecordField !== this.model.get('website')));
        var enrichAccountsFieldForLogo = {
            'website': this.model.get('website'),
            'hint_account_pic': this.model.get('hint_account_logo')
        };
        var doEnrichTitlePhotoDuo = !overwriteOnlyImage &&
            (_.isEmpty(TitleRecordField) || (TitleRecordField !== this.model.get('title')));
        var enrichNonAccountFieldForLogo = {
            'hint_contact_pic': this.model.get('hint_photo'),
            'title': this.model.get('title')
        };

        var isSugarEditMode = app.router._currentFragment.indexOf('/edit') !== -1;

        if (this.moduleName === 'Accounts') {
            if (doEnrichWebsiteLogoDuo) {
                if (this.stage2CreateMode) {
                    this._originalModel.set(enrichAccountsFieldForLogo);
                } else {
                    this._originalModel.save(enrichAccountsFieldForLogo);
                }
            } else {
                if (this.stage2CreateMode) {
                    this._originalModel.set('hint_account_pic', this.model.get('hint_account_logo'));
                } else {
                    this._originalModel.save('hint_account_pic', this.model.get('hint_account_logo'));
                }
            }
        } else {
            if (doEnrichTitlePhotoDuo) {
                if (this.stage2CreateMode || isSugarEditMode) {
                    this._originalModel.set('picture_guid', null);
                    this._originalModel.set(enrichNonAccountFieldForLogo);
                } else {
                    var field = this._getSidebarImageField();
                    if (!_.isEmpty(field)) {
                        field.deleteImage(this._originalModel, enrichNonAccountFieldForLogo);
                    } else {
                        this._originalModel.save(enrichNonAccountFieldForLogo);
                    }
                }
            } else {
                if (this.stage2CreateMode) {
                    this._originalModel.set('picture_guid', null);
                    this._originalModel.set('hint_contact_pic', this.model.get('hint_photo'));
                } else {
                    var field = this._getSidebarImageField();
                    if (!_.isEmpty(field)) {
                        field.deleteImage(this._originalModel, this.model.get('hint_photo'));
                    } else {
                        this._originalModel.save('hint_contact_pic', this.model.get('hint_photo'));
                    }
                }
            }
        }
    },

    /**
     * Update work phones
     *
     * @return {string}
     */
    _updateWorkPhones: function() {
        var phones = this.model.get('phone_work') || '';
        var newPhone = this.model.get('hint_phone_1');
        if (!this._isEmpty(newPhone) && phones.indexOf(newPhone) < 0) {
            phones = (phones === '') ? newPhone : (phones + ', ' + newPhone);
        }
        newPhone = this.model.get('hint_phone_2');
        if (!this._isEmpty(newPhone) && phones.indexOf(newPhone) < 0) {
            phones = (phones === '') ? newPhone : (phones + ', ' + newPhone);
        }
        return phones;
    },

    /**
     * Copy
     *
     * @param {Object} e
     */
    copy: function(e) {
        var self = this;
        var $btn = $(e.currentTarget);
        var attr = $btn.data('name');
        $btn.attr('data-action', '');

        var erasedFields = self.model.get('_erased_Fields');

        if (_.isEqual(attr, 'saveAll')) {

            self.filteredAttrsToSave = this._attrsToSave;
            // Update work phone value.
            if (self.moduleName !== 'Accounts') {
                var phones = this._updateWorkPhones();
                if (!self._isEmpty(phones)) {
                    self.filteredAttrsToSave.phone_work = phones;
                }
                self.filteredAttrsToSave = _.omit(self.filteredAttrsToSave, 'hint_phone_1', 'hint_phone_2');
            }
            // Add loading animation for saveAll icon.
            if (self.isDarkMode) {
                $btn.removeClass('hint-preview-icon-darkmode--cloud').addClass('hint-preview-icon-darkmode--loading');
            } else {
                $btn.removeClass('hint-preview-icon--cloud').addClass('hint-preview-icon--loading');
            }

            //Remove any erased fields
            self.filteredAttrsToSave = _.omit(self.filteredAttrsToSave, self._erasedFields);

            setTimeout(function() {
                if (self.isDarkMode) {
                    $btn.removeClass('hint-preview-icon-darkmode--cloud').addClass('hint-preview-icon--confirm');
                } else {
                    $btn.removeClass('hint-preview-icon--loading').addClass('hint-preview-icon--confirm');
                }
                setTimeout(function() {
                    $btn.addClass('hidden');
                }, 2000);
                setTimeout(function() {
                    if (!_.isEmpty(self.filteredAttrsToSave)) {
                        self._recordEvent('saveAllHintPersonFields', '*');
                        self._updateBaseModel(self.filteredAttrsToSave);
                        this.$('[data-action="copy"]').addClass('hidden');
                        self.$('[data-name="saveAll"]').tooltip('destroy');
                    }
                }, 500);
            }, 2000);
            // Save clicked field.
        } else {
            // Show loading icon first
            if (self.isDarkMode) {
                $btn.removeClass('hint-preview-icon-darkmode--cloud').addClass('hint-preview-icon-darkmode--loading');
            } else {
                $btn.removeClass('hint-preview-icon--cloud').addClass('hint-preview-icon--loading');
            }
            self._recordEvent('saveHintPersonField', attr);
            switch (attr) {
                case 'hint_account_website':
                    if (self.moduleName === 'Leads') {
                        self._updateBaseModel('website', this.model.get(attr));
                        self._attrsToSave = _.omit(self._attrsToSave, 'website');
                    }
                // fall through deliberately
                default:
                    self._updateBaseModel(attr, String(this.model.get(attr)));
                    self._attrsToSave = _.omit(self._attrsToSave, attr);
            }

            // Tracking when specific field gets saved by client.
            if (_.contains(this.enrichAttributeList, attr)) {
                this._trackEvent(' Enrichment - List View Preview', attr + ' saved');
            }
            if (self.isDarkMode) {
                $btn.removeClass('hint-preview-icon-darkmode--loading').addClass('hint-preview-icon--confirm');
            } else {
                $btn.removeClass('hint-preview-icon--loading').addClass('hint-preview-icon--confirm');
            }
            setTimeout(function() {
                $btn.addClass('hidden');
            }, 1500);

            if (!_.isEmpty(self._attrsToSave)) {
                self.$('[data-name="saveAll"]').tooltip({
                    title: app.lang.get('LBL_HINT_PREVIEW_TOOLTIP_TITLE'),
                    placement: 'left'
                });
            } else {
                self.$('[data-name="saveAll"]').remove();
            }
        }
    }
}) },
"bwc": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.BwcView
 * @alias SUGAR.App.view.views.BaseBwcView
 * @extends View.View
 */
({
	// Bwc View (base) 

    className: 'bwc-frame',
    // Precompiled regex (note-regex literal causes errors but RegExp doesn't)
    moduleRegex: new RegExp('module=([^&]*)'),
    idRegex: new RegExp('record=([^&]*)'),
    actionRegex: new RegExp('action=([^&]*)'),

    plugins: ['Editable', 'LinkedModel'],

    /**
     * Enabled actions for warning unsaved changes.
     */
    warnEnabledBwcActions: [
        'editview', 'config'
    ],

    /**
     * The URL to a BWC view to be used in the iFrame element (template).
     *
     * See {@link #_renderHtml} on how this is created and then kept in sync
     * with the iFrame.
     *
     * @property {string}
     */
    url: '',

    /**
     * Sets the current URL of this view to point to a bwc link.
     *
     * See {@link #_setCurrentUrl} on how this is kept in sync with the current
     * view url and window hash.
     *
     * @property {string}
     * @private
     */
    _currentUrl: '',

    initialize: function(options) {
        // If (for some reason) we're trying to directly access old Home/Dashboards, for redirect to sidecar #Home
        var url = options.context.get('url');
        if (url && (url.search(/module=Home.*action=index/) > -1 || url.search(/action=index.*module=Home/) > -1)) {
            app.router.navigate('#Home', {trigger: true});
            return;
        }

        app.events.on("api:refreshtoken:success", this._refreshSession, this);

        this._super('initialize', [options]);
        this.bwcModel = app.data.createBean('bwc');

        // because loadView disposes the old layout when the bwc iFrame is no
        // longer in the DOM, it causes a memory leak unless we unbind it
        // before the new layout is loaded.
        app.before('app:view:load', this.unbindDom, this);
    },

    /**
     * @inheritdoc
     *
     * Inspect changes on current HTML input elements with initial values.
     */
    hasUnsavedChanges: function() {
        var bwcWindow = this.$('iframe').get(0).contentWindow;
        //if bwcModel is empty, then it should return false (since it's not in enabled actions)
        // or we couldnt find a edit view to compare or the view doesn't want to be compared
        if (_.isEmpty(this.bwcModel.attributes) || _.isUndefined(bwcWindow.EditView) || $(bwcWindow.EditView).data('disablebwchaschanged')) {
            return false;
        }
        // some forms may still be doing async loading after document ready
        // do not compare if the loading is not done yet
        if (!_.isUndefined(bwcWindow.asyncLoading) && bwcWindow.asyncLoading) {
            return false;
        }
        var newAttributes = this.serializeObject(bwcWindow.EditView);
        return !_.isEmpty(this.bwcModel.changedAttributes(newAttributes));
    },

    /**
     * Retrieves form's input values in object format
     *
     * @param {HTMLElement} theForm form element.
     * @return {Object} key-value paired object.
     */
    serializeObject: function(theForm) {
        var formArray = $(theForm).serializeArray();
        return _.reduce(formArray, function(acc, field) {
            acc[field.name] = field.value;
            return acc;
        }, {});
    },

    /**
     * @inheritdoc
     *
     * Override {@link View.View#_render} method to
     * extend ACL check for Administration module in BWC mode.
     * Allow access to Administration if user has admin access to any
     * module only, if not - show error message and navigate to home.
     */
    _render: function() {
        if (this.module === 'Administration' &&
            !app.acl.hasAccessToAny('admin') &&
            !app.acl.hasAccessToAny('developer')
        ) {
            app.logger.info(
                'Current user does not have access to this module view. name: ' +
                    this.name + ' module:' + this.module
            );
            app.error.handleRenderError(this, 'view_render_denied');
            app.router.navigate('#Home', {trigger: true});
            return;
        }
        app.view.View.prototype._render.call(this);
        return this;
    },

    /**
     * Render the iFrame and listen for content changes on it.
     *
     * Every time there is an update on the iFrame, we:
     * - clear any '.bwc.sugarcrm' event (namespace for any bind in this view);
     * - update the controller context to mach our bwc module (if exists);
     * - update our url to match the current iFrame location in bwc way;
     * - rewrite links for sidecar modules;
     * - rewrite links that go for new windows;
     * - memorize the form input elements in order to warn unsaved changes;
     * - update the context model to mach our current bwc module (if exists);
     *
     * @private
     */
    _renderHtml: function() {
        var self = this;

        this.url = app.utils.addIframeMark(this.context.get('url') || 'index.php?module=' + this.module + '&action=index');
        app.view.View.prototype._renderHtml.call(this);

        this.$('iframe').on('load', function() {
            //In order to update current location once bwc link is clicked.
            self.url = 'index.php' + this.contentWindow.location.search;
            self._setCurrentUrl();

            if (this.contentWindow.$ === undefined) {
                // no jQuery available, graceful fallback
                return;
            }

            $(this.contentWindow).one('beforeunload', _.bind(self.unbindDom, self));

            self._setModule(this.contentWindow);
            self._setBwcModel(this.contentWindow);
            self._setModel(this.contentWindow);
            self._rewriteLinksForSidecar(this.contentWindow);
            self._rewriteNewWindowLinks(this.contentWindow);
            self._cloneBodyClasses(this.contentWindow);

            $('html', this.contentWindow.document).on('click.bwc.sugarcrm', function() {
                app.bwc.trigger('clicked');
            });
        });
    },

    /**
     * Clone classes, added by Modernizr, "top frame" into "bwc frame";
     * necessary for various overrides on iPhone and Android.
     */
    _cloneBodyClasses: function(contentWindow) {
        contentWindow.$('html').addClass($('html').prop('class'));
    },
    /**
     * Update the controller context to mach our bwc module.
     *
     * @param {HTMLElement} contentWindow iframe window.
     * @private
     */
    _setModule: function(contentWindow) {
        var module = this.moduleRegex.exec(contentWindow.location.search);
        module = (_.isArray(module)) ? module[1] : null;

        if (!module) {
            // try and strip module off the page if its not set on location
            if (contentWindow.$ && contentWindow.$('input[name="module"]') && contentWindow.$('input[name="module"]').val()) {
                module = contentWindow.$('input[name="module"]').val();
            } else {
                return;
            }

        }
        // on BWC import we want to try and take the import module as the module
        if (module === 'Import') {
            var importModule = /import_module=([^&]*)/.exec(contentWindow.location.search);
            if (!_.isNull(importModule) && !_.isEmpty(importModule[1])) {
                module = importModule[1];
            } else if (contentWindow.$ &&
                contentWindow.$('input[name="import_module"]') &&
                contentWindow.$('input[name="import_module"]').val()) {

                // try and strip import module off the page if its not set on location
                module = contentWindow.$('input[name="import_module"]').val();
            }
        }
        // update bwc context
        var app = window.parent.SUGAR.App;
        app.controller.context.set('module', module);
        app.events.trigger('app:view:change', this.layout, {module: module});
    },

    /**
     * Memorize the form input elements if current page contains edit form.
     *
     * @param {HTMLElement} contentWindow iframe window.
     * @private
     */
    _setBwcModel: function(contentWindow) {
        var action = this.actionRegex.exec(contentWindow.location.search);
        action = (_.isArray(action)) ? action[1].toLowerCase() : null;

        var EditViewGrid = contentWindow.document.getElementById('EditViewGrid');
        if (EditViewGrid) {
            contentWindow.EditView = EditViewGrid;
        }

        //once edit page is entered, the page is navigated without action query string.
        //Therefore, if current page contains 'EditView' form, bind the action as 'editview'.
        if (contentWindow.EditView) {
            action = 'editview';
        }

        var attributes = {};
        if (_.contains(this.warnEnabledBwcActions, action)) {
            attributes = this.serializeObject(contentWindow.EditView);
        }
        this.resetBwcModel(attributes);
    },

    /**
     * Populates the context model with API data.
     * `this.model` is a link for `this.context.model`.
     *
     * @param {HTMLElement} contentWindow iframe window.
     * @private
     */
    _setModel: function(contentWindow) {
        var action = this.actionRegex.exec(contentWindow.location.search);
        action = (_.isArray(action)) ? action[1].toLowerCase() : null;

        if (action !== 'detailview') {
            return;
        }

        var id = this.idRegex.exec(this._currentUrl);
        if (!_.isArray(id)) {
            return;
        }

        this.model.set('id', id[1]);
        this.model.module = this.context.get('module');
        this.model.fetch();
    },

    /**
     * @inheritdoc
     *
     * Opens the appropriate sidecar create layout in a drawer.
     *
     * @param {String} module Module name.
     * @param {String} link Link name.
     */
    openCreateDrawer: function(module, link) {
        var parentModel = this.context.get('model'),
            model = this.createLinkModel(parentModel, link),
            self = this;
        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                module: model.module,
                model: model
            }
        }, function(context, model) {
            if (!model) {
                return;
            }
            // Reload the BWC to update subpanels.
            self.$('iframe').get(0).contentWindow.location.reload(true);
        });
    },

    /**
     * Opens the Compose Email drawer, passing in the parent model to which the
     * email should be related, as well other prefills, like the subject and
     * body.
     *
     * @param {Object} [options] Data for the email from the compose package.
     * @param {Object} [options.subject] Populate the email with this subject.
     * @param {Object} [options.body] Populate the email with this body.
     * @param {Object} [options.to] Populate the email with these recipients.
     * @param {Object} [options.cc] Populate the email with these recipients.
     * @param {Object} [options.attachments] Populate the email with these
     * attachments.
     */
    openComposeEmailDrawer: function(options) {
        var prepopulate = {
            related: this.context.get('model')
        };

        options = app.utils.deepCopy(options) || {};

        if (!_.isEmpty(options.subject)) {
            prepopulate.name = options.subject;
        }

        if (!_.isEmpty(options.body)) {
            prepopulate.description_html = options.body;
        }

        _.each(['to', 'cc'], function(field) {
            if (!_.isArray(options[field])) {
                return;
            }

            prepopulate[field] = [];

            _.each(options[field], function(data) {
                var bean = app.data.createBean('EmailParticipants', {
                    _link: field,
                    email_address_id: data.email_address_id,
                    email_address: data.email_address
                });

                if (data.parent_type && data.parent_id) {
                    bean.set({
                        parent: {
                            _acl: {},
                            type: data.parent_type,
                            id: data.parent_id,
                            name: data.parent_name || ''
                        },
                        parent_type: data.parent_type,
                        parent_id: data.parent_id,
                        parent_name: data.parent_name || ''
                    });
                }

                prepopulate[field].push(bean);
            });
        });

        if (!_.isEmpty(options.attachments)) {
            prepopulate.attachments = [];

            _.each(options.attachments, function(attachment) {
                var bean = app.data.createBean('Notes', {
                    _link: 'attachments',
                    upload_id: attachment.id,
                    name: attachment.filename,
                    filename: attachment.filename
                });

                prepopulate.attachments.push(bean);
            });
        }

        app.utils.openEmailCreateDrawer(
            'compose-email',
            prepopulate,
            _.bind(function(context, model) {
                // Reload the BWC window to update subpanels.
                if (model) {
                    this.$('iframe').get(0).contentWindow.location.reload(true);
                }
            }, this)
        );
    },

    /**
     * Opens the Archive Email drawer, passing in the parent model to relate to
     * Reloads the BWC page if email created so it appears in the subpanel
     */
    openArchiveEmailDrawer: function() {
        app.utils.openEmailCreateDrawer(
            'create',
            {
                related: this.context.get('model')
            },
            _.bind(function(model) {
                if (model) {
                    // Reload the BWC window to update subpanels.
                    this.$('iframe').get(0).contentWindow.location.reload(true);
                }
            }, this)
        );
    },

    /**
     * Update current window location based on the {@link #url} property.
     *
     * Confirms that the sidecar hash is always matching the url in the iFrame
     * prefixed by`#bwc/` hash (for proper routing handling).
     *
     * @private
     */
    _setCurrentUrl: function() {
        this._currentUrl = app.utils.rmIframeMark('#bwc/' + this.url);
        window.parent.location.hash = this._currentUrl;
    },

    /**
     * Revert model attributes with the current form elements.
     */
    revertBwcModel: function() {
        var bwcWindow = this.$('iframe').get(0).contentWindow;
        var newAttributes = this.serializeObject(bwcWindow.EditView);
        this.resetBwcModel(newAttributes);
    },

    /**
     * Reset model attributes with the initial attributes.
     *
     * @param {Object} key-value pair attributes.
     */
    resetBwcModel: function(attr) {
        this.bwcModel.clear({
            silent: true
        }).set(attr);
    },

    /**
     * Gets the sidecar url based on a given bwc hyperlink.
     * @param {String} href the bwc hyperlink.
     * @return {String} the new sidecar hyperlink (empty string if unable to convert).
     */
    convertToSidecarUrl: function(href) {
        var module = this.moduleRegex.exec(href),
            id = this.idRegex.exec(href),
            action = this.actionRegex.exec(href);

        module = (_.isArray(module)) ? module[1] : null;
        if (!module) {
            return '';
        }
        //Route links for BWC modules through bwc/ route
        if (app.metadata.getModule(module).isBwcEnabled) {
            //Remove any './' nonsense in existing hrefs
            href = href.replace(/^.*\//, '');
            return "bwc/" + href;
        }
        id = (_.isArray(id)) ? id[1] : null;
        action = (_.isArray(action)) ? action[1] : '';
        // fallback to sidecar detail view
        if (action.toLowerCase() === 'detailview') {
            action = '';
        }

        if (!id && action.toLowerCase() === 'editview') {
            action = 'create';
        }
        return app.router.buildRoute(module, id, action);
    },

    /**
     * Rewrites old link element to the new sidecar router.
     *
     * This adds an event to all the links that are converted and don't open in
     * a new tab/window. Therefore it is imperative that you take memory leaks
     * precautions. See {@link #unbindDom} for more information.
     *
     * The reason why we don't use an `onclick="..."` attribute, is simply due
     * to requirements of tracking the event and stop propagation, which would
     * be extremely difficult to support cross browser.
     *
     * @param {HTMLElement} The link `<a>` to rewrite into a sidecar url.
     */
    convertToSidecarLink: function(elem) {
        elem = $(elem);
        //Relative URL works better on all browsers than trying to include origin
        var baseUrl = app.config.siteUrl || window.location.pathname;
        var href = elem.attr('href');
        var module = this.moduleRegex.exec(href);
        var dataSidecarRewrite = elem.attr('data-sidecar-rewrite');
        var action = this.actionRegex.exec(href);

        if (
            !_.isArray(module) ||
            _.isEmpty(module[1]) ||
            _.isUndefined(app.metadata.getModule(module[1])) ||
            module[1] === "Administration" || // Leave Administration module links alone for 7.0
            href.indexOf("javascript:") === 0 || //Leave javascript alone (this is mostly BWC links)
            dataSidecarRewrite === 'false' ||
            (_.isArray(action) && action[1] === 'sugarpdf') //Leave PDF downloads for bwc modules
        ) {
            return;
        }
        var sidecarUrl = this.convertToSidecarUrl(href);
        elem.attr('href', baseUrl + '#' + sidecarUrl);
        elem.data('sidecarProcessed', true);

        if (elem.attr('target') === '_blank') {
            return;
        }

        app.logger.debug('Bind event in BWC view');

        elem.on('click.bwc.sugarcrm', function(e) {
            if (e.button !== 0 || e.ctrlKey || e.metaKey) {
                return;
            }
            e.stopPropagation();
            parent.SUGAR.App.router.navigate(sidecarUrl, {trigger: true});
            return false;
        });
        app.accessibility.run(elem, 'click');
    },

    /**
     * Rewrites old error elements to the new one pop-ups.
     *
     * @param {Object} $errors DOM elements containing errors to rewrite into standard errors.
     */
    convertToSidecarErrors: function($errors) {
        if ($errors.length === 0) {
            return;
        }

        $errors.hide();
        var errorMessages = _.map($errors, function(error) {
            return $(error).text();
        });
        app.alert.show('delete-error', {
            level: 'error',
            messages: errorMessages
        });
    },

    /**
     * Allow BWC modules to rewrite their links when using their own ajax
     * calls.
     *
     * *ATTENTION:* This method might cause memory leaks if not used properly.
     * Make sure that {@link #unbindDom} is being used and cleaning up any
     * events that this view is creating (use {@link Utils.Logger.levels}
     * `debug` level to track all the events being created and check if the
     * ones being cleared by {@link #unbindDom} match.
     */
    rewriteLinks: function() {
        app.logger.warn('Possible memory leak on BWC code');
        var frame = this.$('iframe').get(0).contentWindow;
        this._rewriteLinksForSidecar(frame);
        this._rewriteNewWindowLinks(frame);
    },

    /**
     * Rewrite old links on the frame given to the new sidecar router.
     *
     * This will match all hrefs that contain "module=" on it and if the module
     * isn't blacked listed, then rewrite into sidecar url.
     * Since iFrame needs full URL to sidecar urls (to provide copy paste urls,
     * open in new tab/window, etc.) this will check what is the base url to
     * apply to that path.
     *
     * See `include/modules.php` for the list (`$bwcModules`) of modules not
     * sidecar ready.
     *
     * This method is private because it binds data and might cause memory
     * leaks. Please use this with caution and with {@link #unbindDom}.
     *
     * @param {Window} frame The `contentWindow` of the frame to rewrite links.
     * @private
     */
    _rewriteLinksForSidecar: function(frame) {
        var self = this;

        frame.$('a[href*="module="]').each(function(i, elem) {
            self.convertToSidecarLink(elem);
        });
    },

    /**
     * Rewrite new window links (`target=_blank`) on the frame given to the new
     * sidecar with bwc url.
     *
     * This will match all `"target=_blank"` links that aren't already pointing
     * to sidecar already and make them sidecar bwc compatible. This will
     * assume that all links to sidecar modules are already rewritten.
     *
     * @param {Window} frame The `contentWindow` of the frame to rewrite links.
     * @private
     */
    _rewriteNewWindowLinks: function(frame) {
        var ieOrigin,
            baseUrl,
            $links = frame.$('a[target="_blank"]').not('[href^="http"]').not('[href*="entryPoint=download"]');

        // for IE 10 & below, which does not have window.location.origin
        if (!window.location.origin) {
            ieOrigin = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port: '');
        }
        baseUrl = app.config.siteUrl || (window.location.origin || ieOrigin) + window.location.pathname;

        $links.each(function(i, elem) {
            var $elem = $(elem);
            if ($elem.data('sidecarProcessed')) {
                return;
            }
            $elem.attr('href', baseUrl + '#bwc/' + $elem.attr('href'));
        });
    },

    /**
     * Unbinds all events that were hooked in this view with the `bwc.sugarcrm`
     * namespace into links (`<a>` anchor tags).
     *
     * Only unbinds if the content window has jQuery and the `iframe` is
     * loaded.
     * To avoid memory leaks, please always confirm that this function is
     * called when any event is added to the `iframe` from this view or
     * sidecar.
     *
     * Example:
     *
     *     // write some `methodWithBind` that binds click events in bwc
     *     // elements in this bwc view.
     *     // call that method from within the bwc view like:
     *     parent.SUGAR.App.view.views.BaseBwcView.prototype.methodWithBind();
     *     // memory leak will happen if `methodWithBind` doesn't use the
     *     // `.bwc.sugarcrm` namespace.
     *
     * If the BWC view is replacing it's current html with a new one, it should
     * also call this method before replacing the contents, so that it won't
     * cause memory leak.
     */
    unbindDom: function() {
        var bwcWindow = this.$('iframe').get(0).contentWindow;
        if (!bwcWindow || bwcWindow.$ === undefined) {
            return;
        }

        this.confirmMemLeak(bwcWindow.document);

        $('a', bwcWindow.document).off('.bwc.sugarcrm');
        $('html', bwcWindow.document).off('.bwc.sugarcrm');
    },

    confirmMemLeak: function(target) {
        app.logger.debug(function() {
            var registered = _.reduce($('a', target), function(memo, el) {
                var events = $._data(el, 'events');
                return memo + _.where(_.flatten(events), {namespace: 'bwc.sugarcrm'}).length;
            }, 0);

            return 'Clear ' + registered + ' event(s) in `bwc.sugarcrm`.';
        });
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        app.events.off("api:refreshtoken:success", this._refreshSession, this);

        this.unbindDom();
        app.offBefore(null, null, this);
        if (this.bwcModel) {
            this.bwcModel.off();
            this.bwcModel = null;
        }
        this._super('_dispose');
    },

    /**
     * Refreshes session on server side
     */
    _refreshSession: function() {
        app.bwc.login();
    }
}) },
"omnichannel-search-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * List view for the {@link View.Layouts.Base.SearchLayout
 * Search layout}.
 *
 * @class View.Views.Base.OmnichannelSearchListView
 * @alias SUGAR.App.view.views.BaseOmnichannelSearchListView
 * @extends View.Views.Base.SearchListView
 */
({
	// Omnichannel-search-list View (base) 

    extendsFrom: 'SearchListView',

    className: 'omnichannel-search-list-wrapper',

    /**
     * @inheritdoc
     */
    'events': {
        'click .search-result': 'rowClicked',
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // Share the same collection as other views in the parent layout
        this.collection = this.layout.collection;
        this.collection.on('sync', this.displaySearchPage, this);

        app.events.trigger('omnichannel:modulelist:open');
        this.layout.on('omnichannelsearch:clear:results', this._clearSearchResults, this);
    },

    /**
     * Clears search results
     *
     * @private
     */
    _clearSearchResults: function() {
        if (!this.collection.showMore) {
            this.render();
        }
    },

    /**
     * Used by the Pagination plugin to retrieve fetch options for the
     * collection before paginating
     *
     * @return {Object} The set of collection fetch options to use for pagination
     */
    getPaginationOptions: function() {
        // Start with default options for the pagination
        var options = {
            apiOptions: {
                data: {},
                fetchWithPost: true,
                useNewApi: true
            }
        };

        // Make sure pagination uses the currently selected facets
        var selectedFacets = this.context.get('selectedFacets');
        if (selectedFacets) {
            options.apiOptions.data.agg_filters = selectedFacets;
        }

        return options;
    },

    /**
     * Displays search page
     *
     * @param {Event} evt row click event
     */
    displaySearchPage: _.debounce(function() {
        if (this.disposed || !this.collection instanceof App.BeanCollection) {
            return;
        }

        this.collection.showMore = false;

        this.parseModels(this.collection.models);
        if (this._previewed) {
            app.events.trigger('preview:close');
        }

        $('.omnichannel-search-list')
            .removeClass('omnichannel-search-backdrop');
        this.render();
    }, 200),

    /**
     * Handler for row click event
     * Switches to relevant module tab
     *
     * @param {Event} evt row click event
     */
    rowClicked: function(evt) {
        var loadModel = [];
        var rowId = evt.currentTarget && evt.currentTarget.dataset ? evt.currentTarget.dataset.id : '';
        var dashboard = this.closestComponent('omnichannel-dashboard');
        if (!_.isEmpty(rowId) && dashboard && dashboard.searchCollection) {
            loadModel = _.filter(dashboard.searchCollection.models, function(model) {
                if (model.id === rowId) {
                    return model;
                }
            }, this);
        }

        // set current row as model for the dashboard tab and switch tab based on module
        if (dashboard && loadModel.length !== 0) {
            app.alert.show('data-load', {
                level: 'process',
                title: app.lang.get('LBL_LOADING'),
            });
            loadModel[0].fetch({
                success: _.bind(function(model) {
                    app.alert.dismiss('data-load');
                    if (this.disposed) {
                        return;
                    }
                    dashboard.setModel(dashboard.moduleTabIndex[model.get('_module')], model);
                    dashboard.switchTab(dashboard.moduleTabIndex[model.get('_module')]);
                }, this)
            });
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.collection.off('sync', this.displaySearchPage, this);
        this.layout.off('omnichannelsearch:clear:results', this._clearSearchResults, this);
        this._super('_dispose');
    }
}) },
"selection-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SelectionHeaderpaneView
 * @alias SUGAR.App.view.views.BaseSelectionHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Selection-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    initialize: function(options) {
        this._super('initialize', [options]);

        var moduleMeta = app.metadata.getModule(options.module),
            isBwcEnabled = (moduleMeta && moduleMeta.isBwcEnabled),
            multiSelect = options.context.get('isMultiSelect'),
            buttonsToRemove = [],
            additionalEvents = {};

        this.isMultiLink = options.context.has('recLink');
        var createButtonAcl = _.chain(this.meta.buttons)
            .findWhere({name: 'main_dropdown'}).result('buttons')
            .findWhere({name: 'create_button'}).result('acl_action').value();

        if (isBwcEnabled || multiSelect || this.isMultiLink || !app.acl.hasAccess(createButtonAcl, options.module)) {
            buttonsToRemove.push('create_button');
        } else {
            additionalEvents['click [name=create_button]'] = 'createAndSelect';
            this.events = _.extend({}, this.events, additionalEvents);
        }


        if (this.isMultiLink) {
            //FIXME: This will be removed with SC-4073.
            var linkTitleLabel = _.find(this.meta.fields, function(field) {
                return field.name === 'title';
            }, this);
            linkTitleLabel.default_value = 'TPL_SEARCH_AND_ADD';
        } else {
            buttonsToRemove.push('link_button');
        }

        if (!multiSelect) {
            buttonsToRemove.push('select_button');
        }

        this._removeButtons(buttonsToRemove);
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this._super('_renderHtml');

        this.layout.on('selection:closedrawer:fire', _.once(_.bind(function() {
            this.$el.off();
            app.drawer.close();
        }, this)));

        if (this.isMultiLink) {
            this.layout.on('selection:link:fire', function() {
                this.context.trigger('selection-list:link:multi');
            });
        }
    },

    /**
     * @inheritdoc
     */
    _formatTitle: function(title) {
        var moduleName = app.lang.get('LBL_MODULE_NAME', this.module);
        return app.lang.get(title, this.module, {module: moduleName});
    },

    /**
     * Open create inline modal with no dupe check
     * On save, set the selection model which will close the selection-list inline modal
     */
    createAndSelect: function() {
        app.drawer.open({
            layout: 'create-nodupecheck',
            context: {
                module: this.module,
                create: true
            }
        }, _.bind(function(context, model) {
            if (model) {
                this.context.trigger('selection-list:select', context, model);
            }
        }, this));
    },

    /**
     * Removes buttons from main_dropdown
     *
     * @param {Array} buttons The names of the buttons to remove.
     * @private
     */
    _removeButtons: function(buttons) {
        if (!buttons.length) {
            return;
        }

        var mainDropdown = _.find(this.meta.buttons, function(button) {
            return button.name === 'main_dropdown';
        });

        if (!mainDropdown) {
            return;
        }

        mainDropdown.buttons = _.filter(mainDropdown.buttons, function(button) {
            return !_.contains(buttons, button.name);
        });
    }
}) },
"forecastdetails-record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ForecastdetailsRecordView
 * @alias SUGAR.App.view.views.BaseForecastdetailsRecordView
 * @extends View.Views.Base.ForecastdetailsView
 */
({
	// Forecastdetails-record View (base) 

    extendsFrom: 'ForecastdetailsView',

    /**
     * Holds the logged-in user's ID
     */
    selectedUserId: '',

    /**
     * Holds the current timeperiod object
     */
    currentTP: undefined,

    /**
     * Holds the business card's model's timeperiod object (original Opps TP)
     */
    modelTP: undefined,

    /**
     * Holds a reference to the RevenueLineItems subpanel collection
     */
    rliCollection: undefined,

    /**
     * An array of the RLI ids that go into Closed Won
     */
    closedWonIds: [],

    /**
     * An array of the RLI ids that are included in likely/best/worst values
     */
    includedIds: [],

    /**
     * An array of the RLI ids that are included in likely/best/worst values in this timeperiod
     */
    includedIdsInTP: [],

    /**
     * Holds Sales Stage values that get added to Closed Won amounts
     */
    salesStageWon: [],

    /**
     * Array of commit_stages that are included in totals
     */
    commitStagesInIncludedTotal: [],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.selectedUserId = app.user.get('id');
        this._super('initialize', [options]);

        var config = app.metadata.getModule('Forecasts', 'config') || {};

        this.salesStageWon = config.sales_stage_won || ['Closed Won'];
        var forecastRanges = config.forecast_ranges || [];

        this.modelTP = new Backbone.Model();

        if (forecastRanges == 'show_custom_buckets') {
            var ranges = config[forecastRanges + '_ranges'] || [];
            _.each(ranges, function(value, key) {
                if (!_.isUndefined(value.in_included_total) && value.in_included_total) {
                    this.commitStagesInIncludedTotal.push(key);
                }
            });
        } else {
            this.commitStagesInIncludedTotal.push('include');
        }
    },

    /**
     * Builds dashlet url
     * @override
     * @return {String} url to call
     */
    getProjectedURL: function() {
        var method = this.shouldRollup ? "progressManager" : "progressRep",
            url = 'Forecasts/' + this.model.get('selectedTimePeriod') + '/' + method + '/' + this.selectedUserId,
            params = {};

        // if this is a manager view, send the target_quota param to the endpoint
        if(this.shouldRollup) {
            params = {
                target_quota: (this.showTargetQuota) ? 1 : 0
            };
        }

        return app.api.buildURL(url, 'create', null, params);
    },

    /**
     * @inheritdoc
     */
    renderSubDetails: function() {
        // clear the footer class
        var subEl = this.$el.find('.forecast-details');
        if(subEl && subEl.hasClass('block-footer')) {
            subEl.removeClass('block-footer');
        }

        if(this.currentModule != 'Opportunities'
            || (this.currentModule == 'Opportunities' && this.model.get('selectedTimePeriod'))) {
            this._super('renderSubDetails');
        } else {
            subEl.addClass('block-footer');
            subEl.html(app.lang.get('LBL_NO_DATA_AVAILABLE'));
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.meta.config || !this.isForecastSetup) {
            return;
        }

        // reset closedWonIds
        this.closedWonIds = [];
        this.includedIds = [];
        this.includedIdsInTP = [];

        var ctx = this.context.parent || this.context,
            ctxMdl = ctx.get('model');

        ctxMdl.on('sync', function(model) {
            this.fetchNewTPByDate(model.get('date_closed'), undefined, true);
        }, this);

        if(this.currentModule == 'Opportunities') {

            this.rliCollection = app.utils.getSubpanelCollection(ctx, 'RevenueLineItems');

            if(this.rliCollection) {
                // because the user may be loading this dashlet by switching
                // between the Help dashboard and a user's dashboard,
                // process the collection now to init the dashlet properly
                this.processRLICollection(this.rliCollection);
                
                this.rliCollection.on('reset', this.processRLICollection, this);

                this.rliCollection.on('change:likely_case change:best_case change:worst_case change:amount', this.processCases, this);

                this.rliCollection.on('change:sales_stage', this.processSalesStage, this);

                this.rliCollection.on('change:commit_stage', this.processCommitStage, this);

                this.rliCollection.on('change:date_closed', this.checkFetchNewTPByDate, this);

                ctx.on('editablelist:cancel', function(a,b,c) {
                    // no way to really tell what all manual math we've done, so when the row
                    // gets cancelled, just completely reload the data
                    this.loadData();
                }, this);

                /**
                 * Init the Opp record TimePeriod model to receive new TP data and set a change listener
                 * so we can update which model IDs are included and in the actual timeperiod
                 */
                this.modelTP.on('change', function(model) {
                    var rliModel;

                    // empty array
                    this.includedIdsInTP = [];

                    _.each(this.includedIds, function(id) {
                        rliModel = this.rliCollection.get(id);
                        // check to see if this RLI's date is inside the current Opp timeperiod
                        if(this.isDateInTimePeriod(rliModel.get('date_closed'), this.modelTP.toJSON())) {
                            this.includedIdsInTP.push(rliModel.get('id'));
                        }
                    }, this);
                }, this);
            }
        } else if(this.currentModule == 'RevenueLineItems') {
            // RLI only listeners

            // set up closedWonIds when we change dashboards
            this.initClosedWonIds(ctxMdl);

            ctxMdl.on('change:likely_case change:best_case change:worst_case change:amount', this.processCases, this);

            ctxMdl.on('change:sales_stage', this.processSalesStage, this);

            ctxMdl.on('change:commit_stage', this.processCommitStage, this);

            this.context.parent.on('button:cancel_button:click', function(model, date) {
                var ctx = this.context.parent || this.context,
                    ctxModel = ctx.get('model'),
                    options = {
                        beforeParseData: _.bind(this.addModelTotalsToServerData, this, ctxModel)
                    };
                // no way to really tell what all manual math we've done, so when the row
                // gets cancelled, just completely reload the data
                this.loadData(options);
            }, this);

            ctxMdl.on('change:date_closed', this.checkFetchNewTPByDate, this);

            ctxMdl.on('sync', function(model) {
                // updates our lhsData when the user saves the model
                if(_.has(ctxMdl.attributes, 'lhsData')) {
                    ctxMdl.set({
                        lhsData: {
                            best: model.get('best_case'),
                            likely: model.get('likely_case'),
                            worst: model.get('worst_case')
                        }
                    });
                }
            }, this);

            // Using LHS Model to store the initial values of the LHS model so we don't have
            // to ping the server every dashlet load for the true original DB values of the LHS model
            if(!_.has(ctxMdl.attributes, 'lhsData')) {
                ctxMdl.set({
                    lhsData: {
                        best: ctxMdl.get('best_case'),
                        likely: ctxMdl.get('likely_case'),
                        worst: ctxMdl.get('worst_case')
                    }
                });
            }

            if(_.contains(this.closedWonIds, ctxMdl.get('id'))) {
                this.processSalesStage(ctxMdl);
            }
        }
    },

    /**
     * @inheritdoc
     *
     * @override just calls calculateData on it's own instead of going back to the parent
     */
    handleNewDataFromServer: function(data) {
        // since the user might add this dashlet after they have changed the RLI model, but before they saved it
        // we have to check and make sure that we're accounting for any changes in the dashlet totals that come
        // from the server, but only if this has not already been parsed by a beforeParseData function
        if(this.currentModule == 'RevenueLineItems' && this.context && _.isUndefined(data.parsedData)) {
            var mdl = this.context.parent.get('model') || this.context.get('model'),
                lhsData = mdl.get('lhsData');

            if(lhsData.likely != mdl.get('likely_case')) {
                data.amount = data.amount - (lhsData.likely - mdl.get('likely_case'));
            }
            if(lhsData.best != mdl.get('best_case')) {
                data.best_case = data.best_case - (lhsData.best - mdl.get('best_case'));
            }
            if(lhsData.worst != mdl.get('worst_case')) {
                data.worst_case = data.worst_case - (lhsData.worst - mdl.get('worst_case'));
            }
        }

        this.calculateData(this.mapAllTheThings(data, false));
    },

    /**
     * Processes this.rliCollection.models to determine which models IDs should be
     * saved into the closedWonIds array
     */
    processRLICollection: function(collection) {
        this.oldTotals.models = new Backbone.Model();
        _.each(this.rliCollection.models, function(model) {
            // save all the initial likely values
            this.oldTotals.models.set(model.get('id'), {
                likely: model.get('likely_case'),
                best: model.get('best_case'),
                worst: model.get('worst_case')
            });
            this.initClosedWonIds(model);
        }, this);

        if(collection) {
            // if this is coming from the rliCollection reset, fetch server data
            this.loadData();
        }
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        if(this.context.parent) {
            this.context.parent.off(null, null, this);
            if(this.context.parent.get('model')) {
                this.context.parent.get('model').off(null, null, this);
            }
        }
        if(this.context) {
            this.context.off(null, null, this);
            if(this.context.get('model')) {
                this.context.get('model').off(null, null, this);
            }
        }

        if(this.currentModule == 'Opportunities' && this.rliCollection) {
            this.rliCollection.off(null, null, this);
            this.rliCollection = undefined;
        }

        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * Handles when likely/best/worst case changes, processes numbers and does math before sending
     * to calculateTotals
     *
     * @param {Backbone.Model} model the RLI/Opp model
     */
    processCases: function(model) {
        // model is undefined when users change currency symbols,
        // it throws a change:best_case but there's no model
        if(!_.isUndefined(model) && (app.user.get('id') == model.get('assigned_user_id'))
            && _.contains(this.includedIds, model.get('id'))) {
            var data = _.clone(model.toJSON()),
                diff = 0,
                old = 0,
                totals = {};

            if(this.currentModule == 'Opportunities') {
                // if amount is not undefined, push amount into likely_case
                data.likely_case = (!_.isUndefined(data.amount)) ? data.amount : data.likely_case;
                totals = this.getOldTotalFromCollectionById(model.get('id'));
            } else {
                totals = this.oldTotals;
            }

            // process numbers before parent calculateData
            if(_.has(model.changed, 'likely_case') || _.has(model.changed, 'amount')) {
                data.likely_case = (_.isNaN(Number(data.likely_case)) || _.isEqual(data.likely_case, '')) ? 0 : data.likely_case;
                old = data.likely_case;
                diff = app.math.sub(data.likely_case, totals.likely);
                data.likely_case = app.math.add(this.likelyTotal, diff);
                totals.likely = old;
            } else {
                data.likely_case = this.likelyTotal;
            }

            if(_.has(model.changed, 'best_case')) {
                data.best_case = (_.isNaN(Number(data.best_case)) || _.isEqual(data.best_case, '')) ? 0 : data.best_case;
                old = data.best_case;
                diff = app.math.sub(data.best_case, totals.best);
                data.best_case = app.math.add(this.bestTotal, diff);
                totals.best = old;
            } else {
                data.best_case = this.bestTotal;
            }

            if(_.has(model.changed, 'worst_case')) {
                data.worst_case = (_.isNaN(Number(data.worst_case)) || _.isEqual(data.worst_case, '')) ? 0 : data.worst_case;
                old = data.worst_case;
                diff = app.math.sub(data.worst_case, totals.worst);
                data.worst_case = app.math.add(this.worstTotal, diff);
                totals.worst = old;
            } else {
                data.worst_case = this.worstTotal;
            }

            // set oldTotals back
            if(this.currentModule == 'Opportunities') {
                this.setOldTotalFromCollectionById(model.get('id'), totals);
            } else {
                this.oldTotals = totals;
            }

            return this.calculateData(this.mapAllTheThings(data, true));
        }
    },

    /**
     * Checks a model to see if it should be added to closedWonIds
     *
     * @param {Backbone.Model} model
     */
    initClosedWonIds: function(model) {
        var ss = model.get('sales_stage'),
            cs = model.get('commit_stage'),
            id = model.get('id');

        // If this model's sales_stage and commit_stage both are included in Closed Won totals
        // and the id isnt already in closedWonIds
        if(_.contains(this.salesStageWon, ss)
            && _.contains(this.commitStagesInIncludedTotal, cs)
            && !_.contains(this.closedWonIds, id)) {
            this.closedWonIds.push(id);
        }

        // If this model's commit_stage is included in included totals
        // and the id isnt already in includedIds
        if(_.contains(this.commitStagesInIncludedTotal, cs) && !_.contains(this.includedIds, id)) {
            this.includedIds.push(id);
        }
    },

    /**
     * Process model changes when sales_stage is changed
     * @param model
     */
    processSalesStage: function(model) {
        var shouldBeIncluded = false,
            updatedData = false,
            ss = model.get('sales_stage'),
            cs = model.get('commit_stage'),
            id = model.get('id');

        if(_.contains(this.salesStageWon, ss) && _.contains(this.commitStagesInIncludedTotal, cs)) {
            shouldBeIncluded = true;
        }

        // If the ID was already included in the totals, and now should not be
        if(_.contains(this.closedWonIds, id) && !shouldBeIncluded) {
            // remove the model's ID from the array
            this.closedWonIds = _.without(this.closedWonIds, id);

            // remove this model's likely from the closed won amount
            this.serverData.set({closed_amount: app.math.sub(this.serverData.get('closed_amount'), model.get('likely_case'))});

            updatedData = true;
        } else if(!_.contains(this.closedWonIds, id) && shouldBeIncluded) {
            // model needs to be included in closed_amount
            this.closedWonIds.push(id);

            // add likely amount to closed won
            this.serverData.set({closed_amount: app.math.add(this.serverData.get('closed_amount'), model.get('likely_case'))});

            updatedData = true;
        }

        if(updatedData) {
            // update the calculations
            this.calculateData(this.serverData.toJSON());
        }
    },

    /**
     * Processes a model to see if it should be add/subtracted from likely/best/worst totals
     * based on it's commit_stage
     *
     * @param model
     */
    processCommitStage: function(model) {
        var shouldBeIncluded = false,
            updatedData = false,
            cs = model.get('commit_stage'),
            id = model.get('id');

        if(_.contains(this.commitStagesInIncludedTotal, cs)) {
            shouldBeIncluded = true;
        }

        // If the ID was already included in the totals, and now should not be
        if(_.contains(this.includedIds, id) && !shouldBeIncluded) {
            // remove the model's ID from the array
            this.includedIds = _.without(this.includedIds, id);

            // remove amounts from best/likely/worst
            this.serverData.set({
                likely: app.math.sub(this.serverData.get('likely'), model.get('likely_case')),
                best: app.math.sub(this.serverData.get('best'), model.get('best_case')),
                worst: app.math.sub(this.serverData.get('worst'), model.get('worst_case'))
            });

            updatedData = true;
        } else if(!_.contains(this.includedIds, id) && shouldBeIncluded) {
            // model needs to be included in closed_amount
            this.includedIds.push(id);

            // add amounts to best/likely/worst
            this.serverData.set({
                likely: app.math.add(this.serverData.get('likely'), model.get('likely_case')),
                best: app.math.add(this.serverData.get('best'), model.get('best_case')),
                worst: app.math.add(this.serverData.get('worst'), model.get('worst_case'))
            });
            updatedData = true;
        }

        if(updatedData) {
            // update the calculations
            this.calculateData(this.serverData.toJSON());
        }
    },

    /**
     * Given a model that had its closed_date field changed, check to see if we need to
     * fetch a new timeperiod or not by the date changed and which module we're in
     *
     * @param {Backbone.Model} model the changed model
     */
    checkFetchNewTPByDate: function(model) {
        var newDate = model.get('date_closed'),
            shouldFetch = false,
            inTimePeriod = this.isDateInTimePeriod(newDate, this.modelTP.toJSON()),
            options = {},
            inOpps = (this.currentModule == 'Opportunities'),
            modelId = model.get('id');

        if(!inOpps) {
            // RevenueLineItems

            // always fetch for RLIs
            shouldFetch = true;

            if(!inTimePeriod) {
                // since we don't have parent/Opp data available here, whatever TP the new closed date
                // falls in should be fetched and this new total added to it if it isn't already included
                // after fetching, add this model to the server data that comes back
                options.beforeParseData = _.bind(this.addModelTotalsToServerData, this, model);
            }
        } else {
            // Opportunities
            var alreadyInTP = _.contains(this.includedIdsInTP, modelId),
                newTotals;

            // check if date falls outside current timeperiod, if outside of current timeperiod
            // we need to fetch new timeperiod & projected data
            if(inTimePeriod) {
                // check if RLI is being moved into the TP,
                // if it has already been in the TP, dont do anything
                if(!alreadyInTP) {
                    // item has been moved into the TP

                    // add model ID to included ids in timeperiod
                    this.includedIdsInTP.push(modelId);

                    // fetch new TP based on the new date if user changed item's date
                    // to be outside & after the current timeperiod
                    shouldFetch = true;

                    // after fetching, add this model to the server data that comes back
                    options.beforeParseData = _.bind(this.addModelTotalsToServerData, this, model);
                }
            } else {
                // date is not inside the current timeperiod

                // check if the newDate is before or after the current TP
                if (app.date(newDate).isAfter(this.modelTP.get('end_date'))) {
                    // handle if date is after model (Opportunity) timeperiod

                    // fetch new TP based on the new date if user changed item's date
                    // to be outside & after the current timeperiod
                    shouldFetch = true;

                    // after fetching, add this model to the server data that comes back
                    options.beforeParseData = _.bind(this.addModelTotalsToServerData, this, model);
                } else if (app.date(newDate).isBefore(this.modelTP.get('start_date'))) {
                    // handle if date is before model (Opportunity) timeperiod

                    // check if this RLI has already been inside the TP
                    if(alreadyInTP) {
                        // RLI was in the TP, but is being moved out to before the TP

                        // check to see if this is the last RLI in the TP
                        var isLastRLIInTP = (this.includedIdsInTP.length === 1 && this.includedIdsInTP[0] === modelId);

                        if(isLastRLIInTP) {
                            // since this is the last RLI in the timeperiod, when we move this to an
                            // older timeperiod, fetch new TP based on the new date
                            shouldFetch = true;

                            // after fetching, add this model to the server data that comes back
                            options.beforeParseData = _.bind(this.addModelTotalsToServerData, this, model);
                        } else {
                            // item has been moved out of the TP, but other RLIs in the TP are keeping
                            // the dashlet from updating, so subtract the model totals from the current TP totals
                            newTotals = this.removeModelTotalsFromServerData(model, this.serverData.toJSON());
                            this.calculateData(this.mapAllTheThings(newTotals));
                        }
                    } else {
                        // if trying to move the RLI to a timeperiod before the Opportunity timeperiod start date
                        // set the date to the same start date as the Opp so we don't pull an older timeperiod
                        newDate = this.modelTP.get('start_date');

                        // fetch new TP
                        shouldFetch = true;
                    }
                }

                // if this model is already in the timeperiod, remove it
                if(alreadyInTP) {
                    this.includedIdsInTP = _.without(this.includedIdsInTP, modelId);
                }
            }
        }

        // if we should fetch a new timeperiod, make the call
        if(shouldFetch) {
            this.fetchNewTPByDate(newDate, options);
        }
    },

    /**
     * Given a date, this function makes a call to TimePeriods/<date> to get the whole timeperiod bean
     *
     * @param {string} date the date to use to search for the new timeperiod
     * @param {Backbone.Model} [model] param isn't used but is passed when the model changes
     * @param {boolean} [updateModelTP] if we need to update the modelTP or not
     */
    fetchNewTPByDate: function(date, options, updateModelTP) {
        app.api.call('GET', app.api.buildURL('TimePeriods/' + date), null, {
            success: _.bind(function(data) {
                // Make sure the model is here when we get back and this isn't mid-pageload or anything
                if(this.model) {
                    // if we're updating the model timeperiod
                    if(updateModelTP) {
                        // if the Opp model changed, update the model's TP
                        this.modelTP.set(_.clone(data));
                    }

                    this.currentTP = data;
                    this.model.set({selectedTimePeriod: data.id}, {silent: true});
                    this.loadData(options);
                }
            }, this)
        });
    },

    /**
     * Adds the model's likely/best/worst totals to the data totals
     *
     * @param {Backbone.Model} model the model with values to add to server data
     * @param {Object} data values being returned from the server endpoint with totals
     * @return {Object} returns the data Object back with updated totals
     */
    addModelTotalsToServerData: function(model, data) {
        // if these totals haven't already been added into the data from the server
        // occurs when an RLI was previously saved outside of a timeperiod and is being
        // brought back into this timeperiod. If the RLI *did* start in the current TP
        // and has been moved around and is being brought back in, then don't re-add the totals
        if(!_.contains(data.includedIdsInLikelyTotal, model.get('id'))) {
            data.amount = app.math.add(data.amount, model.get('likely_case'));
            data.best_case = app.math.add(data.best_case, model.get('best_case'));
            data.worst_case = app.math.add(data.worst_case, model.get('worst_case'));
        }

        return data;
    },

    /**
     * Removes the model's likely/best/worst totals from the data totals
     *
     * @param {Backbone.Model} model the model with values to remove from server data
     * @param {Object} data values being returned from the server endpoint with totals
     * @return {Object} returns the data Object back with updated totals
     */
    removeModelTotalsFromServerData: function(model, data) {
        data.amount = app.math.sub(data.amount, model.get('likely_case'));
        data.best_case = app.math.sub(data.best_case, model.get('best_case'));
        data.worst_case = app.math.sub(data.worst_case, model.get('worst_case'));

        return data;
    },

    /**
     * Called during initialize to fetch any relevant data
     *
     * @override
     * @param options
     */
    getInitData: function(options) {
        // This needs to be set going into the function. loadData() checks to see if the init data is loaded and
        // makes an async call to load it, causing this function to be called multiple times until something
        // returns and sets initDataLoaded to be false.  Since everything is async, we are safe to set this on function
        // call to indicate that it HAS been called, eliminating extra api calls.
        this.initDataLoaded = true;

        var ctx = this.context.parent || this.context,
            ctxModel = ctx.get('model'),
            date = ctxModel.get('date_closed');

        // set selectedUser id for progress endpoint param
        this.selectedUser.id = ctxModel.get('assigned_user_id');

        // set old totals in case they change
        this.oldTotals = _.extend(this.oldTotals, {
            best: ctxModel.get('best_case'),
            likely: ctxModel.get('likely_case') || ctxModel.get('amount'),
            worst: ctxModel.get('worst_case')
        });

        if(!_.isEmpty(date)) {
            // get the current timeperiod
            app.api.call('GET', app.api.buildURL('TimePeriods/' + date), null, {
                success: _.bind(function(data) {
                    if(this.model) {
                        // update the initial timeperiod
                        this.modelTP.set(_.clone(data));

                        this.currentTP = data;
                        this.model.set({selectedTimePeriod: data.id}, {silent: true});
                        this.loadData();
                    }
                }, this),
                complete: options ? options.complete : null
            });
        } else {
            // this model doesn't have a selectedTimePeriod yet, so use the current date
            var d = new Date(),
                month = (d.getUTCMonth().toString().length == 1) ? '0' + d.getUTCMonth() : d.getUTCMonth(),
                day = (d.getUTCDate().toString().length == 1) ? '0' + d.getUTCDate() : d.getUTCDate()
            date = d.getFullYear() + '-' + month + '-' + day;
            this.fetchNewTPByDate(date);
        }
    },

    /**
     * Checks a given date from the datepicker against the start/end timestamps of the current
     * timeperiod to see if the user selected a date that needs new data
     *
     * @param {string} date the date we're checking to see if it falls inside the timePeriod
     * @param {Object} timePeriod this is the timeperiod Object to check against
     * @return {boolean} true if a new timeperiod should be fetched from server
     */
    isDateInTimePeriod: function(date, timePeriod) {
        var inTimePeriod = false;

        // check if date is between the timePeriod
        if (app.date(date).isBetween(timePeriod.start_date, timePeriod.end_date)) {
            inTimePeriod = true;
        }

        return inTimePeriod;
    }
}) },
"multi-selection-list-link": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 *
 * @class View.Views.Base.MultiSelectionListLinkView
 * @alias SUGAR.App.view.views.BaseMultiSelectionListLinkView
 * @extends View.Views.Base.MultiSelectionListView
 */
({
	// Multi-selection-list-link View (base) 

    extendsFrom: 'MultiSelectionListView',

    plugins: [
        'SugarLogic',
        'Pagination'
    ],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.meta.selection = _.extend({}, options.meta.selection, {isLinkAction: true});
    },

    /**
     * @override
     */
    initializeEvents: function() {
        this.context.on('selection-list:link:multi', this._selectMultipleAndClose, this);
        this.context.on('selection-list:select', this._refreshList, this);
    },

    /**
     * After a model is selected, refresh the list view and add the model to
     * selections.
     *
     * @private
     */
    _refreshList: function() {
        this.context.reloadData({
            recursive: false,
            error: function() {
                app.alert.show('server-error', {
                    level: 'error',
                    messages: 'ERR_GENERIC_SERVER_ERROR'
                });
            }
        });
    },

    /**
     * Selects multiple models to link and fire the mass link event.
     *
     * @private
     */
    _selectMultipleAndClose: function() {
        var selections = this.context.get('mass_collection');
        var layout = this.layout.layout;
        if (selections && selections.length > 0 && layout) {
            layout.once('list:masslink:complete', this._closeDrawer, this);
            layout.trigger('list:masslink:fire');
        }
    },

    /**
     * Closes the drawer and then refreshes record page with new links.
     *
     * @private
     */
    _closeDrawer: function(model, data, response) {
        app.drawer.close();

        var context = this.context.get('recContext');
        var view = this.context.get('recView');

        if (context.has('parentModel')) {
            var parentModel = context.get('parentModel');
            var syncedAttributes = parentModel.getSynced();
            var updatedAttributes = _.reduce(data.record, function(memo, val, key) {
                    if (!_.isEqual(syncedAttributes[key], val)) {
                        memo[key] = val;
                    }
                    return memo;
                }, {});
            parentModel.set(updatedAttributes);
            //Once parent model is reset, reset internal synced attributes as well
            parentModel.setSyncedAttributes(data.record);

            // get the model's dependencies
            var deps = app.metadata.getModule(parentModel.module, 'dependencies');
            // re-initialize SugarLogic for the parentModel with the module deps
            this.initSugarLogic(parentModel, deps);
        }

        context.set('skipFetch', false);
        // this tells 'collection-count' field to fetch new count in subpanels
        context.set('isLink', true);
        context.reloadData();
    }
}) },
"filter-rows": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Form for creating a filter.
 *
 * Part of {@link View.Layouts.Base.FilterpanelLayout}.
 *
 * @class View.Views.Base.FilterRowsView
 * @alias SUGAR.App.view.views.BaseFilterRowsView
 * @extends View.View
 */
({
	// Filter-rows View (base) 

    events: {
        'click [data-action=add]': 'addRow',
        'click [data-action=remove]': 'removeRow',
        'change [data-filter=field] input[type=hidden]': 'handleFieldSelected',
        'change [data-filter=operator] input[type=hidden]': 'handleOperatorSelected'
    },

    className: 'filter-definition-container',

    filterFields: [],

    lastFilterDef: [],

    /**
     * Map of fields types.
     *
     * Specifies correspondence between field types and field operator types.
     */
    fieldTypeMap: {
        'datetime' : 'date',
        'datetimecombo' : 'date'
    },

    /**
     * @override
     * @param {Object} opts
     */
    initialize: function(opts) {
        //Load partial
        this.formRowTemplate = app.template.get("filter-rows.filter-row-partial");

        this._super('initialize', [opts]);

        this.loadFilterOperators(this.module);

        /**
         * FIXME: we should consider moving it to metadata instead. (see TY-177).
         * Storage for operators that have no values associated with them
         *
         * @private
         * @property {Array}
         * */
        this._operatorsWithNoValues = ['$empty', '$not_empty'];

        this.listenTo(this.layout, "filterpanel:change:module", this.handleFilterChange);
        this.listenTo(this.layout, "filter:create:open", this.openForm);
        this.listenTo(this.layout, 'filter:create:close', this.closeForm);
        this.listenTo(this.context, "filter:create:save", this.saveFilter);
        this.listenTo(this.layout, "filter:create:delete", this.confirmDelete);
    },

    /**
     * Loads filterable fields and operators for supplied module.
     *
     * @param {string} module Selected module name.
     */
    handleFilterChange: function(module) {
        if (_.isEmpty(app.metadata.getModule(module, 'filters')) || this.moduleName === module) {
            return;
        }

        /**
         * Name of the selected module which triggered the filter change.
         *
         * @property {string}
         */
        this.moduleName = module;

        this.loadFilterFields(module);
        this.loadFilterOperators(module);
    },

    /**
     * Loads the list of filter fields for supplied module.
     *
     * @param {string} module The module to load the filter fields for.
     */
    loadFilterFields: function(module) {
        if (_.isEmpty(app.metadata.getModule(module, 'filters'))) {
            return;
        }

        this.fieldList = app.data.getBeanClass('Filters').prototype.getFilterableFields(module);
        this.filterFields = {};

        if (!app.user.hasMapsLicense() && _.has(this.fieldList, '$distance')) {
            const distanceKey = '$distance';

            delete this.fieldList[distanceKey];
        }

        _.each(this.fieldList, function(value, key) {
            this.filterFields[key] = app.lang.get(value.vname, module);
        }, this);
    },

    /**
     * Loads the list of filter operators for supplied module.
     *
     * @param {string} [module] The module to load the filters for.
     */
    loadFilterOperators: function(module) {
        this.filterOperatorMap = app.metadata.getFilterOperators(module);
    },

    /**
     * Handler for filter:create:open event
     * @param {Bean} filterModel
     */
    openForm: function(filterModel) {
        var template = filterModel.get('filter_template') || filterModel.get('filter_definition');
        if (_.isEmpty(template)) {
            this.render();
            this.addRow();
        } else {
            this.populateFilter();
        }
        // After populating the form, save the current edit state
        this.saveFilterEditState();

        //shortcut keys
        app.shortcuts.register({
            id: 'Filter:Add',
            keys: '+',
            component: this,
            description: 'LBL_SHORTCUT_FILTER_ADD',
            handler: function() {
                this.$('[data-action=add]').last().click();
            }
        });
        app.shortcuts.register({
            id: 'Filter:Remove',
            keys: '-',
            component: this,
            description: 'LBL_SHORTCUT_FILTER_REMOVE',
            handler: function() {
                this.$('[data-action=remove]').last().click();
            }
        });
    },

    /**
     * Handler for filter:create:close event
     */
    closeForm: function() {
        this.lastFilterDef = [];
        this.lastFilterTemplate = [];

        this.render();
    },

    /**
     * Save the filter.
     *
     * @param {String} [name] The name of the filter.
     */
    saveFilter: function(name) {
        var self = this,
            obj = {
                filter_definition: this.buildFilterDef(true),
                filter_template: this.buildFilterDef(),
                name: name || this.context.editingFilter.get('name'),
                module_name: this.moduleName
            },
            message = app.lang.get('TPL_FILTER_SAVE', this.moduleName, {name: name});
        if (app.controller.context.get('layout') === 'portaltheme-config') {
            // default is 'base'
            obj.app = 'portal';
        }
        this.context.editingFilter.save(obj, {
            success: function(model) {
                self.context.trigger('filter:add', model);
                self.layout.trigger('filter:toggle:savestate', false);
            },
            showAlerts: {
                'success': {
                    title: app.lang.get('LBL_SUCCESS'),
                    messages: message
                }
            }
        });
    },


    /**
     * Popup alert to confirm delete action.
     */
    confirmDelete: function() {
        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_DELETE_FILTER_CONFIRMATION', this.moduleName),
            onConfirm: _.bind(this.deleteFilter, this)
        });
    },

    /**
     * Delete the filter.
     */
    deleteFilter: function() {
        var self = this,
            name = this.context.editingFilter.get('name'),
            message = app.lang.get('TPL_DELETE_FILTER_SUCCESS', this.moduleName, {name: name});

        this.context.editingFilter.destroy({
            success: function(model) {
                self.layout.trigger('filter:remove', model);
            },
            showAlerts: {
                'success': {
                    title: app.lang.get('LBL_SUCCESS'),
                    messages: message
                }
            }
        });
        this.layout.trigger('filter:create:close');
    },

    /**
     * Get filterable fields from the module metadata
     * @param {String} moduleName
     * @return {Object}
     */
    getFilterableFields: function(moduleName) {
        var moduleMeta = app.metadata.getModule(moduleName),
            fieldMeta = moduleMeta.fields,
            fields = {};
        if (moduleMeta.filters) {
            _.each(moduleMeta.filters, function(templateMeta) {
                if (templateMeta.meta && templateMeta.meta.fields) {
                    fields = _.extend(fields, templateMeta.meta.fields);
                }
            });
        }

        _.each(fields, function(fieldFilterDef, fieldName) {
            var fieldMetaData = app.utils.deepCopy(fieldMeta[fieldName]);
            if (_.isEmpty(fieldFilterDef)) {
                fields[fieldName] = fieldMetaData || {};
            } else {
                fields[fieldName] = _.extend({name: fieldName}, fieldMetaData, fieldFilterDef);
            }
            delete fields[fieldName]['readonly'];
        });

        return fields;
    },

    /**
     * Utility function that instantiates a field for this form.
     *
     * The field action is manually set to `detail` because we want to render
     * the `edit` template but the action remains `detail` (filtering).
     *
     * @param {Data.Bean} model A bean necessary to the field for storing the
     *   value(s).
     * @param {Object} def The field definition.
     * @return {View.Field} The field component.
     */
    createField: function(model, def) {
        var obj = {
            meta: {
                view: "edit"
            },
            def: def,
            model: model,
            context: app.controller.context,
            viewName: "edit",
            view: this
        };
        var field = app.view.createField(obj);
        field.action = 'detail';
        return field;
    },

    /**
     * Add a row to the next element of the event target that triggered it or
     * in the end of the list.
     *
     * @param {Event} [e] The event that triggered the row.
     * @return {Element} The new initialized appended row element.
     */
    addRow: function(e) {
        var $row;

        if (e) {
            // Triggered by clicking the plus sign. Add the row to that point.
            $row = this.$(e.currentTarget).closest('[data-filter=row]');
            $row.after(this.formRowTemplate());
            $row = $row.next();
            this.layout.trigger('filter:toggle:savestate', true);
        }
        return this.initRow($row);
    },

    /**
     * Initializes a row either with the retrieved field values or the
     * default field values.
     *
     * @param {jQuery} [$row] The related filter row.
     * @param {Object} [data] The values to set in the fields.
     * @return {jQuery} $row The initialized row element.
     */
    initRow: function($row, data) {
        $row = $row || $(this.formRowTemplate()).appendTo(this.$el);
        data = data || {};
        var model, field, $fieldValue, $fieldContainer;

        // Init the row with the data available.
        $row.data('name', data.name);
        $row.data('operator', data.operator);
        $row.data('value', data.value);

        // Create a blank model for the enum field, and set the field value if
        // we know it.
        model = app.data.createBean(this.moduleName);
        if (data.name) {
            model.set('filter_row_name', data.name);
        }
        field = this.createField(model, {
            name: 'filter_row_name',
            type: 'enum',
            options: this.filterFields
        });

        // Add the field to the dom.
        $fieldValue = $row.find('[data-filter=field]');
        $fieldContainer = $(field.getPlaceholder().string);
        $fieldContainer.appendTo($fieldValue);

        // Store the field in the data attributes.
        $row.data('nameField', field);

        this._renderField(field, $fieldContainer);

        if (data.name) {
            this.initOperatorField($row);
        }
        return $row;
    },


    /**
     * Remove a row
     * @param {Event} e
     */
    removeRow: function(e) {
        var $row = this.$(e.currentTarget).closest('[data-filter=row]'),
            fieldOpts = [
                {field: 'nameField', value: 'name'},
                {field: 'operatorField', value: 'operator'},
                {field: 'valueField', value: 'value'}
            ];

        this._disposeRowFields($row, fieldOpts);
        $row.remove();
        this.layout.trigger('filter:toggle:savestate', true);
        if (this.$('[data-filter=row]').length === 0) {
            this.addRow();
        }
    },

    /**
     * Validate all filter rows.
     *
     * @param {Array} rows A list of rows to validate.
     * @return {Boolean} `true` if all filter rows are valid, `false`
     *   otherwise.
     */
    validateRows: function(rows) {
        return _.every(rows, this.validateRow, this);
    },

    /**
     * Verify the value of the row is not empty.
     *
     * @param {Element} $row The row to validate.
     * @return {Boolean} `true` if valid, `false` otherwise.
     *
     * TODO we should receive the data only and be jQuery agnostic.
     */
    validateRow: function(row) {
        var $row = $(row),
            data = $row.data();

        if (_.contains(this._operatorsWithNoValues, data.operator)) {
            return true;
        }

        // for empty value in currency we dont want to validate
        if (!_.isUndefined(data.valueField) && !_.isArray(data.valueField) && data.valueField.type ==='currency'
            && (_.isEmpty(data.value) || (_.isObject(data.value) &&
            _.isEmpty(data.valueField.model.get(data.name))))) {
            return false;
        }

        //For date range and predefined filters there is no value
        if (data.isDateRange || data.isPredefinedFilter) {
            return true;
        } else if (data.isFlexRelate) {
            return data.value ?
                _.reduce(data.value, function(memo, val) {
                    return memo && !_.isEmpty(val);
                }, true) :
                false;
        }

        //Special case for between operators where 2 values are needed
        if (_.contains(['$between', '$dateBetween'], data.operator)) {

            if (!_.isArray(data.value) || data.value.length !== 2) {
                return false;
            }

            switch (data.operator) {
                case '$between':
                    // FIXME: the fields should set a true number (see SC-3138).
                    return !(_.isNaN(parseFloat(data.value[0])) || _.isNaN(parseFloat(data.value[1])));
                case '$dateBetween':
                    return !_.isEmpty(data.value[0]) && !_.isEmpty(data.value[1]);
                default:
                    return false;
            }
        }

        return _.isNumber(data.value) || !_.isEmpty(data.value);
    },

    /**
     * Rerender the view with selected filter
     */
    populateFilter: function() {
        var name = this.context.editingFilter.get('name'),
            filterOptions = this.context.get('filterOptions') || {},
            populate = this.context.editingFilter.get('is_template') && filterOptions.filter_populate,
            filterDef = this.context.editingFilter.get('filter_template') ||
                this.context.editingFilter.get('filter_definition');

        this.render();
        this.layout.trigger('filter:set:name', name);

        if (populate) {
            filterDef = app.data.getBeanClass('Filters').prototype.populateFilterDefinition(filterDef, populate);
        }
        _.each(filterDef, function(row) {
            this.populateRow(row);
        }, this);
        //Set lastFilterDef because the filter has already been applied and fireSearch is called in _disposeRowFields
        this.lastFilterDef = this.buildFilterDef(true);
        this.lastFilterTemplate = this.buildFilterDef();
    },

    /**
     * Populates row fields with the row filter definition.
     *
     * In case it is a template filter that gets populated by values passed in
     * the context/metadata, empty values will be replaced by populated
     * value(s).
     *
     * @param {Object} rowObj The filter definition of a row.
     */
    populateRow: function(rowObj) {
        var moduleMeta = app.metadata.getModule(this.layout.currentModule);
        var fieldMeta = moduleMeta.fields;

        _.each(rowObj, function(value, key) {
            var isPredefinedFilter = (this.fieldList[key] && this.fieldList[key].predefined_filter === true);

            if (key === '$or') {
                var keys = _.reduce(value, function(memo, obj) {
                    return memo.concat(_.keys(obj));
                }, []);

                key = _.find(_.keys(this.fieldList), function(key) {
                    if (_.has(this.fieldList[key], 'dbFields')) {
                        return _.isEqual(this.fieldList[key].dbFields.sort(), keys.sort());
                    }
                }, this);

                // Predicates are identical, so we just use the first.
                value = _.values(value[0])[0];
            } else if (key === '$and') {
                var values = _.reduce(value, function(memo, obj) {
                        return _.extend(memo, obj);
                    }, {});
                var def = _.find(this.fieldList, function(fieldDef) {
                        return _.has(values, fieldDef.id_name || fieldDef.name);
                    }, this);

                var operator = '$equals';
                key = def ? def.name : key;

                //  We want to get the operator from our values object only for currency fields
                if (def && !_.isString(values[def.name]) && def.type === 'currency') {
                    operator = _.keys(values[def.name])[0];
                    values[key] = values[key][operator];
                }
                value = {};
                value[operator] = values;
            } else if (key === '$distance') {
                value = value ? value : {};
            } else if (!fieldMeta[key] && !isPredefinedFilter) {
                return;
            }

            if (!this.fieldList[key]) {
                //Make sure we use name for relate fields
                var relate = _.find(this.fieldList, function(field) { return field.id_name === key; });
                // field not found so don't create row for it.
                if (!relate) {
                    return;
                }
                key = relate.name;
                // for relate fields in version < 7.7 we used `$equals` and `$not_equals` operator so for version
                // compatibility & as per TY-159 needed to fix this since 7.7 & onwards we will be using `$in` &
                // `$not_in` operators for relate fields
                if (_.isString(value) || _.isNumber(value)) {
                    value = {$in: [value]};
                } else if (_.keys(value)[0] === '$not_equals') {
                    var val = _.values([value])[0];
                    value = {$not_in: val};
                }
            }

            if (_.isString(value) || _.isNumber(value)) {
                value = {$equals: value};
            }
            _.each(value, function(value, operator) {
                this.initRow(null, {name: key, operator: operator, value: value});
            }, this);
        }, this);
    },

    /**
     * Fired when a user selects a field to filter by
     * @param {Event} e
     */
    handleFieldSelected: function(e) {
        var $el = this.$(e.currentTarget);
        var $row = $el.parents('[data-filter=row]');
        var fieldOpts = [
            {field: 'operatorField', value: 'operator'},
            {field: 'valueField', value: 'value'}
        ];
        this._disposeRowFields($row, fieldOpts);
        this.initOperatorField($row);
    },

    /**
     * Initializes the operator field.
     *
     * @param {jQuery} $row The related filter row.
     */
    initOperatorField: function($row) {
        var $fieldWrapper = $row.find('[data-filter=operator]');
        var data = $row.data();
        var fieldName = data.nameField.model.get('filter_row_name');
        var previousOperator = data.operator;

        // Make sure the data attributes contain the right selected field.
        data['name'] = fieldName;

        if (!fieldName) {
            return;
        }

        // For relate fields
        data.id_name = this.fieldList[fieldName].id_name;
        // For flex-relate fields
        data.type_name = this.fieldList[fieldName].type_name;

        //Predefined filters don't need operators and value field
        if (this.fieldList[fieldName].predefined_filter === true) {
            data.isPredefinedFilter = true;
            this.fireSearch();
            return;
        }

        // Get operators for this filter type
        var fieldType = this.fieldTypeMap[this.fieldList[fieldName].type] || this.fieldList[fieldName].type;
        var payload = {};
        var types = _.keys(this.filterOperatorMap[fieldType]);

        // For parent field with the operator '$equals', the operator field is
        // hidden and we need to display the value field directly. So here we
        // need to assign 'previousOperator' and 'data.operator variables' to let
        // the value field initialize.
        //FIXME: We shouldn't have a condition on the parent field. TY-352 will
        // fix it.
        if (fieldType === 'parent' && _.isEqual(types, ['$equals'])) {
            previousOperator = data.operator = types[0];
        }

        fieldType === 'parent' ?
            $fieldWrapper.addClass('hide').empty() :
            $fieldWrapper.removeClass('hide').empty();
        $row.find('[data-filter=value]').addClass('hide').empty();

        _.each(types, function(operand) {
            payload[operand] = app.lang.get(
                this.filterOperatorMap[fieldType][operand],
                [this.moduleName, 'Filters']
            );
        }, this);

        // Render the operator field
        var model = app.data.createBean(this.moduleName);

        if (previousOperator) {
            model.set('filter_row_operator', data.operator === '$dateRange' ? data.value : data.operator);
        }

        var field = this.createField(model, {
                name: 'filter_row_operator',
                type: 'enum',
                // minimumResultsForSearch set to 9999 to hide the search field,
                // See: https://github.com/ivaynberg/select2/issues/414
                searchBarThreshold: 9999,
                options: payload
            }),
            $field = $(field.getPlaceholder().string);

        $field.appendTo($fieldWrapper);
        data['operatorField'] = field;

        this._renderField(field, $field);

        var hide = fieldType === 'parent';
        this._hideOperator(hide, $row);

        // We want to go into 'initValueField' only if the field value is known.
        // We need to check 'previousOperator' instead of 'data.operator'
        // because even if the default operator has been set, the field would
        // have set 'data.operator' when it rendered anyway.
        if (previousOperator) {
            this.initValueField($row);
        }
    },

    /**
     * Shows or hides the operator field of the filter row specified.
     *
     * Automatically populates the operator field to have value `$equals` if it
     * is not in midst of populating the row.
     *
     * @param {boolean} hide Set to `true` to hide the operator field.
     * @param {jQuery} $row The filter row of interest.
     * @private
     */
    _hideOperator: function(hide, $row) {
        $row.find('[data-filter=value]')
            .toggleClass('span4', !hide)
            .toggleClass('span8', hide);
    },

    /**
     * Fired when a user selects an operator to filter by
     * @param {Event} e
     */
    handleOperatorSelected: function(e) {
        var $el = this.$(e.currentTarget);
        var $row = $el.parents('[data-filter=row]');
        var fieldOpts = [
            {'field': 'valueField', 'value': 'value'}
        ];
        this._disposeRowFields($row, fieldOpts);
        this.initValueField($row);
    },

    /**
     * Check if the selected filter operator is a collective type.
     *
     * @param {jQuery} $row The related filter row.
     */
    isCollectiveValue: function($row) {
        return $row.data('operator') === '$in' || $row.data('operator') === '$not_in';
    },

    /**
     * Initializes the value field.
     *
     * @param {jQuery} $row The related filter row.
     */
    initValueField: function($row) {
        var self = this;
        var data = $row.data();
        var operation = data.operatorField.model.get('filter_row_operator');

        // We have always listened to model changes. More recently, we are
        // listening to attribute changes because collection fields only
        // trigger attribute change events. We don't want to fire a search
        // when both the model and attribute change events occur, hence the
        // debounce.
        var search = _.debounce(function() {
            self._updateFilterData($row);
            self.fireSearch();
        }, 200);

        // Make sure the data attributes contain the right operator selected.
        data.operator = operation;
        if (!operation) {
            return;
        }

        if (_.contains(this._operatorsWithNoValues, operation)) {
            this.fireSearch();
            return;
        }

        // Patching fields metadata
        var moduleName = this.moduleName,
            module = app.metadata.getModule(moduleName),
            fields = app.metadata._patchFields(moduleName, module, app.utils.deepCopy(this.fieldList));

        // More patch for some field types
        var fieldName = $row.find('[data-filter=field] input[type=hidden]').select2('val'),
            fieldType = this.fieldTypeMap[this.fieldList[fieldName].type] || this.fieldList[fieldName].type,
            fieldDef = fields[fieldName];

        switch (fieldType) {
            case 'enum':
                fieldDef.isMultiSelect = this.isCollectiveValue($row);
                // Set minimumResultsForSearch to a negative value to hide the search field,
                // See: https://github.com/ivaynberg/select2/issues/489#issuecomment-13535459
                fieldDef.searchBarThreshold = -1;
                break;
            case 'bool':
                fieldDef.type = 'enum';
                fieldDef.options = fieldDef.options || 'filter_checkbox_dom';
                break;
            case 'int':
                fieldDef.auto_increment = false;
                //For $in operator, we need to convert `['1','20','35']` to `1,20,35` to make it work in a varchar field
                if (operation === '$in') {
                    fieldDef.type = 'varchar';
                    fieldDef.len = 200;
                    if (_.isArray($row.data('value'))) {
                        $row.data('value', $row.data('value').join(','));
                    }
                }
                break;
            case 'teamset':
                fieldDef.type = 'relate';
                fieldDef.isMultiSelect = this.isCollectiveValue($row);
                break;
            case 'datetimecombo':
            case 'date':
                fieldDef.type = 'date';
                //Flag to indicate the value needs to be formatted correctly
                data.isDate = true;
                if (operation.charAt(0) !== '$') {
                    //Flag to indicate we need to build the date filter definition based on the date operator
                    data.isDateRange = true;
                    this.fireSearch();
                    return;
                }
                break;
            case 'relate':
                fieldDef.auto_populate = true;
                fieldDef.isMultiSelect = this.isCollectiveValue($row);
                break;
            case 'parent':
                data.isFlexRelate = true;
                break;
        }
        fieldDef.required = false;
        fieldDef.readonly = false;

        // Create new model with the value set
        var model = app.data.createBean(moduleName);

        var $fieldValue = $row.find('[data-filter=value]');
        $fieldValue.removeClass('hide').empty();

        // Add the field type as an attribute on the HTML element so that it
        // can be used as a CSS selector.
        $fieldValue.attr('data-type', fieldType);

        //fire the change event as soon as the user start typing
        var _keyUpCallback = function(e) {
            if ($(e.currentTarget).is(".select2-input")) {
                return; //Skip select2. Select2 triggers other events.
            }
            this.value = $(e.currentTarget).val();
            // We use "silent" update because we don't need re-render the field.
            model.set(this.name, this.unformat($(e.currentTarget).val()), {silent: true});
            model.trigger('change');
        };

        //If the operation is $between we need to set two inputs.
        if (operation === '$between' || operation === '$dateBetween') {
            var minmax = [];
            var value = $row.data('value') || [];
            if (fieldType === 'currency' && $row.data('value')) {
                value = $row.data('value') || {};
                model.set(value);
                value = value[fieldName] || [];
                // FIXME: Change currency.js to retrieve correct unit for currency filters (see TY-156).
                model.set('id', 'not_new');
            }

            model.set(fieldName + '_min', value[0] || '');
            model.set(fieldName + '_max', value[1] || '');
            minmax.push(this.createField(model, _.extend({}, fieldDef, {name: fieldName + '_min'})));
            minmax.push(this.createField(model, _.extend({}, fieldDef, {name: fieldName + '_max'})));

            if(operation === '$dateBetween') {
                minmax[0].label = app.lang.get('LBL_FILTER_DATEBETWEEN_FROM');
                minmax[1].label = app.lang.get('LBL_FILTER_DATEBETWEEN_TO');
            } else {
                minmax[0].label = app.lang.get('LBL_FILTER_BETWEEN_FROM');
                minmax[1].label = app.lang.get('LBL_FILTER_BETWEEN_TO');
            }

            data['valueField'] = minmax;

            _.each(minmax, function(field) {
                var fieldContainer = $(field.getPlaceholder().string);
                $fieldValue.append(fieldContainer);
                this.listenTo(field, 'render', function() {
                    field.$('input, select, textarea').addClass('inherit-width');
                    field.$('.input-append').prepend('<span class="add-on">' + field.label + '</span>');
                    field.$('.input-append').addClass('input-prepend');
                    // .date makes .inherit-width on input have no effect so we need to remove it.
                    field.$('.input-append').removeClass('date');
                    field.$('input, textarea').on('keyup', _.debounce(_.bind(_keyUpCallback, field), 400));
                });
                this._renderField(field, fieldContainer);
            }, this);
        } else if (data.isFlexRelate) {
            _.each($row.data('value'), function(value, key) {
                model.set(key, value);
            }, this);

            var field = this.createField(model, _.extend({}, fieldDef, {name: fieldName})),
                fieldContainer = $(field.getPlaceholder().string),
                findRelatedName = app.data.createBeanCollection(model.get('parent_type'));
            data['valueField'] = field;
            $fieldValue.append(fieldContainer);

            if (model.get('parent_id')) {
                findRelatedName.fetch({
                    params: {filter: [{'id': model.get('parent_id')}]},
                    complete: _.bind(function() {
                        if (!this.disposed) {
                            if (findRelatedName.first()) {
                                model.set(fieldName,
                                    findRelatedName.first().get(field.getRelatedModuleField()),
                                    {silent: true});
                            }
                            if (!field.disposed) {
                                this._renderField(field, fieldContainer);
                            }
                        }
                    }, this)
                });
            } else {
                this._renderField(field, fieldContainer);
            }
        } else {
            // value is either an empty object OR an object containing `currency_id` and currency amount
            if (fieldType === 'currency' && $row.data('value')) {
                // for stickiness & to retrieve correct saved values, we need to set the model with data.value object
                model.set($row.data('value'));
                // FIXME: Change currency.js to retrieve correct unit for currency filters (see TY-156).
                // Mark this one as not_new so that model isn't treated as new
                model.set('id', 'not_new');
            } else {
                model.set(fieldDef.id_name || fieldName, $row.data('value'));
            }
            // Render the value field
            var field = this.createField(model, _.extend({}, fieldDef, {name: fieldName})),
                fieldContainer = $(field.getPlaceholder().string);
            $fieldValue.append(fieldContainer);
            data['valueField'] = field;

            this.listenTo(field, 'render', function() {
                field.$('input, select, textarea').addClass('inherit-width');
                // .date makes .inherit-width on input have no effect so we need to remove it.
                field.$('.input-append').removeClass('date');
                field.$('input, textarea').on('keyup',_.debounce(_.bind(_keyUpCallback, field), 400));
            });
            if ((fieldDef.type === 'relate' || fieldDef.type === 'nestedset') &&
                !_.isEmpty($row.data('value'))
            ) {
                var findRelatedName = app.data.createBeanCollection(fieldDef.module);
                var relateOperator = this.isCollectiveValue($row) ? '$in' : '$equals';
                var relateFilter = [{id: {}}];
                relateFilter[0].id[relateOperator] = $row.data('value');
                findRelatedName.fetch({fields: [fieldDef.rname], params: {filter: relateFilter},
                    complete: function() {
                        if (!self.disposed) {
                            if (findRelatedName.length > 0) {
                                model.set(fieldDef.id_name, findRelatedName.pluck('id'), { silent: true });
                                model.set(fieldName, findRelatedName.pluck(fieldDef.rname), { silent: true });
                            }
                            if (!field.disposed) {
                                self._renderField(field, fieldContainer);
                            }
                        }
                    }
                });
            } else {
                this._renderField(field, fieldContainer);
            }
        }
        // When the value change a quicksearch should be fired to update the results
        this.listenTo(model, 'change', search);
        this.listenTo(model, 'change:' + fieldName, search);

        // Manually trigger the filter request if a value has been selected lately
        // This is the case for checkbox fields or enum fields that don't have empty values.
        var modelValue = model.get(fieldDef.id_name || fieldName);

        // To handle case: value is an object with 'currency_id' = 'xyz' and 'likely_case' = ''
        // For currency fields, when value becomes an object, trigger change
        if (!_.isEmpty(modelValue) && modelValue !== $row.data('value')) {
            model.trigger('change');
        }
    },

    /**
     * Update filter data for this row
     * @param $row Row to update
     * @private
     */
    _updateFilterData: function($row){
        var data = $row.data(),
            field = data['valueField'],
            name = data['name'],
            valueForFilter;

        //Make sure we use ID for relate fields
        if (this.fieldList[name] && this.fieldList[name].id_name) {
            name = this.fieldList[name].id_name;
        }

        //If we have multiple fields we have to build an array of values
        if (_.isArray(field)) {
            valueForFilter = [];
            _.each(field, function(field) {
                var value = !field.disposed && field.model.has(field.name) ? field.model.get(field.name) : '';
                value = $row.data('isDate') ? (app.date.stripIsoTimeDelimterAndTZ(value) || '') : value;
                valueForFilter.push(value);
            });
        } else {
            var value = !field.disposed && field.model.has(name) ? field.model.get(name) : '';
            valueForFilter = $row.data('isDate') ? (app.date.stripIsoTimeDelimterAndTZ(value) || '') : value;
        }
        $row.data("value", valueForFilter); // Update filter value once we've calculated final value
    },

    /**
     * Check each row, builds the filter definition and trigger the filtering
     */
    fireSearch: _.debounce(function() {
        var filterDef = this.buildFilterDef(true),
            filterTemplate = this.buildFilterDef(),
            defHasChanged = !_.isEqual(this.lastFilterDef, filterDef),
            templateHasChanged = !_.isEqual(this.lastFilterTemplate, filterTemplate);

        // Save the current edit state
        if (defHasChanged || templateHasChanged) {
            this.saveFilterEditState(filterDef, filterTemplate);
            this.lastFilterDef = filterDef;
            this.lastFilterTemplate = filterTemplate;
            this.layout.trigger('filter:toggle:savestate', true);
        }
        if (!defHasChanged) {
            return;
        }
        // Needed in order to prevent filtering a global context collection (see filter.js:applyFilter()).
        if (this.context.get('applyFilter') !== false) {
            this.layout.trigger('filter:apply', null, filterDef);
        }
    }, 400),

    /**
     * Saves the current edit state into the cache
     *
     * @param {Object} [filterDef] Filter Definition. Defaults to the
     *   {@link #builtFilderDef} with only valid rows.
     * @param {Object} [templateDef] Filter template definition. Defaults to
     *   the {@link #builtFilderDef} with all rows.
     */
    saveFilterEditState: function(filterDef, templateDef) {
        if (!this.context.editingFilter) {
            return;
        }
        this.context.editingFilter.set({
            'filter_definition': filterDef || this.buildFilterDef(true),
            'filter_template': templateDef || this.buildFilterDef()
        });
        var filter = this.context.editingFilter.toJSON();

        // Make sure the filter-actions view is rendered, otherwise it will override the name with an empty name.
        if (this.layout.getComponent('filter-actions') &&
            this.layout.getComponent('filter-actions').$('input').length === 1
        ) {
            filter.name = this.layout.getComponent('filter-actions').getFilterName();
        }

        if (!_.isUndefined(this.layout.getComponent('filter'))) {
            this.layout.getComponent('filter').saveFilterEditState(filter);
        }
    },

    /**
     * Build filter definition for all rows.
     *
     * @param {Boolean} onlyValidRows Set `true` to retrieve only filter
     *   definition of valid rows, `false` to retrieve the entire field
     *   template.
     * @return {Array} Filter definition.
     */
    buildFilterDef: function(onlyValidRows) {
        var $rows = this.$('[data-filter=row]'),
            filter = [];

        _.each($rows, function(row) {
            var rowFilter = this.buildRowFilterDef($(row), onlyValidRows);

            if (rowFilter) {
                filter.push(rowFilter);
            }
        }, this);

        return filter;
    },

    /**
     * Build filter definition for this row.
     *
     * @param {jQuery} $row The related row.
     * @param {Boolean} onlyIfValid Set `true` to validate the row and return
     *   `undefined` if not valid, or `false` to build the definition anyway.
     * @return {Object} Filter definition for this row.
     */
    buildRowFilterDef: function($row, onlyIfValid) {
        var data = $row.data();
        if (onlyIfValid && !this.validateRow($row)) {
            return;
        }
        var operator = data['operator'],
            value = data['value'] || '',
            name = data['id_name'] || data['name'],
            filter = {};

        if (_.isEmpty(name)) {
            return;
        }

        if (data.isPredefinedFilter || !this.fieldList) {
            filter[name] = '';
            return filter;
        } else {
            if (!_.isEmpty(data.valueField) && _.isFunction(data.valueField.delegateBuildFilterDefinition)) {
                filter[name] = {};
                filter[name][operator] = data.valueField.delegateBuildFilterDefinition();
            } else if (this.fieldList[name] && _.has(this.fieldList[name], 'dbFields')) {
                var subfilters = [];
                _.each(this.fieldList[name].dbFields, function(dbField) {
                    var filter = {};
                    filter[dbField] = {};
                    filter[dbField][operator] = value;
                    subfilters.push(filter);
                });
                filter['$or'] = subfilters;
            } else {
                if (data.isFlexRelate) {
                    var valueField = data['valueField'],
                        idFilter = {},
                        typeFilter = {};

                    idFilter[data.id_name] = valueField.model.get(data.id_name);
                    typeFilter[data.type_name] = valueField.model.get(data.type_name);
                    filter['$and'] = [idFilter, typeFilter];
                // Creating currency filter. For all but `$between` operators we use type property from data.valueField.
                // For `$between`, data.valueField is an array and therefore we check for type==='currency' from
                // either of the elements.
                } else if (data['valueField'] && (data['valueField'].type === 'currency' ||
                    (_.isArray(data.valueField) && data.valueField[0].type === 'currency'))
                    ) {
                    // initially value is an array which we later convert into an object for saving and retrieving
                    // purposes (stickiness structure constraints)
                    var amountValue;
                    if (_.isObject(value) && !_.isUndefined(value[name])) {
                        amountValue = value[name];
                    } else {
                        amountValue = value;
                    }

                    var amountFilter = {};
                    amountFilter[name] = {};
                    amountFilter[name][operator] = amountValue;

                    // for `$between`, we use first element to get dataField ('currency_id') since it is same
                    // for both elements and also because data.valueField is an array
                    var dataField;
                    if (_.isArray(data.valueField)) {
                        dataField = data.valueField[0];
                    } else {
                        dataField = data.valueField;
                    }

                    var currencyId;
                    currencyId = dataField.getCurrencyField().name;

                    var currencyFilter = {};
                    currencyFilter[currencyId] = dataField.model.get(currencyId);

                    filter['$and'] = [amountFilter, currencyFilter];
                } else if (data.isDateRange) {
                    //Once here the value is actually a key of date_range_selector_dom and we need to build a real
                    //filter definition on it.
                    filter[name] = {};
                    filter[name].$dateRange = operator;
                } else if (operator === '$in' || operator === '$not_in') {
                    // IN/NOT IN require an array
                    filter[name] = {};
                    //If value is not an array, we split the string by commas to make it an array of values
                    if (_.isArray(value)) {
                        filter[name][operator] = value;
                    } else if (!_.isEmpty(value)) {
                        filter[name][operator] = (value + '').split(',');
                    } else {
                        filter[name][operator] = [];
                    }
                } else {
                    filter[name] = {};
                    filter[name][operator] = value;
                }
            }

            return filter;
        }
    },

    /**
     * Reset filter values on filter form. Called after a click on `Reset` button
     */
    resetFilterValues: function() {
        var $rows = this.$('[data-filter=row]');
        _.each($rows, function(row) {
            var $row = $(row);
            var valueField = $row.data('valueField');

            if (!valueField || valueField.disposed) {
                return;
            }
            if (!_.isArray(valueField)) {
                valueField.model.clear();
                return;
            }
            _.each(valueField, function(field) {
                field.model.clear();
            });
        });
    },

    /**
     * Disposes fields stored in the data attributes of the row element.
     *
     *     @example of an `opts` object param:
     *      [
     *       {field: 'nameField', value: 'name'},
     *       {field: 'operatorField', value: 'operator'},
     *       {field: 'valueField', value: 'value'}
     *      ]
     *
     * @param  {jQuery} $row The row which fields are to be disposed.
     * @param  {Array} opts An array of objects containing the field object and
     *  value to the data attributes of the row.
     */
    _disposeRowFields: function($row, opts) {
        var data = $row.data(), model;

        if (_.isObject(data) && _.isArray(opts)) {
            _.each(opts, function(val) {
                if (data[val.field]) {
                    //For in between filter we have an array of fields so we need to cover all cases
                    var fields = _.isArray(data[val.field]) ? data[val.field] : [data[val.field]];
                    data[val.value] = '';
                    _.each(fields, function(field) {
                        model = field.model;
                        if (val.field === "valueField" && model) {
                            model.clear({silent: true});
                            this.stopListening(model);
                        }
                        field.dispose();
                        field = null;
                    }, this);
                    return;
                }
                if (data.isDateRange && val.value === 'value') {
                    data.value = '';
                }
            }, this);
        }
        //Reset flags
        data.isDate = false;
        data.isDateRange = false;
        data.isPredefinedFilter = false;
        data.isFlexRelate = false;
        $row.data(data);
        this.fireSearch();
    }
}) },
"shortcuts-help": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Render help page for keyboard shortcuts.
 *
 * @class View.Views.Base.ShortcutsHelpView
 * @alias SUGAR.App.view.views.BaseShortcutsHelpView
 * @extends View.View
 */
({
	// Shortcuts-help View (base) 

    shortcutsHelpTableTemplate: '',
    modRegExp: new RegExp('mod'),
    macRegExp: new RegExp('Mac|iPod|iPhone|iPad'),
    hasCommandKey: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // refresh shortcuts help page
        this.context.on('shortcuts:help:render', function() {
            this.render();
        }, this);

        // get templates
        this.shortcutsHelpTableTemplate = app.template.getView(this.name + '.shortcuts-help-table');

        // test to see if user uses MacOS.
        this.hasCommandKey = this.macRegExp.test(this.getCurrentPlatform());
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function(ctx, options) {
        this._super('_renderHtml', [ctx, options]);

        // populate help tables
        this.$('[data-render=global]').append(this.buildGlobalHelpTable().children());
        this.$('[data-render=contextual]').append(this.buildContextualHelpTable().children());
    },

    /**
     * Build the help table for global shortcuts.
     * @returns {jQuery}
     */
    buildGlobalHelpTable: function() {
        var $html = $('<div/>'),
            globalShortcuts = app.shortcuts.getRegisteredGlobalShortcuts(),
            help = this.prepareShorcutsHelpDataForDisplay(globalShortcuts);

        $html.append(this.shortcutsHelpTableTemplate(help));

        return $html;
    },

    /**
     * Build the help table for contextual shortcuts.
     * @returns {jQuery}
     */
    buildContextualHelpTable: function() {
        var $html = $('<div/>'),
            lastShortcutSession = app.shortcuts.getLastSavedSession(),
            contextualShortcuts,
            help;

        if (lastShortcutSession) {
            contextualShortcuts = lastShortcutSession.getRegisteredShortcuts();
            if (contextualShortcuts) {
                help = this.prepareShorcutsHelpDataForDisplay(contextualShortcuts);
                $html.append(this.shortcutsHelpTableTemplate(help));
            }
        }

        return $html;
    },

    /**
     * Take the available shortcuts data and transform it for displaying the data
     * in a help table.
     * @param {Array} shortcuts
     * @returns {Array}
     */
    prepareShorcutsHelpDataForDisplay: function(shortcuts) {
        var help = [];

        _.each(shortcuts, function(shortcut) {
            help.push({
                keys: this.getKeyString(shortcut.keys),
                help: app.lang.get(shortcut.description, this.module)
            });
        }, this);

        return help;
    },

    /**
     * Build text for keys needed to perform shortcut action.
     * @param {Array} keys
     * @return {string}
     */
    getKeyString: function(keys) {
        var formattedKeys = _.map(keys, function(key) {
            return key.replace(this.modRegExp, this.hasCommandKey ? 'command' : 'ctrl');
        }, this);

        return formattedKeys.join(', ');
    },

    /**
     * Get the user's current platform.
     * @return {string}
     */
    getCurrentPlatform: function() {
        return navigator.platform;
    }
}) },
"massaddtolist-progress": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MassaddtolistProgressiew
 * @alias SUGAR.App.view.views.BaseMassaddtolistProgressView
 * @extends View.Views.Base.MassupdateProgressView
 */
({
	// Massaddtolist-progress View (base) 

    extendsFrom: 'MassupdateProgressView',

    /**
     * Set of labels.
     *
     * @property
     */
    _labelSet: {
        'update': {
            PROGRESS_STATUS: 'TPL_MASSADDTOLIST_PROGRESS_STATUS',
            DURATION_FORMAT: 'TPL_MASSADDTOLIST_DURATION_FORMAT',
            FAIL_TO_ATTEMPT: 'TPL_MASSADDTOLIST_FAIL_TO_ATTEMPT',
            WARNING_CLOSE: 'TPL_MASSADDTOLIST_WARNING_CLOSE',
            WARNING_INCOMPLETE: 'TPL_MASSADDTOLIST_WARNING_INCOMPLETE',
            SUCCESS: 'TPL_MASSADDTOLIST_SUCCESS',
            TITLE: 'TPL_MASSADDTOLIST_TITLE'
        }
    }

}) },
"hint-config-header-buttons": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HintConfigHeaderButtonsView
 * @alias SUGAR.App.view.views.BaseHintConfigHeaderButtonsView
 * @extends View.Views.Base.ConfigHeaderButtonsView
 */
({
	// Hint-config-header-buttons View (base) 

    extendsFrom: 'ConfigHeaderButtonsView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        var self = this;
        app.api.call('read', this._getSaveConfigURL(), null, {
            success: function(config) {
                config = config || {};
                config.logger = config.logger || {};
                self.model = self.model || app.data.createBean();
                self.model.set('logger_level', config.logger.level || 'alert');
            },
            error: function(err) {
                console.log('Error fetching configuration', err);
            }
        });
    },

    /**
     * @inheritdoc
     */
    cancelConfig: function() {
        this._super('cancelConfig');

        app.router.navigate(this.module, {trigger: true});
    },

    /**
     * @inheritdoc
     */
    showSavedConfirmation: function(onClose) {
        onClose = onClose || function() {};
        var alert = app.alert.show('module_config_success', {
            level: 'success',
            title: app.lang.get('LBL_HINT_CONFIG', 'Administration') + ':',
            messages: app.lang.get('LBL_HINT_CONFIG_SAVED', 'Administration'),
            autoClose: true,
            autoCloseDelay: 5000,
            onAutoClose: _.bind(function() {
                alert.getCloseSelector().off();
                onClose();
            })
        });
        var $close = alert.getCloseSelector();
        $close.on('click', onClose);
        app.accessibility.run($close, 'click');
    },

    /**
     * @inheritdoc
     */
    _saveConfig: function() {
        // update the notifications enabled/disabled entry in the sugar table
        var url = app.api.buildURL('hint/config/notifications');
        var attributes = {};
        var disableNotifications = 'disableNotifications';
        attributes[disableNotifications] = $('#config_disable_hint_notifications').prop('checked');

        var self = this;

        app.api.call('create', self._getSaveConfigURL(), self._getSaveConfigAttributes(), {
            success: function(data) {
                app.api.call('update', url, attributes, {
                    success: _.bind(function() {
                        self.showSavedConfirmation();
                        if (app.drawer.count()) {
                            // close the drawer
                            app.drawer.close(self.context, self.context.get('model'));

                            app.sync();
                        }

                        // we navigate anyway
                        app.router.navigate(self.module, {trigger: true});
                    }, self),
                    error: _.bind(function() {
                        self.getField('save_button').setDisabled(false);
                    }, self)
                });
            },
            error: function(err) {
                self.getField('save_button').setDisabled(false);
            }
        });
    },

    /**
     * @inheritdoc
     */
    _getSaveConfigURL: function() {
        return app.api.buildURL('hint/config');
    },

    /**
     * @inheritdoc
     */
    _getSaveConfigAttributes: function() {
        return {
            logger: {
                level: this.model.get('logger_level')
            }
        };
    }
}) },
"docusign": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DocusignView
 * @alias SUGAR.App.view.views.BaseDocusignView
 * @extends View.View
 */
({
	// Docusign View (base) 

    plugins: ['Dashlet'],
    showNewEnvelopeDocs: false,

    envelopeListLayout: null,
    draftListLayout: null,
    docsListLayout: null,

    className: 'docusign',

    events: {
        'click .nav-tabs li[data-tabname]': 'switchContent',
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.listenTo(app.events, 'docusign:reload', _.bind(function() {
            this.initDashlet();
        }, this));

        this.on('chart:clicked', this.chartClickHandler, this);

        this.listenTo(this.context, 'sendDocumentsToDocuSign', _.bind(this.sendToDocuSign, this));
    },

    /**
     * @inheritdoc
     */
    initDashlet: function(options) {
        if (this.meta.config) {
            return;
        }

        if (_.isUndefined(options) || _.isUndefined(options.params)) {
            options = {
                params: {}
            };
        }

        app.api.call('read', app.api.buildURL('DocuSign/checkEAPM'), {}, {
            success: _.bind(function(connected) {
                this.userIsConfigured = connected;

                if (this.userIsConfigured) {
                    if (app.controller.context.get('module') !== 'Home' &&
                        app.controller.context.get('layout') === 'record') {
                        this.showNewEnvelopeDocs = true;
                    }
                    this.showDrafts = true;
                } else {
                    this.showNewEnvelopeDocs = false;
                    this.showDrafts = false;
                }

                this.setupComponents();
            }, this),
            error: function(error) {
                app.alert.show('error-checking-eapm', {
                    level: 'error',
                    messages: error
                });
            },
        });
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var userHasBeenChecked = _.isBoolean(this.userIsConfigured);
        if (userHasBeenChecked) {
            this.disposeDashletTabContents();

            this.setupComponents();
        }
        this._super('loadData', [options]);
    },

    /**
     * Setup chart and lists
     *
     * @param {Object} options
     */
    setupComponents: function(options) {
        if (this.disposed || this.meta.config) {
            return;
        }

        if (app.acl.hasAccess('read', this.module)) {
            this.loadOverview();
            this.createEnvelopesListLayout();
            if (this.showDrafts) {
                this.createDraftsListLayout();
            }
            if (this.showNewEnvelopeDocs) {
                this.createNewEnvelopeListView();
            }

            this.setupEnvelopesListFilters();
            this.envelopeCollection.fetch({
                success: _.bind(this.renderEnvelopeList, this)
            });

            if (this.showDrafts) {
                this.setupDraftsListFilters();
                this.draftCollection.fetch({
                    success: _.bind(this.renderDraftList, this)
                });
            }
            this.loaded = true;

            this.render();
        }
    },

    /**
     * Load envelopes
     *
     * @param {Object} options Collection options
     */
    setupEnvelopesListFilters: function(options) {
        if (app.controller.context) {
            var contextModule = app.controller.context.get('module');
            this.envelopeCollection.options = options || {
                params: {}
            };

            var layout = app.controller.context.get('layout');

            if (contextModule === 'Home') {
                this.envelopeCollection.options.params.layout = 'records';
            } else {
                if (layout === 'record') {
                    var contextBean = app.controller.context.get('model');
                    this.envelopeCollection.options.params.layout = 'record';
                    this.envelopeCollection.options.params.record = contextBean.get('id');
                } else {
                    this.envelopeCollection.options.params.layout = 'records';
                }
            }
            this.envelopeCollection.options.params.recordModule = contextModule;
            this.envelopeCollection.options = this.envelopeCollection.options || {};
            this.envelopeCollection.options.params.offset = 0;

            this.envelopeCollection._initOptions = _.extend({}, this.envelopeCollection.options);

            if (this.envelopeCollection.setOption) {
                options = _.extend(this.envelopeCollection.options);
                this.envelopeCollection.setOption('params', options.params);
            }
        }
    },

    /**
     * Create envelopes list layout
     */
    createEnvelopesListLayout: function() {
        var model = app.data.createBean('DocuSignEnvelopes');
        this.envelopeCollection = app.data.createBeanCollection('DocuSignEnvelopes', [], {});

        var enabledFieldNames = [
            'date_entered',
            'created_by_name',
            'name',
            'status',
            'envelope_id'
        ];
        this.envelopeCollection.setOption('fields', enabledFieldNames);

        var context = new app.Context({
            module: 'DocuSignEnvelopes',
            model: model,
            collection: this.envelopeCollection,
            fields: enabledFieldNames
        });

        this.envelopeListLayout = app.view.createLayout({
            context: context,
            type: 'docusign-envelopes',
            name: 'docusign-envelopes',
            module: 'DocuSignEnvelopes',
            collection: this.envelopeCollection
        });

        this.envelopeListLayout.initComponents();
    },

    /**
     * Setup drafts
     *
     * @param {Object} options
     */
    setupDraftsListFilters: function(options) {
        if (app.controller.context) {
            var contextModule = app.controller.context.get('module');
            this.draftCollection.options = options || {
                params: {
                    status: 'created'
                }
            };

            var layout = app.controller.context.get('layout');

            if (contextModule === 'Home') {
                this.draftCollection.options.params.layout = 'records';
            } else {
                if (layout === 'record') {
                    var contextBean = app.controller.context.get('model');
                    this.draftCollection.options.params.layout = 'record';
                    this.draftCollection.options.params.record = contextBean.get('id');
                } else {
                    this.draftCollection.options.params.layout = 'records';
                }
            }
            this.draftCollection.options.params.recordModule = contextModule;
            this.draftCollection.options = this.draftCollection.options || {};
            this.draftCollection.options.params.offset = 0;

            this.draftCollection._initOptions = _.extend({}, this.draftCollection.options);

            options = _.extend(this.draftCollection.options);
            this.draftCollection.setOption('params', options.params);
        }
    },

    /**
     * Create drafts list
     */
    createDraftsListLayout: function() {
        var model = app.data.createBean('DocuSignEnvelopes');
        this.draftCollection = app.data.createBeanCollection('DocuSignEnvelopes', [], {});

        var enabledFieldNames = [
            'date_entered',
            'created_by_name',
            'name',
            'status',
            'envelope_id'
        ];
        this.draftCollection.setOption('fields', enabledFieldNames);

        var context = new app.Context({
            module: 'DocuSignEnvelopes',
            model: model,
            collection: this.draftCollection,
            fields: enabledFieldNames
        });

        this.draftListLayout = app.view.createLayout({
            context: context,
            type: 'docusign-drafts',
            name: 'docusign-drafts',
            module: 'DocuSignEnvelopes',
            collection: this.draftCollection
        });

        this.draftListLayout.initComponents();

        //add handler to open drawer for draft seding
        this.listenTo(context, 'list:draft:open', _.bind(this.showDraft, this));
    },

    /**
     * Load overview tab
     */
    loadOverview: function() {
        var data = {
            recordModule: app.controller.context.get('module')
        };

        if (app.controller.context.get('module') !== 'Home') {
            if (app.controller.context.get('layout') === 'record') {
                var contextBean = app.controller.context.get('model');
                data.recordId = contextBean.get('id');
            }
        }

        app.api.call('create', app.api.buildURL('DocuSign/stats'), data, {
            success: _.bind(this.renderOverview, this),
            error: function(error) {
                app.alert.show('error-getting-counts', {
                    level: 'error',
                    messages: error.message
                });
            }
        });
    },

    /**
     * Render overview chart
     *
     * @param {Object} statuses
     */
    renderOverview: function(statuses) {
        if (_.isUndefined(statuses)) {
            return;
        }

        if (statuses.all === 0) {
            if (!this.meta.config && this.chartField) {
                this.chartField.displayNoData(true);
            }
            return;
        }

        let colorPalette = [
            '#517bf8', // @ocean
            '#36b0ff', // @pacific
            '#00e0e0', // @teal
            '#00ba83', // @green
            '#6cdf46', // @army
            '#ffd132', // @yellow
            '#ff9445' // @orange
        ];
        let colorPaletteNotNull = [];

        let rawChartData = {
            values: []
        };

        let availableStatuses = ['created', 'sent', 'delivered', 'completed', 'declined', 'voided', 'signed'];

        _.each(availableStatuses, function(status, idx) {
            if (statuses[status] !== 0) {
                rawChartData.values.push(
                    {
                        label: [
                            app.lang.get('LBL_ENVELOPE_STATUS_' + status.toUpperCase(), 'DocuSignEnvelopes')
                        ],
                        values: [
                            statuses[status]
                        ],
                        valuelabels: [
                            (statuses[status]).toString()
                        ],
                        key: status
                    }
                );
                colorPaletteNotNull.push(colorPalette[idx]);
            }
        });

        var params = this.chartModel.get('rawChartParams');
        params.colorOverrideList = colorPaletteNotNull;

        this.chartModel.set('rawChartParams', params);

        this.chartModel.set('rawChartData', rawChartData);
    },

    /**
     * @inheritdoc
     * When rendering fields, get a reference to the chart field if we don't have one yet
     */
    _renderField: function(field) {
        this._super('_renderField', [field]);

        // hang on to a reference to the chart field
        if ((_.isUndefined(this.chartField) || this.chartField.disposed) && field.name === 'chart') {
            this.chartField = field;
        }
    },

    /**
     * Filter envelope list
     *
     * @param {string} status
     */
    filterEnvelopeList: function(status) {
        if (status === 'created' && this.showDrafts) {
            this.$('[data-tabname=\'drafts\'] a').click();
        } else {
            var options = {
                params: {
                    status: status
                }
            };

            this.setupEnvelopesListFilters(options);
            this.envelopeCollection.fetch({
                success: _.bind(this.renderEnvelopeList, this)
            });

            this.$('[data-tabname=\'envelopes\'] a').click();
        }
    },

    /**
     * Create new envelope list view
     */
    createNewEnvelopeListView: function() {
        var contextCollection = app.controller.context.get('documentCollection');
        if (contextCollection instanceof app.data.beanCollection) {
            this.documentCollection = contextCollection;
        } else {
            this.documentCollection = app.data.createBeanCollection('Documents');
            app.controller.context.set('documentCollection', this.documentCollection);
        }

        var model = app.data.createBean('Documents');
        var context = this.context.getChildContext({
            forceNew: true
        });
        context.set({
            module: 'Documents',
            model: model,
            collection: this.documentCollection,
            layout: 'records'
        });

        this.docsListLayout = app.view.createLayout({
            context: context,
            type: 'docusign-documents',
            name: 'docusign-documents',
            module: 'Documents',
            collection: this.documentCollection
        });

        this.listenTo(this.documentCollection, 'change add remove', _.bind(function changeAddRemoveCollectionHandler() {
            if (this.disposed) {
                return;
            }
            this.docsListLayout.render();
            if (this.$el) {
                this.$('[data-tabname="documents"] a').click();
            }
        }, this));

        this.listenTo(this.documentCollection, 'reset', _.bind(function resetCollectionHandler() {
            if (this.disposed) {
                return;
            }

            this.docsListLayout.render();
        }, this));

        this.docsListLayout.initComponents();
    },

    /**
     * Render new envelope docs list
     */
    renderNewEnvelopeDocsList: function() {
        if (this.$el === null) {
            return;
        }

        this.$('.documents_docusign_content').html(this.docsListLayout.$el);
        this.docsListLayout.render();
    },

    /**
     * Render envelope list
     *
     * @param {Object} res
     */
    renderEnvelopeList: function(res) {
        if (this.$el === null || !(this.envelopeListLayout instanceof app.view.Layout)) {
            return;
        }

        this.$('.envelopes_docusign_content').html(this.envelopeListLayout.$el);
        this.envelopeListLayout.render();

        // we need to manually do this here because just now the component is on DOM
        this.envelopeListLayout.getComponent('docusign-envelopes-list').delegateEvents();
        this.envelopeListLayout.getComponent('list-bottom').delegateEvents();
    },

    /**
     * Render drafts list
     *
     * @param {Object} res
     */
    renderDraftList: function(res) {
        if (this.$el === null) {
            return;
        }

        this.$('.drafts_docusign_content').html(this.draftListLayout.$el);
        this.draftListLayout.render();

        // we need to manually do this here because just now the component is on DOM
        this.draftListLayout.getComponent('docusign-drafts-list').delegateEvents();
        this.draftListLayout.getComponent('list-bottom').delegateEvents();
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (this.disposed) {
            return;
        }

        if (this.meta.config || this.loaded !== true) {
            this._super('_render');
            return;
        }

        // chartField is recreated on each render call so this model must always be defined before render
        this.chartModel = new Backbone.Model({
            rawChartParams: {
                show_title: false,
                chart_type: 'pie chart',
                allowScroll: false
            }
        });

        this._super('_render');


        this.renderEnvelopeList();

        if (this.showDrafts) {
            this.renderDraftList();
        }

        if (this.showNewEnvelopeDocs) {
            this.renderNewEnvelopeDocsList();
        }
    },

    /**
     * Initiate the send process, by opening the tab
     */
    sendToDocuSign: function() {
        if (!this.userIsConfigured) {
            app.alert.show('warn-docusign-user-not-logged-in', {
                level: 'warning',
                messages: app.lang.get('LBL_PLEASE_LOG_IN', 'DocuSignEnvelopes'),
                autoClose: true,
                autoCloseDelay: '10000'
            });

            return;
        }

        app.alert.show('load-tab-for-sending', {
            level: 'process',
            title: app.lang.get('LBL_LOADING')
        });

        var controllerCtx = app.controller.context;
        var controllerModel = controllerCtx.get('model');
        var module = controllerModel.get('_module');
        var modelId = controllerModel.get('id');
        var documents = _.pluck(this.documentCollection.models, 'id');

        var data = {
            returnUrlParams: {
                parentRecord: module,
                parentId: modelId,
                token: app.api.getOAuthToken()
            },
            documents: documents
        };

        var docusignPageURL = app.api.buildURL('DocuSign', 'loadPage');
        var docusignTab = window.open(docusignPageURL);//makes the browser consider the action as user not script made

        this._sendEnvelope(data, docusignTab);
    },

    /**
     * Click handler to filter envelopes
     *
     * @param {Object} event
     * @param {Array} activeElements
     * @param {Object} chart
     */
    chartClickHandler: function(event, activeElements, chart) {
        let element = chart.getElementsAtEventForMode(event, 'nearest', {intersect: true}, false);
        if (_.isEmpty(element)) {
            return;
        }
        let groupIndex = element[0].index;
        let status = this.chartModel.attributes.rawChartData.values[groupIndex].key;

        this.filterEnvelopeList(status);
    },

    /**
     * Switch tab content
     *
     * @param {Event} e
     */
    switchContent: function(e) {
        var liElement = $(e.target).parent();
        var oldLiElement = liElement.parent().find('.active');
        liElement
            .parent()
            .find('li')
            .removeClass('active');
        liElement.addClass('active');

        var oldTab = oldLiElement.data('tabname');
        var newTab = liElement.data('tabname');
        if (oldTab !== newTab) {
            var oldContetSelector = '.' + oldTab + '_docusign_content';
            this.$(oldContetSelector).hide();

            var newContetSelector = '.' + newTab + '_docusign_content';
            this.$(newContetSelector).show();
        }
        if (newTab === 'overview') {
            this.$('.main').show();
        } else {
            // .main is the parent of overview and it must be hidden too for resize to work correctly
            this.$('.main').hide();
        }
    },

    /**
     * Show draft
     *
     * A draft is an envelope already created and saved.
     * Now we just open the tab for that envelope in order to send it.
     *
     * @param  {Object} model
     */
    showDraft: function(model) {
        if (this.userIsConfigured !== true) {
            app.alert.show('warn-docusign-user-not-logged', {
                level: 'warning',
                messages: app.lang.get('LBL_PLEASE_LOG_IN', 'DocuSignEnvelopes'),
                autoClose: true,
                autoCloseDelay: '10000'
            });
            return;
        }

        if (
            model.get('created_by_link').id !== app.user.id
        ) {
            app.alert.show('warn-docusign-create-user', {
                level: 'warning',
                messages: app.lang.get('LBL_SEND_NOT_ALLOWED', 'DocuSignEnvelopes'),
                autoClose: true,
                autoCloseDelay: '10000'
            });
            return;
        }

        var module = this._getEnvelopeSourceModule();
        var modelId = this._getEnvelopeSourceModelId();

        var documents = [];

        var draftId = model.get('envelope_id');

        app.alert.show('load-tab-for-sending', {
            level: 'process',
            title: app.lang.get('LBL_LOADING')
        });

        var data = {
            returnUrlParams: {
                parentRecord: module,
                parentId: modelId,
                draftEnvelopeId: draftId,
                token: app.api.getOAuthToken()
            },
            draftEnvelopeId: draftId,
            documents: documents
        };

        var docusignPageURL = app.api.buildURL('DocuSign', 'loadPage');
        var docusignTab = window.open(docusignPageURL);//makes the browser consider the action as user not script made

        this._sendEnvelope(data, docusignTab);
    },

    /**
     * Send envelope
     *
     * @param {Object} data
     * @param {Object} docusignTab
     */
    _sendEnvelope: function(data, docusignTab) {
        app.api.call('create', app.api.buildURL('DocuSign/send'), data, {
            success: _.bind(function viewLoaded(res) {
                if ((res.status && res.status === 'error') || res.envelopeStatus === 'deleted') {
                    var minifiedErrorMessage = res.message.toLowerCase();
                    if (minifiedErrorMessage === 'cancel') {
                        // do nothing
                    } else if (/envelope status in docusign is now/.test(minifiedErrorMessage)) {
                        if (res.envelopeStatus === 'deleted') {
                            this.confirmDelete(res);
                        } else {
                            this.confirmEnvelopeStatusUpdate(res);
                        }
                    } else {
                        if (!_.isEmpty(res.message)) {
                            app.alert.show('ds_error', {
                                level: 'error',
                                messages: res.message,
                                autoClose: false
                            });
                        }
                    }
                    docusignTab.close();
                    return;
                }

                docusignTab.location.href = res.url;

                $(window).on('storage.docusignAction', function checkDocuSignActionOnStorageChange(e) {
                    if (e.originalEvent.key !== 'docusignAction') {
                        return;
                    }
                    var action = e.originalEvent.newValue;
                    if (!action) {
                        return;
                    }

                    $(window).off('storage.docusignAction');

                    if (app.controller.context.attributes.module === 'pmse_Inbox' &&
                        app.controller.layout.name === 'show-case') {
                        app.router.goBack();
                    } else {
                        app.events.trigger('docusign:reload');
                    }
                });
            }, this),
            error: function(error) {
                app.alert.show('error-loading-tab', {
                    level: 'error',
                    messages: error.message
                });
            },
            complete: function() {
                app.alert.dismiss('load-tab-for-sending');
            }
        });
    },

    /**
     * Get envelope source module
     *
     * @return {string}
     */
    _getEnvelopeSourceModule: function() {
        var module = app.controller.context.get('module');

        if (module === 'pmse_Inbox' && app.controller.layout.name === 'show-case') {
            try {
                var sourceModel = app.controller.layout._components[0]
                    .getComponent('sidebar')
                    .getComponent('main-pane')
                    .model;

                return sourceModel.get('_module');
            } catch (showCaseError) {
                app.logger.debug('_getEnvelopeSourceModule. show-case layout error:' + showCaseError);
            }
        }

        return module;
    },

    /**
     * Get envelope source model id
     *
     * @return {string}
     */
    _getEnvelopeSourceModelId: function() {
        var module = app.controller.context.get('module');
        var modelId = app.controller.context.get('modelId');

        if (module === 'pmse_Inbox' && app.controller.layout.name === 'show-case') {
            try {
                var sourceModel = app.controller.layout._components[0]
                    .getComponent('sidebar')
                    .getComponent('main-pane')
                    .model;

                return sourceModel.get('id');
            } catch (showCaseError) {
                app.logger.debug('_getEnvelopeSourceModelId. show-case layout error:' + showCaseError);
            }
        }

        return modelId;
    },

    /**
     * Creates a confirmation alert and ask for permission to delete the draft
     *
     * @param {Object} data
     */
    confirmDelete: function(data) {
        app.alert.show('draft-does-not-exist', {
            level: 'confirmation',
            messages: app.lang.get('LBL_DRAFT_DELETED_CONFIRMATION', 'DocuSignEnvelopes'),
            autoClose: false,
            onConfirm: function() {
                app.api.call(
                    'create',
                    app.api.buildURL('DocuSign/removeEnvelope'), {
                        envelopeId: data.envelopeId
                    }, {
                        success: function(res) {
                            if (res) {
                                app.alert.show('sugar-envelope-delete', {
                                    level: 'success',
                                    messages: app.lang.get('LBL_DRAFT_DELETE_SUCCESS', 'DocuSignEnvelopes'),
                                    autoClose: true
                                });
                                app.events.trigger('docusign:reload');
                            } else {
                                app.alert.show('sugar-envelope-delete', {
                                    level: 'error',
                                    messages: app.lang.get('LBL_DRAFT_DELETE_ERROR', 'DocuSignEnvelopes'),
                                    autoClose: true,
                                    autoCloseDelay: '10000'
                                });
                            }
                        },
                        error: function(error) {
                            app.alert.show('error-removing-envelope', {
                                level: 'error',
                                messages: error.message
                            });
                        },
                        complete: function() {
                            app.alert.dismiss('envelope-loading');
                        }
                    }
                );
                app.alert.show('envelope-loading', {
                    level: 'process',
                    title: app.lang.get('LBL_LOADING')
                });
            },
            onCancel: function() {}
        });
    },

    /**
     * Confirm envelope status update
     *
     * @param {Object} data
     */
    confirmEnvelopeStatusUpdate: function(data) {
        app.alert.show('draft-does-not-exist', {
            level: 'confirmation',
            messages: app.lang.get('LBL_DRAFT_CHANGED_CONFIRM', 'DocuSignEnvelopes', {status: data.status}),
            autoClose: false,
            onConfirm: function() {
                app.api.call(
                    'create',
                    app.api.buildURL('DocuSign/docusignUpdateBean'), {
                        envelopeId: data.envelopeId
                    }, {
                        success: function(res) {
                            if (res) {
                                app.alert.show('sugar-envelope-update-success', {
                                    level: 'success',
                                    messages: app.lang.get('LBL_DRAFT_CHANGED_SUCCESS', 'DocuSignEnvelopes'),
                                    autoClose: true
                                });
                                app.events.trigger('docusign:reload');
                            } else {
                                app.alert.show('sugar-envelope-update-error', {
                                    level: 'error',
                                    messages: app.lang.get('LBL_DRAFT_CHANGED_ERROR', 'DocuSignEnvelopes'),
                                    autoClose: true,
                                    autoCloseDelay: '10000'
                                });
                            }
                        },
                        error: function(error) {
                            app.alert.show('error-updating-bean', {
                                level: 'error',
                                messages: error.message
                            });
                        },
                        complete: function() {
                            app.alert.dismiss('envelope-loading');
                        }
                    }
                );

                app.alert.show('envelope-loading', {
                    level: 'process',
                    title: app.lang.get('LBL_LOADING')
                });
            },
            onCancel: function() {}
        });
    },

    /**
     * @inheritdoc
     */
    dispose: function() {
        $(window).off('resize.' + this.cid);
        $(window).off('storage.docusignAction');

        app.alert.dismiss('load-tab-for-sending');
        app.alert.dismiss('envelope-loading');

        this.disposeDashletTabContents();

        this._super('dispose');
    },

    disposeDashletTabContents: function() {
        if (this.envelopeListLayout instanceof app.view.Layout) {
            this.envelopeListLayout.dispose();
        }
        if (this.draftListLayout instanceof app.view.Layout) {
            this.draftListLayout.dispose();
        }
        if (this.docsListLayout instanceof app.view.Layout) {
            this.docsListLayout.dispose();
        }
        if (this.chartField instanceof app.view.Field) {
            this.chartField.dispose();
        }
    }
}) },
"purchase-history": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PurchaseHistoryView
 * @alias SUGAR.App.view.views.BasePurchaseHistoryView
 * @extends View.Views.Base.ActiveSubscriptionsView
 */
({
	// Purchase-history View (base) 

    extendsFrom: 'ActiveSubscriptionsView',

    plugins: ['Dashlet', 'Pagination', 'DashletSearchControls'],

    events: {
        'click .toggle-pli-list': 'togglePliList',
        'click [data-action=show-more-plis]': 'getNextPliPagination'
    },

    /**
     * Object representing the initial state of our dropdown.
     *
     * @property {Object}
     */
    _defaultSettings: {
        linked_account_field: null,
        limit: 10
    },

    /**
     * Purchases fields metadata
     *
     * @property {Object}
     */
    purchasesFields: null,

    /**
     *  Purchased Line Items fields metadata
     *
     * @property {Object}
     */
    pliFields: null,

    /**
     * Flag for if pagination needs to be hidden (used for when user lacks module access)
     *
     * @property {boolean}
     */
    hidePagination: true,

    /**
     * Label displayed for the PLI pagination link
     *
     * @property {string}
     */
    showMorePlisLabel: null,

    /**
     * List of fields to be included when fetching PLIs
     *
     * @property {Array}
     */
    pliFieldList: [
        'id', 'name', 'service_start_date', 'service_end_date',
        'quantity', 'total_amount', 'currency_id', 'base_rate',
    ],

    /**
     * Sort dropdown items
     *
     * @property {Array}
     */
    sortItems: null,

    /**
     * Placeholder text for the search field
     *
     * @property {string}
     */
    searchFieldPlaceholder: null,

    /**
     * Options and parameters for fetching the Purchase collection
     *
     * @property {Object}
     */
    collectionOptions: null,

    /**
     * Base filter hold the filter object without any other user entered filters
     *
     * @property {Object}
     */
    baseFilter: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.currentModule = this._currentModule();
        this.module = 'Purchases';
        this.moduleName = {'module_name': app.lang.getModuleName(this.module, {'plural': true})};
        this.baseModule = 'Accounts';

        var canAccessPurchases = !_.isUndefined(app.metadata.getModule('Purchases'));
        var canAccessPlis = !_.isUndefined(app.metadata.getModule('PurchasedLineItems'));
        this.purchasesModule = false;
        if (canAccessPurchases && canAccessPlis) {
            this.purchasesModule = true;
            this.hidePagination = false;

            this.purchasesFields = app.utils.deepCopy(app.metadata.getModule('Purchases', 'fields'));
            this.purchasesFields.name.link = true;
            this.purchasesFields.name.disableFocusDrawerRecordSwitching = true;

            this.pliFields = app.utils.deepCopy(app.metadata.getModule('PurchasedLineItems', 'fields'));
            this.pliFields.name.type = 'dates-name';
            this.pliFields.name.link = true;
            this.pliFields.name.disableFocusDrawerRecordSwitching = true;
            this.pliFields.total_amount.showTransactionalAmount = true;
            this.pliFields.total_amount.convertToBase = true;

            var moduleName = new Handlebars.SafeString(
                app.lang.getModuleName('PurchasedLineItems', {plural: true}).toLowerCase()
            );
            this.showMorePlisLabel = app.lang.get('TPL_SHOW_MORE_MODULE', 'PurchasedLineItems', {module: moduleName});

            this.hideFirstPaginationLoadingMessage = true;
            this.usePaginationComponent = true;

            this.sortItems = this._buildSortList('purchase_history_sort_dom');
            this.searchFieldPlaceholder = app.lang.get('LBL_SEARCH_PURCHASE_NAME');
        }

        this.linkToDocumentation = this._buildDocumentationUrl();
    },

    /**
     * Set up collection when init dashlet.
     *
     * @param {string} viewName Current view
     */
    initDashlet: function(viewName) {
        this._initSettings();

        this.tbodyTag = 'ul[data-action="pagination-body"]';

        this._mode = viewName;

        // Builds our dynamic dropdown list, but also populates the Account field in case it is not already set,
        // for example on upgrade.
        this._buildFieldsList();

        if (!_.isEmpty(this.sortItems)) {
            this.currentSortOrder = _.first(this.sortItems).id;
        }

        this._initCollection();

        this.context.set('fields', this.dashletConfig.fields);
        this.context.set('limit', this.settings.get('limit'));
        this.context.set('skipFetch', false);

        // This is used in the parent view to determine whether or not it's
        // okay to render the dashlet.
        this.settings.set('linked_subscriptions_account_field', true);

        this.layout.reloadableComponent = this;
    },

    /**
     * Build the URL for the dashlet documentation.
     *
     * @return {string}
     * @private
     */
    _buildDocumentationUrl: function() {
        var serverInfo = app.metadata.getServerInfo();
        var language = app.lang.getLanguage();
        var module = 'purchasehistorydashlet';
        var route = app.controller.context.get('layout');

        let products = app.user.getProductCodes();
        products = products ? products.join(',') : '';

        var params = {
            edition: serverInfo.flavor,
            version: serverInfo.version,
            lang: language,
            module: module,
            route: route
        };
        if (!_.isEmpty(products)) {
            params.products = products;
        }

        return 'https://www.sugarcrm.com/crm/product_doc.php?' + $.param(params);
    },

    /**
     * Build our settings object, based on defaults and the metadata, to be used throughout the controller.
     *
     * @private
     */
    _initSettings: function() {
        var settings = _.extend({}, this._defaultSettings, this.settings.attributes);
        if (!settings.limit) {
            settings.limit = this._defaultSettings.limit;
        }

        this.settings.set(settings);
        return this;
    },

    /**
     * Create the dynamic dropdown options for the dashlet config page.
     *
     * @private
     */
    _buildFieldsList: function() {
        var configPanel = this._getDashletConfigField('linked_account_field');
        var configPanelOptions = {};

        if (this.currentModule === this.baseModule) {
            // If this dashlet is being added to the Accounts module record view, use the default ID field in the
            // Account module
            configPanelOptions.id = 'ID';
        } else {
            configPanelOptions = this._getRelationshipFields();
        }

        if (_.keys(configPanelOptions).length > 0) {
            // Populate dropdown with relationship field options
            configPanel.options = configPanelOptions;

            // If we don't have any existing field selected, or the previously selected field is no longer present
            if (
                !this.settings.get('linked_account_field') ||
                !configPanelOptions[this.settings.get('linked_account_field')]
            ) {
                this.settings.set({linked_account_field: _.first(Object.keys(configPanelOptions))});
            }
        }
    },

    /**
     * Builds the list of ordered k-v pairs for the sort list.
     * @param sortStringsKey
     * @return {Array}
     * @private
     */
    _buildSortList: function(sortStringsKey) {
        var sortList = app.lang.getAppListStrings(sortStringsKey);
        var orderedKeys = _.map(app.lang.getAppListKeys(sortStringsKey), function(appListKey) {
            return appListKey.toString();
        });

        var moduleName = new Handlebars.SafeString(app.lang.getModuleName('Purchases', {plural: false})).toString();

        return _.map(orderedKeys, function(key) {
            var value = sortList[key].replace('{{module}}', moduleName);

            return {
                id: key,
                text: value
            };
        });
    },

    /**
     * Initialize collection.
     *
     * @private
     */
    _initCollection: function() {
        if (this._mode === 'config' || !this.purchasesModule) {
            return;
        }

        var limit = this.settings.get('limit');
        var accountId = this._getAccountId('linked_account_field');

        this.baseFilter = {
            'account_id': {
                '$equals': accountId
            }
        };

        this.collectionOptions = {
            'fields': this.dashletConfig.fields || [],
            'filter': [this.baseFilter],
            'limit': limit || app.config.maxRecordFetchSize || 10,
            'params': {
                'order_by': this.currentSortOrder
            },
            'success': _.bind(function() {
                if (this.disposed) {
                    return;
                }
                this.render();
            }, this),
        };
        this.collection = app.data.createBeanCollection(this.module, null, this.collectionOptions);
        this.collection.fieldsMeta = this.purchasesFields;
        this.collection.component = this;
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        if (this._mode === 'config' || !this.purchasesModule) {
            return;
        }

        // Show the loading text on dashlet refresh
        this.collection.dataFetched = false;
        this.render();

        this.collection.fetch(options);
    },

    /**
     * Show or hide the PLI list for a Purchase
     * @param event
     */
    togglePliList: function(event) {
        var $element = this.$(event.currentTarget).find('i.toggle-list');
        var purchaseId = $element.attr('data-id');
        var purchaseModel = this.collection.get(purchaseId);

        this._togglePliVisibility(purchaseModel);

        this._initPliCollection(purchaseModel);

        if (!purchaseModel.hasPlisLoaded) {
            purchaseModel.pliCollection.fetch();
        }

        this.render();
    },

    /**
     * Initializes the PLI collection for a purchase
     * @param purchase
     */
    _initPliCollection: function(purchase) {
        if (purchase.hasPlisLoaded) {
            return;
        }

        purchase.pliLoading = true;

        var limit = this.settings.get('limit');
        var filter = [
            {
                'purchase_id': {
                    '$equals': purchase.get('id'),
                }
            }
        ];
        var options = {
            'fields': this.pliFieldList,
            'params': {
                'order_by': 'service_end_date:desc'
            },
            'filter': filter,
            'limit': limit || app.config.maxRecordFetchSize || 10,
            'success': _.bind(function() {
                if (this.disposed) {
                    return;
                }

                purchase.pliLoading = false;
                purchase.hasPlisLoaded = true;

                this.render();
            }, this),
            'showAlerts': false,
            'add': true,
        };
        purchase.pliCollection = app.data.createBeanCollection('PurchasedLineItems', null, options);
        purchase.pliCollection.fieldsMeta = this.pliFields;
        purchase.pliCollection.component = this;
    },

    /**
     * Get the next pagination for a PLI list
     * @param event
     */
    getNextPliPagination: function(event) {
        var $element = this.$(event.currentTarget);
        var purchaseId = $element.attr('data-id');
        var purchaseModel = this.collection.get(purchaseId);

        purchaseModel.pliLoading = true;
        this.render();

        purchaseModel.pliCollection.paginate({
            add: true
        });
    },

    /**
     * Handle PLI list visibility state and show/hide icon
     * @param purchase
     * @private
     */
    _togglePliVisibility: function(purchase) {
        if (!purchase.chevronIcon || purchase.chevronIcon === 'sicon-chevron-down') {
            purchase.chevronIcon = 'sicon-chevron-up';
            purchase.showPliList = true;
        } else {
            purchase.chevronIcon = 'sicon-chevron-down';
            purchase.showPliList = false;
        }
    },

    /**
     * Updates the sort order with the newly selected criteria
     */
    applySort: function(sortOrder) {
        this.collectionOptions = _.extend({}, this.collectionOptions, {
            'params': {
                'order_by': sortOrder
            }
        });

        this.refetchCollection();
    },

    /**
     * Applies an updated filterdef with the current value on the quicksearch field.
     *
     * @param {string} searchInput the user-entered search string
     */
    applySearch: function(searchInput) {
        this.collectionOptions = _.extend({}, this.collectionOptions, {
            'filter': this.buildFilterDefinition(this.baseFilter || [], searchInput)
        });

        this.refetchCollection();
    },

    /**
     * Updates the persistent options and re-fetch the collection. Used to update the
     * collection on search/sort.
     * @private
     */
    refetchCollection: function() {
        // Pagination uses the persistent options, so we need to set those too.
        // Otherwise when new rows are added they will follow the default filter.
        this.collection._persistentOptions = this.collectionOptions;

        this.collection.dataFetched = false;
        this.render();

        this.collection.fetch(this.collectionOptions);
    },

    /**
     * Builds the filter definition to pass to the request when doing a quick
     * search.
     *
     * It will combine the filter definition for the search term with the
     * initial filter definition. Both are optional, so this method may return
     * an empty filter definition (empty `array`).
     *
     * @param {Object} oSelectedFilter original Selected filter
     * @param {string} searchTerm The term typed in the quick search field.
     * @return {Array} filterDef The filter definition.
     */
    buildFilterDefinition: function(oSelectedFilter, searchTerm) {
        if (!app.metadata.getModule('Filters') || !app.data.createBeanCollection('Filters')) {
            return [];
        }
        var filterBeanClass = app.data.getBeanClass('Filters').prototype;
        var selectedFilter = app.utils.deepCopy(oSelectedFilter);
        var searchTermFilter;
        var searchModule = this.module;

        selectedFilter = _.isArray(selectedFilter) ? selectedFilter : [selectedFilter];

        searchTermFilter = filterBeanClass.buildSearchTermFilter(searchModule, searchTerm, '$contains');

        var isSelectedFilter = _.size(selectedFilter) > 0;
        var isSearchFilter = _.size(searchTermFilter) > 0;

        selectedFilter = this.filterSelectedFilter(selectedFilter);

        var filterDef = [];

        if (isSelectedFilter && isSearchFilter) {
            selectedFilter.push(_.first(searchTermFilter));
            filterDef = [{'$and': selectedFilter}];
        } else if (isSelectedFilter) {
            filterDef = selectedFilter;
        } else if (isSearchFilter) {
            filterDef = searchTermFilter;
        }

        return filterDef;
    },

    /**
     * Filter fields that don't exist either on vardefs or search definition.
     *
     * Special fields (fields that start with `$`) like `$favorite` aren't
     * cleared.
     * @param {Array} selectedFilter def for currently selected filter
     * @return {Array} filtered def
     */
    filterSelectedFilter: function(selectedFilter) {
        var specialField = /^\$/;
        var meta = app.metadata.getModule(this.module);
        selectedFilter = _.filter(selectedFilter, function(def) {
            var fieldName = _.keys(def).pop();
            return specialField.test(fieldName) || meta.fields[fieldName];
        }, this);

        return selectedFilter;
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.collection) {
            this.collection.on('reset', this.render, this);
        }
    },

    /**
     * Fetches the metadata object that needs to be updated with the dynamically generated dropdown options.
     *
     * @private
     */
    _getDashletConfigField: function(fieldName) {
        var configPanelMetadata = this.dashletConfig.panels;
        var fieldMetadata = null;

        _.each(configPanelMetadata, function(p) {
            if (_.has(p, 'fields')) {
                _.each(p.fields, function(f) {
                    if (f.name === fieldName) {
                        fieldMetadata = f;
                        return;
                    }
                });
            }
        });

        return fieldMetadata;
    },

    /**
     * @inheritdoc
     * @param options
     * @private
     */
    _render: function(options) {
        this._super('_render', [options]);

        if (!this.settings.get('linked_account_field')) {
            // If we don't have any available fields, replace the dropdown with a label.
            this.template = app.template.get(this.name + '.unavailable');
            this._super('_render', [options]);
        }
    },
}) },
"subpanel-list-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Custom RecordlistView used for SubpanelCreate layouts.
 *
 * @class View.Views.Base.SubpanelListCreateView
 * @alias SUGAR.App.view.views.BaseSubpanelListCreateView
 * @extends View.Views.Base.SubpanelListView
 */
({
	// Subpanel-list-create View (base) 

    extendsFrom: 'SubpanelListView',

    /**
     * @inheritdoc
     */
    dataView: 'subpanel-list-create',

    contextEvents: {
        'list:deleterow:fire': 'onDeleteRow',
        'list:addrow:fire': 'onAddRow'
    },

    /**
     * Flag if the view has all valid models
     */
    hasValidModels: true,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.events = _.extend({}, this.events, {
            'click [data-action=addRow]': 'onAddRow'
        });

        // undo flex-list's hardcoding and re-hardcode to use the subpanel-list-create.hbs
        this.template = app.template.getView('subpanel-list-create');

        // Set necessary context values
        let settings = this.context.get('settings');
        this.context.set({
            isCreateSubpanel: true,
            allowEmpty: settings && settings.allowEmpty
        });
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        var link;
        var oppsConfig;
        var userACLs;

        this._super('bindDataChange');

        link = this.context.get('link');
        oppsConfig = app.metadata.getModule('Opportunities', 'config');
        userACLs = app.user.getAcls();

        if (oppsConfig.opps_view_by === 'RevenueLineItems') {
            if (!(_.has(userACLs.Opportunities, 'edit') ||
                _.has(userACLs.RevenueLineItems, 'access') ||
                _.has(userACLs.RevenueLineItems, 'edit'))) {
                // only listen for PCDashlet if this is Opps in Opps/RLI mode and user has access
                // to both Opportunities and RLIs
                // need to trigger on app.controller.context because of contexts changing between
                // the PCDashlet, and Opps create being in a Drawer, or as its own standalone page
                // app.controller.context is the only consistent context to use
                var viewDetails = this.closestComponent('create') ||
                    this.closestComponent('record') ||
                    this.closestComponent('convert');

                if (!_.isUndefined(viewDetails)) {
                    app.controller.context.on(viewDetails.cid + ':productCatalogDashlet:add',
                        this.onAddFromProductCatalog,
                        this);
                }
            }
        }

        // listen to revalidate the collection
        this.context.parent.on('subpanel:validateCollection:' + link, this.validateModels, this);

        // listen to reset the collection
        this.context.parent.on('subpanel:resetCollection:' + link, this.resetSubpanel, this);

        this.collection.on('add remove', this.render, this);

        this.resetSubpanel();
    },

    /**
     * Handles when users click to add items from the Product Catalog dashlet to the Opportunity
     *
     * @param {Object} data The ProductCatalog Data
     */
    onAddFromProductCatalog: function(data) {
        var existingModel = this.collection.length === 1 && this.collection.at(0);
        var isEmpty = existingModel &&
            _.isEmpty(existingModel.changedAttributes()) &&
            _.isEmpty(existingModel.get('product_template_id'));

        data.likely_case = data.discount_price;
        data.best_case = data.discount_price;
        data.worst_case = data.discount_price;
        data.assigned_user_id = app.user.get('id');
        data.assigned_user_name = app.user.get('full_name');

        if (isEmpty) {
            this.collection.remove(existingModel);
        }

        this._addBeanToList(true, data);
    },

    /**
     * Resets the subpanel's collection and adds a new bean to the list
     */
    resetSubpanel: function() {
        this.collection.reset();

        // Unless we allow an empty list of models, add a default model
        if (!this.context.get('allowEmpty')) {
            this._addBeanToList(true);
        }
    },

    /**
     * @inheritdoc
     *
     * Toggles all fields in the SubpanelList to Edit view
     */
    render: function() {
        this._super('render');

        // toggle fields to edit view
        this._toggleEdit(true);

        _.defer(_.bind(function() {
            this.checkButtons();
        }, this));
    },

    /**
     * Handles toggling collection fields to edit or detail
     *
     * @param {Boolean} isEdit If we're toggling fields TO Edit view or not
     * @private
     */
    _toggleEdit: function(isEdit) {
        isEdit = isEdit || false;

        // toggle the fields in the list to be in edit mode
        _.each(this.collection.models, function(model) {
            this.toggleFields(this.rowFields[model.get('id')], isEdit);
            if (isEdit) {
                // this is a subpanel specific logic: when the subpanel is back to edit mode,
                // manually fire the dependency trigger on all its models
                this.context.trigger("list:editrow:fire", model, {def: {}});
            }
        }, this);
    },

    /**
     * Checks the -/+ buttons to enable/disable
     */
    checkButtons: function() {
        if (this.disposed) {
            return;
        }
        var delBtns = this.$('.deleteBtn');
        var addBtns = this.$('.addBtn');

        // When there is only one row, disable the delete button on it
        // unless an empty collection is allowed
        if (!this.context.get('allowEmpty') && delBtns && delBtns.length === 1 && !delBtns.hasClass('disabled')) {
            delBtns.addClass('disabled');
        }

        if (addBtns && addBtns.length > 1) {
            // disable all add buttons except the last row
            _.each(addBtns, function(btn, index) {
                if (index < addBtns.length - 1) {
                    $(btn).addClass('disabled');
                }
            });
        }
    },

    /**
     * @inheritdoc
     *
     * Overriding RecordList/FlexList addActions to use actionmenu-create for the left column
     *
     * @override
     */
    addActions: function() {
        if (this.actionsAdded) {
            return;
        }

        // just need the right-side actions
        if (this.meta && _.isObject(this.meta.rowactions)) {
            // add the fieldset and init rightColumns
            this.addRowActions();
        }

        this.actionsAdded = true;
    },

    /**
     * @inheritdoc
     *
     * Overriding flex-list addRowActions to make the rowactions-create type
     *
     * @override
     */
    addRowActions: function() {
        var _generateMeta = function(label, css_class, buttons) {
            return {
                'type': 'fieldset',
                'fields': [
                    {
                        'type': 'rowactions-create',
                        'label': label || '',
                        'css_class': css_class,
                        'buttons': buttons || [],
                        'no_default_action': true
                    }
                ],
                'value': false,
                'sortable': false
            };
        };
        var def = this.meta.rowactions;
        this.rightColumns.push(_generateMeta(def.label, def.css_class, def.actions));
    },

    /**
     * Validates the models in the subpanel
     *
     * @param {Function} callback The callback function to call after validation
     * @param {undefined|Boolean} [fromCreateView] If this function is being called from Create view or not
     */
    validateModels: function(callback, fromCreateView) {
        this.clearValidationErrors();

        fromCreateView = fromCreateView || false;

        // Wrap the callback function to be called with different parameters based
        // on the view we are in
        this.hasValidModels = true;
        let runCallback = () => {
            if (!_.isFunction(callback)) {
                return;
            }
            if (fromCreateView) {
                // the create waterfall wants the opposite of if this is validated
                callback(!this.hasValidModels);
            } else {
                // this view wants if the models are valid or not
                callback(this.hasValidModels);
            }
        };

        // If there are no created models in the subpanel, there's nothing to do
        if (_.isEmpty(this.collection.models)) {
            runCallback();
            return;
        }

        // There are created models in the subpanel, so loop through all models
        // and call doValidate on each model
        let returnCt = 0;
        _.each(this.collection.models, function(model) {
            model.doValidate(
                this.getFields(this.module, model),
                _.bind(function(isValid) {
                    returnCt++;

                    // Keep track of whether any model has failed validation
                    this.hasValidModels = this.hasValidModels && isValid;

                    // If all model validations have occurred, run the callback function
                    if (returnCt === this.collection.length) {
                        runCallback();
                    }
                }, this));
        }, this);
    },

    /**
     * Click handler for the Add (+) button.
     * Validates each model on the collection and if they all validate, calls
     */
    onAddRow: function() {
        this.validateModels(_.bind(this._addBeanToList, this));
    },

    /**
     * Handler for when the delete button is clicked
     *
     * @param model
     */
    onDeleteRow: function(model) {
        this.context.get('collection').remove(model);
        this.checkButtons();
    },

    /**
     * Adds a bean for this.module to the collection
     *
     * @param {Boolean} hasValidModels If this collection has validated models
     * @param {Object} prepopulateData The ProductCatalog data to add prepopulate an RLI
     * @private
     */
    _addBeanToList: function(hasValidModels, prepopulateData) {
        var beanId;
        var bean;
        var addAtZeroIndex;
        prepopulateData = prepopulateData || {};

        if (hasValidModels) {
            beanId = app.utils.generateUUID();
            addAtZeroIndex = !_.isEmpty(prepopulateData);

            bean = app.data.createBean(this.module);
            bean._module = this.module;
            bean.set('id', beanId);

            // check the parent record to see if an assigned user ID/name has been set
            if (this.context.parent && this.context.parent.has('model')) {
                var parentModel = this.context.parent.get('model'),
                    userId = parentModel.get('assigned_user_id'),
                    userName = parentModel.get('assigned_user_name');

                if (userId) {
                    bean.setDefault('assigned_user_id', userId);
                }

                if (userName) {
                    bean.setDefault('assigned_user_name', userName);
                }
            }

            // must add to this.collection so the bean shows up in the subpanel list
            if (addAtZeroIndex) {
                bean = this.collection.unshift(bean);
            } else {
                bean = this.collection.add(bean);
            }

            bean.set(prepopulateData);
            this._addCustomFieldsToBean(bean, addAtZeroIndex, prepopulateData);
            this._addCustomEventHandlers(bean);

            this.context.trigger('subpanel-list-create:row:added', bean);
        }

        this.checkButtons();
    },

    /**
     * Allows child functions to override and add module-specific properties to the bean
     * before it gets added to the collection
     *
     * @param {Data.Bean} bean The bean to add new properties to
     * @param {boolean} skipCurrency Skip or set currency properties
     * @param {Object} prepopulatedData data that has already been pre-populated on the bean
     * @return {Data.Bean}
     * @private
     */
    _addCustomFieldsToBean: function(bean, skipCurrency, prepopulatedData) {
        return bean;
    },

    /**
     * Allows subpanels that extend this to add module-specific event listeners to the bean,
     * for example to update fields when another changes
     * @param {Data.Bean} bean
     * @return {Data.Bean}
     * @private
     */
    _addCustomEventHandlers: function(bean) {
        return bean;
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (app.controller && app.controller.context) {
            var viewDetails = this.closestComponent('create') ?
                this.closestComponent('create') :
                this.closestComponent('record');

            if (!_.isUndefined(viewDetails)) {
                app.controller.context.off(viewDetails.cid + ':productCatalogDashlet:add', null, this);
            }
        }
        if (this.context && this.context.parent) {
            this.context.parent.off(null, null, this);
        }
        this._super('_dispose');
    }
}) },
"panel-top-readonly": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Header section for Subpanel layouts.
 *
 * @class View.Views.Base.PanelTopReadonlyView
 * @alias SUGAR.App.view.views.BasePanelTopReadonlyView
 * @extends View.PanelTopView
 */
({
	// Panel-top-readonly View (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'PanelTopView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
    }
}) },
"product-quick-picks-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Views.Base.ProductQuickPicksDashletView
 * @alias SUGAR.App.view.views.BaseProductQuickPicksDashletView
 * @extends View.Views.Base.ProductQuickPicksView
 */
({
	// Product-quick-picks-dashlet View (base) 

    extendsFrom: 'ProductQuickPicksView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['Tooltip']);
        this._super('initialize', [options]);
    },

    /**
     * Calls the render method in parent class
     * assign class name to the dashlet component
     * @inheritdoc
     */
    _render: function() {
        if (!this.meta.config) {
            this._super('_render');
            var dashlet = this.$el.parents('.dashlet-container').first();
            if (dashlet) {
                dashlet.addClass('product-catalog-quick-picks');
            }
        }
    },

    /**
     * @inheritdoc
     */
    toggleLoading: function(startLoading) {
        if (this.layout.disposed === true) {
            return;
        }
        var $el = this.layout.$('i[data-action=loading]');
        if (startLoading) {
            $el.removeClass('sicon-settings');
            $el.addClass('sicon-refresh sicon-is-spinning');
        } else {
            $el.removeClass('sicon-refresh sicon-is-spinning');
            $el.addClass('sicon-settings');
        }
    }
}) },
"merge-duplicates-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for merge duplicates header pane.
 *
 * @class View.Views.Base.MergeDuplicatesHeaderpaneView
 * @alias SUGAR.App.view.views.BaseMergeDuplicatesHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Merge-duplicates-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click a[name=cancel_button]': 'cancel',
        'click a[name=save_button]': 'save'
    },

    /**
     * @inheritdoc
     *
     * Gets the selected duplicates from the context and defines the title based
     * on the number of selected records.
     */
    _formatTitle: function(title) {
        var records = this.context.get('selectedDuplicates');
        return app.lang.get(title, this.module, {mergeCount: records.length});
    },

    /**
     * Cancel and close the drawer.
     */
    cancel: function() {
        app.drawer.close();
    },

    /**
     * Save primary and delete other records.
     */
    save: function() {
        this.layout.trigger('mergeduplicates:save:fire');
    }
}) },
"filter-actions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Actions for {@link View.Views.Base.FilterRowsView}.
 *
 * Part of {@link View.Layouts.Base.FilterpanelLayout}.
 *
 * @class View.Views.Base.FilterActionsView
 * @alias SUGAR.App.view.views.BaseFilterActionsView
 * @extends View.View
 */
({
	// Filter-actions View (base) 

    events: {
        'change input': 'filterNameChanged',
        'keyup input': 'filterNameChanged',
        'click [data-action=filter-reset]': 'triggerReset',
        'click [data-action=filter-close]': 'triggerClose',
        'click [data-action=filter-delete]:not(.hide)': 'triggerDelete',
        'click [data-action=filter-save]:not(.disabled)': 'triggerSave',
        'click [data-action=filter-collapse]': 'triggerCollapse'
    },

    className: 'filter-header',

    /**
     * @type {Boolean} `true` if the button is enabled, `false` otherwise.
     */
    saveState: false,

    /**
     * @type {Boolean} Whether or not to display the filter action buttons.
     */
    showActions: true,

    /**
     * @inheritdoc
     */
    initialize: function(opts) {
        this._super('initialize', [opts]);

        this.layout.on('filter:create:open', function(model) {
            this.toggle(model);
            var name = model ? model.get('name') : '';
            this.setFilterName(name);

            //shortcut keys
            app.shortcuts.register({
                id: 'Filter:Close',
                keys: ['esc', 'mod+alt+l'],
                component: this,
                description: 'LBL_SHORTCUT_FILTER_CLOSE',
                callOnFocus: true,
                handler: function() {
                    this.$('[data-action=filter-close]').click();
                }
            });
            app.shortcuts.register({
                id: 'Filter:Save',
                keys: ['mod+s', 'mod+alt+a'],
                component: this,
                description: 'LBL_SHORTCUT_FILTER_SAVE',
                callOnFocus: true,
                handler: function() {
                    this.$('[data-action=filter-save]:not(.disabled)').click();
                }
            });
            app.shortcuts.register({
                id: 'Filter:Delete',
                keys: 'd',
                component: this,
                description: 'LBL_SHORTCUT_FILTER_DELETE',
                handler: function() {
                    this.$('[data-action=filter-delete]:not(.hide)').click();
                }
            });
            app.shortcuts.register({
                id: 'Filter:Reset',
                keys: 'r',
                component: this,
                description: 'LBL_SHORTCUT_FILTER_RESET',
                handler: function() {
                    this.$('[data-action=filter-reset]').click();
                }
            });
        }, this);

        this.listenTo(this.layout, 'filter:toggle:savestate', this.toggleSave);
        this.listenTo(this.layout, 'filter:set:name', this.setFilterName);
        this.listenTo(this.context, 'change:filterOptions', this.render);

        this.before('render', this.setShowActions, this);
    },

    /**
     * This function sets the `showActions` object on the controller.
     * `true` when `show_actions` is set to `true` on the `filterOptions`
     * object on the context (originating from filterpanel metadata),
     * `false` otherwise.
     */
    setShowActions: function() {
        var filterOptions = this.context.get('filterOptions') || {};
        this.showActions = !!filterOptions.show_actions;
    },

    /**
     * Get the filter name.
     *
     * @return {String} The value of the input.
     */
    getFilterName: function() {
        var filterName = this.$('input').val();
        return filterName.trim();
    },

    /**
     * Shows or hides this view.
     *
     * This view will be hidden when the filter is a template that is populated
     * on the fly.
     *
     * @param {Data.Bean} filter The filter being edited.
     */
    toggle: function(filter) {
        this.$el.toggleClass('hide', !!filter.get('is_template'));
    },

    /**
     * Set input value and hide the delete button if we're clearing the name.
     *
     * @param {String} name The filter name.
     */
    setFilterName: function(name) {
        var input = this.$('input').val(name);
        // We have this.context.editingFilter if we're setting the name.
        this.toggleDelete(!_.isUndefined(this.context.get('currentFilterId')));
    },

    /**
     * Fired when the filter name changed.
     *
     * @param {Event} event The `change` event.
     */
    filterNameChanged: _.debounce(function(event) {
        if (this.disposed || !this.context.editingFilter) {
            return;
        }

        var name = this.getFilterName();
        this.context.editingFilter.set('name', name);
        this.layout.trigger('filter:toggle:savestate', true);

        if (this.layout.getComponent('filter-rows')) {
            this.layout.getComponent('filter-rows').saveFilterEditState();
        }
    }, 200),

    /**
     * Toggle delete button.
     *
     * @param {Boolean} enable `true` to enable the button, `false` otherwise.
     */
    toggleDelete: function(enable) {
        this.$('[data-action=filter-delete]').toggleClass('hide', !enable);
    },

    /**
     * Toggle save button.
     *
     * @param {Boolean} enable `true` to enable the button, `false` otherwise.
     */
    toggleSave: function(enable) {
        this.saveState = _.isUndefined(enable) ? !this.saveState : !!enable;
        var isEnabled = this.getFilterName() && this.saveState;
        this.$('[data-action=filter-save]').toggleClass('disabled', !isEnabled);
    },

    /**
     * Handler for canceling form editing.
     *
     * First, it will revert model attributes (back to synced attributes), and
     * remove the current edit state.
     * Second,
     * - if the filter has changed, the collection is refreshed.
     * - if we were creating a new filter, the cached selected filter id is
     * cleared (so that we will get back to the default filter), otherwise we
     * just close the form.
     *
     * @triggers filter:apply to apply the previous filter definition.
     * @triggers filter:select:filter to switch back to the default filter.
     * @triggers filter:create:close to close the filter creation form.
     */
    triggerClose: function() {
        var filter = this.context.editingFilter,
            filterLayout = this.layout.getComponent('filter'),
            id = filter.get('id'),
            changedAttributes = filter.changedAttributes(filter.getSynced());
            filter.revertAttributes();

        filterLayout.clearFilterEditState();

        //Apply the previous filter definition if something has changed meanwhile
        if (changedAttributes && changedAttributes.filter_definition) {
            this.layout.trigger(
                /**
                 * @event
                 * See {@link View.Layouts.Base.FilterPanelLayout#filter:apply}.
                 */
                'filter:apply', null, filter.get('filter_definition'));
        }
        if (!id) {
            filterLayout.clearLastFilter(this.layout.currentModule, filterLayout.layoutType);
            filterLayout.trigger(
                /**
                 * @event
                 * See {@link View.Layouts.Base.FilterLayout#filter:select:filter}.
                 */
                'filter:select:filter', filterLayout.filters.collection.defaultFilterFromMeta);
            return;
        }
        this.layout.trigger(
            /**
             * @event
             * See {@link View.Layouts.Base.FilterLayout#filter:create:close}.
             */
            'filter:create:close');
    },

    /**
     * Call a method on filter-rows to reset filter values.
     */
    triggerReset: function() {
        this.layout.getComponent('filter-rows').resetFilterValues();
    },

    /**
     * Trigger `filter:create:save` to save the created filter.
     */
    triggerSave: function() {
        var filterName = this.getFilterName();
        this.context.trigger('filter:create:save', filterName);
    },

    /**
     * Trigger `filter:create:delete` to delete the created filter.
     */
    triggerDelete: function() {
        this.layout.trigger('filter:create:delete');
    },

    /**
     * Trigger `filter:collapse` to collapse the filter panel, but maintain filters
     */
    triggerCollapse: function() {
        const filter = this.context.editingFilter;
        const changed = !!(filter.changedAttributes() || filter.changedAttributes(filter.getSynced()));

        // Changes have been made on a saved filter
        if (changed && filter.get('id')) {
            this.layout.trigger('filter:collapse');
        // Changes were made in a previous collapse and are retained
        } else if (!filter.get('id') &&
            (filter.get('filter_definition').length > 0 || filter.get('filter_template').length)) {
            this.layout.trigger('filter:collapse');
        // No changes made, trigger regular close
        } else {
            this.triggerClose();
        }
    }
}) },
"history-summary-preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HistorySummaryPreviewView
 * @alias SUGAR.App.view.views.BaseHistorySummaryPreviewView
 * @extends View.Views.Base.PreviewView
 */
({
	// History-summary-preview View (base) 

    extendsFrom: 'PreviewView',

    /**
     * @inheritdoc
     * @override
     *
     * Overridden to make custom calls by module to get activities
     */
    _renderPreview: function(model, collection, fetch, previewId) {
        var self = this,
            newModel;

        // If there are drawers there could be multiple previews, make sure we are only rendering preview for active drawer
        if(app.drawer && !app.drawer.isActive(this.$el)){
            return;  //This preview isn't on the active layout
        }

        // Close preview if we are already displaying this model
        if(this.model && model && (this.model.get("id") == model.get("id") && previewId == this.previewId)) {
            // Remove the decoration of the highlighted row
            app.events.trigger("list:preview:decorate", false);
            // Close the preview panel
            app.events.trigger('preview:close');
            return;
        }

        if (app.metadata.getModule(model.module).isBwcEnabled) {
            // if module is in BWC mode, just return
            return;
        }

        if (model) {
            // Use preview view if available, otherwise fallback to record view
            var viewName = 'preview',
                previewMeta = app.metadata.getView(model.module, 'preview'),
                recordMeta = app.metadata.getView(model.module, 'record');
            if (_.isEmpty(previewMeta) || _.isEmpty(previewMeta.panels)) {
                viewName = 'record';
            }
            this.meta = this._previewifyMetadata(_.extend({}, recordMeta, previewMeta));

            newModel = app.data.createBean(model.module);
            newModel.set('id', model.id);

            if (fetch) {
                newModel.fetch({
                    //Show alerts for this request
                    showAlerts: true,
                    success: function(model) {
                        self.renderPreview(model, collection);
                    },
                    //The view parameter is used at the server end to construct field list
                    view: viewName
                });
            } else {
                newModel.copy(model);
                this.renderPreview(newModel, collection);
            }
        }

        this.previewId = previewId;
    }
}) },
"hint-data-enrichment-drawer-fields": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Hint-data-enrichment-drawer-fields View (base) 

    plugins: ['Stage2CssLoader'],

    /**
     * @inheritdoc
     */
    initialize: function(view) {
        this._super('initialize', arguments);
        var self = this;
        this.currentModule = 'Accounts';
        this.enrichHintFields = this.getAllEnrichFieldsForHint(this.currentModule);
        this.availableFields = this.getAllAvailableFields(this.currentModule);
        this.configId = app.user.get('configId');
        this.configKey = 'hintConfig';
        this.bucketList = (app.user.get('fieldConfigCache') &&
            JSON.parse(app.user.get('fieldConfigCache'))) || {};
        self._subscriptionType = '';
        this._saveConfig = this._saveConfig.bind(this);
        this._lastUpdatedCache = app.user.get('fieldConfigCacheLastUpdated');
        // Field config cache should expire after 5 minutes
        this._maxLifetime = 5 * 60 * 1000;

        // check if cache has not been updated or has expired (need to hit backend)
        // if so, then we must retrieve config from the backend and update the cache
        // along with rendering the UI
        if (!this._lastUpdatedCache || Date.now() - this._lastUpdatedCache >= this._maxLifetime) {
            this._callStage2API('read', 'hint/enrich/config', {
                success: function(data) {
                    var res = data.response;
                    var config = res.config_data;
                    self.bucketList = JSON.parse(config);
                    app.user.set('fieldConfigCache', config);
                    self.configId = res.id;
                    app.user.set('configId', self.configId);
                    app.user.set('fieldConfigCacheLastUpdated', Date.now());
                    self.render();
                },
                error: function(err) {
                    app.logger.error('Failed to reach hint/enrich/config' + JSON.stringify(err));
                }
            });
        }

        this.contextModel = self.context.get('model');
        this.context = self.context;
        this.module = self.module;
        this.tokenExpirationTimeOut = 60 * 60 * 1000;
        // Determines which fields should be 'checked' by default
        this.defaultPanelFields = app.hint.getVisibleFieldsFromAllPannelsForDefaultSelection(self.currentModule);

        app.events.on('hint:config:module:changed', function(data) {
            self.currentModule = data.module;
            self.enrichHintFields = self.getAllEnrichFieldsForHint(data.module);
            self.availableFields = self.getAllAvailableFields(data.module);
            self.defaultPanelFields = data.metadata.basicFields.concat(data.metadata.expandedFields);
            self.render();
        });

        app.events.on('hint:config:save', this._saveConfig);

        app.events.on('hint:config:defaults:restored', function(data) {
            self.enrichHintFields = self.getAllEnrichFieldsForHint(data.module);
            self.availableFields = self.getAllAvailableFields(data.module);
            self.defaultPanelFields = data.metadata.basicFields.concat(data.metadata.expandedFields);
            self.resetEnrichFieldsView(data.module);
            self.render();
        });
    },

    events: {
        'keyup .searchbox-field': 'onSearchFilterChanged',
        'click .fieldSelector': 'fieldToggled',
        'click .fieldSelectorForEnrich': 'addEnrichArray'
    },

    /**
     * Check the expiration time token
     *
     * @param {number} dataEnrichmentAccessTokenExpiration
     * @return {number}
     */
    isTokenExpired: function(dataEnrichmentAccessTokenExpiration) {
        return (!dataEnrichmentAccessTokenExpiration || dataEnrichmentAccessTokenExpiration < Date.now());
    },

    /**
     * Get metadata for saving
     * Teleported the function from hint-drawer-view.js to make it hard synchronous as there will be should be
     * one hint:config:save event.
     *
     * @param {string} module
     * @return {Object}
     */
    _getMetadataForSaving: function(module) {
        var basicPanelFields = [];
        var expandedPanelFields = [];

        //Get all the fields from the dom and their order.
        $('div#' + module.toLowerCase() + '-basic-panel').find('div.configurable > div.row-fluid').each(
            function(index) {
                basicPanelFields.push($(this).data('name'));
            });

        $('div#' + module.toLowerCase() + '-expanded-panel').find('div.configurable > div.row-fluid').each(
            function(index) {
                expandedPanelFields.push($(this).data('name'));
            });

        return {'basic': basicPanelFields, 'expanded': expandedPanelFields};
    },

    /**
     * Save config
     * Teleported the function from hint-drawer-view.js to make it hard synchronous as there will be should be
     * one hint:config:save event.
     */
    _saveConfig: function() {
        var self = this;

        self._withValidAuthenticationToken(function() {
            if (typeof ($('.hint-config-save').attr('disabled')) !== 'undefined') {
                return;
            }

            $('.hint-config-save').attr('disabled', 'disabled');

            if (!_.isEmpty(self.bucketList)) {
                var config = self.bucketList;
                app.user.set('fieldConfigCache', config);
                app.user.set('fieldConfigCacheLastUpdated', Date.now());

                self._callStage2API('update', 'hint/enrich/config', {
                    'id': self.configId,
                    'config_data': config
                });
            }

            var modulesToSave = ['Accounts', 'Contacts', 'Leads'];

            var metadataToSave = {};
            _.each(modulesToSave, function(module) {

                metadataToSave[module] = self._getMetadataForSaving(module);

            });

            self._updateHintConfigBackEnd(modulesToSave, metadataToSave);

            return;
        });
    },

    /**
     * Update hint config
     *
     * @param {Array} modulesToSave
     * @param {Object} metadataToSave
     */
    _updateHintConfigBackEnd: function(modulesToSave, metadataToSave) {
        var self = this;

        /**
         * We need to save each configuration in a serial call so we don't blow up the metadata hash.
         * This is a platform limitation that
         * we must work around.
         */
        async.forEachSeries(modulesToSave, function(module, callback) {
                var url = app.api.buildURL(module, 'config');
                var attributes = {};
                attributes[self.configKey] = metadataToSave[module];

                // In order to save the different modules in a row this is necessary,
                // otherwise we'll get an error about the metadata being out of sync.
                var apiOptions = {
                    skipMetadataHash: true
                };

                app.api.call('create', url, attributes, {
                        success: _.bind(function() {
                            callback();
                        }, this),
                        error: _.bind(function(err) {
                            callback(err);
                        }, this)
                    }, apiOptions
                );
            },
            function(err) {
                if (err) {
                    app.logger.error('Error saving configuration');
                } else {
                    if (app.drawer.count()) {
                        // close the drawer and return to the admin page
                        app.drawer.close(self.context, self.contextModel);

                        var backUrl = app.api.buildURL(self.module);
                        app.router.navigate(self.module, {trigger: true});

                        //We always require a hash sync and hard refresh
                        app.sync();
                        app.utils.hardRefresh();

                    } else {
                        app.router.navigate(self.module, {trigger: true});
                    }
                }
            }
        );
    },

    /**
     * Stage2 data enrichment config
     *
     * @param {string} method
     * @param {string} api
     * @param {Object} options
     */
    _callStage2API: function(method, api, options) {
        var self = this;

        // In order to save the different modules in a row this is necessary,
        // otherwise we'll get an error about the metadata being out of sync.
        var apiOptions = {
            skipMetadataHash: true
        };

        app.api.call(method, app.api.buildURL(api), options, {
            success: function(data) {
                if (api === 'hint/enrich/config' && method === 'update') {
                    self._callToSendEnrichFields('create', app.user.get('dataEnrichmentAccessToken'));
                }
                return options && options.success && options.success(data);
            },
            error: function(err) {
                app.logger.error('Failed to reach' + api + JSON.stringify(err));
            }
        }, apiOptions);
    },

    /**
     * Call to send enrich fields
     *
     * @param {string} method
     * @param {string} dataEnrichmentAccessToken
     */
    _callToSendEnrichFields: function(method, dataEnrichmentAccessToken) {
        var self = this;
        var username = null;
        if (app.user && app.user.attributes) {
            username = app.user.attributes.user_name;
        }
        var instanceId = app.config.uniqueKey;

        /* This is to make sure if the user has clicked ::save before _render();
           then accessToken & enrichField Options are not available and config remains same at v2
           since w/o render  user made no change. Thus, save the call to v2.
         */
        if (!_.isEmpty(dataEnrichmentAccessToken)) {
            var url = app.api.buildURL('hint/data/enrich/fields');
            var attributes = {
                'data': self.bucketList,
                'username': username,
                'instanceId': instanceId,
                'subscriptionType': self.subscriptionType,
                'moduleName': 'Admin' //REMIND: will be updated when the endpoint is completely ready.
            };

            var apiOptions = {
                skipMetadataHash: true
            };

            app.api.call(method, url, attributes, {
                success: function(data) {
                },
                error: function(err) {
                    app.logger.error('Failed to reach hint/data/enrich/fields' + JSON.stringify(err));
                }
            }, apiOptions);
        }
        return;
    },

    /**
     * Call with a valid authentication token
     *
     * @param callback
     */
    _withValidAuthenticationToken: function(callback) {
        var self = this;
        if (self.isTokenExpired(app.user.get('dataEnrichmentAccessTokenExpiration'))) {
            self._callStage2API('create', 'stage2/token', {
                success: function(data) {
                    app.user.set({
                        'dataEnrichmentAccessToken': data.accessToken,
                        'dataEnrichmentAccessTokenExpiration': Date.now() + self.tokenExpirationTimeOut
                    });
                    self._subscriptionType = data.subscriptionType;

                    if (!app.user.get('dataEnrichmentUrl')) {
                        self._callStage2API('read', 'stage2/params', {
                            success: function(data) {
                                app.user.set('dataEnrichmentUrl', data.enrichmentServiceUrl);
                                callback();
                            },
                            error: function(err) {
                                app.logger.error('Failed to reach stage2/params' + JSON.stringify(err));
                            }
                        });
                    } else {
                        callback();
                    }
                },
                error: function(err) {
                    app.logger.error('Failed to reach stage2/token' + JSON.stringify(err));
                }
            });
        } else {
            callback();
        }
    },

    /**
     * The following guard is made for users of Hint version less than 5.1.
     * Name and website are duplicates from the main panel, but below 5.1
     * they could be enabled on the extended panel through Layout configuration.
     *
     * @param {Array} allFields The full list of field definitions for the field selector.
     * @return {Array} The list of field definitions for the field selector without some duplicate fields.
     */
    excludeMainPanelFields: function(allFields) {
        var excludedFields = ['name', 'website', 'hint_education_2'];
        return _.reduce(excludedFields, function(fields, fieldName) {
            return _.without(fields, _.findWhere(fields, {name: fieldName}));
        }, allFields);
    },

    /**
     * Reset enrich fields view
     *
     * @param {string} moduleName
     */
    resetEnrichFieldsView: function(moduleName) {
        var self = this;
        _.each(_.keys(self.bucketList[moduleName].fields), function(field) {
            self.bucketList[moduleName].fields[field] = true;
        });
    },

    /**
     * Get all available fields
     *
     * @param module
     * @return {*[]}
     */
    getAllAvailableFields: function(module) {
        var results = [];
        var self = this;
        var fields = app.hint.getModuleFieldsAvailableForSelection(module);
        var selectableFields = this.excludeMainPanelFields(fields);

        _.each(selectableFields, function(field) {
            field.disabled = this.isFieldDisabled(module, field.name);
            field.value = field.label;
            if (!field.label || field.label === '') {
                return;
            }

            for (var i = 0; i < self.enrichHintFields.length; i++) {
                if (self.enrichHintFields[i].name === field.name) {
                    return;
                }
            }

            results.push(field);
        }, this);

        return results;

    },

    /**
     * Get all enrich fields for hint
     *
     * @param {string} module
     * @return {Array}
     */
    getAllEnrichFieldsForHint: function(module) {
        var results = [];
        var fields = app.hint.getPanelsForHintEnrichFields(module);
        var isPersonOrientedModule = module !== 'Accounts';

        if (isPersonOrientedModule) {
            fields = this.addAccountRelatedFields(fields);
        }

        var notSelectableFields = this.removeUnwantedfield(module);
        _.each(fields, function(field) {
            if (!_.includes(notSelectableFields, field.name)) {
                field.disabled = this.isFieldDisabled(module, field.name);
                field.hintOnlyField = this.isHintOnlyField(field);
                field.value = field.label;
                field.hideCheckbox = _.includes(['title', 'account_name', 'hint_account_website'], field.name);
                if (!field.label || field.label === '') {
                    return;
                }

                if (field.name === 'picture') {
                    field.name = 'hint_photo';
                    field.disabled = true;
                    field.hintOnlyField = false;
                }

                results.push(field);
            }
        }, this);

        results = _.sortBy(results, function(f) {
            return f.label.toLowerCase();
        });

        return results;
    },

    /**
     * Starts with
     *
     * @param {string} string
     * @param {string} searchTerm
     * @return {boolean}
     */
    startsWith: function(string, searchTerm) {
        return string.substr(0, searchTerm.length) === searchTerm;
    },

    /**
     * Add account related fields
     *
     * @param {Array} fields
     * @return {Array}
     */
    addAccountRelatedFields: function(fields) {
        var self = this;
        var accountsRelatedMetadata = app.hint.getPanelsForHintEnrichFields('Accounts');
        var hintPrefix = 'hint_account_';
        var notSelectableFields = this.removeUnwantedfield(this.currentModule);
        _.each(accountsRelatedMetadata, function(field) {
            var shouldRenameField = field.name && !_.includes(notSelectableFields, field.name) &&
                !self.startsWith(field.name, 'hint_');
            if (shouldRenameField) {
                if (field.name === 'sic_code') {
                    field.name = 'hint_account_sic_code_label';
                } else if (field.name === 'twitter') {
                    field.name = 'hint_account_twitter_handle';
                } else {
                    field.name = hintPrefix + field.name;
                }
            }

            if (field.name === 'hint_account_industry_tags') {
                field.name = 'hint_industry_tags';
            }
        });

        var haveAccountsFieldsInPersonModule = fields.concat(accountsRelatedMetadata);
        haveAccountsFieldsInPersonModule = _.uniq(haveAccountsFieldsInPersonModule, false, function(item) {
            return item.name;
        });

        haveAccountsFieldsInPersonModule = _.sortBy(haveAccountsFieldsInPersonModule, function(f) {
            return f.label;
        });

        return haveAccountsFieldsInPersonModule;
    },

    /**
     * Check if is hint only field
     *
     * @param {Object} field
     * @return {Array}
     */
    isHintOnlyField: function(field) {
        return field && field.name && field.name.match(/^hint_[\w]*/gi);
    },

    /**
     * Remove unwanted field
     *
     * @param {string} module
     * @return {Array}
     */
    removeUnwantedfield: function(module) {
        var disabledFields = {
            'Accounts': ['name', 'website', 'picture'],
            'Contacts': ['full_name', 'email', 'account_name', 'name', 'hint_account_logo', 'hint_education_2'],
            'Leads': ['full_name', 'email', 'hint_account_logo', 'name', 'hint_education_2']
        };
        return disabledFields[module];
    },

    /**
     * These are default fields that should not be selectable, should move this to metadata
     *
     * @param module
     * @param field
     */
    isFieldDisabled: function(module, field) {
        var disabledFields = {
            'Accounts': [],
            'Contacts': ['full_name', 'account_name', 'hint_photo', 'hint_education_2'],
            'Leads': ['full_name', 'hint_photo', 'hint_education_2']
        };
        return disabledFields[module] && _.contains(disabledFields[module], field);
    },

    /**
     * Handles when search term is changed, hides and shows fields
     */
    onSearchFilterChanged: _.debounce(function(evt) {
        var self = this;
        var searchTerm = $(evt.currentTarget).val();

        if (searchTerm) {
            searchTerm = searchTerm.toLowerCase();
        }

        // initially all the fields are available
        $('h1[name="subHeaderTitle1-rightpanel"]').show();
        $('h1[name="subHeaderTitle2-rightpanel"]').show();
        $('p[name="showNoMessageField1"]').text('');
        $('p[name="showNoMessageField2"]').text('');

        _.each([self.availableFields, self.enrichHintFields], function(fieldSection) {
            _.each(fieldSection, function(field) {
                if (field.name) {
                    $('div[name=" + field.name + "-rightpanel]').show();
                }
            });
        });

        // depending on the search term the fields the filtered.
        _.each([self.availableFields, self.enrichHintFields], function(fieldSection) {
            _.each(fieldSection, function(field) {
                if (field.label.toLowerCase().indexOf(searchTerm) < 0) {
                    $('div[name=" + field.name + "-rightpanel]').hide();
                }
            });
        });

        var showNoMessageField1 = self._areAnyFieldsVisible(self.enrichHintFields);
        var showNoMessageField2 = self._areAnyFieldsVisible(self.availableFields);

        // this display the No fields found message in enrichFields.
        if (showNoMessageField1) {
            $('h1[name="subHeaderTitle1-rightpanel"]').hide();
            $('p[name="showNoMessageField1"]').text(app.lang.get('LBL_HINT_NO_RESULTS_MSG'));
        }

        // this display the No fields found message in SugarOnly Fields.
        if (showNoMessageField2) {
            $('h1[name="subHeaderTitle2-rightpanel"]').hide();
            $('p[name="showNoMessageField2"]').text(app.lang.get('LBL_HINT_NO_RESULTS_MSG'));
        }

    }, 400),

    /**
     * Check if any fields are visible
     *
     * @param {Array} fieldsArray
     */
    _areAnyFieldsVisible: function(fieldsArray) {
        return _.every(fieldsArray, function(field) {
            return !$('div[name=" + field.name + "-rightpanel]').is(':visible');
        });
    },

    /**
     *
     * @param module
     * @return {Array}
     */
    getHintFieldsFromMeadata: function(module) {
        var hintFields = [];
        var allFields = app.metadata.getModule(module).fields;

        _.each(allFields, function(field) {
            if (field.name && field.name.match(/^hint_[\w]*/gi)) {
                field.label = app.lang.get(field.vname, module);
                hintFields.push(field);
            }
        });

        return hintFields;
    },

    /**
     * @override
     */
    _render: function() {
        var self = this;
        if (!_.isEmpty(self.bucketList)) {
            this._super('_render');
            //Select our default fields...
            _.each(self.defaultPanelFields, function(field) {
                $('.field-container-show' + field.name).prop('checked', true);
            });

            // check the fields in Enrich fields column
            _.each(self.enrichHintFields, function(field) {
                if (self.bucketList[self.currentModule].fields[field.name]) {
                    $('.field-container-' + field.name).prop('checked', true);
                }
            });

            //Based on the Enriched Field checked or unchecked decide to check the shared fields...
            _.each(self.enrichHintFields, function(field) {
                var ishintField = self.isHintOnlyField(field);
                var enrichFieldCheckedBox = $('.field-container-' + field.name);
                var sugarFieldCheckedBox = $('.field-container-show' + field.name);
                var checkedFieldOnRestore =  sugarFieldCheckedBox[0] && sugarFieldCheckedBox[0].checked;
                var corresspondingEnrichFieldChecked = enrichFieldCheckedBox[0] && enrichFieldCheckedBox[0].checked;

                if (checkedFieldOnRestore && !_.isEmpty(ishintField)) {
                    enrichFieldCheckedBox.prop('checked', true);
                } else if (!corresspondingEnrichFieldChecked && !_.isEmpty(ishintField)) {
                    sugarFieldCheckedBox.prop('checked', false);
                    sugarFieldCheckedBox.prop('disabled', true);
                }

                if (field.name === 'hint_photo') {
                    $('.field-container-show' + field.name).prop('checked', true);
                    $('.field-container-' + field.name).prop('disabled', false);
                }
            });
        }
    },

    /**
     * Add enrich array
     *
     * @param {Object} event
     */
    addEnrichArray: function(event) {
        var self = this;
        var fieldName = event.currentTarget.id;
        var fullField = _.find(this.enrichHintFields, function(f) {
            return f.name == fieldName;
        });

        var currentModuleFields = self.bucketList[self.currentModule].fields;

        if (event.currentTarget.checked) {
            if (fullField.hintOnlyField) {
                $('.field-container-show' + fullField.name).prop('disabled', false);
            }

            // Add the status of checked enriched fields of the hint panel.
            _.each(self.enrichHintFields, function(field) {
                var name = field.name;
                if (name === 'hint_education') {
                    currentModuleFields.hint_education_2 = $('.field-container-' + name)[0].checked;;
                } else if (name === 'sic_code' && self.currentModule === 'Accounts') {
                    currentModuleFields.hint_account_sic_code_label = $('.field-container-' + name)[0].checked;
                }
                currentModuleFields[name] = $('.field-container-' + name)[0].checked;
            });

        } else {
            _.each(self.enrichHintFields, function(field) {
                var name = field.name;
                if (name === 'hint_education') {
                    currentModuleFields.hint_education_2 = $('.field-container-' + name)[0].checked;
                } else if (name === 'sic_code' && self.currentModule === 'Accounts') {
                    currentModuleFields.hint_account_sic_code_label = $('.field-container-' + name)[0].checked;
                }
                currentModuleFields[name] = $('.field-container-' + name)[0].checked;
            });

            if (fullField.hintOnlyField) {
                $('.field-container-show' + fullField.name).prop('checked', false);
                $('.field-container-show' + fullField.name).prop('disabled', true);
                app.events.trigger('hint:config:fieldRemoved', fullField);
            }
        }
    },

    /**
     * Check field toggled
     *
     * @param {Object} event
     */
    fieldToggled: function(event) {
        var fieldName = event.currentTarget.id;
        var allFields = this.availableFields.concat(this.enrichHintFields);

        var fullField = _.find(allFields, function(f) {
            return f.name == fieldName;
        });

        if (event.currentTarget.checked) {
            app.events.trigger('hint:config:fieldAdded', fullField);
        } else {
            app.events.trigger('hint:config:fieldRemoved', fullField);
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        app.events.off('hint:config:module:changed');
        app.events.off('hint:config:save');
        app.events.off('hint:config:defaults:restored');
        this._super('_dispose');
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.RecordView
 * @alias SUGAR.App.view.views.BaseRecordView
 * @extends View.View
 */
({
	// Record View (base) 

    /**
     * @inheritdoc
     */
    dataView: 'record',

    inlineEditMode: false,

    /**
     * Flag to keep track of the elements that clicked in-line on a detail view to edit view
     */
    inlineEditModeFields: [],

    createMode: false,

    plugins: [
        'SugarLogic',
        'ErrorDecoration',
        'GridBuilder',
        'Editable',
        'Audit',
        'Pii',
        'FindDuplicates',
        'ToggleMoreLess',
        'ActionButton',
        'DocumentMerge',
        'MappableRecord',
    ],

    enableHeaderButtons: true,

    enableHeaderPane: true,

    events: {
        'mousemove .record-edit-link-wrapper, .record-lock-link-wrapper': 'handleMouseMove',
        'mouseleave .record-edit-link-wrapper, .record-lock-link-wrapper': 'handleMouseLeave',
        'mouseup .record-link-wrapper': 'handleLinkWrapperMouseUp',
        'click .record-edit-link-wrapper': 'handleEdit',
        'click .label-pill .record-label': 'handleEdit',
        'click a[name=cancel_button]': '_deprecatedCancelClicked',
        'click [data-action=scroll]': 'paginateRecord',
        'click .record-panel-header-container': 'togglePanel',
        'click #recordTab > .tab > a:not(.dropdown-toggle)': 'setActiveTab',
        'click .tab .dropdown-menu a': 'triggerNavTab'
    },

    /**
     * Button fields defined in view definition.
     */
    buttons: null,

    /**
     * Button states.
     */
    STATE: {
        EDIT: 'edit',
        VIEW: 'view'
    },

    // current button states
    currentState: null,

    // fields that should not be editable
    noEditFields: null,

    // width of the layout that contains this view
    _containerWidth: 0,

    /**
     * Flag indicating if the model for this view contains fields that are locked.
     *
     * @private
     * @type {boolean}
     */
    _hasLockedFields: false,

    /**
     * Name of the field that contains the field and its surrounding elements
     * like the label, pencil icon, etc.
     */
    decoratorField: 'record-decor',

    /**
     * Current active contact and model in SugarLive. Store these here so that we can properly hide and show
     * the link button when leaving edit mode.
     */
    sugarLiveContact: null,
    sugarLiveContactModel: null,

    /**
     * Reference to the SugarLive record link button
     */
    sugarLiveLinkButton: null,

    /**
     * Variables to store data related to dropdown-based views
     * baseMetaPanels: The base record view metadata panels defintions
     * dbvMetaPanels: A map of dropdown value -> metadata panels definitions
     * dbvTriggerField: The name of the dropdown field that triggers dropdown-based view changes
     * dbvCurrentKey: The key of dbvMetaPanels that is currently in use
     */
    baseMetaPanels: null,
    dbvMetaPanels: null,
    dbvTriggerField: null,
    dbvCurrentKey: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        /**
         * @inheritdoc
         * @property {Object} meta
         * @property {boolean} meta.hashSync Set to `true` to update URL
         *   consistently with the view state (`edit` or `detail`)
         */
        options.meta = _.extend({}, app.metadata.getView(null, 'record'), options.meta);
        this.inlineEditModeFields = [];
        options.meta.hashSync = _.isUndefined(options.meta.hashSync) ? true : options.meta.hashSync;
        if (options.meta.hasExternalFields) {
            this.plugins = _.union(this.plugins || [], ['ExternalApp']);
        }
        app.view.View.prototype.initialize.call(this, options);
        this.buttons = {};
        //Adding the favorite and follow fields.
        this.context.addFields(this._getDataFields());

        // FIXME: SC-5650 will handle removing these deprecation warnings in 7.10+
        _.each(this.meta.panels, function(panel) {
            _.each(panel.fields, function(field) {
                if (field.label_css_class) {
                    app.logger.warn('Warning: metadata property "label_css_class" found on field with name "' +
                        field.name + '" is deprecated and will be removed in a future release.');
                }
                if (field.cell_css_class) {
                    app.logger.warn('Warning: metadata property "cell_css_class" found on field with name "' +
                        field.name + '" is deprecated and will be removed in a future release.');
                }
            }, this);
        }, this);

        /**
         * An array of the {@link #alerts alert} names in this view.
         *
         * @property {Array}
         * @protected
         */
        this._viewAlerts = [];

        /**
         * A collection of alert messages to be used in this view. The alert methods
         * should be invoked by Function.prototype.call(), passing in an instance of
         * a sidecar view. For example:
         *
         *     // ...
         *     this.alerts.showInvalidModel.call(this);
         *     // ...
         *
         * FIXME: SC-3451 will refactor this `alerts` structure.
         * @property {Object}
         */
        this.alerts = {
            showInvalidModel: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                        'an instance of this view.');
                    return;
                }
                var name = 'invalid-data';
                this._viewAlerts.push(name);
                app.alert.show(name, {
                    level: 'error',
                    messages: 'ERR_RESOLVE_ERRORS'
                });
            },
            showNoAccessError: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                        'an instance of this view.');
                    return;
                }
                // dismiss the default error
                app.alert.dismiss('data:sync:error');
                // display no access error
                app.alert.show('server-error', {
                    level: 'error',
                    messages: 'ERR_HTTP_404_TEXT_LINE1'
                });
                // discard any changes before redirect
                this.handleCancel();
                // redirect to list view
                var route = app.router.buildRoute(this.module);
                app.router.navigate(route, {trigger: true});
            }
        };
        this.createMode = this.context.get('create') ? true : false;

        this.action = this.context.get('action') || 'detail';

        this.context.on('change:record_label', this.setLabel, this);
        this.context.set('viewed', true);
        this.model.on('duplicate:before', this.setupDuplicateFields, this);
        // displays error msg when required field is missing
        this.model.on('error:validation', this.alerts.showInvalidModel, this);
        this.on('editable:keydown', this.handleKeyDown, this);
        this.on('editable:mousedown', this.handleMouseDown, this);
        this.on('field:error', this.handleFieldError, this);
        this.on('editable:toggle_fields', this.focusFirstInput, this);
        this.model.on('acl:change', this.handleAclChange, this);
        this.context.on('field:disabled', this._togglePencil, this);

        this._initializeSugarLiveLink();

        //event register for preventing actions
        // when user escapes the page without confirming deleting
        app.routing.before('route', this.beforeRouteDelete, this);
        $(window).on('beforeunload.delete' + this.cid, _.bind(this.warnDeleteOnRefresh, this));

        this.delegateButtonEvents();

        if (this.createMode) {
            this.model.isNotEmpty = true;
        }

        this.noEditFields = [];
        // properly namespace SHOW_MORE_KEY key
        this.MORE_LESS_KEY = app.user.lastState.key(this.MORE_LESS_KEY, this);

        this.adjustHeaderpane = _.bind(_.debounce(this.adjustHeaderpane, 50), this);
        $(window).on('resize.' + this.cid, this.adjustHeaderpane);
        $(window).on('resize.' + this.cid, _.bind(this.overflowTabs, this));

        if (!this.getLabelPlacement()) {
            $(window).on('resize.' + this.cid, _.bind(_.debounce(this.relocatePencils, 500), this));
        }

        // initialize tab view after the component is attached to DOM
        this.on('append', function() {
            this.overflowTabs();
            this.handleActiveTab();
        }, this);

        this.on('render', this.registerShortcuts, this);

        // Option to specify additional noEdit/readonly fields
        this.extraNoEditFields = this.context.get('noEditFields') || [];

        // Option to open the record view to immediately validate/save
        this.saveImmediately = this.context.get('saveImmediately') || false;

        // Option to make this view edit-only
        this.editOnly = this.context.get('editOnly') || false;

        // Optional callbacks for after-save, after-cancel, and after-validation
        this.saveCallback = this.context.get('saveCallback') || null;
        this.cancelCallback = this.context.get('cancelCallback') || null;
        this.validationCallback = this.context.get('validationCallback') || null;

        // Option to avoid navigating to other routes during edit/save (useful for opening in a drawer)
        this.skipRouting = this.context.get('skipRouting') || false;

        // Listening for the save from preview to finish and reload data on the main record view
        // to reflect changes from preview's edit
        app.events.on('preview:edit:save', function() {
            this.context.reloadData();
        }, this);

        this.cancelButtonClicked = false;

        this.on('init', this._initDropdownBasedViews, this);
    },

    /**
     * Initializes any data needed to support dropdown-based views
     *
     * @private
     */
    _initDropdownBasedViews: function() {
        // If dropdown-based views are defined, no need to do anything
        let dropdownViews = app.metadata.getDropdownViews(this.module, this._getDropdownBasedViewName());
        if (_.isEmpty(dropdownViews)) {
            return;
        }

        // Store the original/base metadata the view was initialized with
        this.baseMetaPanels = this.meta.panels;

        // Store the name of the field that triggers dropdown-based view
        // changes, and the set of possible view metadata configurations by
        // dropdown value
        this.dbvTriggerField = _.first(_.keys(dropdownViews));
        this.dbvMetaPanels = _.mapObject(dropdownViews[this.dbvTriggerField], function(valueMeta) {
            return _.get(valueMeta, ['meta', 'panels']) || null;
        }, this);

        this._initDropdownBasedViewsForModel();
    },

    /**
     * Initializes the dropdown-conditional view metadata to be based on the
     * current model for the view
     *
     * @private
     */
    _initDropdownBasedViewsForModel: function() {
        if (_.isEmpty(this.dbvMetaPanels)) {
            return;
        }

        // Consider the trigger dropdown's value on the model as a "key" that
        // we can use to determine what the proper metadata is for the view
        this.dbvCurrentKey = this._getDropdownBasedViewKeyForModel(this.model);

        // Now, initialize the view metadata to the proper set based on the
        // current "key"/trigger field value
        this._setDbvMeta(this.dbvCurrentKey);

        // Whenever the "key"/trigger field value changes on the model,
        // recalculate and rerender based on which view metadata should be used
        this.listenTo(this.model, `change:${this.dbvTriggerField}`, this._handleDbvTriggerChange);

        // Don't show the dropdown-based view change warning when the record
        // is being fetched
        this.model.setOption('hideDbvWarning', true);
    },

    /**
     * Returns the name used by this view for dropdown-based view metadata
     *
     * @return {string} the dropdown-based view name
     * @private
     */
    _getDropdownBasedViewName: function() {
        return this.name;
    },

    /**
     * Given a model, determines which dropdown-based view metadata key to use
     *
     * @param {Bean} model the model for the view
     * @return {string|null} the view metadata key to use in this.dbvMetaPanels
     * @private
     */
    _getDropdownBasedViewKeyForModel: function(model) {
        if (model && this.dbvTriggerField) {
            let triggerFieldValue = model.get(this.dbvTriggerField);
            if (triggerFieldValue && !_.isString(triggerFieldValue)) {
                triggerFieldValue = triggerFieldValue.toString();
            }
            if (Object.keys(this.dbvMetaPanels).includes(triggerFieldValue)) {
                return triggerFieldValue;
            }
        }

        return null;
    },

    /**
     * Given a dropdown-based view metadata key, returns the proper metadata
     * to use in the view
     *
     * @param {string} key the dropdown-based view metadata key
     * @return {Object} the metadata configuration associated with the key
     * @private
     */
    _getMetaForDropdownBasedViewKey: function(key) {
        return this.dbvMetaPanels[key] || this.baseMetaPanels;
    },

    /**
     * For dropdown-based views, determines whether a change in the model's
     * dropdown value should trigger a view metadata refresh with the updated
     * set of panels. If it should, updates metadata and re-renders the view
     *
     * @private
     */
    _handleDbvTriggerChange: function(model, dbvTriggerFieldValue, options) {
        _.defer(() => {
            let newDropdownViewKey = this._getDropdownBasedViewKeyForModel(model);
            if (newDropdownViewKey !== this.dbvCurrentKey) {
                // Replace the view metadata with the dropdown-based view meta
                this.dbvCurrentKey = newDropdownViewKey;
                this._setDbvMeta(this.dbvCurrentKey);

                this.render();

                // If necessary, display a warning message that the view is
                // changing
                let hideDbvWarning = options && options.hideDbvWarning;
                if (!hideDbvWarning) {
                    this._displayDropdownBasedViewWarning();
                }
            }
        });
    },

    /**
     * Sets the view's metadata to the metadata specified by the given
     * dropdown-based view key
     *
     * @param dbvKey
     * @private
     */
    _setDbvMeta: function(dbvKey) {
        this.meta.panels = this._getMetaForDropdownBasedViewKey(dbvKey);
    },

    /**
     * Displays a warning to the user that a dropdown-based view change has
     * been triggered. If the "Undo" link is clicked in the warning, the
     * view changes are canceled
     *
     * @private
     */
    _displayDropdownBasedViewWarning: function() {
        app.alert.show('cancel-dropdown-view-change', {
            level: 'info',
            autoClose: true,
            autoCloseDelay: 4000,
            messages: app.lang.get('LBL_DROPDOWN_VIEW_CHANGE_WARNING', this.module)
        });
        let alert = app.alert.get('cancel-dropdown-view-change');
        if (alert) {
            alert.$el.find('#cancel_button').on('click', () => {
                this._cancelDropdownViewChange();
            });
        }
    },

    /**
     * Cancels the record edit when the user cancels a dropdown view change
     * @private
     */
    _cancelDropdownViewChange: function() {
        this.cancelClicked();
    },

    /**
     * Relocate all pencils of the record
     */
    relocatePencils: function() {
        _.each(this.fields, function(field) {
            if (field.type === 'record-decor') {
                field.relocatePencil();
            }
        });
    },

    /**
     * Handler for when the ACLs change on the model. Toggles the `hide` class
     * on the pencil wrapper for each of the fields on this view that had ACL
     * changes.
     * Hide the wrapper if no access to edit.
     *
     * @param {Object} diff The diff object of fields with ACL changes.
     */
    handleAclChange: function(diff) {
        var editAccess = app.acl.hasAccessToModel('edit', this.model);

        this._setNoEditFields();
        this.setEditableFields();

        var noEditFieldsMap = _.object(this.noEditFields, _.values(this.noEditFields));
        var $pencils = this.$('[data-wrapper=edit]');

        _.each($pencils, function(pencilEl) {
            var $pencilEl = $(pencilEl);
            var field = $pencilEl.data('name');

            if (editAccess && !diff[field]) {
                return;
            }

            var isEditable = _.isUndefined(noEditFieldsMap[field]);
            $pencilEl.toggleClass('hide', !isEditable);

            if (this.action === 'edit') {
                $pencilEl.closest('.record-cell').toggleClass('edit', isEditable);
            }
        }, this);
    },

    /**
     * Shows or hides the edit pencil icon for a field.
     *
     * @param {string} fieldName The field name.
     * @param {boolean} hide `true` to hide the pencil, `false` to show it.
     * @private
     */
    _togglePencil: function(fieldName, hide) {
        var isEditable = !_.contains(this.noEditFields, fieldName) && app.acl.hasAccessToModel('edit', this.model);

        if (!hide && !isEditable) {
            return;
        }

        this.$('span.record-edit-link-wrapper[data-name=' + fieldName + ']').toggleClass('hide', hide);
    },

    /**
     * Go through the field controllers and set the locked states accordingly.
     */
    handleLockedFields: function() {
        var self = this;

        // Reset the locked field state
        this._setLockedFieldFlag(false);

        var lockedFields = this.model.get('locked_fields');

        // Loop and check locked field state of each field
        _.each(this.$('.record-lock-link-wrapper[data-name]'), function(el) {
            var $el = $(el);
            var fieldName = $el.data('name');

            // No field name, nothing to do
            if (fieldName == '') {
                return;
            }

            // Get the field object
            var field = this.getField(fieldName);

            // Is the current field locked?
            var isLocked = _.contains(lockedFields, fieldName);

            // Special handling for fieldsets
            if (field.fields) {
                var hasLockedChildField = false;
                isLocked = true;
                _.each(field.fields, function(fieldSetField) {
                    // Some fieldsets have fields that are only for viewing, like the
                    // `copy` field on alternate addresses. Those should be filtered
                    // out of the fields list.
                    if (_.isUndefined(this.model.get(fieldSetField.name))) {
                        return;
                    }

                    var isChildLocked = _.contains(lockedFields, fieldSetField.name);
                    hasLockedChildField = hasLockedChildField || isChildLocked;

                    // A fieldset is locked when all of its actual fields are locked
                    if (!isChildLocked) {
                        isLocked = false;
                    }
                }, this);
            }

            // Set the flag that says if we have locked fields
            this._setLockedFieldFlag(this.hasLockedFields() || isLocked || hasLockedChildField);

            // Handle toggling the class
            $el.toggleClass('hide', !isLocked);
        }, this);

        // Show the locked field warning if there is one
        if (this.hasLockedFields()) {
            this.warnLockedFields();
        }
    },

    /**
     * Returns the flag that tells whether this object has locked fields or not
     * @return {boolean}
     */
    hasLockedFields: function() {
        return this._hasLockedFields;
    },

    /**
     * Sets the locked field flag
     * @param {boolean} setFlag
     * @private
     */
    _setLockedFieldFlag: function(setFlag) {
        this._hasLockedFields = setFlag;
    },

    /**
     * Alert warning if there are locked fields on the model.
     */
    warnLockedFields: function() {
        if (this.getCurrentButtonState() !== this.STATE.EDIT) {
            return;
        }

        if (this.context.get('lockedFieldsWarning') === false) {
            this.context.set('lockedFieldsWarning', true);
        } else {
            app.alert.show('record_locked_field_warning', {
                level: 'warning',
                messages: 'LBL_LOCKED_FIELD_RECORD_VIEW_WARNING',
                autoClose: true,
                autoCloseDelay: 5000
            });
        }
    },

    /**
     * Compare with last fetched data and return true if model contains changes.
     *
     * Check changes for fields that are editable only.
     *
     * {@link app.plugins.view.editable}
     *
     * @return {Boolean} `true` if current model contains unsaved changes, otherwise `false`.
     */
    hasUnsavedChanges: function() {
        var changedAttributes,
            editableFieldNames = [],
            unsavedFields,
            self = this,
            setAsEditable = function(fieldName) {
                if (fieldName && _.indexOf(self.noEditFields, fieldName) === -1) {
                    editableFieldNames.push(fieldName);
                }
            };

        if (this.resavingAfterMetadataSync)
            return false;

        changedAttributes = this.model.changedAttributes(this.model.getSynced());

        if (_.isEmpty(changedAttributes)) {
            return false;
        }

        // get names of all editable fields on the page including fields in a fieldset
        _.each(this.meta.panels, function(panel) {
            _.each(panel.fields, function(field) {
                if (!field.readonly) {
                    setAsEditable(field.name);
                    if (field.fields && _.isArray(field.fields)) {
                        _.each(field.fields, function(field) {
                            setAsEditable(field.name);
                        });
                    }
                }
            });
        });

        // check whether the changed attributes are among the editable fields
        unsavedFields = _.intersection(_.keys(changedAttributes), editableFieldNames);

        return !_.isEmpty(unsavedFields);
    },

    /**
     * Called when current record is being duplicated to allow customization of
     * fields that will be copied into new record.
     *
     * Override to setup the fields on this bean prior to being displayed in
     * Create dialog.
     *
     * @param {Object} prefill Bean that will be used for new record.
     * @template
     */
    setupDuplicateFields: function(prefill) {
    },

    setLabel: function(context, value) {
        var plus = '<i class="sicon sicon-plus-sm label-plus"></i>';
        this.$('.record-label[data-name="' + value.field + '"]')
            .html(plus).append(document.createTextNode(value.label));
    },

    /**
     * Called each time a validation pass is completed on the model.
     *
     * Enables the action button and calls {@link #handleSave} if the model is
     * valid.
     *
     * @param {boolean} isValid TRUE if model is valid.
     */
    validationComplete: function(isValid) {
        this.toggleButtons(true);
        if (isValid) {
            this.handleSave();
        }
        if (typeof this.validationCallback === 'function') {
            this.validationCallback(isValid);
        }
    },

    /**
     * Assign events to button clicks.
     */
    delegateButtonEvents: function() {
        this.context.on('button:edit_button:click', this.editClicked, this);
        this.context.on('button:save_button:click', this.saveClicked, this);
        this.context.on('button:delete_button:click', this.deleteClicked, this);
        this.context.on('button:duplicate_button:click', this.duplicateClicked, this);
        this.context.on('button:cancel_button:click', this.cancelClicked, this);
    },

    _render: function() {
        this._buildGridsFromPanelsMetadata(this.meta.panels);
        if (!_.isEmpty(_.get(this, ['meta', 'panels']))) {
            this._initTabsAndPanels();
        }
        // it seems like this.fields gets set somewhere here...
        // but that makes no sense.
        app.view.View.prototype._render.call(this);

        if (this.context.get('record_label')) {
            this.setLabel(this.context, this.context.get('record_label'));
        }

        // Field labels in headerpane should be hidden on view but displayed in edit and create
        _.each(this.fields, function(field) {
            // some fields like 'favorite' is readonly by default, so we need to remove edit-link-wrapper
            if (app.utils.isFieldAlwaysReadOnly(field.def, field.viewDefs) &&
                field.name && !_.contains(this.noEditFields, field.name)
            ) {
                this.$('.record-edit-link-wrapper[data-name=' + field.name + ']').remove();
            }
        }, this);

        if (this.action === 'edit') {
            this.setButtonStates(this.STATE.EDIT);
            this.toggleEdit(true);
        } else {
            this.setButtonStates(this.STATE.VIEW);
            if (this.createMode) {
                this.toggleEdit(true);
            }
        }

        // initialize tab view only if the component is attached to DOM,
        // otherwise it's initialized partially and cannot be properly
        // re-initialized after the component is attached to DOM
        if ($.contains(document.documentElement, this.$el[0])) {
            this.handleActiveTab();
            this.overflowTabs();
        }

        // If saveImmediately is set, programmatically click Edit -> Save
        if (this.saveImmediately) {
            this.editClicked();
            this.saveClicked();
        }

        this.createSugarLiveLinkButton();

        // If any fields were in inline edit mode when the view re-renderd,
        // place them back into that mode
        if (this.inlineEditMode) {
            _.each(this.inlineEditModeFields, function(field) {
                let element = this.getField(field);
                if (element) {
                    this.toggleField(element, true, true);
                }
            }, this);
            this.setButtonStates(this.STATE.EDIT);
        }
    },

    _renderField: function(field, $fieldEl) {
        // When we render the view, we need to enforce `action`
        // to be 'detail' if the field is non editable.
        // This is due to how View.Field#_loadTemplate currently works.
        // FIXME SC-6037: Will remove this hack.
        if (!_.contains(this.editableFields, field)) {
            // For fieldsets, we need to also set the actions of their subfields
            let fields = [field];
            if (field.type === 'fieldset' && !_.isEmpty(field.fields)) {
                fields = _.union(fields, field.fields);
            }

            _.each(fields, function(fieldToSet) {
                fieldToSet.action = 'detail';
                // Set viewName to `detail` if it was set to `edit` (because the field is non-editable)
                // but if it is not `edit` (hardcoded e.g. preview template), we want to keep it as it was.
                if (fieldToSet.options.viewName === 'edit') {
                    fieldToSet.options.viewName = 'detail';
                }
            }, this);
        }

        this._super('_renderField', [field, $fieldEl]);
    },

    /**
     * Handles initiation of Tabs and Panels view upon render
     * @private
     */
    _initTabsAndPanels: function() {
        this.meta.firstPanelIsTab = this.checkFirstPanel();
        this.meta.lastPanelIndex = this.meta.panels.length - 1;

        _.each(this.meta.panels, function(panel, i) {
            if (panel.header) {
                this.meta.firstNonHeaderPanelIndex = (i + 1);
            }
        }, this);

        // Tell the view to use Tabs and Panels view if either there exists a tab or if the number of panels isn't
        // equivalent to the amount expected for Business Card view (2 panels + possibly 1 if header exists)
        var headerExists = 0;
        if (_.first(this.meta.panels).header) {
            headerExists = 1;
        }

        this.meta.useTabsAndPanels = false;

        //Check if there are any newTabs
        for (i = headerExists; i < this.meta.panels.length; i++) {
            if (this.meta.panels[i].newTab) {
                this.meta.useTabsAndPanels = true;
            }
        }

        //Check for panel number
        if (this.meta.panels.length > (2 + headerExists)) {
            this.meta.useTabsAndPanels = true;
        }

        // set states
        _.each(this.meta.panels, function(panel){
            var panelKey = app.user.lastState.key(panel.name+':tabState', this);
            var panelState = app.user.lastState.get(panelKey);
            panel.panelState = panelState || panel.panelDefault;
        }, this);
    },
    /**
     * handles setting active tab
     */
    handleActiveTab: function() {
        var activeTabHref = this.getActiveTab(),
            activeTab = this.$('#recordTab > .tab > a[href="'+activeTabHref+'"]');

        // Always show first tab if we're on the create view
        if (this.createMode) {
            this.$('#recordTab a:first').tab('show');
            return;
        }

        if (activeTabHref && activeTab) {
            activeTab.tab('show');
        } else if (this.meta.useTabsAndPanels && this.checkFirstPanel()) {
            // If tabs and no last state set, show first tab on render
            this.$('#recordTab a:first').tab('show');
        }
    },
    /**
     * Gets the active tab in the user last state
     * @return {String} The active tab id in the user's last state.
     */
    getActiveTab: function() {
        var activeTabHref = app.user.lastState.get(app.user.lastState.key('activeTab', this));

        // Set to first tab by default
        if (!activeTabHref) {
            activeTabHref = this.$('#recordTab > .tab:first-child > a').attr('href') || '';
            app.user.lastState.set(
                app.user.lastState.key('activeTab', this),
                activeTabHref.substring(0, activeTabHref.indexOf(this.cid))
            );
        }
        else {
            activeTabHref += this.cid;
        }
        return activeTabHref;
    },
    /**
     * sets active tab in user last state
     * @param {Event} event
     */
    setActiveTab: function(event) {
        if (this.createMode) {
            return;
        }
        var tabTarget = this.$(event.currentTarget).attr('href'),
            tabKey = app.user.lastState.key('activeTab', this),
            cidIndex = tabTarget.indexOf(this.cid);

        tabTarget = tabTarget.substring(0, cidIndex);
        app.user.lastState.set(tabKey, tabTarget);
    },
    /**
     * saves panel state in user last state
     * @param {String} panelID
     * @param {String} state
     */
    savePanelState: function(panelID, state) {
        if (this.createMode) {
            return;
        }
        var panelKey = app.user.lastState.key(panelID+':tabState', this);
        app.user.lastState.set(panelKey, state);
    },

    /**
     * Parses through an array of panels metadata and sets some of them
     * as no edit fields.
     *
     * @param {Object[]} [panels=this.meta.panels] The panels to parse.
     * @private
     */
    _setNoEditFields: function(panels) {
        var self = this;
        panels = panels || this.meta.panels;

        delete this.noEditFields;
        this.noEditFields = [];

        _.each(panels, function(panel) {
            _.each(panel.fields, function(field, index) {
                var keys = _.keys(field);
                // Make filler fields readonly
                if (keys.length === 1 && keys[0] === 'span') {
                    field.readonly = true;
                }

                /* Disable the pencil icon if the user doesn't have ACLs.
                   Collection fields may have the "fields" property, but it corresponds to fields
                   on models in the related collection, not the model itself. */
                var isCollectionField = this.model.fields[field.name] &&
                    (this.model.fields[field.name].type === 'collection');
                if (field.fields && !isCollectionField) {
                    // Some fieldsets have fields that are only for viewing, like the
                    // `copy` field on alternate addresses. Those should be filtered
                    // out of the fields list.
                    var fieldSetFields = _.filter(field.fields, function(fieldSetField) {
                        return !_.isUndefined(self.model.get(fieldSetField.name));
                    });

                    if (field.readonly || this.extraNoEditFields.indexOf(field.name) !== -1 ||
                        _.every(fieldSetFields, function(f) {
                            return !app.acl.hasAccessToModel('edit', this.model, f.name);
                        }, this)) {
                        this.noEditFields.push(field.name);
                    }
                } else if (field.readonly || !app.acl.hasAccessToModel('edit', this.model, field.name) ||
                    this.extraNoEditFields.indexOf(field.name) !== -1) {
                    this.noEditFields.push(field.name);
                }
            }, this);
        }, this);
    },

    /**
     * Returns a list of fields that are not buttons of the view.
     *
     * @private
     */
    _getNonButtonFields: function() {
        return this._filterButtonsFromFields(this.fields);
    },

    /**
     * Removes button fields from list of passed in fields
     * @param {Object} fields
     * @return {Object}
     * @private
     */
    _filterButtonsFromFields: function(fields) {
        return _.filter(fields, _.bind(function(field) {
            if (field.type === this.decoratorField) {
                return false;
            }
            if (field.name) {
                return !this.buttons[field.name];
            }

            return true;
        }, this));
    },

    /**
     * Uses {@link app.plugins.Editable} to
     * set the internal property of {@link #editableFields}.
     */
    setEditableFields: function() {
        this.editableFields = this.getEditableFields(this._getNonButtonFields(), this.noEditFields);
    },

    /**
     * Registers fields as buttons.
     *
     * @deprecated Since 7.10.
     */
    initButtons: function() {
        app.logger.warn('`BaseRecordView#initButtons` is deprecated since 7.10 and will be ' +
            'removed in a future release.');
        if (this.options.meta && this.options.meta.buttons) {
            _.each(this.options.meta.buttons, function(button) {
                this.registerFieldAsButton(button.name);
            }, this);
        }
    },

    /**
     * Registers fields as buttons.
     *
     * @protected
     */
    _initButtons: function() {
        var buttons = this.meta.buttons;
        _.each(buttons, function(button) {
            this.registerFieldAsButton(button.name);
        }, this);
    },

    showPreviousNextBtnGroup: function() {
        var listCollection = this.context.get('listCollection') || new app.data.createBeanCollection(this.module);
        var recordIndex = listCollection.indexOf(listCollection.get(this.model.id));
        if (listCollection && listCollection.models && listCollection.models.length <= 1) {
            this.showPrevNextBtnGroup = false;
        } else {
            this.showPrevNextBtnGroup = true;
        }
        if (this.collection && listCollection.length !== 0) {
            this.showPrevious = listCollection.hasPreviousModel(this.model);
            this.showNext = listCollection.hasNextModel(this.model);
        }
    },

    /**
     * Adds a button field into `this.buttons`.
     *
     * @param {string} buttonName Name of the button.
     */
    registerFieldAsButton: function(buttonName) {
        var button = this.getField(buttonName);
        if (button) {
            this.buttons[buttonName] = button;
        }
    },

    _renderHtml: function() {
        this.showPreviousNextBtnGroup();
        app.view.View.prototype._renderHtml.call(this);
        this._initButtons();
        this.setEditableFields();
        _.bind(_.debounce(this.adjustHeaderpane, 800), this)();
    },

    /**
     * Calls setEditable fields after the fields are rendered
     * @private
     */
    _renderFields: function() {
        app.view.View.prototype._renderFields.call(this);
        this.setEditableFields();
    },

    bindDataChange: function() {
        // Handle locked field changes
        this.model.on('change:locked_fields', this.handleLockedFields, this);
        this.model.on('change', function() {
            if (this.inlineEditMode) {
                this.setButtonStates(this.STATE.EDIT);
            }
        }, this);
    },

    /**
     * Enables or disables the action buttons that are currently shown on the
     * page. Toggles the `.disabled` class by default.
     *
     * @param {boolean} [enable=false] Whether to enable or disable the action
     *   buttons. Defaults to `false`.
     */
    toggleButtons: function(enable) {
        var state = !_.isUndefined(enable) ? !enable : false;

        _.each(this.buttons, function(button) {
            var showOn = button.def.showOn;
            if (_.isUndefined(showOn) || this.currentState === showOn) {
                button.setDisabled(state);
            }
        }, this);
    },

    duplicateClicked: function() {
        var self = this,
            prefill = app.data.createBean(this.model.module);

        prefill.copy(this.model);
        this._copyNestedCollections(this.model, prefill);
        self.model.trigger('duplicate:before', prefill);
        prefill.unset('id');
        prefill.unset('is_escalated');

        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                model: prefill,
                copiedFromModelId: this.model.get('id')
            }
        }, function(context, newModel) {
            if (newModel && newModel.id) {
                app.router.navigate(self.model.module + '/' + newModel.id, {trigger: true});
            }
        });

        prefill.trigger('duplicate:field', self.model);
    },

    /**
     * Clones the attributes that are collections by way of the
     * {@link VirtualCollection} plugin.
     *
     * This guarantees that all related models in nested collection are copied
     * instead of only the ones that have already been fetched.
     *
     * All models of the collection on the source model are fetched
     * asynchronously and then added to the same collection on the target model
     * once there are no more models to retrieve. Note that this leaves open
     * the possibility for a race condition where the user clicks the Save
     * button on the Create View before all models have been received.
     *
     * @param {Data.Bean} source
     * @param {Data.Bean} target
     * @private
     */
    _copyNestedCollections: function(source, target) {
        var collections, view;

        // only model's that utilize the VirtualCollection plugin support this
        // functionality
        if (!_.isFunction(source.getCollectionFieldNames)) {
            return;
        }

        // avoid using the ambiguous `this` since there are references to many
        // objects in this method: view, field, model, collection, source,
        // target, etc.
        view = this;

        /**
         * Removes the `_action` attribute from a model when cloning it.
         *
         * @param {Data.Bean} model
         * @return {Data.Bean}
         */
        function cloneModel(model) {
            var attributes = _.chain(model.attributes).clone().omit('_action').value();
            return app.data.createBean(model.module, attributes);
        }

        /**
         * Copies all of the models from a collection to the same collection on
         * the target model.
         *
         * @param collection
         */
        function copyCollection(collection) {
            var field, relatedFields, options;

            /**
             * Adds all of the records from the source collection to the same
             * collection on the target model.
             *
             * @param {VirtualCollection} sourceCollection
             * @param {Object} [options]
             */
            function done(sourceCollection, options) {
                var targetCollection = target.get(collection.fieldName);

                if (!targetCollection) {
                    return;
                }

                targetCollection.add(sourceCollection.map(cloneModel));
            }

            field = view.getField(collection.fieldName, source);
            relatedFields = [];

            if (field.def.fields) {
                relatedFields = _.map(field.def.fields, function(def) {
                    return _.isObject(def) ? def.name : def;
                });
            }

            options = {success: done};

            // request the related fields from the field definition if possible
            if (relatedFields.length > 0) {
                options.fields = relatedFields;
            }

            collection.fetchAll(options);
        }

        // get all attributes from the source model that are collections
        collections = _.intersection(source.getCollectionFieldNames(), _.keys(source.attributes));

        _.each(collections, function(name) {
            copyCollection(source.get(name));
        });
    },

    /**
     * Event handler for click event.
     */
    editClicked: function() {
        this.setButtonStates(this.STATE.EDIT);
        this.cancelButtonClicked = false;
        this.action = 'edit';
        this.toggleEdit(true);
        this.setRoute('edit');
    },

    saveClicked: function() {
        // Disable the action buttons.
        this.toggleButtons(false);
        var allFields = this.getFields(this.module, this.model);
        var fieldsToValidate = {};
        var erasedFields = this.model.get('_erased_fields');
        for (var fieldKey in allFields) {
            if (app.acl.hasAccessToModel('edit', this.model, fieldKey) &&
                (!_.contains(erasedFields, fieldKey) || this.model.get(fieldKey) || allFields[fieldKey].id_name)) {
                _.extend(fieldsToValidate, _.pick(allFields, fieldKey));
            }
        }
        this.model.doValidate(fieldsToValidate, _.bind(this.validationComplete, this));
    },

    /**
     * Handles when the cancel_button view event is triggered.
     *
     * FIXME: This method will be removed as part of BR-3945
     *
     * @private
     *
     * @deprecated Since 7.7. Will be removed in 7.9.
     *   Use the `MetadataEventDriven` plugin events from the
     *   `record.php` button metadata instead.
     */
    _deprecatedCancelClicked: function() {
        var cancelBtn = this.getField('cancel_button');
        if (!cancelBtn || !cancelBtn.def || !cancelBtn.def.events) {
            app.logger.warn(this.module + ': Invoking the cancel_button from `this.events` has been deprecated' +
                ' since 7.7. This handler will be removed in 7.9. Please use the `MetadataEventDriven` plugin' +
                ' events from the \'record.php\' button metadata instead.');
            this.cancelClicked.apply(this, arguments);
        }
    },

    cancelClicked: function() {
        app.alert.dismiss('cancel-dropdown-view-change');
        this.setButtonStates(this.STATE.VIEW);
        this.cancelButtonClicked = true;
        this.action = 'detail';
        this.handleCancel();
        this.clearValidationErrors(this.editableFields);
        this.setRoute();
        this.unsetContextAction();

        if (typeof this.cancelCallback === 'function') {
            this.cancelCallback();
        }
    },

    deleteClicked: function(model) {
        this.warnDelete(model);
    },

    /**
     * Render fields into either edit or view mode.
     *
     * @param {Boolean} isEdit `true` to set the field in edit mode, `false`
     *   otherwise.
     */
    toggleEdit: function(isEdit) {
        if (this.editOnly) {
            isEdit = true;
        }

        var self = this;
        this.$('.record-lock-link').toggleClass('record-lock-link-on', isEdit);
        if (this.hasLockedFields()) {
            this.warnLockedFields();
        }
        this.toggleFields(this.editableFields, isEdit, function() {
            self.toggleViewButtons(isEdit);
            self.adjustHeaderpaneFields();
        });

        this._getCurrentSugarLiveContact();
        this.createSugarLiveLinkButton();
        this.handleSugarLiveLinkButtonState(isEdit);
    },

    /**
     * Gets target fields in a record-cell for a mouse event.
     * For now it only returns fields with tooltips.
     *
     * @param {Event} event Event object
     * @return {Object} collection of DOM elements of the target fields
     * @private
     */
    _getMouseTargetFields: function(event) {
        var target = this.$(event.target);
        var cell = target.parents('.record-cell');
        var fields = cell.find('[title]');
        return fields;
    },

    /**
     * Checks if tooltip is visible.
     *
     * @param {Object} field
     * @return {boolean}
     * @private
     */
    _isTooltipOn: function(field) {
        return !!$(field).attr('aria-describedby');
    },

    /**
     * Handles mousemove event.
     *
     * @param {Event} event Event object
     */
    handleMouseMove: function(event) {
        var fields = this._getMouseTargetFields(event);
        _.each(fields, function(field) {
            var rect = field.getBoundingClientRect();
            var tooltipOn = this._isTooltipOn(field);
            if (event.clientX >= rect.left && event.clientX < (rect.left + rect.width) &&
                event.clientY >= rect.top && event.clientY < (rect.top + rect.height)) {
                if (!tooltipOn) {
                    $(field).tooltip('show');
                }
            } else if (tooltipOn) {
                $(field).tooltip('hide');
            }
        }, this);
    },

    /**
     * Handles mouseleave event.
     *
     * @param {Event} event Event object
     */
    handleMouseLeave: function(event) {
        var fields = this._getMouseTargetFields(event);
        _.each(fields, function(field) {
            var tooltipOn = this._isTooltipOn(field);
            if (tooltipOn) {
                $(field).tooltip('hide');
            }
        }, this);
    },

    /**
     * Handles mouseup event.
     *
     * @param {Event} event Event object
     */
    handleLinkWrapperMouseUp: function(event) {
        // Checks if this field is editable
        var isEF = this.$(event.target).parents('.record-cell').find('.record-edit-link-wrapper:not(.hide)').get(0);
        var isLink = this.$(event.target).attr('href');
        var isEditMode = this.action === 'edit' || this.$(event.target).parents('.record-cell').hasClass('edit');
        // This handles the case where we click on a button within a field and we want that listener to fire
        // not the one one for the record edit link wrapper.
        var hasClickableAction = this.hasClickableAction(event.target);
        var selection = window.getSelection ? window.getSelection().toString() : document.selection.createRange().text;

        if (!this.createMode && isEF && !isLink && !isEditMode && !hasClickableAction && !selection) {
            this.handleEdit(event);
        }
    },

    /**
     * Determine if the click target has an action that should stop edit mode from triggering
     * @param {HTMLElement} element
     * @return {boolean}
     */
    hasClickableAction: function(element) {
        return _.some(['data-action', 'data-clipboard'], attr => {
            return element.getAttribute(attr) || element.parentElement.getAttribute(attr);
        });
    },

    /**
     * Handler for intent to edit. This handler is called both as a callback
     * from click events, and also triggered as part of tab focus event.
     *
     * @param {Event} e Event object (should be click event).
     * @param {jQuery} cell A jQuery node cell of the target node to edit.
     */
    handleEdit: function(e, cell) {
        var target,
            cellData,
            field;

        if (e) { // If result of click event, extract target and cell.
            target = this.$(e.target);
            cell = target.parents('.record-cell');
            // hide tooltip
            this.handleMouseLeave(e);
        }

        cellData = cell.data();
        field = this.getField(cellData.name);

        // If the focus drawer icon was clicked, open the focus drawer instead
        // of entering edit mode
        if (target && target.hasClass('focus-icon') && field && field.focusEnabled) {
            field.handleFocusClick();
            return;
        }

        // Set Editing mode to on.
        this.inlineEditMode = true;
        this.inlineEditModeFields.push(field.name);
        this.cancelButtonClicked = false;

        this.setButtonStates(this.STATE.EDIT);

        this.toggleField(field);

        if (this.$('.headerpane').length > 0) {
            this.toggleViewButtons(true);
            this.adjustHeaderpaneFields();
        }

        this.handleSugarLiveLinkButtonState(true);
    },

    /**
     * Hide view specific button during edit.
     *
     * @param {Boolean} isEdit `true` to hide some specific buttons, `false`
     *   otherwise.
     *
     * FIXME this should be done in a more generic way (field or metadata
     * property).
     */
    toggleViewButtons: function(isEdit) {
        this.$('.headerpane .btn-group-previous-next').toggleClass('hide', isEdit);
    },

    handleSave: function() {
        if (this.disposed) {
            return;
        }
        app.alert.dismiss('cancel-dropdown-view-change');
        this._saveModel();
        this.$('.record-save-prompt').hide();

        if (!this.disposed) {
            if (this.editOnly) {
                // If we are in edit-only mode, prevent multiple saves at a time.
                // Buttons will be re-enabled after save call is complete
                this.toggleButtons(false);
            } else {
                this.setButtonStates(this.STATE.VIEW);
                this.action = 'detail';
                this.setRoute();
                this.unsetContextAction();
                this.toggleEdit(false);
                this.inlineEditMode = false;
                this.inlineEditModeFields = [];
            }
        }
    },

    /**
     * Checks if the given field, represents a temporary file type.
     *
     * @param {string} key A field name.
     * @return {boolean} True if the field is of a temporary file type.
     */
    isTemporaryFileType: function(key) {
        return this.model.fields[key] && this.model.fields[key].type === 'file_temp';
    },

    /**
     * Clears a model of any temporary file type field values in order to
     * avoid sending the same value again with another, successive update.
     */
    resetTemporaryFileFields: function() {
        _.each(Object.keys(this.model.attributes), function(key) {
            if (this.isTemporaryFileType(key)) {
                delete this.model.attributes[key];
            }
        }, this);
    },

    _saveModel: function() {
        var options,
            successCallback = _.bind(function() {
                this.resetTemporaryFileFields();
                // Loop through the visible subpanels and previews and have them sync. This is to update any related
                // fields to the record that may have been changed on the server on save.
                _.each(this.context.children, function(child) {
                    // This will catch the preview panel since it's loaded as a record view
                    if ((child.get('isSubpanel') && !child.get('hidden')) || child.get('isPreview')) {
                        if (child.get('collapsed')) {
                            child.resetLoadFlag({recursive: false});
                        } else {
                            child.reloadData({recursive: false});
                        }
                    }
                });
                if (this.createMode && !this.skipRouting) {
                    app.navigate(this.context, this.model);
                } else if (!this.disposed && !app.acl.hasAccessToModel('edit', this.model)) {
                    //re-render the view if the user does not have edit access after save.
                    this.render();
                }

                if (typeof this.saveCallback === 'function') {
                    this.saveCallback(true);
                }
            }, this);

        //Call editable to turn off key and mouse events before fields are disposed (SP-1873)
        this.turnOffEvents(this.fields);

        options = {
            showAlerts: true,
            success: successCallback,
            error: _.bind(function(model, error) {
                if (error.status === 412 && !error.request.metadataRetry) {
                    this.handleMetadataSyncError(error);
                } else if (error.status === 409) {
                    app.utils.resolve409Conflict(error, this.model, _.bind(function(model, isDatabaseData) {
                        if (model) {
                            if (isDatabaseData) {
                                successCallback();
                            } else {
                                this._saveModel();
                            }
                        }
                    }, this));
                } else if (error.status === 403 || error.status === 404) {
                    this.alerts.showNoAccessError.call(this);
                } else {
                    this.editClicked();
                }

                if (typeof this.saveCallback === 'function') {
                    this.saveCallback(false);
                }
            }, this),
            complete: _.bind(function() {
                if (this.editOnly) {
                    this.toggleButtons(true);
                }
            }, this),
            lastModified: this.model.get('date_modified'),
            viewed: true
        };

        // ensure view and field are sent as params so collection-type fields come back in the response to PUT requests
        // (they're not sent unless specifically requested)
        options.params = options.params || {};
        if (this.context.has('dataView') && _.isString(this.context.get('dataView'))) {
            // Ensure the default fetch view is also used when we want fields returned in PUT requests
            options.params.view = this.model.getOption('view') || this.context.get('dataView');
        }

        if (this.context.has('fields')) {
            options.params.fields = this.context.get('fields').join(',');
        }

        options = _.extend({}, options, this.getCustomSaveOptions(options));

        this.model.save({}, options);
    },

    handleMetadataSyncError: function(error) {
        var self = this;
        //On a metadata sync error, retry the save after the app is synced
        self.resavingAfterMetadataSync = true;
        app.once('app:sync:complete', function() {
            error.request.metadataRetry = true;
            self.model.once('sync', function() {
                self.resavingAfterMetadataSync = false;
                //self.model.changed = {};
                app.router.refresh();
            });
            //add a new success callback to refresh the page after the save completes
            error.request.execute(null, app.api.getMetadataHash());
        });
    },

    getCustomSaveOptions: function(options) {
        return {};
    },

    handleCancel: function() {
        this.inlineEditMode = false;
        this.inlineEditModeFields = [];
        this.model.revertAttributes({
            hideDbvWarning: true
        });
        this.toggleEdit(false);
        this._dismissAllAlerts();
        this.trigger('record:edit:cancel');
    },

    /**
     * Pre-event handler before current router is changed.
     *
     * @return {Boolean} `true` to continue routing, `false` otherwise.
     */
    beforeRouteDelete: function() {
        if (this._modelToDelete) {
            this.warnDelete(this._modelToDelete);
            return false;
        }
        return true;
    },

    /**
     * Formats the messages to display in the alerts when deleting a record.
     *
     * @return {Object} The list of messages.
     * @return {string} return.confirmation Confirmation message.
     * @return {string} return.success Success message.
     */
    getDeleteMessages: function() {
        var messages = {};
        var model = this.model;
        var name = Handlebars.Utils.escapeExpression(this._getNameForMessage(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' "' + name + '"';

        messages.confirmation = app.utils.formatString(
            app.lang.get('NTC_DELETE_CONFIRMATION_FORMATTED', this.module),
            [context]
        );
        messages.success = app.utils.formatString(app.lang.get('NTC_DELETE_SUCCESS'), [context]);
        return messages;
    },

    /**
     * Retrieves the name of a record
     *
     * @param {Data.Bean} model The model concerned.
     * @return {string} name of the record.
     */
    _getNameForMessage: function(model) {
        return app.utils.getRecordName(model);
    },

    /**
     * Popup dialog message to confirm delete action
     */
    warnDelete: function(model) {
        var self = this;
        this._modelToDelete = model;

        self._targetUrl = Backbone.history.getFragment();
        //Replace the url hash back to the current staying page
        if (self._targetUrl !== self._currentUrl) {
            app.router.navigate(self._currentUrl, {trigger: false, replace: true});
        }

        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: self.getDeleteMessages().confirmation,
            onConfirm: _.bind(self.deleteModel, self),
            onCancel: function() {
                self._modelToDelete = false;
            }
        });
    },

    /**
     * Popup browser dialog message to confirm delete action
     *
     * @return {String} The message to be displayed in the browser dialog.
     */
    warnDeleteOnRefresh: function() {
        if (this._modelToDelete) {
            return this.getDeleteMessages().confirmation;
        }
    },

    /**
     * Delete the model once the user confirms the action
     */
    deleteModel: function() {
        var self = this;

        self.model.destroy({
            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': {
                    messages: self.getDeleteMessages().success
                }
            },
            success: function() {
                var redirect = self._targetUrl !== self._currentUrl;

                self.context.trigger('record:deleted', self._modelToDelete);

                self._modelToDelete = false;

                if (redirect) {
                    self.unbindBeforeRouteDelete();
                    //Replace the url hash back to the current staying page
                    app.router.navigate(self._targetUrl, {trigger: true});
                    return;
                }

                app.router.navigate(self.module, {trigger: true});
            }
        });

    },

    /**
     * Verify if the current target is the last one from an address block field.
     *
     * @param {View.Field} field Current focused field (field in inline-edit mode).
     * @param {String} currentTargetName attribute of the current target.
     *
     * @return {Boolean} `true` if field is the address block last field, `false` otherwise.
     **/
    isLastAddressBlockFieldSetField: function(field, currentTargetName) {
        var isFieldSet = field.type === 'fieldset';
        var lastField = _.last(field.fields);

        if (isFieldSet) {
            if (!lastField) {
                return false;
            }
            // Alternate and shipping address has no name attribute on their last field
            if (!currentTargetName) {
                return true;
            }
            return lastField.name === currentTargetName;
        } else {
            return false;
        }
    },

    /**
     * Key handlers for inline edit mode.
     *
     * Jump into the next or prev target field if `tab` key is pressed.
     * Calls {@link app.plugins.Editable#nextField} to go to next/prev field.
     *
     * @param {Event} e Event object.
     * @param {View.Field} field Current focused field (field in inline-edit mode).
     */
    handleKeyDown: function(e, field) {
        var whichField = e.shiftKey ? 'prevField' : 'nextField';

        if (e.which === 9) { // If tab
            var isFieldSet = field.type === 'fieldset';
            var isLastAddressBlockFieldSetField = this.isLastAddressBlockFieldSetField(field, e.currentTarget.name);
            // If the current field is not an address block
            // or it's the last field of an address block
            // then jumping to other fields.
            if (!isFieldSet || isLastAddressBlockFieldSetField) {
                e.preventDefault();
                this.nextField(field, whichField);
            }
            if (field.$el.closest('.headerpane').length > 0) {
                this.toggleViewButtons(false);
                this.adjustHeaderpaneFields();
            }
            if (field[whichField] && field[whichField].$el.closest('.headerpane').length > 0) {
                this.toggleViewButtons(true);
                this.adjustHeaderpaneFields();
            }
        }
    },

    /**
     * Adjust headerpane fields when they change to view mode
     */
    handleMouseDown: function() {
        this.toggleViewButtons(false);
        this.adjustHeaderpaneFields();
    },

    /**
     * Handles a field validation error for record views.
     * @param field
     * @param {Boolean} hasError True if a field has an error, false if the field is clearing it's error state
     */
    handleFieldError: function(field, hasError) {
        if(!hasError) {
            return;
        }

        var tabLink,
            fieldTab   = field.$el.closest('.tab-pane'),
            fieldPanel = field.$el.closest('.record-panel-content');

        if (field.view.meta && field.view.meta.useTabsAndPanels) {
            // If field's panel is a tab, switch to the tab that contains the field with the error
            if (fieldTab.length > 0) {
                // Make sure all previous active tab content is hidden
                this.$('.tab-pane').removeClass('active in');

                // Switch to the tab with the error
                tabLink = this.$('[href="#' + fieldTab.attr('id') + '"][data-toggle="tab"]');
                tabLink.tab('show');

                // Put a ! next to the tab if one doesn't already exist
                if (tabLink.find('.sicon-error').length === 0) {
                    tabLink.append(' <i class="sicon sicon-error tab-warning"></i>');
                }

                // Make sure the new current active tab is shown
                this.$('.tab-content [id="' + fieldTab.attr('id') + '"]').addClass('active in');
            }

            // If field's panel is a panel that is closed, open it and change arrow
            if (fieldPanel && fieldPanel.is(':hidden')) {
                fieldPanel.toggle();
                var fieldPanelArrow = fieldPanel.prev().find('i');
                fieldPanelArrow.toggleClass('sicon-chevron-down sicon-chevron-right');
            }
        } else if (field.$el.is(':hidden')) {
            this.$('.more[data-moreless]').trigger('click');
            app.user.lastState.set(this.SHOW_MORE_KEY, this.$('.less[data-moreless]'));
        }
        else if (field.$el.closest('.panel_hidden.hide').length > 0) {
            this.toggleMoreLess(this.MORE_LESS_STATUS.MORE, true);
        }
    },

    /**
     * Show/hide buttons depending on the state defined for each buttons in the
     * metadata.
     *
     * @param {String} state The {@link #STATE} of the current view.
     */
    setButtonStates: function(state) {
        if (this.editOnly) {
            state = this.STATE.EDIT;
        }

        this.currentState = state;

        _.each(this.buttons, function(field) {
            var showOn = field.def.showOn;
            if (_.isUndefined(showOn) || (showOn === state)) {
                field.show();
            } else {
                field.hide();
            }
        });

        this.toggleButtons(true);
    },

    /**
     * Get the current button state.
     * @return {string} The current button state
     */
    getCurrentButtonState: function() {
        return this.currentState;
    },

    /**
     * Set the title in the header pane.
     *
     * @param {String} title The new title to set on the headerpane.
     *
     * FIXME this should be done with the header pane view + re-render it.
     */
    setTitle: function(title) {
        var $title = this.$('.headerpane .module-title');
        if ($title.length > 0) {
            $title.text(title);
        } else {
            this.$('.headerpane h1').prepend('<div class="record-cell"><span class="module-title">' + title + '</span></div>');
        }
    },

    /**
     * Initialize the SugarLive link button with the starting details, and listen for any changes
     * @private
     */
    _initializeSugarLiveLink: function() {
        this._getCurrentSugarLiveContact();
        app.events.on('omniconsole:contact:changed', this.handleSugarLiveContactChange, this);
    },

    /**
     * Directly get the current contact in SugarLive. This is used for getting the initial data on first load,
     * and also for refreshing when switching tabs in record dashlet
     * @private
     */
    _getCurrentSugarLiveContact: function() {
        if (app.omniConsole) {
            let ccp = app.omniConsole.getComponent('omnichannel-ccp');
            let activeContact = ccp.getActiveContact();
            let activeModel = ccp.getActiveModel();

            if (activeContact && activeModel) {
                this.handleSugarLiveContactChange(activeContact, activeModel);
            }
        }
    },

    /**
     * Listen for changes to the current SugarLive contact
     * @param contact
     * @param contactModel
     */
    handleSugarLiveContactChange: function(contact, contactModel) {
        this.sugarLiveContact = contact;
        this.sugarLiveContactModel = contactModel;
        this.showSugarLiveLinkButton = this.sugarLiveContact !== null;

        if (this.disposed || !this.sugarLiveLinkButton) {
            return;
        }

        this.handleSugarLiveLinkButtonState(this.action === 'edit' || this.inlineEditMode);
    },

    /**
     * Handle the link button state depending on if we're in edit mode or not
     * @param isEdit
     */
    handleSugarLiveLinkButtonState: function(isEdit) {
        if (this.sugarLiveLinkButton && this.sugarLiveContact) {
            let contactModule = this.sugarLiveContact.getType() === 'voice' ? 'Calls' : 'Messages';

            // Determine the correct tooltip based on the state of the link
            let tooltip;
            if (this._isLinkedToActiveContact()) {
                tooltip = app.lang.get('LBL_OMNICHANNEL_LINKED', this.module);
            } else {
                tooltip = app.lang.get('LBL_OMNICHANNEL_LINK_RECORD', this.module, {
                    module: new Handlebars.SafeString(app.lang.get('LBL_MODULE_NAME_SINGULAR', contactModule))
                });
            }

            this.sugarLiveLinkButton.setOptions({
                tooltip: tooltip,
                className: this._isLinkedToActiveContact() ? 'linked' : 'unlinked'
            });
            this.sugarLiveLinkButton.render();
        }

        this._toggleSugarLiveButtonVisibility(isEdit);
    },

    /**
     * Check if this record is already linked in some way to the current active contact
     * @return {boolean}
     * @private
     */
    _isLinkedToActiveContact: function() {
        let detail = app.omniConsole.getComponent('omnichannel-detail');
        if (!detail || !this.sugarLiveContactModel) {
            return false;
        }

        let isLinkedAsGuest = false;
        // Check this model against current linked models from omnichannel detail
        // panel to see if this model is linked to the active record
        _.each(['Contacts', 'Leads'], function(module) {
            let model = detail.getModel(null, module);
            if (model && model.get('id') === this.model.get('id')) {
                isLinkedAsGuest = true;
            }
        }, this);

        let isLinkedAsParent = this.module === this.sugarLiveContactModel.get('parent_type') &&
            this.model.get('id') === this.sugarLiveContactModel.get('parent_id');

        return isLinkedAsGuest || isLinkedAsParent;
    },

    /**
     * Hide or show the link button
     * @param isEdit
     */
    _toggleSugarLiveButtonVisibility: function(isEdit) {
        if (this.showSugarLiveLinkButton && !isEdit && this._isValidLinkableModule()) {
            this.$('.headerpane .omni-record-link').removeClass('hide');
        } else {
            this.$('.headerpane .omni-record-link').addClass('hide');
        }
    },

    /**
     * Inserts the link button
     * @param linkButton
     * @private
     */
    _insertSugarLiveButton: function(linkButton) {
        if (this.$('.headerpane .omni-record-link').length) {
            this.$('.headerpane .omni-record-link').remove();
        }

        let actionButtons = this.$('.headerpane .btn-toolbar .fieldset.actions').first();
        actionButtons.before(linkButton.$el);
    },

    /**
     * Checks if the current record is allowed to be linked to the SugarLive contact
     * @return {boolean}
     * @private
     */
    _isValidLinkableModule: function() {
        let contactModule = this.sugarLiveContact.getType() === 'voice' ? 'Calls' : 'Messages';
        let contactModuleMetadata = app.metadata.getModule(contactModule, 'fields');
        let linkableModules = app.lang.getAppListKeys(contactModuleMetadata.parent_name.options);
        return linkableModules.includes(this.module);
    },

    /**
     * Creates the SugarLive record link button
     * @private
     */
    createSugarLiveLinkButton: function() {
        if (this.sugarLiveLinkButton) {
            this._destroySugarLiveLinkButton();
        }

        let linkButton = app.view.createView({
            type: 'omnichannel-record-link',
            model: this.model
        });
        linkButton.render();
        this._insertSugarLiveButton(linkButton);

        this.sugarLiveLinkButton = linkButton;

        this.handleSugarLiveLinkButtonState(this.action === 'edit' || this.inlineEditMode);
    },

    /**
     * Cleans up the SugarLive record link button
     * @private
     */
    _destroySugarLiveLinkButton: function() {
        this.sugarLiveLinkButton.dispose();
        this.sugarLiveLinkButton = null;
    },

    /**
     * Detach the event handlers for warning delete
     */
    unbindBeforeRouteDelete: function() {
        app.routing.offBefore('route', this.beforeRouteDelete, this);
        $(window).off('beforeunload.delete' + this.cid);
    },

    _buildGridsFromPanelsMetadata: function(panels) {
        var lastTabIndex = 0;
        this.noEditFields = [];

        _.each(panels, function(panel) {
            // get user preference for labelsOnTop before iterating through
            // fields
            panel.labelsOnTop = this.getLabelPlacement();
            // it is assumed that a field is an object but it can also be a string
            // while working with the fields, might as well take the opportunity to check the user's ACLs for the field
            _.each(panel.fields, function(field, index) {
                if (_.isString(field)) {
                    panel.fields[index] = field = {name: field};
                }

                var keys = _.keys(field);

                // Make filler fields readonly
                if (keys.length === 1 && keys[0] === 'span') {
                    field.readonly = true;
                }

                // disable the pencil icon if the user doesn't have ACLs
                if (field.fields && _.isArray(field.fields)) {
                    if ((field.readonly && this.checkReadonlyFormula(field.name)) ||
                        _.contains(this.extraNoEditFields, field.name) ||
                        _.every(field.fields, function(field) {
                            return !app.acl.hasAccessToModel('edit', this.model, field.name);
                        }, this)) {
                        this.noEditFields.push(field.name);
                    }
                } else if ((field.readonly && this.checkReadonlyFormula(field.name)) ||
                    !app.acl.hasAccessToModel('edit', this.model, field.name) ||
                    _.contains(this.extraNoEditFields, field.name)) {
                    this.noEditFields.push(field.name);
                }

                // set field labelsOnTop value for use in rendering
                field.labelsOnTop = panel.labelsOnTop;
            }, this);

            // Set flag so that show more link can be displayed to show hidden panel.
            if (panel.hide) {
                this.hiddenPanelExists = true;
            }

            // labels: visibility for the label
            if (_.isUndefined(panel.labels)) {
                panel.labels = true;
            }

            if (_.isFunction(this.getGridBuilder)) {
                var options = {
                        fields: panel.fields,
                        columns: panel.columns,
                        labels: panel.labels,
                        labelsOnTop: panel.labelsOnTop,
                        tabIndex: lastTabIndex
                    },
                    gridResults = this.getGridBuilder(options).build();

                panel.grid = gridResults.grid;
                lastTabIndex = gridResults.lastTabIndex;
            }
        }, this);
    },

    /**
     * To check if readonly_formula is empty
     * @param fieldName
     * @return {*|boolean}
     */
    checkReadonlyFormula: function(fieldName) {
        return (this.model.fields[fieldName] && _.isUndefined(this.model.fields[fieldName].readonly_formula));
    },

    /**
     * Used to set labelsOnTop in views. Returns true if user preference is
     * 'field_on_top', else false.
     *
     * @return {boolean} True if user prefers 'field_on_top' otherwise false
     */
    getLabelPlacement: function() {
        return app.user.getPreference('field_name_placement') === 'field_on_top';
    },

    /**
     * Handles click event on next/previous button of record.
     * @param {Event} evt
     */
    paginateRecord: function(evt) {
        var el = $(evt.currentTarget),
            data = el.data();
        if (data.id) {
            var list = this.context.get('listCollection'),
                model = list.get(data.id);
            this._doPaginate(model, data.actionType);
        }
    },
    /**
     * paginates record view depeding on direction and model
     * @param {Object} model
     * @param {String} actionType
     * @private
     */
    _doPaginate: function(model, actionType) {
        var list = this.context.get('listCollection');
        switch (actionType) {
            case 'next':
                list.getNext(model, this.navigateModel);
                break;
            case 'prev':
                list.getPrev(model, this.navigateModel);
                break;
            default:
                this._disablePagination(el);
        }
    },
    /**
     * Callback for navigate to new model.
     *
     * @param {Data.Bean} model model New model to navigate.
     * @param {String} actionType actionType Side of navigation (prev/next).
     */
    navigateModel: function(model, actionType) {
        if (model && model.id) {
            if (app.acl.hasAccessToModel('view', model)) {
                app.router.navigate(app.router.buildRoute(this.module, model.id), {trigger: true});
            } else {
                this._doPaginate(model, actionType);
            }
        } else {
            var el = this.$el.find('[data-action=scroll][data-action-type=' + actionType + ']');
            this._disablePagination(el);
        }
    },

    /**
     * Updates url without triggering the router.
     *
     * @param {string} action Action to pass when building the route
     *   with {@link Core.Router#buildRoute}.
     */
    setRoute: function(action) {
        if (!this.meta.hashSync || this.skipRouting) {
            return;
        }
        app.router.navigate(app.router.buildRoute(this.module, this.model.id, action), {trigger: false});
    },

    /**
     * Unsets the `action` attribute from the current context.
     *
     * Once 'action' is unset, the action is 'detail' and the view will render
     * next in detail mode.
     */
    unsetContextAction: function() {
        this.context.unset('action');
    },

    /**
     * Disabling pagination if we can't paginate.
     * @param {Object} el Element to disable pagination on.
     */
    _disablePagination: function(el) {
        app.logger.error('Wrong data for record pagination. Pagination is disabled.');
        el.addClass('disabled');
        el.data('id', '');
    },

    /**
     * Adjust headerpane such that certain fields can be shown with ellipsis
     */
    adjustHeaderpane: function() {
        if (this.disposed) {
            return;
        }
        this.setContainerWidth();
        this.adjustHeaderpaneFields();
    },

    /**
     * Get the width of the layout container
     */
    getContainerWidth: function() {
        return this._containerWidth;
    },

    /**
     * Set the width of the layout container
     */
    setContainerWidth: function() {
        this._containerWidth = this._getParentLayoutWidth(this.layout);
    },

    /**
     * Get the width of the parent layout that contains `getPaneWidth()`
     * method.
     *
     * @param {View.Layout} layout The parent layout.
     * @return {Number} The parent layout width.
     * @private
     */
    _getParentLayoutWidth: function(layout) {
        if (!layout) {
            return 0;
        } else if (_.isFunction(layout.getPaneWidth)) {
            return layout.getPaneWidth(this);
        }

        return this._getParentLayoutWidth(layout.layout);
    },

    /**
     * Adjust headerpane fields such that the first field is ellipsified and the last field
     * is set to 100% on view.  On edit, the first field is set to 100%.
     */
    adjustHeaderpaneFields: function() {
        var $ellipsisCell;
        var ellipsisCellWidth;

        if (this.disposed) {
            return;
        }

        var $recordCells = this._getRecordCells();

        if ($recordCells && ($recordCells.length > 0) && (this.getContainerWidth() > 0)) {
            $ellipsisCell = $(this._getCellToEllipsify($recordCells));

            if ($ellipsisCell.length > 0) {
                if ($ellipsisCell.hasClass('edit')) {
                    // make the ellipsis cell widen to 100% on edit
                    $ellipsisCell.css({'width': '100%'});
                } else {
                    ellipsisCellWidth = this._calculateEllipsifiedCellWidth($recordCells, $ellipsisCell);
                    this._setMaxWidthForEllipsifiedCell($ellipsisCell, ellipsisCellWidth);
                }
            }
        }

        if (this.layout) {
            this.layout.trigger('headerpane:adjust_fields');
        }
    },

    /**
     * Get the collection of headerpane record-cell and btn-toolbar elements.
     *
     * @return {jQuery} The collection of headerpane record-cell and
     *   btn-toolbar elements.
     * @protected
     */
    _getRecordCells: function() {
        return this.$('.headerpane h1').children('.record-cell, .btn-toolbar');
    },

    /**
     * Get the first cell for the field that can be ellipsified.
     * @param {jQuery} $cells
     * @return {jQuery}
     * @private
     */
    _getCellToEllipsify: function($cells) {
        var fieldTypesToEllipsify = ['fullname', 'name', 'text', 'base', 'enum', 'url', 'dashboardtitle'];

        return _.find($cells, function(cell) {
            return (_.indexOf(fieldTypesToEllipsify, $(cell).data('type')) !== -1);
        });
    },

    /**
     * Calculate the width for the cell that needs to be ellipsified.
     * @param {jQuery} $cells
     * @param {jQuery} $ellipsisCell
     * @return {Number}
     * @private
     */
    _calculateEllipsifiedCellWidth: function($cells, $ellipsisCell) {
        var width = this.getContainerWidth();

        _.each($cells, function(cell) {
            var $cell = $(cell);

            if ($cell.is($ellipsisCell)) {
                width -= (parseInt($ellipsisCell.css('padding-left'), 10) +
                    parseInt($ellipsisCell.css('padding-right'), 10));
            } else if ($cell.is(':visible')) {
                $cell.css({'width': 'auto'});
                width -= $cell.outerWidth();
            }
            $cell.css({'width': ''});
        });

        return width;
    },

    /**
     * Set the max-width for the specified cell.
     * @param {jQuery} $ellipsisCell
     * @param {number} width
     * @private
     */
    _setMaxWidthForEllipsifiedCell: function($ellipsisCell, width) {
        var ellipsifiedCell,
            fieldType = $ellipsisCell.data('type');
        if (fieldType === 'fullname' || fieldType === 'dashboardtitle') {
            ellipsifiedCell = this.getField($ellipsisCell.data('name'));
            if (ellipsifiedCell) {
                width -= ellipsifiedCell.getCellPadding();
                ellipsifiedCell.setMaxWidth(width);
            }
        } else {
            $ellipsisCell.css({'width': width}).children().css({'max-width': (width - 2) + 'px'});
        }
    },

    /**
     * Returns some fields to be used with app.view.View.getFieldNames() if their corresponding
     * meta attribute is true
     *
     * @private
     */
    _getDataFields: function() {
        var fields = [];

        var favorite = _.find(this.meta.panels, function(panel) {
            return _.find(panel.fields, function(field) {
                return field.type === 'favorite';
            });
        });

        var follow = _.find(this.meta.panels, function(panel) {
            return _.find(panel.fields, function(field) {
                return field.type === 'follow';
            });
        });

        if (favorite) {
            fields.push('my_favorite');
        }

        if (follow) {
            fields.push('following');
        }

        return fields;
    },

    /**
     * Extracts the field names from the metadata for directly related views/panels.
     * @param {string} [module] Module name.
     */
    getFieldNames: function(module) {
        return _.union(this._super('getFieldNames', arguments), this._getDataFields());
    },

    /**
     * Hide or show panel based on click to the panel header
     * @param {Event} e
     */
    togglePanel: function(e) {
        var $panelHeader = this.$(e.currentTarget);
        if ($panelHeader && $panelHeader.next()) {
            $panelHeader.next().toggle();
            $panelHeader.toggleClass('panel-inactive panel-active');
        }
        if ($panelHeader && $panelHeader.find('i')) {
            var $panelArrow = $panelHeader.find('i');
            $panelArrow.toggleClass('sicon-chevron-down sicon-chevron-right');
        }
        var panelName = this.$(e.currentTarget).parent().data('panelname');
        var state = 'collapsed';
        if (this.$(e.currentTarget).next().is(":visible")) {
            state = 'expanded';
        }
        this.savePanelState(panelName, state);
    },

    /**
     * Returns true if the first non-header panel has useTabs set to true
     */
    checkFirstPanel: function() {
        if (this.meta && this.meta.panels) {
            if (this.meta.panels[0] && this.meta.panels[0].newTab && !this.meta.panels[0].header) {
                return true;
            }
            if (this.meta.panels[1] && this.meta.panels[1].newTab) {
                return true;
            }
        }
        return false;
    },

    /**
     * Moves overflowing tabs into a dropdown
     */
    overflowTabs: function() {
        if (this.disposed) {
            return;
        }
        var $tabs = this.$('#recordTab > .tab:not(.dropdown)'),
            $dropdownList = this.$('#recordTab .dropdown'),
            $dropdownTabs = this.$('#recordTab .dropdown-menu li'),
            navWidth = this.$('#recordTab').width(),
            activeTabHref = this.getActiveTab(),
            $activeTab = this.$('#recordTab > .tab > a[href="'+activeTabHref+'"]').parent(),
            // Calculate available width for items in navbar
            // Includes the activetab to ensure it is displayed
            width = $activeTab.outerWidth() + $dropdownList.outerWidth();

        $tabs.each(_.bind(function (index, elem) {
            var $tab = $(elem),
                overflow;

            // Always include the active tab
            if ($tab.hasClass('active')) {
                overflow = false;
            }
            else {
                width += $tab.outerWidth();
                // Check if the tab fits in the navbar
                overflow = width >= navWidth;
            }

            // Toggle tabs in the navbar
            $tab.toggleClass('hidden', overflow);
            // Toggle items in the dropdown
            this.$($dropdownTabs[index]).toggleClass('hidden', !overflow);
        }, this));
        // Toggle the dropdown arrow
        $dropdownList.toggleClass('hidden', !$tabs.is(':hidden'));
    },

    /**
     * Takes a tab dropdown link and triggers the corresponding tab
     * @param {Event} e
     */
    triggerNavTab: function(e) {
        var tabTarget = e.currentTarget.hash,
            activeTab = this.$('#recordTab > .tab > a[href="'+tabTarget+'"]');

        e.preventDefault();
        activeTab.trigger('click');
        this.overflowTabs();
    },

    /**
     * Register keyboard shortcuts.
     */
    registerShortcuts: function() {
        app.shortcuts.register({
            id: 'Record:Edit',
            keys: ['e','mod+alt+i'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_EDIT',
            handler: function() {
                var $editButton = this.$('.headerpane [name=edit_button]');
                if ($editButton.is(':visible') && !$editButton.hasClass('disabled')) {
                    $editButton.click();
                }
            }
        });

        app.shortcuts.register({
            id: 'Record:Delete',
            keys: ['d','mod+alt+d'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_DELETE',
            handler: function() {
                this.$('.headerpane [data-toggle=dropdown]:visible').click().blur();
                this.$('.headerpane [name=delete_button]:visible').click();
            }
        });

        app.shortcuts.register({
            id: 'Record:Save',
            keys: ['mod+s','mod+alt+a'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_SAVE',
            callOnFocus: true,
            handler: function() {
                var $saveButton = this.$('a[name=save_button]');
                if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                    $saveButton.click();
                }
            }
        });

        app.shortcuts.register({
            id: 'Record:Cancel',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_CANCEL',
            callOnFocus: true,
            handler: function() {
                var $cancelButton = this.$('a[name=cancel_button]');
                if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                    $cancelButton.click();
                }
            }
        });

        app.shortcuts.register({
            id: 'Record:Previous',
            keys: 'h',
            component: this,
            description: 'LBL_SHORTCUT_RECORD_PREVIOUS',
            handler: function() {
                var $previous = this.$('.btn.previous-row');
                if ($previous.is(':visible') && !$previous.hasClass('disabled')) {
                    $previous.click();
                }
            }
        });

        app.shortcuts.register({
            id: 'Record:Next',
            keys: 'l',
            component: this,
            description: 'LBL_SHORTCUT_RECORD_NEXT',
            handler: function() {
                var $next = this.$('.btn.next-row');
                if ($next.is(':visible') && !$next.hasClass('disabled')) {
                    $next.click();
                }
            }
        });

        app.shortcuts.register({
            id: 'Record:Favorite',
            keys: 'f a',
            component: this,
            description: 'LBL_SHORTCUT_FAVORITE_RECORD',
            handler: function() {
                this.$('.headerpane .sicon-star-outline:visible').click();
            }
        });

        app.shortcuts.register({
            id: 'Record:Follow',
            keys: 'f o',
            component: this,
            description: 'LBL_SHORTCUT_FOLLOW_RECORD',
            handler: function() {
                this.$('.headerpane [name=follow]:visible').click();
            }
        });

        app.shortcuts.register({
            id: 'Record:Copy',
            keys: ['shift+c','mod+alt+u'],
            component: this,
            description: 'LBL_SHORTCUT_COPY_RECORD',
            handler: function() {
                this.$('.headerpane [data-toggle=dropdown]:visible').click().blur();
                this.$('.headerpane [name=duplicate_button]:visible').click();
            }
        });

        app.shortcuts.register({
            id: 'Record:Action:More',
            keys: 'm',
            component: this,
            description: 'LBL_SHORTCUT_OPEN_MORE_ACTION',
            handler: function() {
                var $primaryDropdown = this.$('.headerpane .btn-primary[data-toggle=dropdown]:visible');
                if (($primaryDropdown.length > 0) && !$primaryDropdown.hasClass('disabled')) {
                    $primaryDropdown.click();
                }
            }
        });
    },

    /**
     * Dismisses all {@link #_viewAlerts alerts} defined in this view.
     *
     * @protected
     */
    _dismissAllAlerts: function() {
        if (_.isEmpty(this._viewAlerts)) {
            return;
        }
        _.each(_.uniq(this._viewAlerts), function(alert) {
            app.alert.dismiss(alert);
        });
        this._viewAlerts = [];
    },

    /**
     * Focus the first text input available when toggling to edit mode
     */
    focusFirstInput: function(fields, viewName) {
        if (viewName === 'edit') {
            var $firstInput;
            _.find(fields, function(field) {
                var $input = field.$('input[type="text"]');
                if ($input.length > 0) {
                    $firstInput = $input;
                    return true;
                }
                return false;
            });

            if ($firstInput) {
                var $el = $firstInput.first();
                if ($el.is(':visible')) {
                    $el.focus();
                    this.setCaretToEnd($el);
                }
            }
        }
    },

    /**
     * Move the input cursor to the end
     *
     * @param {jQuery} $element
     */
    setCaretToEnd: function($element) {
        if ($element.val().length > 0) {
            var elementVal = $element.val();
            $element.val('').val(elementVal);
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.sugarLiveLinkButton) {
            this._destroySugarLiveLinkButton();
        }

        this.unbindBeforeRouteDelete();
        _.each(this.editableFields, function(field) {
            field.nextField = null;
            field.prevField = null;
        });
        this.buttons = null;
        this.editableFields = null;
        this.inlineEditModeFields = [];
        this.stopListening(this.model);
        this.off('editable:keydown', this.handleKeyDown, this);
        $(window).off('resize.' + this.cid);
        app.view.View.prototype._dispose.call(this);
    }
}) },
"dashlet-row-empty": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletRowEmptyView
 * @alias SUGAR.App.view.views.BaseDashletRowEmptyView
 * @extends View.View
 */
({
	// Dashlet-row-empty View (base) 

    events: {
        'click .add-dashlet' : 'layoutClicked',
        'click .add-row.empty' : 'addClicked'
    },
    originalTemplate: null,
    columnOptions: [],
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        this.model = this.layout.context.get("model");

        this.model.on("setMode", this.setMode, this);
        this.originalTemplate = this.template;
        this.setMode(this.model.mode);
        this.columnOptions = [];

        var parentLayoutWidth = 12,
            parentLayout = this;
        while (parentLayout) {
            if (parentLayout.type === 'dashlet-row') {
                parentLayoutWidth = parentLayout.meta.width;
            }
            parentLayout = parentLayout.layout;
        }
        var allowColumnSize = _.max([
            1, //should be at least one
            Math.floor(parentLayoutWidth / this.model.minColumnSpanSize)
        ]);
        _.times(allowColumnSize, function(index) {
            var n = index + 1;
            this.columnOptions.push({
                index: n,
                label: (n > 1) ?
                    app.lang.get('LBL_DASHBOARD_ADD_' + n + '_COLUMNS', this.module) :
                    app.lang.get('LBL_DASHBOARD_ADD_' + n + '_COLUMN', this.module)
            });
        }, this);
    },
    addClicked: function(evt) {
        var self = this;
        this._addRowTimer = setTimeout(function() {
            self.addRow(1);
        }, 100);
    },
    layoutClicked: function(evt) {
        var columns = $(evt.currentTarget).data('value');
        var addRow = _.bind(this.addRow, this);
        _.delay(addRow, 0, columns);
    },
    addRow: function(columns) {
        this.layout.addRow(columns);
        if(this._addRowTimer) {
            clearTimeout(this._addRowTimer);
        }
    },
    setMode: function(model) {
        if(model === 'edit') {
            this.template = this.originalTemplate;
        } else {
            this.template = app.template.empty;
        }
        this.render();
    },
    _dispose: function() {
        this.model.off("setMode", null, this);
        app.view.View.prototype._dispose.call(this);
    }
}) },
"list-map": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Assign Record action configuration view
 *
 * @class View.Views.Base.BaseListMapView
 * @alias SUGAR.App.view.views.BaseListMapView
 * @extends View.View
 */
({
	// List-map View (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this._initProperties(options);
    },

    /**
     * Property initialization, nothing to do for this view
     *
     * @param {Object} options
     */
    _initProperties: function(options) {
        this._mapController = null;
        this._locations = [];
        this._mapOptions = {};
        this._showCloseButton = true;
        this._showExpandButton = true;
        this._showMapToPdfButton = true;
        this._showMapShareButton = true;
        this._showDirections = app.controller.context.showDirections;
        this._isDashlet = false;
    },

    /**
     * Create the map
     *
     * @param {Data.Bean[]} records
     * @param {Object} options
     */
    createMap: function(records, options = {}) {
        this.onMapExpanded(false);

        var fieldContainer = this.$('div[data-container="main-map-container"]');
        fieldContainer.show();

        this._mapOptions = options;

        if (this._mapOptions.directions) {
            this._fetchRecordsForDirections(records);
        } else {
            this._fetchTargetRecords(this.module, records, [], {});
        }
    },

    /**
     * Fetch either by mapping field or related record
     *
     * @param {string} module
     * @param {Array} records
     * @param {Array} additionalRecords
     * @param {Object} additionalMappings
     */
    _fetchTargetRecords: function(module, records, additionalRecords, additionalMappings) {
        const mapModuleData = app.config.maps.modulesData[module];
        const selectedRecordsCount = _.keys(records).length;
        const recordsId = _.pluck(records, 'id').concat(additionalRecords);
        const firstRecord = _.first(records);
        const targetModule = firstRecord ? firstRecord.get('_module') : module;
        const targetModuleData = app.config.maps.modulesData[targetModule];

        if (mapModuleData && mapModuleData.mappingType === 'relateRecord') {
            this._fetchRelatedRecordsLocationData(
                mapModuleData.mappingRecord,
                selectedRecordsCount,
                additionalRecords,
                additionalMappings,
                recordsId
            );
        } else if (targetModuleData && targetModuleData.mappingType === 'relateRecord') {
            this._fetchRelatedRecordsLocationData(
                targetModuleData.mappingRecord,
                selectedRecordsCount,
                additionalRecords,
                additionalMappings,
                recordsId
            );
        } else {
            const mapType = this._mapOptions.directions ? '_buildMapWithDirections' : '_buildMap';

            this._fetchRecordsLocationData(_.bind(this[mapType], this, {}, selectedRecordsCount), recordsId);
        }
    },

    /**
     * Fetch starting point and target records
     *
     * @param {Array} records
     */
    _fetchRecordsForDirections: function(records) {
        const startPoint = this._mapOptions.directions.startPoint;
        const startPointModule = startPoint.module;
        const startPointId = startPoint.id;

        const mapModuleData = app.config.maps.modulesData[startPointModule];

        if (mapModuleData && mapModuleData.mappingType === 'relateRecord' && !_.isEmpty(mapModuleData.mappingRecord)) {
            const mappingRecordKey = _.chain(mapModuleData.mappingRecord)
                                        .keys()
                                        .first()
                                        .value();

            const startPointModel = app.data.createBean(startPointModule, {id: startPointId});

            startPointModel.fetch({
                fields: [mappingRecordKey, 'name'],
                success: _.bind(function mapsModelFetched(fetchedModel) {
                    let mappings = {};
                    let recordsIds = [];

                    let recordId = fetchedModel.get(mappingRecordKey);
                    const modelId = fetchedModel.get('id');

                    if (_.isEmpty(recordId.records)) {
                        app.alert.show('maps-invalid-starting-point', {
                            level: 'warning',
                            messages: 'LBL_MAPS_MISSING_GEOCODING_START_POINT',
                        });
                        this._fetchTargetRecords(this.module, records, [], []);
                        return;
                    }

                    recordId = _.first(recordId.records).id;

                    mappings[modelId] = {
                        recordId: recordId,
                        table: {
                            'parent_name': fetchedModel.get('name')
                        }
                    };

                    recordsIds.push(recordId);

                    this._mapOptions.directions.startPoint = {
                        id: recordId,
                        module: fetchedModel._module
                    };

                    this._fetchTargetRecords(this.module, records, recordsIds, mappings);
                }, this),
                error: function() {
                    this._fetchTargetRecords(this.module, records, [], {});
                },
            });
        } else {
            this._fetchTargetRecords(this.module, records, [startPointId], {});
        }
    },

    /**
     * Get related records location
     *
     * @param {Object} mappingRecord
     * @param {number} selectedRecordsCount
     * @param {Array} additionalRecords
     * @param {Object} additionalMappings
     * @param {Array} recordsIds
     */
    _fetchRelatedRecordsLocationData: function(
        mappingRecord,
        selectedRecordsCount,
        additionalRecords,
        additionalMappings,
        recordsIds
    ) {
        if (_.isEmpty(mappingRecord)) {
            const mapType = this._mapOptions.directions ? '_buildMapWithDirections' : '_buildMap';
            this._fetchRecordsLocationData(_.bind(this[mapType], this, {}, selectedRecordsCount), []);
            return;
        }

        const context = app.controller.context;
        const massCollection = context.get('mass_collection');
        const targetCollection = massCollection ? massCollection : this.collection;
        const mapsCollection = targetCollection.clone();
        let modelsIds = _.pluck(mapsCollection.models, 'id');

        if (recordsIds) {
            modelsIds = recordsIds;
        }

        mapsCollection.filterDef = [{'id': {'$in': modelsIds}}];

        const mappingRecordKey = _.chain(mappingRecord)
                                    .keys()
                                    .first()
                                    .value();

        // certain target collections have custom module, clone will not pass that along
        if (!mapsCollection.module && !_.isEmpty(this.collection.models)) {
            mapsCollection.module = this.collection.models[0].module;
        }

        mapsCollection.fetch({
            limit: targetCollection.length,
            fields: [mappingRecordKey, 'name'],
            success: _.bind(function mapsCollectionFetched(updatedCollection) {
                let mappings = additionalMappings;
                let recordsIds = additionalRecords;

                _.each(updatedCollection.models, function getRelatedKey(model) {
                    const modelId = model.get('id');
                    let recordId = model.get(mappingRecordKey);

                    if (recordId) {
                        if (_.isEmpty(recordId.records)) {
                            return;
                        }

                        recordId = _.first(recordId.records).id;
                    } else {
                        recordId = modelId;
                    }


                    mappings[modelId] = {
                        recordId: recordId,
                        table: {
                            'parent_name': model.get('name')
                        }
                    };

                    recordsIds.push(recordId);
                });

                const mapType = this._mapOptions.directions ? '_buildMapWithDirections' : '_buildMap';
                this._fetchRecordsLocationData(_.bind(this[mapType], this, mappings, selectedRecordsCount), recordsIds);
            }, this),
            error: _.bind(function mapsCollectionFetched() {
                const mapType = this._mapOptions.directions ? '_buildMapWithDirections' : '_buildMap';
                this._fetchRecordsLocationData(_.bind(this[mapType], this, {}, selectedRecordsCount), []);
            }, this),
        });
    },

    /**
     * Get current records location
     *
     * @param {Function} successCallback
     * @param {Array} recordsIds
     */
    _fetchRecordsLocationData: function(successCallback, recordsIds) {
        const geocodeCollection = app.data.createBeanCollection('Geocode');

        if (_.isEmpty(recordsIds)) {
            successCallback(geocodeCollection);
            return;
        }

        geocodeCollection.filterDef = [
            {
                'parent_id': {
                    '$in': recordsIds
                }
            },
            {
                'geocoded': 1
            },
            {
                'deleted': 0
            }
        ];

        geocodeCollection.fetch({
            limit: recordsIds.length,
            success: successCallback
        });
    },

    /**
     * Create the field map
     *
     * @param {Object} mappings
     * @param {number} selectedRecordsCount
     * @param {Data.BeanCollection[]} collection
     */
    _createFieldMap: function(mappings, selectedRecordsCount, collection) {
        this._disposeMap();

        var fieldContainer = this.$('div[data-container="main-map-container"]');

        this._locations = {};

        _.each(collection.models, function createLocations(model) {
            let locationData = model.toJSON();

            const related = _.filter(mappings, function getRelatedRecords(mapping, relatedId) {
                mapping.relatedId = relatedId;
                return mapping.recordId === model.get('parent_id');
            });

            if (_.isEmpty(related)) {
                const modelId = model.get('id');

                this._locations[modelId] = locationData;
                return;
            }

            // if we have multiple locations in the exact same spot we spread them in a circle
            let counter = 1;
            let stepDegrees = 20;
            let radius = 0.0002;

            _.each(related, function goThroughRelated(data) {
                let relatedLocationData = app.utils.deepCopy(locationData);

                _.each(data.table, function mapValues(fieldValue, fieldName) {
                    relatedLocationData[fieldName] = fieldValue;
                });

                relatedLocationData.latitude = locationData.latitude + radius * Math.cos(counter * stepDegrees);
                relatedLocationData.longitude = locationData.longitude + radius * Math.sin(counter * stepDegrees);

                counter++;

                this._locations[data.relatedId] = relatedLocationData;
            }, this);
        }, this);

        if (_.keys(this._locations).length === 0 && !this._isDashlet) {
            app.alert.show('maps-invalid-records', {
                level: 'info',
                messages: 'LBL_MAPS_MISSING_GEOCODING_RECORD',
            });
        } else if (selectedRecordsCount > this._locations.length && !this._isDashlet) {
            app.alert.show('maps-invalid-records', {
                level: 'info',
                messages: 'LBL_MAPS_MISSING_GEOCODING_RECORDS',
            });
        }

        // we simply create the formula builder field
        this._mapController = app.view.createField({
            def: {
                type: 'bing-map',
                name: 'BingMap'
            },
            view: this,
            viewName: 'main-map-container',
            showCloseButton: this._showCloseButton,
            showExpandButton: this._showExpandButton,
            showMapToPdfButton: this._showMapToPdfButton,
            showMapShareButton: this._showMapShareButton,
        });

        this._mapController.render();
        this._mapController.createMap();

        this.$('[data-widget=list-map-loading]').hide();

        fieldContainer.append(this._mapController.$el);

        if (this.name === 'list-map') {
            this.$('.map-loading-screen-overlay').height(this.$el.height());
        }

        this.listenTo(this._mapController, 'map:close', this.onMapClose, this);
        this.listenTo(this._mapController, 'map:expand', this.onMapExpanded, this);
        this.listenTo(this._mapController, 'map:save:pdf', this.onMapSavePdf, this);
        this.listenTo(this._mapController, 'map:share:email', this.onMapEmailed, this);
    },

    /**
     * Create the map and show directions
     *
     * @param {Object} mappings
     * @param {number} selectedRecordsCount
     * @param {Data.BeanCollection[]} collection
     */
    _buildMapWithDirections: function(mappings, selectedRecordsCount, collection) {
        this._createFieldMap(mappings, selectedRecordsCount, collection);

        this.listenTo(this._mapController, 'map:directions:load:complete', this.onMapDirectionsReady, this);
    },

    /**
     * Create the map
     *
     * @param {Object} mappings
     * @param {number} selectedRecordsCount
     * @param {Data.BeanCollection[]} collection
     */
    _buildMap: function(mappings, selectedRecordsCount, collection) {
        this._createFieldMap(mappings, selectedRecordsCount, collection);

        this.listenTo(this._mapController, 'map:load:complete', this.onMapReady, this);
    },

    /**
     * Change list view height depending on map height
     *
     * @param {bool} fullscreen
     */
    adjustListViewHeight: function(fullscreen) {
        if (!this.layout) {
            return;
        }

        const listView = this.layout.getComponent('filterpanel');

        if (!listView) {
            return;
        }

        if (fullscreen) {
            listView.$el.height('100%');
        } else {
            const parentHeight = listView.$el.parent().height();
            const mapHeight = this.$el.height();
            const diff = parentHeight - mapHeight;
            const correctHeight = diff * 100 / parentHeight + '%';

            // list view height + map height must always be 100%
            listView.$el.height(correctHeight);
            this.$('.map-loading-screen-overlay').height(mapHeight);
        }
    },

    /**
     * Hide map view
     */
    onMapClose: function() {
        const fieldContainer = this.$('div[data-container="main-map-container"]');
        fieldContainer.hide();

        const mapContainer = this.$('.map-holder-list-view').parent();
        mapContainer.removeClass('map-holder-list-view-big').removeClass('map-holder-list-view-small');

        this.adjustListViewHeight(true);
    },

    /**
     * Expand/Collapse map view
     */
    onMapExpanded: function(expand) {
        const classToBeRemoved = expand ? 'map-holder-list-view-small' : 'map-holder-list-view-big';
        const classToBeAdded = expand ? 'map-holder-list-view-big' : 'map-holder-list-view-small';

        const fieldContainer = this.$('.map-holder-list-view').parent();
        fieldContainer.removeClass(classToBeRemoved).addClass(classToBeAdded);

        this.adjustListViewHeight();
    },

    /**
     * Save Map as PDF
     */
    onMapSavePdf: function() {
        if (_.size(this._locations) === 0) {
            app.alert.show('maps-invalid-starting-point', {
                level: 'warning',
                messages: 'LBL_MAPS_ONE_GEOCDED_RECORD_NEEDED',
            });

            return;
        }

        let locations = this._locations;

        const map = this._mapController._map;

        const fromDirections = _.has(this._mapOptions, 'directions');
        const mapType = map.getMapTypeId();
        const mapZoom = map.getZoom();
        const mapBounds = map.getBounds();
        const mapCenter = map.getCenter();
        const mapExpanded = this._isMapExpanded();
        const provider = 'bing';
        const mapMeta = {
            mapType,
            mapZoom,
            mapBounds,
            fromDirections,
            mapExpanded,
            mapCenter,
        };

        if (fromDirections) {
            const startPoint = _.findWhere(this._locations, {
                'parent_id': this._mapOptions.directions.startPoint.id
            });

            if (!startPoint) {
                app.alert.show('maps-invalid-starting-point', {
                    level: 'warning',
                    messages: 'LBL_MAPS_MISSING_GEOCODING_START_POINT',
                });

                return;
            }

            //put the starting point first
            locations = _.chain(locations)
                        .without(startPoint)
                        .unshift(startPoint)
                        .value();

            const itineraryKey = '_itinerary';

            mapMeta.itinerary = this._mapController[itineraryKey];
        }

        if (_.isEmpty(mapMeta.itinerary) && fromDirections) {
            app.alert.show('maps-invalid-itinerary', {
                level: 'warning',
                messages: 'LBL_MAPS_NO_VALID_ITINERARY',
            });

            return;
        }

        const recordsMeta = _.values(locations);

        app.alert.show('maps-generating', {
            level: 'info',
            messages: 'LBL_MAPS_GENERATING',
        });

        const generateMapPath = 'maps/generateMap';
        const requestType = 'create';

        const calbacks = {
            success: _.bind(function(document) {
                const currentTime = new Date().toJSON();
                const name = `Map-${currentTime}.pdf`;

                this.downloadFileLocally(name, document);

                app.alert.dismiss('maps-generating');
            }, this),
            error: _.bind(function() {
                app.alert.dismiss('maps-generating');
            }, this),
        };

        const requestMeta = {
            mapMeta,
            recordsMeta,
            provider
        };
        const apiUrl = app.api.buildURL(generateMapPath, requestType, requestMeta, {});

        app.api.call(requestType, apiUrl, requestMeta, null, calbacks);
    },

    /**
     * Share Map on email
     */
    onMapEmailed: function() {
        if (_.size(this._locations) === 0) {
            app.alert.show('maps-invalid-starting-point', {
                level: 'warning',
                messages: 'LBL_MAPS_ONE_GEOCDED_RECORD_NEEDED',
            });

            return;
        }

        if (_.size(this._locations) > 10) {
            app.alert.show('maps-max-points-exceeded', {
                level: 'warning',
                messages: 'LBL_MAPS_MAX_GEOCDED_RECORD_EXCEDED',
            });

            return;
        }

        const completeMapUrl = this._buildShareMapURL(this._locations, this._mapOptions.directions);
        const pointNameKey = 'parent_name';

        let mapPoints = [];

        _.each(this._locations, function getShareURL(locationData) {
            const locationMapUrl = this._buildShareMapURL([locationData]);

            mapPoints.push({
                url: locationMapUrl,
                name: locationData[pointNameKey],
            });

        }, this);

        const emailBody = app.template.getView('list-map', 'share')({
            completeMapUrl,
            mapPoints
        });

        this._sendMapByEmail(emailBody);
    },

    /**
     * Opens a drawer containing Bing Maps Data
     *
     * @param {Array} body
     */
    _sendMapByEmail: function(body) {
        const emailModel = app.data.createBean('Emails');

        emailModel.set({
            name: app.lang.get('LBL_MAPS_MAP_ON_BING_WEB'),
            description_html: body,
        });

        app.drawer.open({
            layout: 'compose-email',
            context: {
                create: 'true',
                module: 'Emails',
                model: emailModel,
            },
        });
    },

    /**
     * Generate bing map url
     *
     * @param {Array} mapLocations
     * @param {Object} directions
     *
     * @return string
     */
    _buildShareMapURL: function(mapLocations, directions) {
        const baseURL = 'https://www.bing.com/maps?';
        const delimiter = '~';
        const coordsDelimiter = '_';
        const pointNameKey = 'parent_name';
        const parentIdKey = 'parent_id';

        const map = this._mapController._map;
        const center = map.getCenter();
        const zoom = map.getZoom();
        const style = map.getMapTypeId();

        const centerPoint = 'cp=' + center.latitude + delimiter + center.longitude;
        const zoomLvl = '&lvl=' + zoom;
        const mapStyle = '&style=' + style;
        const locType = directions ? '&rtp=' : '&sp=';
        const pointType = directions ? 'pos.' : 'point.';

        let locations = '';
        let startPointId = '';

        if (directions) {
            startPointId = directions.startPoint.id;

            const pointData = _.findWhere(mapLocations, {
                parent_id: startPointId,
            });

            if (pointData) {
                const point = pointData.latitude + coordsDelimiter + pointData.longitude;

                locations = pointType + point + coordsDelimiter + pointData[pointNameKey];
            }
        }

        _.each(mapLocations, function getLocationData(locData) {
            if (locData[parentIdKey] === startPointId) {
                return;
            }

            const prefix = _.isEmpty(locations) ? '' : delimiter;
            const coords = locData.latitude + coordsDelimiter + locData.longitude;

            locations += prefix + pointType + coords + coordsDelimiter + locData[pointNameKey];
        }, this);

        const shareMapURL = baseURL + centerPoint + zoomLvl + mapStyle + locType + encodeURIComponent(locations);

        return shareMapURL;
    },

    /**
     * Check if the map is expanded
     *
     * @return bool
     */
    _isMapExpanded: function() {
        //from subpanel it's always expanded
        if (this.layout.name === 'subpanel-map') {
            return true;
        }

        if (_.has(this._mapController, '_expanded')) {
            return this._mapController._expanded;
        }

        return false;
    },

    /**
     * Downloads a file on the file system
     *
     * @param {string} filename
     * @param {string} content
     */
    downloadFileLocally: function(filename, content) {
        const dataURIToBlob = function(dataURI) {
            let binStr = atob(dataURI);
            let len = binStr.length;
            let arr = new Uint8Array(len);

            for (let i = 0; i < len; i++) {
                arr[i] = binStr.charCodeAt(i);
            }

            return new Blob([arr], {
                type: 'application/octet-stream'
            });
        };

        const blob = dataURIToBlob(content);
        const url = URL.createObjectURL(blob);

        let element = document.createElement('a');
        element.setAttribute('href', url);
        element.setAttribute('download', filename);

        element.style.display = 'none';
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
    },

    /**
     * Called when Map is loaded
     */
    onMapReady: function() {
        this._createLocation();
        this._mapController.centerMap();
    },

    /**
     * Called when Directions Map is loaded
     */
    onMapDirectionsReady: function() {
        this._mapController.clearMap();
        this._mapController.createLocations(this._locations);
        this._mapController.centerMap();

        const startPoint = _.findWhere(this._locations, {
            'parent_id': this._mapOptions.directions.startPoint.id
        });

        if (!startPoint) {
            app.alert.show('maps-invalid-starting-point', {
                level: 'warning',
                messages: 'LBL_MAPS_MISSING_GEOCODING_START_POINT',
            });

            this._mapController.clearMap();
            this._mapController.centerMap();

            return;
        }

        const locations = _.chain(this._locations)
                            .without(startPoint)
                            .map(function getAddress(location) {
                                return {
                                    address: location.parent_name,
                                    coords: {
                                        latitude: location.latitude,
                                        longitude: location.longitude
                                    }
                                };
                            }).value();

        this._mapController.showDirections(
            locations,
            {
                address: startPoint.parent_name,
                coords: {
                    latitude: startPoint.latitude,
                    longitude: startPoint.longitude
                }
            }
        );
    },

    /**
     * Create map location
     */
    _createLocation: function() {
        this._mapController.clearMap();
        this._mapController.createLocations(this._locations);
        this._mapController.createPushPins();
        this._mapController.drawPushPins();
    },

    /**
     * Dispose map element
     */
    _disposeMap: function() {
        if (this._mapController) {
            this._mapController.dispose();
            this._mapController = null;
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this._disposeMap();
        this._super('_dispose');
    },
}) },
"quicksearch-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.QuicksearchButtonView
 * @alias SUGAR.App.view.fields.BaseQuicksearchButtonView
 * @extends View.View
 */
({
	// Quicksearch-button View (base) 

    className: 'quicksearch-button-wrapper',

    events: {
        'click [data-action=search_icon]' : 'searchIconClickHandler'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        // Listener for `quicksearch:close`.
        this.layout.on('quicksearch:close', function() {
            if (!this.context.get('search')) {
                this.toggleSearchIcon(true);
            }
        }, this);

        /**
         * Used for keyboard up/down arrow navigation between components of `globalsearch` layout
         *
         * @property {boolean}
         */
        this.isFocusable = false;

        /**
         * Used for indicating the state of the button icon.
         *
         * @property {boolean}
         * - `true` means magnifying glass.
         * - `false` means X icon.
         */
        this.searchButtonIcon = true;

        this.layout.on('quicksearch:button:toggle', this.toggleSearchIcon, this);
    },


    /**
     * Toggles the search icon between the magnifying glass and x.
     *
     * @param {boolean} searchButtonIcon Indicates the state of the search button icon
     * - `true` means magnifying glass.
     * - `false` means X icon.
     */
    toggleSearchIcon: function(searchButtonIcon) {
        if (this.searchButtonIcon === searchButtonIcon) {
            return;
        }
        var iconEl = this.$('[data-action=search_icon] .sicon').first();
        this.searchButtonIcon = searchButtonIcon;
        if (searchButtonIcon) {
            iconEl.removeClass('sicon-close');
            iconEl.addClass('sicon-search');
        } else {
            iconEl.removeClass('sicon-search');
            iconEl.addClass('sicon-close');
        }
    },

    /**
     * Handler for clicks on the search icon (or x, depending on state).
     */
    searchIconClickHandler: function() {
        if (this.searchButtonIcon) {
            if (this.layout.isResponsiveMode) {
                this.layout.trigger('quicksearch:expand');
            } else {
                this.layout.trigger('quicksearch:bar:search');
            }
        } else {
            this.layout.trigger('quicksearch:bar:clear');
            this.layout.trigger('quicksearch:close');
        }
    }
}) },
"footer-actions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.FooterActionsView
 * @alias SUGAR.App.view.views.BaseFooterActionsView
 * @extends View.View
 */
({
	// Footer-actions View (base) 

    events: {
        'click [data-action=shortcuts]': 'shortcuts',
        'click [data-action=feedback]': 'feedback',
        'click [data-action=help]': 'help'
    },
    tagName: 'span',
    layoutName: '',

    /**
     * Flag to indicate if the footer is currently watching for the help status.
     *
     * @property {boolean}
     */
    watchingForHelp: false,

    /**
     * Array of layout names where the help button should be disabled
     */
    helpBtnDisabledLayouts: [
        'about',
        'first-login-wizard'
    ],

    /**
     * Enable or disable buttons on the footer depending on view.
     * @param {string|Object} layout The type of the layout we are changing to.
     * @param {Object} params Additional parameters.
     */
    handleViewChange: function(layout, params) {
        this.module = params && params.module ? params.module : app.controller.context.get('module');
        // should we disable the help button or not, this only happens when layout is 'bwc'
        this.layoutName = _.isObject(layout) ? layout.name : layout;
        this.toggleHelpButton(this._shouldHelpBeActive(params.drawer));
        this.disableHelpButton(true);
    },

    handleRouteChange: function(route, params) {
        this.routeParams = {'route': route, 'params': params};
    },

    /**
     * Enable the (now non-existent) tour button.
     *
     * @deprecated 7.9 Will be removed in 7.11.
     *   Please use `HelpletView.toggleTourLink` instead.
     */
    enableTourButton: function() {
        app.logger.warn('The function `View.Views.Base.FooterActionsView.enableTourButton`' +
            ' is deprecated in 7.9.0.0 and will be removed in 7.11.0.0. ' +
            'Please use `View.Views.Base.HelpletView.toggleTourLink` instead.');
        this.$('[data-action=tour]').removeClass('disabled');
        this.events['click [data-action=tour]'] = 'showTutorialClick';
        this.undelegateEvents();
        this.delegateEvents();
    },

    /**
     * Disable the (now non-existent) tour button.
     *
     * @deprecated 7.9 Will be removed in 7.11.
     *   Please use `HelpletView.toggleTourLink` instead.
     */
    disableTourButton: function() {
        app.logger.warn('The function `View.Views.Base.FooterActionsView.disableTourButton`' +
            ' is deprecated in 7.9.0.0 and will be removed in 7.11.0.0. ' +
            'Please use `View.Views.Base.HelpletView.toggleTourLink` instead.');
        this.$('[data-action=tour]').addClass('disabled');
        delete this.events['click [data-action=tour]'];
        this.undelegateEvents();
        this.delegateEvents();
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        app.events.on('app:view:change', this.handleViewChange, this);
        var self = this;
        app.utils.doWhen(function() {
            return !_.isUndefined(app.router);
        }, function() {
            self.listenTo(app.router, 'route', self.handleRouteChange);
        });

        app.events.on('app:help', function() {
            this.help();
        }, this);

        app.events.on('app:help:shown', function() {
            this.toggleHelpButton(true);
            this.disableHelpButton(false);
        }, this);

        app.events.on('app:help:hidden', function() {
            this.toggleHelpButton(false);
            this.disableHelpButton(true);
        }, this);

        app.events.on('alert:cancel:clicked', function() {
            // re-check if help should be disabled or not and set accordingly
            this.disableHelpButton(this.shouldHelpBeDisabled());
        }, this);

        // Create a doWhen to update the help button in the footer.
        this._watchForHelpActive();

        app.shortcuts.registerGlobal({
            id: 'Shortcut:Help',
            keys: '?',
            component: this,
            description: 'LBL_SHORTCUT_HELP',
            handler: this.shortcuts
        });

        app.user.lastState.preserve(app.user.lastState.key('toggle-show-tutorial', this));

        this.before('render', function() {
            if (this._feedbackView) {
                this._feedbackView.dispose();
            }

            if (this._helpLayout) {
                this._helpLayout.dispose();
            }
        }, this);
    },

    /**
     * Watch the app state for when the help button needs to be active.
     * @private
     */
    _watchForHelpActive: function() {
        if (this.watchingForHelp) {
            return;
        }
        this.watchingForHelp = true;

        app.utils.doWhen(this.helpActiveCheck, _.bind(function() {
            // If the layout check passes, enable the help button
            this.watchingForHelp = false;
            this.disableHelpButton(false);
        }, this));
    },

    /**
     * Check to see if the help button should be active based on the current layout.
     *
     * @return {boolean} Returns true if the app state should always highlight
     *  the help button.
     */
    helpActiveCheck: function() {
        if (app.drawer && !app.drawer.isActive(this.$el)) {
            return false;
        }

        return true;
    },

    /**
     * Checks any criteria to see if help button should be disabled
     * @return {boolean}
     */
    shouldHelpBeDisabled: function() {
        return (_.indexOf(this.helpBtnDisabledLayouts, this.layoutName) !== -1);
    },

    /**
     * Checks if the help button should be set active.
     *
     * @param {boolean} drawer `true` should be passed when this method is called when
     * a drawer is closing or opening.
     * @return {boolean}
     * @private
     */
    _shouldHelpBeActive: function(drawer) {
        return drawer ? this.helpButton && this.helpButton.hasClass('active') : false;
    },

    _renderHtml: function() {
        this.isAuthenticated = app.api.isAuthenticated();
        this.isShortcutsEnabled = (this.isAuthenticated && app.shortcuts.isEnabled());
        this._super('_renderHtml');
        this.helpButton = this.$('[data-action=help]');
    },

    /**
     * Toggles feedback popup on click (open or close).
     * TODO move this to a feedback field
     *
     * This currently sets and uses the internal `_feedbackIsOpen` flag to
     * create and dispose the {@link FeedbackView}.
     * FIXME this shouldn't work that way and should trigger an event that the
     * additionalComponent (the feedback layout) is listening to and the toggle
     * will simply trigger the event for the layout to show and hide.
     * This will improve performance (no more layout being disposed and created
     * on click).
     *
     * If the app isn't yet in sync (all metadata loaded to create the view)
     * the button doesn't do anything.
     *
     * @param {Event} evt the `click` event.
     * @deprecated Feedback is no longer supported
     */
    feedback: function(evt) {
        app.logger.warn('Feedback functionality has been deprecated and will be removed in a future release');
        if (!app.isSynced) {
            return;
        }

        if (!this._feedbackView || this._feedbackView.disposed) {
            this._feedbackView = app.view.createView({
                module: 'Feedbacks',
                type: 'feedback',
                button: this.$('[data-action="feedback"]')
            });

            this.listenTo(this._feedbackView, 'show hide', function(view, active) {
                this.$('[data-action="feedback"]').toggleClass('active', active);
            });
        }
        this._feedbackView.toggle();
    },

    /**
     * Open the SugarCRM support website in another tab.
     *
     * @deprecated 7.9. Will be removed in 7.11.
     */
    support: function() {
        app.logger.warn('The function `View.Views.Base.FooterActionsView.support`' +
            ' is deprecated in 7.9.0.0 and will be removed in 7.11.0.0.');
        window.open('https://support.sugarcrm.com', '_blank');
    },

    /**
     * Help button click event listener.
     */
    help: function() {
        if (!app.isSynced) {
            return;
        }

        if (this.helpButton.hasClass('disabled')) {
            return;
        }

        // For bwc modules and the About page, handle the help click differently.
        if (this.layoutName === 'bwc' || this.layoutName === 'about') {
            this.bwcHelpClicked();
            return;
        }

        if (!this._helpLayout || this._helpLayout.disposed) {
            this._createHelpLayout();
        }

        this._helpLayout.toggle();
    },

    /**
     * Creates the help layout.
     *
     * @param {jQuery} button The Help button.
     * @private
     */
    _createHelpLayout: function() {
        this._helpLayout = app.view.createLayout({
            module: app.controller.context.get('module'),
            type: 'help',
            button: this.helpButton
        });

        this._helpLayout.initComponents();

        this.listenTo(this._helpLayout, 'show hide', function(view, active) {
            this.helpButton.toggleClass('active', active);
        });
    },

    /**
     * Disable the help button
     *
     * @param {boolean} [disable=true]      Should we disable it or enable it, if not passed will default to true
     */
    disableHelpButton: function(disable) {
        disable = _.isUndefined(disable) ? true : disable;
        if (this.helpButton) {
            this.helpButton.toggleClass('disabled', disable);
        }

        if (disable) {
            this._watchForHelpActive();
        }

        return disable;
    },

    /**
     * Utility Method to toggle the help button on and off.
     *
     * @param {Boolean} active      Set or remove the active state of the button
     * @param {Object} (button)     Button Object (optional), will be found if not passed in
     */
    toggleHelpButton: function(active, button) {
        if (_.isUndefined(button)) {
            button = this.helpButton;
        }

        if (button) {
            button
                .toggleClass('active', active)
                .attr('aria-pressed', active);
        }
    },

    /**
     * Open shortcut help.
     * @param event
     */
    shortcuts: function(event) {
        var activeDrawerLayout = app.drawer.getActive(),
            $shortcutButton = this.$('[data-action=shortcuts]');

        if (!activeDrawerLayout || activeDrawerLayout.type !== 'shortcuts') {
            $shortcutButton.addClass('active');
            app.drawer.open({
                layout: 'shortcuts'
            }, function() {
                $shortcutButton.removeClass('active');
            });
        } else {
            app.drawer.close();
        }
    },

    /**
     * Click event for the (now non-existent) show tour icon.
     *
     * @param {Object} e click event.
     * @deprecated 7.9. Will be removed in 7.11.
     *   Please use `HelpletView.showTour` instead.
     */
    showTutorialClick: function(e) {
        app.logger.warn('The function `View.Views.Base.FooterActionsView.showTutorialClick`' +
            ' is deprecated in 7.9.0.0 and will be removed in 7.11.0.0.');
        if (!app.tutorial.instance) {
            this.showTutorial();
            e.currentTarget.blur();
        }
    },

    /**
     * Show tour overlay.
     *
     * @param {Object} prefs preferences to preserve.
     * @deprecated 7.9. Will be removed in 7.11.
     */
    showTutorial: function(prefs) {
        app.logger.warn('The function `View.Views.Base.FooterActionsView.showTutorial`' +
            ' is deprecated in 7.9.0.0 and will be removed in 7.11.0.0. '  +
            'Please use `View.Views.Base.HelpletView.showTour` instead.');
        app.tutorial.resetPrefs(prefs);
        app.tutorial.show(app.controller.context.get('layout'), {module: app.controller.context.get('module')});
    },

    /**
     * Calls the old Help Docs if in BWC mode
     */
    bwcHelpClicked: function() {
        let serverInfo = app.metadata.getServerInfo();
        let lang = app.lang.getLanguage();
        let module = app.controller.context.get('module');
        let route = this.routeParams.route;

        let products = app.user.getProductCodes();
        let url = 'https://www.sugarcrm.com/crm/product_doc.php?edition=' + serverInfo.flavor +
                '&version=' + serverInfo.version + '&lang=' + lang + '&module=' + module + '&route=' + route +
                '&products=' + encodeURIComponent(products.join(','));

        if (route == 'bwc') {
            var action = window.location.hash.match(/#bwc.*action=(\w*)/i);
            if (action && !_.isUndefined(action[1])) {
                url += '&action=' + action[1];
            }
        }
        app.logger.info("help URL: " + url);
        window.open(url);
    }
}) },
"dupecheck-list-multiselect": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckListMultiselectView
 * @alias SUGAR.App.view.views.BaseDupecheckListMultiselectView
 * @extends View.Views.Base.DupecheckListView
 */
({
	// Dupecheck-list-multiselect View (base) 

    extendsFrom: 'DupecheckListView',
    additionalTableClasses: 'duplicates-multiselect',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, ['MassCollection']);
        this._super('initialize', [options]);
    }
}) },
"tabbed-dashboard": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.TabbedDashboardView
 * @alias SUGAR.App.view.views.BaseTabbedDashboardView
 * @extends View.View
 */
({
	// Tabbed-dashboard View (base) 

    className: 'tabbed-dashboard-pane bg-primary-content-background',

    events: {
        'click [data-toggle=tab]': 'tabClicked',
    },

    activeTab: 0,
    tabs: [],
    sticky: true,
    buttons: [],

    /**
     * Hash key for stickness.
     * @property {string}
     */
    lastStateKey: '',

    /**
     * Initialize this component.
     * @param {Object} options Initialization options.
     * @param {Object} options.meta Metadata.
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initTabs(options.meta);
        if (options.meta && !_.isUndefined(options.meta.sticky)) {
            this.sticky = options.meta.sticky;
        }
    },

    /**
     * Build the cache key for last visited tab.
     *
     * @return {string} hash key.
     */
    getLastStateKey: function() {
        if (!this.sticky) {
            return '';
        }

        if (this.lastStateKey) {
            return this.lastStateKey;
        }

        var modelId = this.model.get('id');
        this.lastStateKey = modelId ? modelId + '.' + 'last_tab' : '';
        return this.lastStateKey;
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.context.on('tabbed-dashboard:update', this._setTabs, this);
        this.model.on('setMode', this._setMode, this);
    },

    /**
     * Check if a tab is dashboard.
     *
     * @param {number} tabIndex The tab's index
     * @return {bool} True if tab is a dashboard, otherwise false
     * @private
     */
    _isDashboardTab: function(tabIndex) {
        if (_.isEmpty(this.tabs)) {
            return true;
        }
        tabIndex = _.isUndefined(tabIndex) ? this.activeTab : tabIndex;

        var isStandardDashboard = !!this.tabs[tabIndex].dashlets;
        var isConsoleDashboard = !!(this.tabs[tabIndex].components && this.tabs[tabIndex].components.rows);

        return isStandardDashboard || isConsoleDashboard;
    },

    /**
     * Switch the active dashboard based on the clicked tab.
     * @param {Event} event Click event.
     */
    tabClicked: function(event) {
        var index = this.$(event.currentTarget).data('index');
        if (index === this.activeTab) {
            return;
        }
        // can't edit a non-dashboard tab or open a disabled tab
        if (!this.canSwitchTab(index) ||
            (this.model.mode === 'edit' && !this._isDashboardTab(index)) ||
            !this.isTabEnabled(index)) {
            event.stopPropagation();
            return;
        }
        this.context.trigger('tabbed-dashboard:switch-tab', index);
    },

    /**
     * Determine if anything is blocking a graceful tab switch
     *
     * @return boolean true if nothing blocking, false otherwise
     */
    canSwitchTab: function(index) {
        var components = [];

        var sideDrawer = this._getSideDrawer();
        if (sideDrawer && sideDrawer.isOpen()) {
            components.push(sideDrawer);
        }

        var omniDashboard = this._getOmnichannelDashboard();
        if (omniDashboard) {
            components.push(omniDashboard);
        }

        var blocked = _.find(components, function(component) {
            var switchTab = _.bind(this.switchTab, this, index);

            // return the first component that blocks tab switching
            return component.triggerBefore('tabbed-dashboard:switch-tab', {callback: switchTab}) === false;
        }, this);

        return _.isUndefined(blocked);
    },

    /**
     * Change active tab.
     * @param {number} tabIndex
     */
    switchTab: function(tabIndex) {
        if ((this.model.mode === 'edit' && !this._isDashboardTab(tabIndex)) ||
            !this.isTabEnabled(tabIndex)) {
            return;
        }
        this.context.trigger('tabbed-dashboard:switch-tab', tabIndex);
    },

    /**
     * Enable/disable a tab.
     * @param {number} index The tab index
     * @param {boolean} mode True to enable, false to disbale
     */
    setTabMode: function(index, mode) {
        if (this.tabs && this.tabs[index]) {
            this.tabs[index].enabled = mode;
        }
        var $tab = this.$('a[data-index="' + index + '"]').closest('.tab');
        if ($tab) {
            mode ? $tab.removeClass('disabled') : $tab.addClass('disabled');
        }
    },

    /**
     * Check if tab is enabled.
     * @param {number} index The tab index
     * @return {boolean} True if enabled, otherwise false
     */
    isTabEnabled: function(index) {
        return !(this.tabs && this.tabs[index] && this.tabs[index].enabled === false);
    },

    /**
     * Handle button events.
     *
     * @param {string} state Button state
     * @private
     */
    _setMode: function(state) {
        if (_.isEmpty(this.tabs)) {
            return;
        }
        _.each(this.tabs, function(tab, index) {
            if (index !== this.activeTab && !this._isDashboardTab(index)) {
                var $tab = this.$('a[data-index="' + index + '"]').closest('.tab');
                if (state === 'edit') {
                    // disable non-dahsboard tabs
                    $tab.addClass('disabled');
                } else if (state === 'view') {
                    // enable non-dahsboard tabs
                    $tab.removeClass('disabled');
                }
            }
        }, this);
    },

    /**
     * Initialize tabs.
     * @param {Object} [options={}] Tab options.
     * @private
     */
    _initTabs: function(options) {
        options = options || {};
        var lastStateKey = this.getLastStateKey();
        var lastVisitTab = lastStateKey ? app.user.lastState.get(lastStateKey) : 0;

        if (!_.isUndefined(options.activeTab)) {
            this.activeTab = options.activeTab;
            if (lastStateKey) {
                app.user.lastState.set(lastStateKey, this.activeTab);
            }
        } else if (!_.isUndefined(lastVisitTab)) {
            this.activeTab = lastVisitTab;
        }

        if (!_.isUndefined(options.tabs)) {
            this.$el.addClass('mb-2');
            this.tabs = options.tabs;
            this.context.set('tabs', this.tabs);
            this.context.set('activeTab', this.activeTab);
            this._initTabBadges();
        }

        if (!_.isUndefined(options.buttons)) {
            this.buttons = options.buttons;
        }
    },

    /**
     * Initialize tab badges.
     * @private
     */
    _initTabBadges: function() {
        var modelId = this.context.get('modelId');
        var configMeta = app.metadata.getModule('ConsoleConfiguration');

        if (this.tabs && configMeta) {
            _.each(this.tabs, function(tab) {
                if (!_.isUndefined(tab.badges)) {
                    _.each(tab.badges, function(badge) {
                        if (badge.type === 'record-count' && badge.module === 'Cases') {
                            badge.filter = _.union(
                                [
                                    {follow_up_datetime: _.first(_.pluck(badge.filter, 'follow_up_datetime'))}
                                ],
                                configMeta.config.filter_def[modelId][badge.module]
                            );
                        }
                    });
                }
            });
        }
    },

    /**
     * Set tab options, then re-render.
     * @param {Object} [options] Tab options.
     * @private
     */
    _setTabs: function(options) {
        this._initTabs(options);
        this.render();
    },

    /**
     * Get the side drawer
     *
     * @return {Object} The side drawer
     * @private
     */
    _getSideDrawer: function() {
        var dashboard = this.closestComponent('dashboard');
        var dmComponent = dashboard.getComponent('dashlet-main');

        return dmComponent.getComponent('side-drawer');
    },

    /**
     * Get the omnichannel dashboard
     *
     * @return {Object} The omnichannel dashboard
     * @private
     */
    _getOmnichannelDashboard: function() {
        return this.closestComponent('omnichannel-dashboard');
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        if (this.model.mode === 'edit') {
            this._setMode('edit');
        }
    },

    /**
     * Fetch the model if the model exists
     *
     * If new metadata is fetched, this will trigger 'change:metadata'. That will
     * then trigger 'tabbed-dashboard:update' to set tabs and render
     */
    fetchModel: function() {
        if (this.model) {
            this.model.fetch();
        }
    }
}) },
"list-bottom": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ListBottomView
 * @alias SUGAR.App.view.views.BaseListBottomView
 * @extends View.View
 */
({
	// List-bottom View (base) 

    events: {
        'click [data-action="show-more"]': 'showMoreRecords'
    },

    /**
     * Flag for if the loading placeholder text should be hidden or not
     *
     * @property {boolean}
     */
    hideLoading: false,

    initialize: function(options) {
        this._super('initialize', [options]);
        // This component should always have a `list` action.
        this.action = 'list';

        /**
         * Label key used for {@link #showMoreLabel}.
         *
         * You can define it in metadata under `label` property. Defaults to
         * `TPL_SHOW_MORE_MODULE`.
         *
         * @type {string}
         * @private
         */
        this._showMoreLabel = this.meta && this.meta.label || 'TPL_SHOW_MORE_MODULE';
        this._initPagination();

        if (app.utils.isTruthy(options.usePaginationComponent)) {
            this.collection = this.paginationComponent.collection;
            this.moduleIsAvailable = true;
        }
        if (app.utils.isTruthy(options.hideFirstPaginationLoadingMessage)) {
            this.hideLoading = true;
        }
    },

    /**
     * Initialize pagination component in order to react the show more link.
     * @private
     */
    _initPagination: function() {
        this.paginationComponent = _.find(this.layout._components, function(component) {
            return _.contains(component.plugins, 'Pagination');
        }, this);
    },

    /**
     * Retrieving the next page records by pagination plugin.
     *
     * Please see the {@link app.plugins.Pagination#getNextPagination}
     * for detail.
     */
    showMoreRecords: function() {
        if (!this.paginationComponent) {
            return;
        }

        this.hideLoading = false;

        var options = {};
        options.success = _.bind(function() {
            this.layout.trigger('list:paginate:success');

            // Tell the side drawer that there are new records to look at
            if (app.sideDrawer) {
                app.sideDrawer.trigger('sidedrawer:collection:change', this.collection);
            }

            // FIXME: This should trigger on `this.collection` instead of
            // `this.context`. Will be fixed as part of SC-2605.
            this.context.trigger('paginate');
            this.render();
        }, this);
        // collection offset is not properly set before Pagination fetch.
        this.collection.offset = this.collection.length;
        this.paginationComponent.getNextPagination(options);
        this.render();
    },

    /**
     * Assign proper label for 'show more' link.
     * Label should be "More <module name>...".
     */
    setShowMoreLabel: function() {
        if (!this.collection) {
            return;
        }

        var model = this.collection.at(0);
        var module = model ? model.module : this.context.get('module');
        var context = {
            count: this.collection.length,
            offset: this.collection.next_offset >= 0
        };
        if (module) {
            context.module = new Handlebars.SafeString(app.lang.getModuleName(module, {plural: true}).toLowerCase());
        }

        /**
         * Label used in the template to display Show more message.
         *
         * By default it will display "More {module}...".
         *
         * @type {string}
         * @private
         */
        this.showMoreLabel = app.lang.get(this._showMoreLabel, module, context);
    },

    /**
     * Reset previous collection handlers and
     * bind the listeners for new collection.
     */
    onCollectionChange: function() {
        var prevCollection = this.context.previous('collection');
        if (prevCollection) {
            prevCollection.off(null, null, this);
        }
        this.collection = this.context.get('collection');
        if (this.collection) {
            this.collection.on('add remove reset', this.render, this);
        }
        this.render();
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this.setShowMoreLabel();

        this.moreClassToggle();
        this._super('_renderHtml');
    },

    /**
     * @inheritdoc
     *
     * Bind listeners for collection updates.
     * The pagination link synchronizes its visibility with the collection's
     * status.
     */
    bindDataChange: function() {
        this.context.on('change:collection', this.onCollectionChange, this);
        this.collection.on('add remove reset', this.render, this);
    },

    /**
    * Toggle CSS class to show if pagination button is available.
    */
    moreClassToggle: function() {
        if (!this.paginationComponent.layout) {
            return;
        }

        let layout = this.paginationComponent.layout.$el;

        layout.removeClass('more-active');
        let collectionDataFetched = _.has(this.collection, 'dataFetched') && this.collection.dataFetched;
        let isLastOffset = _.has(this.collection, 'next_offset') && this.collection.next_offset !== -1;
        if (collectionDataFetched && isLastOffset) {
            layout.addClass('more-active');
        }
    },

    /**
     * @inheritdoc
     *
     * Add dashlet placeholder's class in order to handle the custom css style.
     */
    show: function() {
        this._super('show');
        if (!this.paginationComponent) {
            return;
        }
        this.paginationComponent.layout.$el.addClass('pagination');
    },

    /**
     * @inheritdoc
     *
     * Remove pagination custom CSS class on dashlet placeholder.
     */
    hide: function() {
        this._super('hide');
        if (!this.paginationComponent) {
            return;
        }
        this.paginationComponent.layout.$el.removeClass('pagination');
    }
}) },
"external-app": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ExternalAppView
 * @alias SUGAR.App.view.views.BaseExternalAppView
 * @extends View.View
 */
({
	// External-app View (base) 

    mounted: false,
    rendered: false,
    className: 'external-app-interface',
    extraParcelParams: {},
    sugarAppStore: {
        listPreviewModel: undefined
    },

    /**
     * Initializing the SingleSpa, using systemJs getting hold of the needed information of the MFE.
     * singleSpa Bootstrap function is called during component initialize.
     * @inheritdoc
     */
    initialize: function(options) {
        singleSpa.start();

        // if coming from external-app-dashlet, this will be set to true or false
        // else it will be undefined. Either way, if undefined or true set to true, otherwise false.
        this.allowApp = _.isUndefined(this.allowApp) || this.allowApp;

        this.isTabbedLayout = options.layout.type === 'tabbed-layout';

        // set appId based on if this is in a tabbed-layout or not
        this.appId = this.isTabbedLayout ? options.layout.cid : this.cid;

        this._super('initialize', [options]);

        // Creating Listeners for various Sugar Events.
        this._sdkEventHandler();

        // pass any env options to be mounted with the external app
        if (this.meta && this.meta.env) {
            this.extraParcelParams = this.meta.env;
        }

        if (this.isTabbedLayout) {
            this.context.on(
                'sugarApp:' + this.appId + ':load:' + this.meta.srn,
                this._onSugarAppLoad,
                this
            );
        } else {
            this._onSugarAppLoad();
        }
    },

    /**
     * This Method is the Handler to SugarEvents that stores the event callback data to the sugarAppStore object so that
     * SDK wrapper can use it for SugarApps.
     * @private
     */
    _sdkEventHandler: function() {
        this.on('sugarApp:' + this.appId + ':store:get', function(callback) {
            callback(this.sugarAppStore);
        }, this);

        this.context.on('list:preview:fire', function(model) {
            this.sugarAppStore.listPreviewModel = model;

            // trigger to let store has changed
            this.trigger('sugarApp:' + this.appId + ':store:change', this.sugarAppStore);
        }, this);
    },

    /**
     * singleSpa Mount function is called during the initial render
     */
    render: function() {
        this.rendered = true;
        this._mountApp();
    },

    /**
     * Click handler that imports / loads the spa module that was clicked
     * @protected
     */
    _onSugarAppLoad: function() {
        var serverInfo = app.metadata.getServerInfo();

        // don't re-import already mounted parcel apps
        if (this.meta.src && !this.parcelLib) {
            var url = this.meta.src;
            if (this.meta.appendVersion && serverInfo.version) {
                url += (url.indexOf('?') ? '&' : '?') + 'sugar_version=' + serverInfo.version;
            }

            System.import(url).then(function(mod) {
                if (!mod) {
                    app.log.error('Unable to load external module from ' + url);
                }

                //Check if the export was under 'default' rather than at the top level of the module
                for (var i = 0; i < 3; i++) {
                    var props = Object.getOwnPropertyNames(mod).filter(function(name) {
                        return name.substr(0, 2) !== '__';
                    });

                    if (mod.default && (props.length === 1 || mod.__useDefault)) {
                        mod = mod.default;
                    } else {
                        break;
                    }
                }

                if (this.allowApp) {
                    // only if the app is allowed, continue loading it
                    this.parcelLib = mod;
                    //If we haven't been asked to render yet, don't force a render.
                    //If we have been rendered, mount the app into our element.
                    if (this.rendered) {
                        this._mountApp();
                    }
                }

            }.bind(this)).catch(function(e) {
                if (!this.allowApp) {
                    // catalog could not find the dashlet, and the service url failed
                    this.errorCode = 'SVC-404';
                    this.displayError();
                }
                System.delete(url);
            }.bind(this));
        }
    },

    /**
     * Displays an error message with error code into the template
     */
    displayError: function() {
        this.errorMsg = app.lang.get('LBL_SUGAR_APPS_DASHLET_CATALOG_ERROR', null, {
            errorCode: this.errorCode
        });
        this.$el.empty();
        this.$el.append(this.template(this));
    },

    /**
     * singleSpa Update function is called when the component in render is called after the initial render
     * @private
     */
    _mountApp: function() {
        if (!this.mounted && this.parcelLib) {
            this.extraParcelParams = _.assign(this.extraParcelParams, {component: this});

            var root = document.createElement('div');
            //Since we can't use a shadow dom, we can at least reset the css to isolate styling.
            this.el.appendChild(root);
            this.parcelParams = {
                domElement: root,
                view: this
            };

            // update parcelParams with any extra keys added
            if (this.extraParcelParams) {
                for (var key in this.extraParcelParams) {
                    if (this.extraParcelParams.hasOwnProperty(key)) {
                        this.parcelParams[key] = this.extraParcelParams[key];
                    }
                }
            }

            this.parcelApp = singleSpa.mountRootParcel(this.parcelLib, this.parcelParams);
            this.mounted = true;
        }
        if (this.mounted && this.parcelApp && this.parcelApp.update) {
            this.parcelApp.update(this.parcelParams);
        }
    },

    /**
     * singleSpa Unmount function is called when dispose is called on the sidecar view
     * @inheritdoc
     * @private
     */
    _dispose: function() {
        if (this.parcelApp && this.parcelApp.unmount) {
            this.parcelApp.unmount();
        }

        // Removing listener on sugar app dispose.
        this.off('sugarApp:' + this.appId + ':store:get', null, this);

        this._super('_dispose');
    }
}) },
"list-pagination": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ListPaginationView
 * @alias SUGAR.App.view.views.BaseListPaginationView
 * @extends View.Views.Base.BaseView
 */
({
	// List-pagination View (base) 

    events: {
        'click .paginate-prev:not(.disabled)': 'handlePaginate',
        'click .paginate-next:not(.disabled)': 'handlePaginate',
        'click .page-count': 'getPageCount',
        'change input.current-page': 'handlePaginate',
        'focus input.current-page:not([data-focus-expect=true])': 'handleFocusPageInput',
    },

    /**
     * Maintains the current page being displayed
     *
     * @property {number}
     */
    page: 1,

    /**
     * Current pagination limit
     *
     * @property {number}
     */
    limit: 0,

    /**
     * Maintains the total number of pages present in the collection
     *
     * @property {number}
     */
    pagesCount: 0,

    /**
     * Flag to display the loading text
     *
     * @property {boolean}
     */
    isLoadingCount: false,

    cachedCollection: {},

    /**
     * Flag if input field "current-page" should be focused
     *
     * @property {boolean}
     */
    pageInputFocusExpect: false,

    /**
     * Store valid key-value pagination actions
     */
    paginationActions: {
        '': '',
        'paginate': 'PAGINATE',
        'filter': 'FILTER',
    },

    /**
     * The current pagination action
     */
    paginationAction: '',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.collection = this.context.get('collection');

        this.bindCollectionEvents();
        this.bindLayoutEvents();
        this.bindContextEvents();
    },

    /**
     * Bind collection events
     */
    bindCollectionEvents: function() {
        if (!this.collection) {
            return;
        }

        this.collection.on('list:page-total:fetched', this.pageTotalFetched, this);
        this.collection.on('list:page-total:fetching', this.loadingPageTotal, this);
        this.collection.on('add', _.bind(function() {
            this.setCache();
            this.render();
        }, this));
        this.collection.on('remove', _.bind(function() {
            if (this.layout && this.layout.type && this.layout.type === 'list') {
                return;
            }

            this.handleCollectionRemove();
        }, this));
        this.collection.on('reset', this.handleCollectionReset, this);
    },

    /**
     * Bind layout events
     */
    bindLayoutEvents: function() {
        if (!this.layout) {
            return;
        }

        this.layout.on('list:sort:fire', this.handleListSort, this);
        this.layout.on('list:record:deleted', this.handleCollectionRemove, this);
    },

    /**
     * Bind context events
     */
    bindContextEvents: function() {
        if (!this.context) {
            return;
        }

        this.context.on('filter:fetch:start', function() {
            this.clearCache();
            this.setPaginationAction('filter');
        }, this);
        this.context.on('filter:fetch:success', function() {
            this.handleListFilter();
        }, this);
        this.context.on('reload', function() {
            this.clearCache();
        }, this);
    },

    /**
     * Handles the collection reset event
     *
     * The reset event is triggered on every paginate, as the
     * list shows a subset of records (different than list-bottom)
     */
    handleCollectionReset: function() {
        if (this.paginationAction === this.paginationActions.paginate) {
            if (this.collection.page !== this.page && this.collection.page === 1) {
                // should update page after linking records
                this.getFirstPage(false);
            }
            return;
        }

        const limit = parseInt(this.collection.getOption('limit'));
        if (this.limit !== limit) {
            // Clear cache if records limit was changed
            this.limit = limit;
            this.clearCache();
        }

        this.pagesCount = 0;
        this.setCache();
        this.render();
    },

    /**
     * Handles the collection remove event
     *
     * The remove event is triggered when record(s) are deleted/unlinked/etc
     * from the collection
     */
    handleCollectionRemove: function() {
        this.clearPaginationAction();
        this.clearCache();
        this.getFirstPage(true);
    },

    /**
     * Set data of current page to cache variable
     */
    setCache: function() {
        this.cachedCollection[this.page] = {
            models: _.clone(this.collection.models),
            next_offset: this.collection.next_offset,
            page: this.page
        };
    },

    /**
     * Clear cache variable
     */
    clearCache: function() {
        this.cachedCollection = {};
    },

    /**
     * Set collection data from cache variable
     * @return {boolean} true if collection was restored
     */
    restoreFromCache: function() {
        if (!this.cachedCollection[this.page]) {
            return false;
        }

        const cache = this.cachedCollection[this.page];
        this.collection.reset(cache.models);
        this.collection.next_offset = cache.next_offset;
        this.collection.page = cache.page;
        this.page = cache.page;
        return true;
    },

    /**
     * Set the current pagination action
     *
     * @param action
     */
    setPaginationAction: function(action) {
        this.paginationAction = this.paginationActions[action];
        this.context.set('paginationAction', this.paginationAction);
    },

    /**
     * Clear the pagination action
     */
    clearPaginationAction: function() {
        this.setPaginationAction('');
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this.setVisibility();
        this._super('_renderHtml');

        this.$('[data-focus-expect=true]')
            .trigger('focus')
            .attr('data-focus-expect', false);
    },

    /**
     * Handles page number entry into the pagination input field
     * and updates the current page number value accordingly.
     *
     * @param {Event} event
     */
    handlePageInput: function(event) {
        let target = this.$(event.currentTarget);
        if (target.length > 0) {
            let inputVal = target.val() || this.page;
            if (_.isString(inputVal) && !isNaN(parseInt(inputVal))) {
                inputVal = parseInt(inputVal);
            }

            inputVal = this.validatePageNumber(inputVal);

            if (inputVal !== this.page) {
                this.getPage(inputVal);
            }

            if (event.target.value !== inputVal) {
                event.target.value = inputVal;
            }
        }
    },

    /**
     * Checks the page number to so that it falls under the valid page range
     * @param {number} page number to be validated
     * @return {number} a valid page number to be paginated to
     */
    validatePageNumber: function(pageNum) {
        if (pageNum < 1) {
            pageNum = 1;
        }

        if (!_.isUndefined(this.pagesCount) && this.pagesCount > 0 && pageNum > this.pagesCount) {
            pageNum = this.pagesCount;
        }

        return pageNum;
    },

    /**
     * Paginates the collection to a given page number.
     *
     * @param {number} page value of page number to paginate to
     */
    getPage: function(page) {
        if (_.isString(page)) {
            page = parseInt(page);
        }

        var options = {
            reset: true,
            page: page,
            limit: this.collection.getOption('limit'),
            strictOffset: true
        };

        this.page = page;
        options.success = _.bind(function(shouldCache = true) {
            this.layout.trigger('list:paginate:success');

            // Tell the side drawer that there are new records to look at
            if (app.sideDrawer) {
                app.sideDrawer.trigger('sidedrawer:collection:change', this.collection);
            }

            // update count label
            this.context.trigger('list:paginate');

            this.render();

            if (shouldCache) {
                this.setCache();
            }
        }, this);

        if (this.restoreFromCache()) {
            options.success(false);
        } else {
            this.collection.paginate(options);
        }
    },

    /**
     * Switch on the event's data action and call the appropriate paginate
     *
     * @param event
     */
    handlePaginate: function(event) {
        this.setPaginationAction('paginate');

        let action = event.currentTarget.getAttribute('data-action');

        let callback;
        let layoutEvent;

        switch (action) {
            case 'paginate-prev':
                layoutEvent = 'list:paginate:previous';
                callback = _.bind(this.getPreviousPage, this);
                break;
            case 'paginate-next':
                layoutEvent = 'list:paginate:next';
                callback = _.bind(this.getNextPage, this);
                break;
            case 'paginate-input':
                layoutEvent = 'list:paginate:input';
                callback = _.bind(this.handlePageInput, this, event);
                break;
        }

        if (action === 'paginate-prev' || action === 'paginate-next') {
            if (this.pagesCount === 0) {
                this.getPageCount();
            }
        }

        if (this.layout && this.layout._events && !!this.layout._events[layoutEvent]) {
            this.layout.trigger(layoutEvent, callback);
        } else {
            callback();
        }
    },

    /**
     * Paginate to the previous page
     */
    getPreviousPage: function() {
        let pageNum = this.validatePageNumber(this.page - 1);
        this.getPage(pageNum);
    },

    /**
     * Paginate to the next page
     */
    getNextPage: function() {
        let pageNum = this.validatePageNumber(this.page + 1);
        this.getPage(pageNum);
    },

    /**
     * Trigger the paginate event on the context. This in turn fetches the total count from
     * 'collection-count' field.
     */
    getPageCount: function() {
        this.context.trigger('paginate');
    },

    /**
     * Sets the page count correctly on the pagination component ones the total is fetched successfully.
     * @param {number} total total number of records present in the collection
     */
    pageTotalFetched: function(total) {
        let limit = this.collection.getOption('limit') || app.config.maxQueryResult || 0;
        if (_.isNumber(total) && limit > 0) {
            this.pagesCount = Math.ceil(total / limit);
        }

        this.isLoadingCount = false;
        this.render();
    },

    /**
     * Handles the fetching event to get total pages. Sets the 'isLoadingCount' to true to display
     * loading labels.
     */
    loadingPageTotal: function() {
        this.isLoadingCount = true;
        this.render();
    },

    /**
     * Set pagesCount variable to -1 to hide pagination
     */
    setVisibility: function() {
        if (this.pagesCount > 1) {
            return;
        }

        let collectionDataFetched = _.has(this.collection, 'dataFetched') && this.collection.dataFetched;
        let isLastOffset = _.has(this.collection, 'next_offset') && this.collection.next_offset === -1;
        let currentPage = _.has(this.collection, 'page') ? this.collection.page : -1;

        let isPortalThemeConfig = false;
        if (this.layout.context.parent && this.layout.context.parent.get('layout') === 'portaltheme-config') {
            isPortalThemeConfig = true;
        }

        if ((collectionDataFetched && isLastOffset) || isPortalThemeConfig) {
            this.pagesCount = currentPage;
            if (this.layout.type !== 'list' && currentPage === 1) {
                this.pagesCount = -1;
            }
        }
    },

    /**
     * Get the first page
     *
     * @param fetch true to fetch the collection, false to render to 1
     */
    getFirstPage: function(fetch) {
        if (fetch) {
            this.getPage(1);
            return;
        }

        this.page = 1;

        if (!_.has(this.cachedCollection, 1)) {
            this.setCache();
        }

        this.render();
    },

    /**
    * Set the page to 1 and render
    *
    * On list column sort, BaseListView paginates to the first page using
    * the new sort criteria. There's no need to fetch the collection again
    */
    handleListSort: function() {
        this.clearCache();
        this.getFirstPage(false);
        if (!_.isEmpty(this.context)) {
            this.context.trigger('refresh:count');
        }
    },

    /**
     * Handle list filter
     */
    handleListFilter: function() {
        this.getFirstPage(false);
    },

    /**
     * Unset keys set in context
     */
    unsetContextKeys: function() {
        this.context.unset('paginationAction');
    },

    /**
     * Handles the on focus event for page input
     */
    handleFocusPageInput: function() {
        this.pageInputFocusExpect = true;

        if (this.pagesCount === 0) {
            this.getPageCount();
        }
    },

    /**
     * @inheritdoc
     */
    _dispose() {
        if (this.collection) {
            this.collection.off('list:page-total:fetched', this.pageTotalFetched, this);
            this.collection.off('list:page-total:fetching', this.loadingPageTotal, this);
            this.collection.off('add remove reset', this.render, this);
        }

        this.unsetContextKeys();

        this._super('_dispose');
    }
}) },
"themeroller": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ThemerollerView
 * @alias SUGAR.App.view.views.BaseThemerollerView
 * @extends View.View
 */
({
	// Themeroller View (base) 

    events: {
        'click [name=save_button]': 'saveTheme',
        'click [name=refresh_button]': 'loadTheme',
        'click [name=reset_button]': 'resetTheme',
        'blur input': 'previewTheme'
    },
    initialize: function(options) {
        this._super('initialize', [options]);
        this.context.set('skipFetch', true);
        this.customTheme = 'default';
        this.loadTheme();
    },
    parseLessVars: function() {
        if (this.lessVars && this.lessVars.rel && this.lessVars.rel.length > 0) {
            _.each(this.lessVars.rel, function(obj, key) {
                this.lessVars.rel[key].relname = this.lessVars.rel[key].value;
                this.lessVars.rel[key].relname = this.lessVars.rel[key].relname.replace('@', '');
            }, this);
        }
    },
    _renderHtml: function() {
        if (!app.acl.hasAccess('admin', 'Administration')) {
            return;
        }
        this.parseLessVars();
        app.view.View.prototype._renderHtml.call(this);
        _.each(this.$('.hexvar[rel=colorpicker]'), function(obj, key) {
            $(obj).blur(function() {
                $(this).parent().parent().find('.swatch-col').css('backgroundColor', $(this).val());
            });
        }, this);
        this.$('.hexvar[rel=colorpicker]').colorpicker();
        this.$('.rgbavar[rel=colorpicker]').colorpicker({format: 'rgba'});
    },
    loadTheme: function() {
        this.themeApi('read', {}, _.bind(function(data) {
            this.lessVars = data;
            if (this.disposed) {
                return;
            }
            this.render();
            this.previewTheme();
        }, this));
    },
    saveTheme: function() {
        var self = this;
        // get the value from each input
        var colors = this.getInputValues();

        this.showMessage('LBL_SAVE_THEME_PROCESS');
        this.themeApi('create', colors, function() {
            app.alert.dismissAll();
        });
    },
    resetTheme: function() {
        var self = this;
        app.alert.show('reset_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_RESET_THEME_MODAL_INFO'),
            onConfirm: function() {
                self.showMessage('LBL_RESET_THEME_PROCESS');
                self.themeApi('create', {'reset': true}, function(data) {
                    app.alert.dismissAll();
                    self.loadTheme();
                });
            }
        });
    },
    previewTheme: function() {
        var colors = this.getInputValues();
        this.context.set('colors', colors);
    },
    themeApi: function(method, params, successCallback) {
        var self = this;
        _.extend(params, {
            platform: 'portal',
            themeName: self.customTheme
        });
        var paramsGET = (method === 'read') ? params : {};
        var paramsPOST = (method === 'read') ? {} : params;
        var url = app.api.buildURL('theme', '', {}, paramsGET);
        app.api.call(method, url, paramsPOST,
            {
                success: successCallback,
                error: function(error) {
                    if (error.status === 412) {
                        self._handleMetadataSyncError(error, method, url, paramsPOST, successCallback);
                    } else {
                        app.error.handleHttpError(error);
                    }
                }
            },
            { context: self }
        );
    },
    getInputValues: function() {
        var colors = {};
        this.$('input').each(function() {
            var $this = $(this);
            colors[$this.attr('name')] = $this.hasClass('bgvar') ? '"' + $this.val() + '"' : $this.val();
        });
        return colors;
    },
    showMessage: function(messageKey) {
        app.alert.show('themeProcessing', {
            level: 'process',
            title: app.lang.get(messageKey),
            closeable: true,
            autoclose: true
        });
    },

    /**
     * Handles HTTP error 412 Metadata out of sync when saving the portal theme.
     * Syncs the metadata and tries to save the portal theme after the sync.
     *
     * @param {Object} error The error object.
     * @param {string} method The method used in the errored API call.
     * @param {string} url The URL used in the errored API call.
     * @param {Object} paramsPOST The POST params used in the errored API call.
     * @param {Function} successCallback The success callback used in the errored API call.
     * @private
     */
    _handleMetadataSyncError: function(error, method, url, paramsPOST, successCallback) {
        var self = this;
        app.metadata.sync(function() {
            app.api.call(method, url, paramsPOST,
                {
                    success: function() {
                        // The sync resets the colors displayed. We need to load
                        // the colors we just saved to display the correct
                        // colors.
                        self.loadTheme();
                        successCallback();
                    },
                    error: function(error) {
                        app.error.handleHttpError(error);
                    }
                },
                { context: self }
            );
        });
    }
}) },
"stage2-email-import": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Stage2-email-import View (base) 

    plugins: ['Stage2CssLoader'],

    events: {
        'change input[name=checkbox-import]': 'isChecked',
        'click .save_import': 'saveImport',
        'click .cancel': 'cancel',
        'mouseenter [rel="tooltip"]': 'showTooltip',
        'mouseleave [rel="tooltip"]': 'hideTooltip'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.context.set('forceNew', true);
        this._super('initialize', [options]);
        this._emailCollection = options.context.get('_emailCollection');
        if (this.layout) {
            this.layout.on('app:view:stage2-email-import', function() {
                this._emailsToImport = [];
                this._emailCollection = this.context.get('_emailCollection');
                this.render();
            }, this);
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        this.$('.modal').modal({
            backdrop: 'static'
        });

        this.$('.modal').modal('show');
        $('.datepicker').css('z-index', '20000');
        app.$contentEl.attr('aria-hidden', true);
        $('.modal-backdrop').insertAfter($('.modal'));
        $('.save_import').prop('disabled', true);
    },

    /**
     * Check if is checked
     *
     * @param {Object} e
     */
    isChecked: function(e) {
        var self = this;
        var $btn = $(e.currentTarget);
        var isChecked = $btn.is(':checked');
        var newEmail = $btn.attr('value');

        if (isChecked) {
            if (_.indexOf(self._emailsToImport, newEmail) === -1) {
                self._emailsToImport.push(newEmail);
            }
        } else {
            self._emailsToImport = _.without(self._emailsToImport, newEmail);
        }

        if (!_.isEmpty(this._emailsToImport)) {
            $('.save_import').prop('disabled', false);
        } else {
            $('.save_import').prop('disabled', true);
        }

    },

    /**
     * Merge emails
     *
     * @return {Array}
     */
    _mergeEmail: function() {
        var emails = this.model.get('email') || [];
        var newEmails = [];
        var isPrimary = false;
        if (!_.isEmpty(this._emailsToImport)) {
            if (emails.length === 0) {
                isPrimary = true;
            }
            _.each(this._emailsToImport, function(item) {
                var newItem = {
                    email_address: item,
                    invalid_email: false,
                    opt_out: false,
                    primary_address: isPrimary
                };
                newEmails.push(newItem);
                emails.push(newItem);
                isPrimary = false;
            }, this);
            this._emailsToImport = newEmails;
        }
        return emails;
    },

    /**
     * Disable buttons
     *
     * @param {boolean} flag
     */
    _disableButtons: function(flag) {
        $('[data-name="email-import-btn"]').prop('disabled', flag);
        $('input[name=checkbox-import]').prop('disabled', flag);
    },

    /**
     * Save import
     */
    saveImport: function() {
        var self = this;
        if (!_.isEmpty(this._emailsToImport)) {
            this._disableButtons(true);
            if (this.context.parent.get('create')) {
                this.model.set({
                    'email': this._mergeEmail()
                });
            } else {
                this.model.save({
                    'email': this._mergeEmail()
                });
            }
            this._disableButtons(false);
            this.layout.trigger('app:preview:popup-close', this._emailsToImport);
            app.$contentEl.removeAttr('aria-hidden');
            this._disposeView();

        } else {
            app.alert.show('message-id', {
                level: 'error',
                messages: 'No email is selected',
                autoClose: true
            });
        }
    },

    /**
     * Dispose view
     */
    _disposeView: function() {
        var index = _.indexOf(this.layout._components, _.findWhere(this.layout._components, {
            name: 'stage2-email-import'
        }));
        if (index > -1) {
            this.layout._components[index].dispose();
            this.layout._components.splice(index, 1);
        }
    },

    /**
     * Remove aria hidden on cancel button and dispose the view
     */
    cancel: function() {
        app.$contentEl.removeAttr('aria-hidden');
        this._disposeView();
    }
}) },
"contentsearch-results": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ContentsearchResultsView
 * @alias SUGAR.App.view.views.BaseContentsearchResultsView
 * @extends View.View
 */
({
	// Contentsearch-results View (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.dataFetched = false;
        this.records = [];
        this.context.on('data:fetching', this.showFetching, this);
        this.context.on('data:fetched', this.showData, this);
    },

    /**
     * Shows data.
     *
     * @param {Object} data The data to show
     */
    showData: function(data) {
        this.records = data.records;
        this.dataFetched = true;
        this.render();
    },

    /**
     * Shows message 'Searching...'.
     */
    showFetching: function() {
        this.records = [];
        this.dataFetched = false;
        this.render();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.context) {
            this.context.off('data:fetching', null, this);
            this.context.off('data:fetched', null, this);
        }
    }
}) },
"masslink-progress": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MasslinkProgressView
 * @alias SUGAR.App.view.views.BaseMasslinkProgressView
 * @extends View.Views.Base.MassupdateProgressView
 */
({
	// Masslink-progress View (base) 

    extendsFrom: 'MassupdateProgressView',

    /**
     * Set of labels.
     */
    _labelSet: {
        'update': {
            PROGRESS_STATUS: 'TPL_MASSLINK_PROGRESS_STATUS',
            DURATION_FORMAT: 'TPL_MASSLINK_DURATION_FORMAT',
            FAIL_TO_ATTEMPT: 'TPL_MASSLINK_FAIL_TO_ATTEMPT',
            WARNING_CLOSE: 'TPL_MASSLINK_WARNING_CLOSE',
            WARNING_INCOMPLETE: 'TPL_MASSLINK_WARNING_INCOMPLETE',
            SUCCESS: 'TPL_MASSLINK_SUCCESS',
            TITLE: 'TPL_MASSLINK_TITLE'
        }
    }

}) },
"action-items": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This component shows action items driven by metadata. A component can
 * have multiple 'action-items' components with varying items definition
 *
 * To use:
 * [
 *  'view' => [
 *      'name' => 'action-items',
 *      'items' => [
 *          [
 *              'icon' => 'the_icon',
 *              'tooltip' => 'the_tooltip',
 *              'href' => 'the_href',
 *              'label' => 'the_label'
 *          ]
 *      ]
 *  [
 * ]
 *
 * @class View.Views.Base.ActionItemsView
 * @alias SUGAR.App.view.views.BaseActionItemsView
 * @extends View.View
 */
({
	// Action-items View (base) 

    className: 'action-items',

    /**
     * A list of items
     */
    items: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.addItems(this.getItemsDef());
    },

    /**
     * Add items to be rendered
     *
     * @param items
     */
    addItems: function(items) {
        if (!this.items) {
            this.items = [];
        }

        this.items.push(...items);
    },

    /**
     * Get item definitions
     *
     * @return array
     */
    getItemsDef: function() {
        return this.meta.items || [];
    }
}) },
"dupecheck-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckHeaderView
 * @alias SUGAR.App.view.views.BaseDupecheckHeaderView
 * @extends View.View
 */
({
	// Dupecheck-header View (base) 


    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        this.context.on('dupecheck:collection:reset', this.updateCount, this);
     },

    updateCount: function() {
        var translatedString = app.lang.get(
            'LBL_DUPLICATES_FOUND',
            this.module,
            {'duplicateCount': this.collection.length}
        );
        this.$('span.duplicate_count').text(translatedString);
    }
}) },
"shift-exceptions-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ShiftExceptionsDashletView
 * @alias SUGAR.App.view.views.BaseShiftExceptionsDashletView
 * @extends @extends View.Views.Base.ListView
 */
({
	// Shift-exceptions-dashlet View (base) 

    plugins: ['Dashlet'],

    extendsFrom: 'ListView',

    /**
     * Fields displayed in dashlet
     *
     * @property {Array}
     */
    displayedFields: [
        'name',
        'start_date',
        'end_date',
        'shift_exception_type',
    ],

    /**
     * ShiftExceptions bean collection.
     *
     * @property {Data.BeanCollection}
     */
    collection: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initCollection();
    },

    /**
     * Initialize feature collection.
     */
    _initCollection: function() {
        var today = app.date().formatServer(true);
        var self = this;
        this.collection = app.data.createBeanCollection(this.module);
        this.collection.setOption({
            fields: this.displayedFields,
            filter: {
                'enabled': {
                    '$equals': 1
                },
                'end_date': {
                    '$gte': today
                }
            },
        });
        this.collection.displayedFields = this._initDisplayedFields();

        // set meta last state id so sorting order is maintained
        this.meta.last_state = {id: 'shift-exceptions-dashlet'};
        this.orderByLastStateKey = app.user.lastState.key('order-by', this);
        this.orderBy = this._initOrderBy();
        if (this.collection) {
            this.collection.orderBy = this.orderBy;
        }

        return this;
    },

    /**
     * Returns the displayed field objects
     *
     * @return {Array} the field objects
     * @private
     */
    _initDisplayedFields: function() {
        var displayedFields = [];

        _.each(this.displayedFields, function(field) {
            if (!this.model.fields) {
                return;
            }
            var toPush = this.model.fields[field];
            toPush.link = (field === 'name') ? true : false;
            displayedFields.push(toPush);
        }, this);

        return displayedFields;
    },

    /**
     * @inheritdoc
     *
     * Once collection has been changed, the view should be refreshed.
     */
    bindDataChange: function() {
        if (this.collection) {
            this.collection.on('add remove reset', function() {
                if (this.disposed) {
                    return;
                }
                this.render();
            }, this);
        }
    },

    /**
     * @inheritdoc
     */
    _setOrderBy: function(options) {
        if (this.orderByLastStateKey) {
            app.user.lastState.set(this.orderByLastStateKey, this.orderBy);
        }
        this.loadData(options);
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        this.collection.fetch(options);
    },

}) },
"logout": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.LogoutView
 * @alias SUGAR.App.view.views.BaseLogoutView
 * @extends View.View
 */
({
	// Logout View (base) 

    events: {
        "click [name=login_button]": "login",
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        this.logoUrl = app.metadata.getLogoUrl(app.utils.isDarkMode());
        app.view.View.prototype._render.call(this);
        this.refreshAddtionalComponents();
        return this;
    },

    /**
     * Refresh additional components
     */
    refreshAddtionalComponents: function() {
        _.each(app.additionalComponents, function(component) {
            component.render();
        });
    },

    /**
     * @deprecated
     */
    login_form: function() {
        app.logger.warn('`View.Views.Base.LogoutView#login_form` has been deprecated since 7.9.1.0 and' +
            ' will be removed in a future release. Please use `View.Views.Base.LogoutView#login`.');
        this.login();
    },

    /**
     * Process Login
     */
    login: function() {
        app.router.login();
    }
}) },
"hint-data-enrichment-drawer-view": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ConfigDrawerLayout
 * @alias SUGAR.App.view.layouts.BaseConfigDrawerLayout
 * @extends View.Layout
 */
({
	// Hint-data-enrichment-drawer-view View (base) 

    plugins: ['Stage2CssLoader'],

    events: {
        'click .restoreDefaults': 'restoreDefaults',
    },

    /**
     * @inheritdoc
     */
    initialize: function(view) {
        var self = this;
        this._super('initialize', arguments);
        var ctx = this.context;
        var accountsModule = 'Accounts';
        var contactsModule = 'Contacts';
        var leadsModule = 'Leads';
        this.isDarkMode = app.hint.isDarkMode();
        this.currentModule = 'Accounts'; //Default module we always start with
        this.documentationLink = 'http://www.sugarcrm.com/crm/product_doc.php?module=HintAdminConfig';
        this.hintConfig = app.metadata.getModule(this.currentModule, 'config');
        this.configKey = 'hintConfig';
        this.moduleList = app.metadata.getFullModuleList();
        this.shouldShowAccountsTab = this.moduleList[accountsModule] ? true : false;
        this.shouldShowContactsTab = this.moduleList[contactsModule] ? true : false;
        this.shouldShowLeadsTab = this.moduleList[leadsModule] ? true : false;
        this.modulesMetaData = [{
            module: 'accounts',
            'basicFields': app.hint.getAccountBasicPanelFields(),
            'expandedFields': app.hint.getAccountExpandedPanelFields()
        }, {
            module: 'contacts',
            'basicFields': app.hint.getPeopleBasicPanelFields('Contacts'),
            'expandedFields': app.hint.getPeopleExpandedPanelFields('Contacts')
        }, {
            module: 'leads',
            'basicFields': app.hint.getPeopleBasicPanelFields('Leads'),
            'expandedFields': app.hint.getPeopleExpandedPanelFields('Leads')
        }];

        app.events.on('hint:config:fieldRemoved', function(fieldRemoved) {
            _.each(self.modulesMetaData, function(moduleMetaData) {

                if (moduleMetaData.module.toLowerCase() == self.currentModule.toLowerCase()) {

                    moduleMetaData.basicFields =
                        _.without(moduleMetaData.basicFields, _.findWhere(moduleMetaData.basicFields, {
                            name: fieldRemoved.name
                        }));

                    moduleMetaData.expandedFields =
                        _.without(moduleMetaData.expandedFields, _.findWhere(moduleMetaData.expandedFields, {
                            name: fieldRemoved.name
                        }));
                }
            });
            this.render();
        }, this);

        app.events.on('hint:config:fieldAdded', function(fieldAdded) {
            var self = this;
            _.each(this.modulesMetaData, function(metadata) {
                if (metadata.module == self.currentModule.toLowerCase()) {

                    var existsInBasicPanel = _.find(metadata.basicFields, function(field) {
                        return field == fieldAdded;
                    });

                    var existsInExtendedPanel = _.find(metadata.expandedFields, function(field) {
                        return field == fieldAdded;
                    });

                    if (!existsInBasicPanel && !existsInExtendedPanel) {
                        metadata.expandedFields.push(fieldAdded);
                    }

                }
            });
            this.render();
        }, this);
    },

    /**
     * Restore default config
     *
     * @param {Object} event
     */
    restoreDefaults: function(event) {
        var self = this;
        event.preventDefault();

        app.alert.show('message-id', {
            level: 'confirmation',
            messages: app.lang.get('LBL_HINT_CONFIG_WARNING_MESSAGE', self.currentModule, {
                module: self.currentModule
            }),
            autoClose: false,
            onConfirm: function() {
                self._restoreModulesMetaData();
                self.render();
                app.events.trigger('hint:config:defaults:restored', {
                    module: self.currentModule, metadata: self._getMetadataForModule(self.currentModule)
                });
            },
            onCancel: function() {
                $.noop();
            }
        });
    },

    /**
     * Restore modules metadata
     */
    _restoreModulesMetaData: function() {
        var basicPanelAccounts;
        var basicPanelContacts;
        var basicPanelLeads;
        var expandedPanelAccounts;
        var expandedPanelContacts;
        var expandedPanelLeads;

        _.each(this.modulesMetaData, function(moduleMetaData) {
            switch (moduleMetaData.module.toLowerCase()) {
                case 'accounts':
                    basicPanelAccounts = moduleMetaData.basicFields;
                    expandedPanelAccounts = moduleMetaData.expandedFields;
                    break;
                case 'contacts':
                    basicPanelContacts = moduleMetaData.basicFields;
                    expandedPanelContacts = moduleMetaData.expandedFields;
                    break;
                case 'leads':
                    basicPanelLeads = moduleMetaData.basicFields;
                    expandedPanelLeads = moduleMetaData.expandedFields;
                    break;
            }
        }, this);

        this.modulesMetaData = [
            {
                module: 'accounts',
                'basicFields': (this.currentModule === 'Accounts') ?
                    app.hint.getAccountDefaultBasicPanelFields() : basicPanelAccounts,
                'expandedFields': (this.currentModule === 'Accounts') ?
                    app.hint.getAccountDefaultExpandedPanelFields() : expandedPanelAccounts
            }, {
                module: 'contacts',
                'basicFields': (this.currentModule === 'Contacts') ?
                    app.hint.getPeopleDefaultBasicPanelFields('Contacts') : basicPanelContacts,
                'expandedFields': (this.currentModule === 'Contacts') ?
                    app.hint.getPeopleDefaultExpandedPanelFields('Contacts') : expandedPanelContacts
            }, {
                module: 'leads',
                'basicFields': (this.currentModule === 'Leads') ?
                    app.hint.getPeopleDefaultBasicPanelFields('Leads') : basicPanelLeads,
                'expandedFields': (this.currentModule === 'Leads') ?
                    app.hint.getPeopleDefaultExpandedPanelFields('Leads') : expandedPanelLeads
            }
        ];
    },

    /**
     * Get metadata for saving
     *
     * @param {string} module
     * @return {Object}
     */
    _getMetadataForSaving: function(module) {
        var basicPanelFields = [];
        var expandedPanelFields = [];

        //Get all the fields from the dom and their order.
        $('div#' + module.toLowerCase() + '-basic-panel').find('div.configurable > div.row-fluid').each(
            function(index) {
                basicPanelFields.push($(this).data('name'));
            });

        $('div#' + module.toLowerCase() + '-expanded-panel').find('div.configurable > div.row-fluid').each(
            function(index) {
                expandedPanelFields.push($(this).data('name'));
            });

        return {'basic': basicPanelFields, 'expanded': expandedPanelFields};
    },

    /**
     * @param currentModule
     * @private
     */
    _hidePanelsForOtherModules: function(currentModule) {
        var lowerCaseModule = '#' + currentModule.toLowerCase();
        var basicPanelToShow = lowerCaseModule + '-basic-panel';
        var expandedPanelToShow = lowerCaseModule + '-expanded-panel';
        var directionsPanelToShow = lowerCaseModule + '-directions';

        $('.hint-config-container').hide();
        $('.directions-container').hide();

        $(basicPanelToShow).show();
        $(expandedPanelToShow).show();
        $(directionsPanelToShow).show();
        if (this.currentModule !== currentModule) {
            this.currentModule = currentModule;
            this._render();
        }
    },

    /**
     * Given our metadata and an array of sorted fields, return a copy of the metadata sorted with the same order
     * as the ordered fields.  O(n) time complexity.
     *
     * @private
     */
    _sortMetadataFields: function(metadataFields, sortedFields) {
        if (!sortedFields) {
            return metadata;
        }

        //Restructure to a hashmap for easy sorting
        var metadataFieldsByKey = {};
        for (var z = 0; z < metadataFields.length; z++) {
            var key = metadataFields[z].name;
            metadataFieldsByKey[key] = metadataFields[z];
        }

        var results = [];
        for (var x = 0; x < sortedFields.length; x++) {
            var currentField = sortedFields[x];

            if (typeof (metadataFieldsByKey[currentField]) !== 'undefined') {
                results.push(metadataFieldsByKey[currentField]);
            }
        }

        return results;
    },
    /**
     * Event handler for the sortstop "drop" event.  We need to resort the backing data
     * with what the dom is showing otherwise when we switch tabs or call any other render functionality
     * we'll loose the state.
     *
     * @param {jQuery.Event} evt The jQuery sortstop event
     * @param {Object} ui The jQuery Sortable UI Object
     * @private
     */
    _onDragStop: function(evt, ui) {
        var self = this;
        var sortedMetadata = self._getMetadataForSaving(this.currentModule);

        _.each(self.modulesMetaData, function(moduleMetaData) {

            if (moduleMetaData.module.toLowerCase() == self.currentModule.toLowerCase()) {
                var allMetadataFields = moduleMetaData.basicFields.concat(moduleMetaData.expandedFields);
                moduleMetaData.basicFields = self._sortMetadataFields(allMetadataFields, sortedMetadata.basic);
                moduleMetaData.expandedFields = self._sortMetadataFields(allMetadataFields, sortedMetadata.expanded);
            }
        });

    },

    /**
     * Get metadata for module
     *
     * @param {string} module
     * @private
     */
    _getMetadataForModule: function(module) {

        var self = this;
        return _.find(this.modulesMetaData, function(moduleMetaData) {

            return moduleMetaData.module.toLowerCase() == module.toLowerCase();
        });
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var self = this;
        this._super('_render');

        self._hidePanelsForOtherModules(this.currentModule);

        //This will ensure that our panels are drag and drop enabled.
        $('.panel.configurable').sortable({
            items: 'div.row-fluid',
            // allow drag to only go in Y axis direction
            axis: 'y',
            // make the "helper" row (the row the user actually drags around) a clone of the original row
            helper: 'clone',
            // adds a slow animation when "dropping" a group, removing this causes the row
            // to immediately snap into place wherever it's sorted
            revert: 150,
            // the CSS class to apply to the placeholder underneath the helper clone the user is dragging
            placeholder: 'ui-state-highlight',
            // the cursor to use when dragging
            cursor: 'move',
            //All items to move to a different panel
            connectWith: '.panel.configurable',
            // handler for when dragging stops; the "drop" event
            stop: _.bind(this._onDragStop, this),
        });

        //Listen to tab changes for the tab events (module changed)
        $('a[data-toggle="tab"]').on('shown.bs.tab', function(e) {
            var target = $(e.target).attr('href'); // activated tab
            var module = target.substring(1).charAt(0).toUpperCase() + target.substring(2);

            self._hidePanelsForOtherModules(module);
            self.currentModule = module;
            app.events.trigger('hint:config:module:changed', {
                module: module, metadata: self._getMetadataForModule(module)
            });
        });
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        app.events.off('hint:config:fieldRemoved');
        app.events.off('hint:config:fieldAdded');
        this._super('_dispose');
    }
}) },
"quicksearch-modulelist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchModuleListView
 * @alias SUGAR.App.view.views.BaseQuicksearchModuleListView
 * @extends View.View
 */
({
	// Quicksearch-modulelist View (base) 

    className: 'quicksearch-modulelist-wrapper',
    plugins: ['Dropdown'],
    dropdownItemSelector: '[data-action=select-module], [data-action=select-all]',

    events: {
        'click [data-action=select-all]': 'selectAllModules',
        'click [data-action=select-module]': 'selectModule',
        'keydown [data-action=select-all]': 'allModulesKeydownHandler',
        'keydown [data-action=select-module]': 'moduleKeydownHandler',
        'click [data-toggle=dropdown]': 'moduleDropdownClick'
    },

    // List of modules that should not be included in the module list
    blacklistModules: ['Tags'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.hide();

        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        /**
         * A collection of the available modules.
         *
         * @type {Backbone.Collection}
         */
        this.searchModuleFilter = new Backbone.Collection(null, {
            //adds models in alphabetical order of model's id's module name translation
            comparator: function(model) {
                return app.lang.getModuleName(model.id, {plural: true});
            }
        });

        /**
         * The lastState key for local storage.
         *
         * @type {String}
         */
        this.stateKey = app.user.lastState.buildKey('quicksearch', 'modulelist', this.name);

        /**
         * Template for the module icons in the search bar.
         *
         * @type {Handlebars.Template}
         * @private
         */
        this._moduleIconTemplate = app.template.getView(this.name + '.module-avatar');

        /**
         * Data structure for the display of the module icons.
         *
         * @type {Object}
         */
        this.moduleIcons = {};

        // When the app is ready, fetch the searchable modules and put them in
        // the module list dropdown. This cannot be in the initialize because
        // when initialize is called, the only module available is login.
        app.events.on('app:sync:complete', function() {
            this.populateModules();
            // If there is a module preference stored in local storage,
            // default selection to those modules.
            var previousModuleSelection = app.user.lastState.get(this.stateKey);
            if (_.isEmpty(previousModuleSelection)) {
                this.searchModuleFilter.allSelected = true;
            } else {
                _.each(previousModuleSelection, function(module) {
                    this.searchModuleFilter.get(module).set('selected', true);
                }, this);
            }
            this._setSelectedModules();
            // Prepare the module icons for display
            var moduleIconObj = this._buildModuleIconList();
            this.moduleIcons = {icon: moduleIconObj};
            this.render();
            this.layout.off('route:search', this.populateModuleSelectionFromContext);
            this.layout.on('route:search', this.populateModuleSelectionFromContext, this);

            // We need to call `populateModuleSelectionFromContext` here to
            // update the module icons if the user navigates directly to the
            // search page from outside Sugar. In this use case,
            // 'quicksearch-modulelist.js' is initialized and needs to update
            // the module icons to be in sync with the ones in the url.
            this.populateModuleSelectionFromContext();
        }, this);

        // On expansion of quicksearch, show the module dropdown & buttons.
        this.layout.on('quicksearch:expanded', this.show, this);

        // On collapse of quicksearch, hide the module dropdown & buttons.
        this.layout.on('quicksearch:collapse', this.hide, this);

        // Whenever anything happens within the quicksearch layout navigation,
        // close the module list dropdown.
        this.layout.on('navigate:next:component navigate:previous:component navigate:to:component', function() {
            this.$el.removeClass('open');
        }, this);
    },

    /**
     * Populate the module selection from the search context.
     */
    populateModuleSelectionFromContext: function() {
        // Reset all the selections
        var previousModuleSelection = this.context.get('module_list');
        this.searchModuleFilter.invoke('set', {selected: false});
        this.$('[data-action=select-module]').removeClass('selected');

        // Handle the 'all selected' case
        if (_.isEmpty(previousModuleSelection)) {
            this.searchModuleFilter.allSelected = true;
            this.$('[data-action=select-all]').addClass('selected');
            // A specific set of modules have been selected.
        } else {
            this.searchModuleFilter.allSelected = false;
            this.$('[data-action=select-all]').removeClass('selected');
            _.each(previousModuleSelection, function(module) {
                var moduleFilter = this.searchModuleFilter.get(module);
                if (moduleFilter) {
                    moduleFilter.set('selected', true);
                    this.$('[data-action=select-module][data-module=' + module + ']').addClass('selected');
                }
            }, this);
        }
        this._setSelectedModules();
        this._updateModuleIcons();
    },

    /**
     * Handle module 'select/unselect' event.
     *
     * @param {Event} event
     */
    selectModule: function(event) {
        // We need to stop propagation for two reasons:
        // 1) Stop scrolling when using the spacebar.
        // 2) Prevent collapse of the `quicksearch` layout. The module list is
        // considered inside the dropdown plugin, and not in the layout. Clicks
        // outside the layout normally collapse the layout.
        event.stopImmediatePropagation();
        var $li = $(event.currentTarget);
        var module = $li.data('module');
        var moduleModel = this.searchModuleFilter.get(module);

        // If all the modules were selected, we unselect all of them first.
        if (this.searchModuleFilter.allSelected) {
            this.$('[data-action=select-all]').removeClass('selected', false);
            this.searchModuleFilter.allSelected = false;
        }

        // Then we select the clicked module.
        var checkModule = !moduleModel.get('selected');
        moduleModel.set('selected', checkModule);
        $li.toggleClass('selected', checkModule);

        // Check to see if all the modules are now all selected or unselected.
        var selectedLength = this.searchModuleFilter.where({'selected': true}).length;

        // All modules are selected, set them all to unselected.
        if (selectedLength === this.searchModuleFilter.length) {
            this.searchModuleFilter.invoke('set', {selected: false});
            selectedLength = 0;
        }

        // If all modules are now unselected, update checkboxes and set the
        // `allSelected` property of the filter.
        if (selectedLength === 0) {
            this.searchModuleFilter.allSelected = true;
            this.$('[data-action=select-all]').addClass('selected');
            this.$('[data-action=select-module]').removeClass('selected');
        }

        this._setSelectedModules();
        this._updateModuleIcons();
    },

    /**
     * Handle clicks on the "Search all" list item.
     * @param {event} event
     */
    selectAllModules: function(event) {
        // We need to stop propagation for two reasons:
        // 1) Stop scrolling when using the spacebar.
        // 2) Prevent collapse of the `quicksearch` layout. The module list is
        // considered inside the dropdown plugin, and not in the layout. Clicks
        // outside the layout normally collapse the layout.
        event.stopImmediatePropagation();

        // Selects all modules.
        this.$('[data-action=select-all]').addClass('selected');
        this.$('[data-action=select-module]').removeClass('selected');
        this.searchModuleFilter.invoke('set', {selected: false});
        this.searchModuleFilter.allSelected = true;

        this._setSelectedModules();
        this._updateModuleIcons();
    },

    /**
     * Handles the keydown events on the "All Modules" checkbox.
     * On spacebar, trigger the same functionality as a click.
     *
     * @param {Event} event The `keydown` event
     */
    allModulesKeydownHandler: function(event) {
        if (event.keyCode === 32) { // space bar
            this.selectAllModules(event);
            event.preventDefault();
        }
    },

    /**
     * Handles the keydown events on the module list items.
     * On spacebar, trigger the same functionality as a click.
     *
     * @param {Event} event The `keydown` event
     */
    moduleKeydownHandler: function(event) {
        if (event.keyCode === 32) { // space bar
            this.selectModule(event);
            event.preventDefault();
        }
    },

    /**
     * Trigger `quicksearch:results:close` when the module dropdown is clicked.
     */
    moduleDropdownClick: function() {
        this.layout.trigger('quicksearch:results:close');
    },

    /**
     * Updates the modules icons in the search bar, based on the currently
     * selected modules.
     *
     * @private
     */
    _updateModuleIcons: function() {
        // Update the module icons in the search bar.
        var $moduleIconContainer = this.$('[data-label=module-icons]');
        $moduleIconContainer.empty();
        var moduleIconObj = this._buildModuleIconList();

        $moduleIconContainer.append(this._moduleIconTemplate({icon: moduleIconObj}));
    },

    /**
     * Builds an array of objects for displaying the module icons.
     * @return {Array}
     * @private
     */
    _buildModuleIconList: function() {
        var moduleIconObj = [];
        // If all modules are selected, display "all" icon.
        if (this.collection.selectedModules.length === 0) {
            moduleIconObj.push({});
            // If 3 or fewer selected, display the module icons that are selected.
        } else if (this.collection.selectedModules.length <= 3) {
            _.each(this.collection.selectedModules, function(module) {
                moduleIconObj.push({module: module});
            }, this);
            // If there are more than 3 modules selected, display the
            // "Multiple Modules" icon
        } else {
            moduleIconObj.push({multiple: true});
        }
        return moduleIconObj;
    },

    /**
     * Populate `this.searchModuleFilter` with the searchable modules, using
     * acls and the metadata attribute `checkGlobalSearchEnabled`.
     */
    populateModules: function() {
        if (this.disposed) {
            return;
        }

        //Reset the collection of module filters so we don't add duplicate
        //elements to the original collection.
        this.searchModuleFilter.reset();
        var modules = app.metadata.getModules() || {};

        //filter the module names out based on global search enabled, has
        //access to acl, and is not a blacklisted module
        _.each(modules, function(meta, module) {
            if (meta.globalSearchEnabled &&
                app.acl.hasAccess.call(app.acl, 'view', module) &&
                !_.contains(this.blacklistModules, module)
            ) {
                var moduleModel = new Backbone.Model({id: module, selected: false});
                this.searchModuleFilter.add(moduleModel);
            }
        }, this);
    },

    /**
     * Store the selected modules on the collection and in local storage.
     *
     * @private
     */
    _setSelectedModules: function() {
        var selectedModules = [];
        if (!this.searchModuleFilter.allSelected) {
            this.searchModuleFilter.each(function(model) {
                if (model.get('selected')) {
                    selectedModules.push(model.id);
                }
            });
        }

        this.collection.selectedModules = selectedModules;
        app.user.lastState.set(this.stateKey, this.collection.selectedModules);
    }
}) },
"activitystream-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Activitystream-dashlet View (base) 

    /**
     * The plugins used by this view.
     */
    plugins: ['Dashlet'],

    events: {
        'click .addComment' : 'addComment'
    },

    className: 'block filtered activitystream-layout',

    /**
     * The default settings for activity stream.
     *
     * @property {Object}
     */
    _defaultSettings: {
        limit: 5,
        auto_refresh: 0
    },

    /**
     * Omnibar ActivityStream view
     */
    omnibarView: null,

    initialize: function(opts) {
        this.renderedActivities = {};

        var moduleMeta = app.metadata.getModule(opts.context.parent.get('module'));
        this.activityStreamEnabled = moduleMeta.activityStreamEnabled;
        if (this.activityStreamEnabled && this.activityStreamEnabled === true) {
            this.plugins.push('Pagination');
        }

        this._super('initialize', [opts]);

        this.setCollectionOptions();
        this.context.on('activitystream:post:prepend', this.prependPost, this);

        this.omnibarView = app.view.createView({
            context: this.context,
            type: 'activitystream-omnibar',
            module: this.module,
            layout: this
        });

        if (this.meta.config) {
            this.listenTo(this.layout, 'init', this._addFilterComponent);
            this.layout.before('dashletconfig:save', this.saveDashletFilter, this);
        }
    },

    /**
     * Init dashlet settings
     */
    initDashlet: function()
    {
        var options = {};
        var self = this;
        var refreshRate;

        options.limit = this.settings.get('limit') || this._defaultSettings.limit;
        this.settings.set('limit', options.limit);

        options.auto_refresh = this.settings.get('auto_refresh') || this._defaultSettings.auto_refresh;
        this.settings.set('auto_refresh', options.auto_refresh);

        options = _.extend({}, this.context.get('collectionOptions'), options);
        this.context.set('collectionOptions', options);

        // Set the refresh rate for setInterval so it can be checked ahead of
        // time.  60000 is 1000 miliseconds times 60 seconds in a minute.
        refreshRate = options.auto_refresh * 60000;

        // Only set up the interval handler if there is a refreshRate higher than 0
        if (refreshRate > 0) {
            if (this.timerId) {
                clearInterval(this.timerId);
            }
            this.timerId = setInterval(_.bind(function() {
                if (self.context) {
                    self.context.resetLoadFlag();
                    self.loadData();
                }
            }, this), refreshRate);
        }
    },

    /**
     * This function adds the `dashablelist-filter` component to the layout
     * (dashletconfiguration), if the component doesn't already exist.
     */
    _addFilterComponent: function() {
        var filterComponent = this.layout.getComponent('asdashlet-filter');
        if (filterComponent) {
            return;
        }

        this.layout.initComponents([{
            layout: 'asdashlet-filter'
        }]);
    },

    /**
     * Gets Filter Definition from metadata given a filter id
     */
    _getFilterDefFromMeta: function(id) {
        if (!id) {
            return;
        }

        var moduleMeta = app.utils.deepCopy(app.metadata.getModule('Activities'));
        if (_.isObject(moduleMeta)) {
            var filters = _.compact(_.flatten(_.pluck(_.compact(_.pluck(moduleMeta.filters, 'meta')), 'filters')));
            var filter = _.find(filters, function(filter) {
                return filter.id === id;
            }, this);

            if (filter) {
                return filter;
            }
        }
    },

    /**
     * Set endpoint and the success callback for retrieving activities.
     */
    setCollectionOptions: function() {
        var self = this;

        var endpoint = function(method, model, options, callbacks) {
            var real_module = self.context.parent.get('module'),
                layoutType = self.context.parent.get('layout'),
                modelId,
                action = model.module, // equal to 'Activities'
                url;

            switch (layoutType) {
                case 'focus':
                    modelId = self.context.parent.parent.get('modelId');
                    break;
                case 'multi-line':
                    modelId = self.context.parent.parent.get('model').get('id');
                    break;
                default:
                    modelId = self.context.parent.get('modelId');
            }

            // For :Home/:record case we should call for global ActivityStream
            if (real_module == 'Home' && layoutType == 'record') {
                real_module = self.module;
                layoutType = 'activities';
            }

            switch (layoutType) {
                case 'activities':
                    url = app.api.buildURL(real_module, null, {}, options.params);
                    break;
                case 'records':
                    url = app.api.buildURL(real_module, action, {}, options.params);
                    break;
                case 'record':
                case 'focus':
                case 'multi-line':
                    url = app.api.buildURL(real_module, null, {id: modelId, link: 'activities'}, options.params);
                    break;
            }

            return app.api.call('read', url, null, callbacks);
        };

        this.context.set('collectionOptions', {
            endpoint: endpoint,
            success: function(collection) {
                // Toogle no-data visibility
                self.$el.find('.block-footer').toggleClass('hide', (collection.length > 0));
                collection.each(function(model) {
                    self.renderPost(model);
                });
            },
            limit: this._defaultSettings.limit
        });
    },

    /**
     * This function is invoked by the `dashletconfig:save` event. It takes the
     * `currentFilterId` stored on the context, and saves it on the dashlet.
     *
     * @param {Bean} model The dashlet mo`del.
     */
    saveDashletFilter: function() {
        this.layout.trigger('asdashlet:config:save');
    },

    /**
     * Show\hide activity stream omnibar
     */
    addComment: function()
    {
        this.$el.find('.omnibar-dashlet').toggleClass('hide');
    },

    /**
     * Bind data changes and comments\post adding
     */
    bindDataChange: function() {
        if (this.collection) {
            this.collection.on('add', function(model) {
                this.renderPost(model);
            }, this);
            this.collection.on('reset', function() {
                this.disposeAllActivities();

                // Clean up post container
                this.$el.find('.activitystream-list').html('');
                this.collection.each(function(post) {
                    this.renderPost(post);
                }, this);
            }, this);
        }

        if (this.context.parent) {
            var model = this.context.parent.get('model');
            this.listenTo(model, 'sync', _.once(function() {
                // Only attach to the sync event after the inital sync is done.
                this.listenTo(model, 'sync', function() {
                    var options = this.context.get('collectionOptions');
                    var filterDef = this._getFilterDefFromMeta(this.meta.currentFilterId);
                    if (filterDef) {
                        options.filter = filterDef.filter_definition;
                    }
                    this.collection.fetch(options);
                });
            }));
        }
    },

    /**
     * Add posts to activity stream on data change
     *
     * @param model
     */
    prependPost: function(model) {
        var view = this.renderPost(model);
        view.$el.parent().prepend(view.$el);
    },

    loadData: function(options) {
        if (_.isUndefined(this.context.parent.get('layout'))) {
            return;
        }

        // If activity streams are disabled for the current module on which the dashlet sits
        // then display a warning saying as much
        if (!this.activityStreamEnabled) {
            this.template = app.template.get(this.name + '.disabled');
            this._super('_render', [options]);
            return;
        }

        options = _.extend({}, options, this.context.get('collectionOptions'));

        if (this.collection) {
            var filterDef = this._getFilterDefFromMeta(this.meta.currentFilterId);
            if (filterDef) {
                options.filter = filterDef.filter_definition;
            }

            this.collection.fetch(options);
        }
    },

    /**
     * Render each ActivityStream model
     *
     * @param model
     * @return {Mixed}
     */
    renderPost: function(model) {
        var view;

        if (_.has(this.renderedActivities, model.id)) {
            view = this.renderedActivities[model.id];
        } else {
            view = app.view.createView({
                context: this.context,
                type: 'activitystream',
                module: this.module,
                layout: this,
                model: model,
                nopreview: true  // hide preview button
            });

            // Place view to dashlet layout container
            this.$el.find('.activitystream-list').append(view.el);
            this.renderedActivities[model.id] = view;
            view.render();
        }

        return view;
    },

    /**
     * Skip rendering on pagination update
     * This is a hack to prevent dashlet re-render
     *
     * @param options
     */
    render: function(options)
    {
        if (!this.rendered) {
            this.rendered = true;
            this._super('render', [options]);

            // Append sub view - aka add component
            this.$el.find('.omnibar-dashlet').append(this.omnibarView.el);
            this.omnibarView.render();
        }
    },

    unbindData: function() {
        var model, collection;

        if (this.context.parent) {
            model = this.context.parent.get('model');
            collection = this.context.parent.get('collection');

            if (model) {
                model.off('change sync', null, this);
            }
            if (collection) {
                collection.off('sync', null, this);
            }
        }

        this._super('unbindData');
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.omnibarView.dispose();
        this.disposeAllActivities();
        this._super('_dispose');
    },

    /**
     * Dispose all previously rendered activities
     */
    disposeAllActivities: function() {
        _.each(this.renderedActivities, function(component) {
            component.dispose();
        });
        this.renderedActivities = {};
    }
}) },
"shortcuts-config": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Configure keyboard shortcuts.
 *
 * @class View.Views.Base.ShortcutsConfigView
 * @alias SUGAR.App.view.views.BaseShortcutsConfigView
 * @extends View.View
 */
({
	// Shortcuts-config View (base) 

    /**
     * Handle button actions from the headerpane.
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.context.on('button:cancel_button:click', function() {
            app.drawer.close();
        }, this);
        this.context.on('button:save_button:click', this.saveShortcuts, this);
        this.context.on('button:restore_button:click', this.removeCustomizations, this);
    },

    /**
     * Render global and contextual shortcut keys.
     * @inheritdoc
     */
    _renderHtml: function(ctx, options) {
        var shortcutSession = this.context.get('shortcutSession');

        if (shortcutSession) {
            this.shortcuts = shortcutSession.getRegisteredShortcuts();
        }

        this.global = app.shortcuts.getRegisteredGlobalShortcuts();

        this._super('_renderHtml', [ctx, options]);
    },

    /**
     * Save custom shortcut keys to user preferences.
     */
    saveShortcuts: function() {
        var self = this,
            shortcutsToSave = [],
            findShortcut = function(shortcuts, id) {
                return _.find(shortcuts, function(shortcut) {
                    return (shortcut.id === id);
                });
            };

        this.$('[data-id]').each(function() {
            var $row = $(this),
                id = $row.data('id'),
                keys = $row.find('input').val().trim().split(','),
                shortcut = findShortcut(self.shortcuts, id);

            _.each(keys, function (key, index){
                keys[index] = key.trim();
            });

            if (shortcut && !_.isEqual(shortcut.keys, keys)) {
                shortcutsToSave.push({
                    id: id,
                    keys: keys
                });
            }
        });

        app.shortcuts.saveCustomShortcutKey(shortcutsToSave, this._savePreferencesCallback);
    },

    /**
     * Clear custom shortcut keys in user preferences.
     */
    removeCustomizations: function() {
        var customShortcutsToDelete = [];

        this.$('[data-id]').each(function() {
            customShortcutsToDelete.push($(this).data('id'));
        });

        app.shortcuts.removeCustomShortcutKeys(customShortcutsToDelete, this._savePreferencesCallback);
    },

    /**
     * Close drawer once custom shortcut keys are saved.
     * @param {Object} error Error data from the server.
     * @private
     */
    _savePreferencesCallback: function(error) {
        var refreshHelp;

        if (error) {
            app.alert.show('preference-save-error', {
                level: 'error',
                messages: 'LBL_SHORTCUT_CONFIG_ERROR'
            });
        } else {
            refreshHelp = true;
        }

        app.drawer.close(refreshHelp);
    }
}) },
"dashlet-console-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletConsoleListView
 * @alias SUGAR.App.view.views.BaseDashletConsoleListView
 * @extends View.Views.Base.ListView
 */
({
	// Dashlet-console-list View (base) 

    extendsFrom: 'ListView',

    className: 'dashlet-console-list',

    /**
     * ListView sort will close previews, but this is not needed for dashlet console lists
     * In fact, closing preview causes problem when previewing this list dashlet
     * from dashlet-select
     */
    sort: $.noop,

    /**
     * These labels are used in the filter dropdown
     *  - labelDropdownTitle        label used as the dropdown title. ie `Filter`
     *  - labelAllRecordsFormatted  label used when all records are selected. ie `All <Module>s`
     */
    labelDropdownTitle: 'LBL_FILTER',
    labelAllRecords: 'LBL_FILTER_ALL_RECORDS',

    /**
     * @inheritdoc
     */
    dataView: '',

    /**
     * @inheritdoc
     */
    plugins: [
        'Dashlet',
        'Pagination',
        'ConfigDrivenList'
    ],

    /**
     * @inheritdoc
     */
    fallbackFieldTemplate: 'list',

    /**
     * The default settings for a list view dashlet.
     *
     * @property {Object}
     */
    _defaultSettings: {
        module: 'Cases',
        freeze_first_column: true,
        limit: 5,
        filter_id: 'all_records'
    },

    /**
     * The filter definition for selected filter
     *
     * @property {Array}
     */
    currentFilterDef: [],

    /**
     * The current search string in quick search bar
     *
     * @property {string}
     */
    currentSearch: '',

    /**
     * Cache of the modules a user is allowed to see.
     *
     * The keys are the module names and the values are the module names after
     * resolving them against module and/or app strings. The cache logic can be
     * seen in {@link BaseDashablelistView#_getAvailableModules}.
     *
     * @property {Object}
     */
    _availableModules: {
        'Cases': app.lang.getModuleName('Cases'),
        'Contacts': app.lang.getModuleName('Contacts')
    },

    /**
     * Flag indicates if a module is available for display.
     */
    moduleIsAvailable: true,

    /**
     * Flag to keep track the ACL access of the module
     */
    moduleACLAccess: true,

    /**
     * Truthy when filter dropdown is enabled.  Updated whenever the filter module changes.
     */
    filterDropdownEnabled: true,

    /**
     * Flag indicates if dashlet filter is accessible.
     */
    filterIsAccessible: true,

    /**
     * A list of all the filter models available
     *
     * @property {Array}
     */
    filterModels: [],

    /**
     * An object for different modules and their fields to filter results against
     *
     * @property {Object}
     */
    moduleFilterField: {
        Contacts: 'primary_contact_id',
    },

    /**
     * A list of all the modules available for custom filters
     *
     * @property {Array}
     */
    customFilterModuleList: ['Cases'],

    /**
     * Defines the scroll container jQuery element
     */
    scrollContainer: null,

    /**
     * @inheritdoc
     */
    'events': {
        'click .single': 'rowClicked',
        'click [class*="orderBy"]': 'setOrderBy',

        // filter quick search events
        'click .add-on.sicon-close': 'clearQuickSearch',
        'keyup .search-name': 'search',
        'paste .search-name': 'search',

        // filter dropdown events
        'click .choice-filter-close': 'handleClearFilter',
        'keydown .choice-filter-close': 'handleClearFilter',

        //dashlet action
        'click .sicon-refresh': 'refreshClicked',
    },

    /**
     * @inheritdoc
     *
     * Append lastStateID on metadata in order to active user cache. Load partials for dropdown selection and result.
     * Fix dropdown and other dashlet css on completion of reload
     */
    initialize: function(options) {
        options.meta = _.extend({}, options.meta, {
            last_state: {
                id: 'dashlet-console-list'
            }
        });
        this.currentFilterId = {};
        this._super('initialize', [options]);

        //Load partials
        this._select2formatSelectionTemplate = app.template.get('dashlet-console-list.selection-partial');
        this._select2formatResultTemplate = app.template.get('dashlet-console-list.result-partial');

        if (!_.isUndefined(this.collection)) {
            this.collection.on('data:sync:complete', function() {
                this._renderDropdown(this.filterModels[this.module]);
                if (this.currentFilterId[this.module] === this.layout.filters.collection.defaultFilterFromMeta) {
                    this.$('.choice-filter-close').hide();
                }

                var searchElem = this.$('input.search-name');
                this.updatePlaceholder(searchElem);

                // if search string is present but not displayed on the search bar
                if (!_.isEmpty(this.currentSearch) && searchElem.val() === '') {
                    // put back the search string after dashlet load
                    this.$('input.search-name').val(this.currentSearch);
                    this.toggleClearQuickSearchIcon(true);
                }

                this.checkFooterVisibility();
            }, this);
        }

        this.context.set('isUsingListPagination', true);
    },

    /**
     * Build the cache key for last filter.
     * @return {string} hash key.
     */
    getLastFilterKey: function() {
        return this.options.meta.last_state + '.' + this.module + '.last_filter_id';
    },

    /**
     * Get last filter id if cached.
     * @return {string|null} last filter id or null
     */
    getLastFilterId: function() {
        if (this.context.parent) {
            return this.context.parent.get(this.getLastFilterKey());
        }
        return null;
    },

    /**
     * Cache filter id.
     * @param {string} filterId
     */
    setLastFilterId: function(filterId) {
        if (this.context.parent) {
            this.context.parent.set(this.getLastFilterKey(), filterId);
        }
    },

    /**
     * Update quick search placeholder to Search by Field1, Field2, Field3 when the module changes
     * @param {Object} el
     */
    updatePlaceholder: function(el) {
        var filtersBeanPrototype = app.data.getBeanClass('Filters').prototype;
        var fields = filtersBeanPrototype.getModuleQuickSearchMeta(this.module).fieldNames;
        var fieldLabels = app.utils.getFieldLabels(this.module, fields);
        var label = app.lang.get('LBL_SEARCH_BY') + ' ' + fieldLabels.join(', ').toLowerCase() + '...';
        return el.attr('placeholder', label);
    },

    /**
     * select2 change handler to update the list based on selected filter
     *
     * @param {Event} evt
     */
    handleSelect: function(evt) {
        if (evt && evt.type === 'keydown' &&
            !(evt.keyCode === $.ui.keyCode.ENTER || evt.keyCode === $.ui.keyCode.SPACE)) {
            return;
        }
        evt.stopPropagation();
        this.setSelection(evt.val);
    },

    /**
     * Handle selection of a new filter dropdown value.
     *
     * @param {string} id The id of the filter to select in the dropdown.
     */
    setSelection: function(id) {
        this.currentFilterId[this.module] = id;

        var filter = this.layout.filters && this.layout.filters.collection ?
            this.layout.filters.collection.get(id) : {};
        var filterDef = !_.isEmpty(filter) ? filter.get('filter_definition') : [];

        filterDef = this.buildFilterDefinition(filterDef, this.currentSearch);
        this.currentFilterDef = filterDef;
        this.setLastFilterId(id);
        this._displayDashlet(filterDef);
    },

    /**
     * When a click happens on the close icon, clear the last filter and trigger selection of default filter
     *
     * @param {Event} evt
     * */
    handleClearFilter: function(evt) {
        if (evt && evt.type === 'keydown' &&
            !(evt.keyCode === $.ui.keyCode.ENTER || evt.keyCode === $.ui.keyCode.SPACE)) {
            return;
        }

        //This event is fired within .choice-filter and another event is attached to .choice-filter
        //We want to stop propagation so it doesn't bubble up.
        evt.stopPropagation();
        var filterId;
        if (this.currentFilterId[this.module] === this.layout.filters.collection.defaultFilterFromMeta) {
            filterId = 'all_records';
        } else {
            filterId = this.layout.filters.collection.defaultFilterFromMeta;
        }

        this.setSelection(filterId);
    },

    /**
     * Handler for refresh button or dashlet refresh click
     */
    refreshClicked: function() {
        this._displayDashlet(this.currentFilterDef);
    },

    /**
     * Render select2 filter dropdown
     * @param {Array} data array of all the available filter defs
     * @private
     */
    _renderDropdown: function(data) {
        this.filterNode = this.$('input.console-list-dropdown');

        this.filterNode.select2({
            data: data,
            multiple: false,
            minimumResultsForSearch: 7,
            formatSelection: _.bind(this.formatSelection, this),
            formatResult: _.bind(this.formatResult, this),
            formatResultCssClass: _.bind(this.formatResultCssClass, this),
            dropdownCss: {width: 'auto'},
            dropdownCssClass: 'search-filter-dropdown',
            escapeMarkup: function(m) {
                return m;
            },
            shouldFocusInput: function() {
                // We return false here so that we do not refocus on the field once
                // it has been blurred. If we return true, blur needs to happen
                // twice before it is really blurred.
                return false;
            },
            width: 'off'
        })
            .off('change')
            .on('change', _.bind(this.handleSelect, this));

        this.fixChoiceFilter(data);
        this.fixDropdownCss();
    },

    /**
     * Fix the choice-filter-label on first render
     *
     * @param {Array} data array of all the available filter defs
     */
    fixChoiceFilter: function(data) {
        var choiceElem = this.$('.choice-filter-label') || [];

        if (!_.isEmpty(choiceElem)) {
            _.each(data, function(value, key) {
                if (value.id === this.currentFilterId[this.module]) {
                    choiceElem[0].innerHTML = data[key].text;
                }
            }, this);
        }
    },

    /**
     * Fix the css for filter select2 dropdown on first render
     */
    fixDropdownCss: function() {
        var arrowElem = this.$('.select2-arrow') || [];
        var caratElem = this.$('.sicon.sicon-chevron-down') || [];
        var filterElem = this.$('.select2-chosen') || [];

        if (arrowElem.length !== 0) {
            arrowElem.remove();
        }

        if (caratElem.length === 0  && filterElem.length !== 0) {
            filterElem.append('<i class="sicon sicon-chevron-down"></i>');
        }
    },

    /**
     * Update the text for the selected filter and returns template
     *
     * @param {Object} item
     * @return {string} selection-partial template
     * */
    formatSelection: function(item) {
        var ctx = {};
        var safeString;
        var a11yLabel;
        var a11yTabindex = 0;

        //Don't remove this line. We want to update the selected filter name but don't want to change to the filter
        //name displayed in the dropdown
        item = _.clone(item);

        //Escape string to prevent XSS injection
        safeString = Handlebars.Utils.escapeExpression(item.text);
        a11yTabindex = 0;
        a11yLabel = app.lang.get('LBL_FILTER_EDIT_FILTER') + ' ' + safeString;

        // Update the text for the selected filter.
        this.$('.choice-filter-label')
            .html(safeString)
            .attr('aria-label', a11yLabel)
            .attr('tabindex', a11yTabindex);

        this.$('.choice-filter-close').toggle(item.id !== 'all_records');
        this.$('.choice-filter').toggleClass('with-close', item.id !== 'all_records');

        ctx.label = app.lang.get(this.labelDropdownTitle);
        ctx.enabled = this.filterDropdownEnabled;

        return this._select2formatSelectionTemplate(ctx);
    },

    /**
     * Returns template for all the select2 dropdown items
     *
     * @param {Object} option
     * @return {string} result-partial template
     * */
    formatResult: function(option) {
        if (option.id === this.currentFilterId[this.module]) {
            option.icon = 'sicon-check';
        } else {
            option.icon = undefined;
        }
        return this._select2formatResultTemplate(option);
    },

    /**
     * Adds a class to the first user custom filter (to add border top)
     *
     * @param {Object} item
     * @return {string} css class to attach
     */
    formatResultCssClass: function(item) {
        if (item.firstNonUserFilter) {
            return 'select2-result-border-top';
        }
    },

    /**
     * Fires the quick search.
     * @param {Event} event A keyup event.
     */
    throttledSearch: _.debounce(function(event) {
        this.applyQuickSearch(true, event.type);
    }, 400),

    /**
     * Wrapper to throttle search
     * @param {Event} event A keyup event.
     */
    search: function(event) {
        this.currentSearch = this.$('input.search-name').val();
        this.throttledSearch(event);
    },

    /**
     * Handler for clearing the quick search bar
     *
     * @param {Event} event A click event on the close button of search bar
     */
    clearQuickSearch: function(event) {
        this.currentSearch = '';
        this.$('input.search-name').val('');
        this.applyQuickSearch(true, event.type);
    },

    /**
     * Applies an updated filterdef with the current value on the quicksearch field.
     *
     * @param {boolean} force `true` to always trigger the `filter:apply`
     *   event, `false` otherwise. Defaults to `false`.
     * @param {string} evtType the type of event that triggered the quick search
     */
    applyQuickSearch: function(force, evtType) {
        force = !_.isUndefined(force) ? force : false;
        if (!force) {
            var searchElem = this.$('input.search-name');
            var newSearch = searchElem.val();

            if (this.currentSearch !== newSearch) {
                this.currentSearch = newSearch;
                force = true;
            }
        }

        if (force) {
            // an empty filterDef is the same as all_records filters, so we use that as our fallback
            var filterDef = this.buildFilterDefinition(this.currentFilterDef || [], this.currentSearch);

            this._displayDashlet(filterDef);

            // once the dashlet has loaded fix the filter and footer component
            this.collection.once('data:sync:complete', function() {
                this.toggleClearQuickSearchIcon(!_.isEmpty(this.currentSearch));

                var searchElem = this.$('input.search-name');
                if (!searchElem.val().length) {
                    searchElem.val(this.currentSearch);
                }

                // keep focus on input field for all keyup events only
                // not for click events on the clear button
                if (evtType === 'keyup') {
                    searchElem.focus();
                }

                this.checkFooterVisibility();
            }, this);
        }
    },

    /**
     * Append or remove an icon to the quicksearch input so the user can clear the search easily
     * @param {boolean} addIt TRUE if you want to add it, FALSE to remove
     */
    toggleClearQuickSearchIcon: function(addIt) {
        if (addIt && !this.$('.sicon-remove.add-on')[0]) {
            this.$('.filter-view.search').append('<i class="sicon sicon-close add-on"></i>');
        } else if (!addIt) {
            this.$('.sicon-remove.add-on').remove();
        }
    },

    /**
     * Builds the filter definition to pass to the request when doing a quick
     * search.
     *
     * It will combine the filter definition for the search term with the
     * initial filter definition. Both are optional, so this method may return
     * an empty filter definition (empty `array`).
     *
     * @param {Object} oSelectedFilter original Selected filter
     * @param {string} searchTerm The term typed in the quick search field.
     * @return {Array} The filter definition.
     */
    buildFilterDefinition: function(oSelectedFilter, searchTerm) {
        if (!app.metadata.getModule('Filters') || !this.layout.filters) {
            return [];
        }
        var filterBeanClass = app.data.getBeanClass('Filters').prototype;
        var selectedFilter = app.utils.deepCopy(oSelectedFilter);
        var searchTermFilter;
        var searchModule = this.module;

        selectedFilter = _.isArray(selectedFilter) ? selectedFilter : [selectedFilter];

        searchTermFilter = filterBeanClass.buildSearchTermFilter(searchModule, searchTerm);

        var isSelectedFilter = _.size(selectedFilter) > 0;
        var isSearchFilter = _.size(searchTermFilter) > 0;

        selectedFilter = this.filterSelectedFilter(selectedFilter);

        if (isSelectedFilter && isSearchFilter) {
            selectedFilter.push(searchTermFilter[0]);
            return [{'$and': selectedFilter}];
        } else if (isSelectedFilter) {
            return selectedFilter;
        } else if (isSearchFilter) {
            return searchTermFilter;
        }

        return [];
    },

    /**
     * Filter fields that don't exist either on vardefs or search definition.
     *
     * Special fields (fields that start with `$`) like `$favorite` aren't
     * cleared.
     * @param {Array} selectedFilter def for currently selected filter
     * @return {Array} filtered def
     */
    filterSelectedFilter: function(selectedFilter) {
        var specialField = /^\$/;
        var meta = app.metadata.getModule(this.module);
        selectedFilter = _.filter(selectedFilter, function(def) {
            var fieldName = _.keys(def).pop();
            return specialField.test(fieldName) || meta.fields[fieldName];
        }, this);

        return selectedFilter;
    },

    /**
     * Handler for row click event
     * Switches to relevant module tab
     *
     * @param {Event} evt row click event
     */
    rowClicked: function(evt) {
        var loadModel = [];
        var rowId = evt.currentTarget && evt.currentTarget.dataset ? evt.currentTarget.dataset.id : '';
        if (!_.isEmpty(rowId) && this.collection) {
            loadModel = _.filter(this.collection.models, function(model) {
                if (model.id === rowId) {
                    return model;
                }
            }, this);
        }

        var dashboard = this.closestComponent('omnichannel-dashboard');

        // set current row as model for the dashboard tab and switch tab based on module
        if (dashboard && loadModel.length !== 0) {
            dashboard.setModel(dashboard.moduleTabIndex[this.module], loadModel[0]);
            dashboard.switchTab(dashboard.moduleTabIndex[this.module]);
        }
    },

    /**
     * In case the filter for the dashlet has been retrieved successfully
     * a filter definition based dashlet setup will be triggered.
     *
     *  @param {Object} data object from specified filter request.
     */
    triggerDashletSetup: function(data) {
        this.filterIsAccessible = true;
        this.currentFilterDef = data.filter_definition;
        this._displayDashlet(data.filter_definition);
    },

    /**
     * Must implement this method as a part of the contract with the Dashlet
     * plugin. Kicks off the various paths associated with a dashlet:
     * Configuration, preview, and display.
     *
     * @param {string} view The name of the view as defined by the `oninit`
     *   callback in {@link DashletView#onAttach}.
     */
    initDashlet: function(view) {
        if (this.meta.config) {
            // keep the display_columns and label fields in sync with the selected module when configuring a dashlet
            this.settings.on('change:module', function(model, moduleName) {
                model.set('label', app.lang.getModuleName(moduleName, {plural: true}));

                // Re-initialize the filterpanel with the new module.
                this.dashModel.set('module', moduleName);
                this.dashModel.set('filter_id', 'all_records');
                this.layout.trigger('dashlet:filter:reinitialize');

                this._updateDisplayColumns();
            }, this);
        }
        this._initializeSettings();
        this.metaFields = this._getColumnsForDisplay();
        this.moduleACLAccess = app.acl.hasAccess('view', this.settings.get('module'));

        this.before('render', function() {
            if (!this.moduleIsAvailable || !this.filterIsAccessible) {
                return false;
            }
        });

        // the pivot point for the various dashlet paths
        if (this.meta.config) {
            this._configureDashlet();
            this.listenTo(this.layout, 'init', this._addFilterComponent);
            this.listenTo(this.layout.context, 'filter:add', this.updateDashletFilterAndSave);
            this.layout.before('dashletconfig:save', function() {
                this.saveDashletFilter();
                // NOTE: This prevents the drawer from closing prematurely.
                return false;
            }, this);
        } else if (this.moduleIsAvailable) {
            var filterId = this.settings.get('filter_id');
            if (!filterId || this.meta.preview || !this.moduleACLAccess) {
                this._displayDashlet();
                return;
            }

            var filters = app.data.createBeanCollection('Filters');
            filters.setModuleName(this.settings.get('module'));
            filters.load({
                success: _.bind(function() {
                    if (this.disposed) {
                        return;
                    }

                    var filterModelArr = [];
                    // get filter details to show on dashlet view dropdown
                    if (!_.isUndefined(filters.collection.models)) {
                        _.each(filters.collection.models, function(model) {
                            filterModelArr.push({
                                id: model.get('id'),
                                text: filters.collection._getTranslatedFilterName(model),
                                firstNonUserFilter: model.get('id') === 'all_records'
                            });
                        }, this);

                        // add filters to filterModels so they can be retrieved based on the module
                        this.filterModels[this.module] = filterModelArr;

                        // set filters for the layout if not already present
                        if (_.isUndefined(this.layout.filters)) {
                            this.layout.filters = filters;
                        }
                    }

                    // get current filter id and def
                    var filter = filters.collection.get(filterId);
                    if (!_.isUndefined(filter)) {
                        this.currentFilterDef = filter.get('filter_definition');
                        this.currentFilterId[this.module] = filter.get('id');
                    }

                    // In case the filter assigned to the list-dashlet is NOT in the filters collection,
                    // as collection only contains certain number (= max_filters) of entries.
                    // Will make a separate api call to fetch the specified filter data.
                    if (!this.currentFilterDef) {
                        var url = app.api.buildURL('Filters/' + filterId, null, null);
                        app.api.call('read', url, null, {
                            success: _.bind(this.triggerDashletSetup, this)
                        });
                    } else if (_.isUndefined(this.currentFilterDef)) {
                        this.filterIsAccessible = false;
                    } else {
                        this._displayDashlet(this.currentFilterDef);
                    }
                }, this),
                error: _.bind(function() {
                    if (this.disposed) {
                        return;
                    }
                    this._displayDashlet();
                }, this)
            });
        }
    },

    /**
     * Adds a custom filter to display cases relevant to Current Contact for the Contacts Tab in omnichannel-dashboard.
     * Here we update the current filter just before it gets applied and fetches data, so we only get relevant data.
     * This approach makes sure that the actual filter models are not overwritten so that they show default behavior
     * in other cases.
     *
     * @param {Array} filterDef the original filter definition to be applied
     * @return {Array} updated filter definition for the Cases dashlet in Contacts tab
     */
    updateFilterForModule: function(filterDef) {
        var dashboard = this.closestComponent('omnichannel-dashboard') || null;

        if (dashboard !== null) {
            var dashboardComp = !_.isUndefined(dashboard) && !_.isUndefined(dashboard.getComponent('dashboard')) ?
                dashboard.getComponent('dashboard') : null;
            var activeTab = !_.isUndefined(dashboardComp) && dashboardComp.getComponent('omnichannel-dashboard') ?
                dashboardComp.getComponent('omnichannel-dashboard').activeTab : 0;

            // if Contacts tab is active and it is Cases Console List view dashlet
            if (!_.isUndefined(dashboard.moduleTabIndex) &&
                activeTab === dashboard.moduleTabIndex.Contacts && this.module === this.customFilterModuleList[0]) {
                // get the model Id for current contact
                var rowId = !_.isUndefined(dashboard.context) && !_.isUndefined(dashboard.context.get('rowModel')) ?
                    dashboard.context.get('rowModel').id : '';

                // get the field to filter result against
                var field = this.moduleFilterField.Contacts || '';

                // create a custom filter to get cases relevant to current Contact
                if (rowId && !_.isEmpty(field)) {
                    var customFilterDef = {};
                    customFilterDef[field] =  {$equals: rowId};
                    // append the custom filter to the existing filter
                    filterDef.push(customFilterDef);
                }
            }
        }

        return filterDef;
    },

    /**
     * @inheritdoc
     * Don't load data if dashlet filter is not accessible.
     */
    loadData: function(options) {
        if (!this.filterIsAccessible) {
            if (options && _.isFunction(options.complete)) {
                options.complete();
            }
            return;
        }
        this._super('loadData', [options]);
    },

    /**
     * Fetch the next pagination records.
     */
    showMoreRecords: function() {
        // Show alerts for this request
        this.getNextPagination();
    },

    /**
     * Returns a custom label for this dashlet.
     *
     * @return {string}
     */
    getLabel: function() {
        var module = this.settings.get('module') || this.context.get('module');
        var moduleName = app.lang.getModuleName(module, {plural: true});
        return app.lang.get(this.settings.get('label'), module, {module: moduleName});
    },

    /**
     * This function is invoked by the `dashletconfig:save` event. If the dashlet
     * we are saving is a dashlet console list, it initiates the save process for a new
     * filter on the appropriate module's list view, otherwise, it takes the
     * `currentFilterId` stored on the context, and saves it on the dashlet.
     */
    saveDashletFilter: function() {
        // Accessing the dashletconfiguration context.
        var context = this.layout.context;

        if (context.editingFilter) {
            // We are editing/creating a new filter
            if (!context.editingFilter.get('name')) {
                context.editingFilter.set('name', app.lang.get('LBL_DASHLET') +
                    ': ' + app.lang.get(this.settings.get('label'), this.settings.get('module')));
            }
            // Triggers the save on `filter-rows` which then triggers
            // `filter:add` which then calls `updateDashletFilterAndSave`
            context.trigger('filter:create:save');
        } else {
            // We are saving a dashlet with a predefined filter
            var filterId = context.get('currentFilterId');
            var obj = {id: filterId};
            this.updateDashletFilterAndSave(obj);
        }
    },

    /**
     * This function is invoked by the `filter:add` event. It saves the
     * filter ID on the dashlet model prior to saving it, for later reference.
     *
     * @param {Bean} filterModel The saved filter model.
     */
    updateDashletFilterAndSave: function(filterModel) {
        // We need to save the filter ID on the dashlet model before saving
        // the dashlet.
        var id = filterModel.id || filterModel.get('id');
        this.settings.set('filter_id', id);
        this.dashModel.set('filter_id', id);

        var componentType = this.dashModel.get('componentType') || 'view';

        // Adding a new dashlet requires componentType to be set on the model.
        if (!this.dashModel.get('componentType')) {
            this.dashModel.set('componentType', componentType);
        }

        app.drawer.close(this.dashModel);

        // The filter collection is not shared amongst views and therefore
        // changes to this collection on different contexts (list views and
        // dashlets) need to be kept in sync.
        app.events.trigger('dashlet:filter:save', this.dashModel.get('module'));
    },

    /**
     * Certain dashlet settings can be defaulted.
     *
     * Builds the available module cache by way of the
     * {@link BaseDashletConsoleListView#_setDefaultModule} call. The module is set
     * after "filter_id" because the value of "filter_id" could impact the value
     * of "label" when the label is set in response to the module change while
     * in configuration mode (see the "module:change" listener in
     * {@link BaseDashletConsoleListView#initDashlet}).
     *
     * @private
     */
    _initializeSettings: function() {
        if (!this.settings.get('limit')) {
            this.settings.set('limit', this._defaultSettings.limit);
        }
        if (this.getLastFilterId()) {
            this.settings.set('filter_id', this.getLastFilterId());
        }
        if (!this.settings.get('filter_id')) {
            this.settings.set('filter_id', this._defaultSettings.filter_id);
        }
        if (_.isUndefined(this.settings.get('freeze_first_column'))) {
            this.settings.set('freeze_first_column', this._defaultSettings.freeze_first_column);
        }
        this._setDefaultModule();
        if (!this.settings.get('label')) {
            this.settings.set('label', 'LBL_MODULE_NAME');
        }
    },

    /**
     * Sets the default module when a module isn't defined in the dashlet's
     * view definition.
     *
     * If the module was defined but it is not in the list of available modules
     * in config mode, then the view's module will be used.
     * @private
     */
    _setDefaultModule: function() {
        var availableModules = _.keys(this._getAvailableModules());
        var module = this.settings.get('module') || this.context.get('module');

        if (_.contains(availableModules, module)) {
            this.settings.set('module', module);
        } else if (this.meta.config) {
            module = _.first(availableModules);
            // On 'initialize' model is set to context's model - that model can have no access at all
            // and we'll result in 'no-access' template after render. So we change it to default model.
            this.model = app.data.createBean(module);
            this.settings.set('module', module);
        } else {
            this.moduleIsAvailable = false;
        }
    },

    /**
     * Update the display_columns attribute based on the current module defined
     * in settings.
     *
     * This will mark, as selected, all fields in the module's list view
     * definition. Any existing options will be replaced with the new options
     * if the "display_columns" DOM field ({@link EnumField}) exists.
     *
     * @private
     */
    _updateDisplayColumns: function() {
        var availableColumns = this._getAvailableColumns();
        this.settings.set('display_columns', _.keys(availableColumns));
    },

    /**
     * Perform any necessary setup before the user can configure the dashlet.
     *
     * Modifies the dashlet configuration panel metadata to allow it to be
     * dynamically primed prior to rendering.
     *
     * @private
     */
    _configureDashlet: function() {
        var availableModules = this._getAvailableModules();
        var availableColumns = this._getAvailableColumns();
        _.each(this.getFieldMetaForView(this.meta), function(field) {
            switch (field.name) {
                case 'module':
                    // load the list of available modules into the metadata
                    field.options = availableModules;
                    break;
                case 'display_columns':
                    // load the list of available columns into the metadata
                    field.options = availableColumns;
                    break;
            }
        });

        // From ConfigDrivenList Plugin
        this.filterConfigFieldsForDashlet();
    },

    /**
     * This function adds the `dashablelist-filter` component to the layout
     * (dashletconfiguration), if the component doesn't already exist.
     */
    _addFilterComponent: function() {
        var filterComponent = this.layout.getComponent('dashablelist-filter');
        if (filterComponent) {
            return;
        }

        this.layout.initComponents([{
            layout: 'dashablelist-filter'
        }]);
    },

    /**
     * Gets all of the modules the current user can see.
     *
     * This is used for populating the module select and list view columns
     * fields.
     *
     * @return {Object} {@link BaseDashletConsoleListView#_availableModules}
     * @private
     */
    _getAvailableModules: function() {
        return this._availableModules;
    },

    /**
     * Gets the correct list view metadata.
     *
     * Returns the correct module list metadata
     *
     * @param  {string} module
     * @return {Object}
     */
    _getListMeta: function(module) {
        return app.metadata.getView(module, 'list');
    },

    /**
     * Gets all of the fields from the list view metadata for the currently
     * chosen module.
     *
     * This is used for the populating the list view columns field and
     * displaying the list.
     *
     * @return {Object} columns A key value pair of all the available columns
     * @private
     */
    _getAvailableColumns: function() {
        var columns = {};
        var module = this.settings.get('module');
        if (!module) {
            return columns;
        }

        _.each(this.getFieldMetaForView(this._getListMeta(module)), function(field) {
            columns[field.name] = app.lang.get(field.label || field.name, module);
        });

        return columns;
    },

    /**
     * Perform any necessary setup before displaying the dashlet.
     *
     * @param {Array} filterDef The filter definition array.
     * @private
     */
    _displayDashlet: function(filterDef) {
        // Get the columns that are to be displayed and update the panel metadata.
        var columns = this._getColumnsForDisplay();
        this.meta.panels = [{fields: columns}];

        this.context.set('skipFetch', false);
        this.context.set('limit', this.settings.get('limit'));
        this.context.set('fields', this.getFieldNames());

        if (filterDef) {
            this._applyFilterDef(filterDef);
            this.context.reloadData({
                recursive: false,
            });
        } else {
            var listBottom = this.layout.getComponent('list-bottom');
            if (listBottom) {
                listBottom.render();
            }
        }

        this._startAutoRefresh();
    },

    /**
     * Hide the No data available footer if dashlet has rows
     */
    checkFooterVisibility: function() {
        var footerElem = this.$('.block-footer') || [];
        if (footerElem.length === 0) {
            return;
        }

        var row = this.$('.dashlet-console-list-row') || [];
        if (row.length !== 0) {
            footerElem.hide();
        }
    },

    /**
     * Sets the filter definition on the context collection to retrieve records
     * for the list view.
     *
     * @param {Array} filterDef The filter definition array.
     * @private
     */
    _applyFilterDef: function(filterDef) {
        if (filterDef) {
            filterDef = _.isArray(filterDef) ? filterDef : [filterDef];

            filterDef = this.filterSelectedFilter(filterDef);

            if (!_.isUndefined(this.context) && !_.isUndefined(this.context.get('collection'))) {
                // get custom filter def for Contacts tab if needed
                filterDef = this.updateFilterForModule(filterDef);

                this.context.get('collection').filterDef = filterDef;
            }
        }
    },

    /**
     * Gets the columns chosen for display for this dashlet list.
     *
     * The display_columns setting might not have been defined when the dashlet
     * is being displayed from a metadata definition, all columns for
     * the selected module are shown in these cases.
     *
     * @return {Object[]} Array of objects defining the field metadata for
     *   each column.
     * @private
     */
    _getColumnsForDisplay: function() {
        var columns = [];
        var fields = this.getFieldMetaForView(this._getListMeta(this.settings.get('module')));
        var moduleMeta = app.metadata.getModule(this.module);
        if (!this.settings.get('display_columns')) {
            this._updateDisplayColumns();
        }

        _.each(this.settings.get('display_columns'), function(name) {
            var field = _.find(fields, function(field) {
                return field.name === name;
            }, this);
            // It's possible that a column is on the dashlet and not on the
            // main list view (thus was never patched by metadata-manager).
            // We need to fix up the columns in that case.
            field = field || app.metadata._patchFields(this.module, moduleMeta, [name]);

            // Handle setting of the sortable flag on the list. This will not
            // always be true
            var sortableFlag;
            var fieldDef = app.metadata.getModule(this.module).fields[field.name];

            // If the module's field def says nothing about the sortability, then
            // assume it's ok to sort
            if (_.isUndefined(fieldDef) || _.isUndefined(fieldDef.sortable)) {
                sortableFlag = true;
            } else {
                // Get what the field def says it is supposed to do
                sortableFlag = fieldDef.sortable;
            }

            var column = _.extend({sortable: sortableFlag}, field);

            columns.push(column);
        }, this);
        return columns;
    },

    /**
     * Starts the automatic refresh of the dashlet.
     *
     * @private
     */
    _startAutoRefresh: function() {
        var refreshRate = parseInt(this.settings.get('auto_refresh'), 10);
        if (refreshRate) {
            this._stopAutoRefresh();
            this._timerId = setInterval(_.bind(function() {
                this.context.resetLoadFlag();
                this.layout.loadData();
            }, this), refreshRate * 1000 * 60);
        }
    },

    /**
     * Cancels the automatic refresh of the dashlet.
     *
     * @private
     */
    _stopAutoRefresh: function() {
        if (this._timerId) {
            clearInterval(this._timerId);
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this.currentSearch = this.$('input.search-name').val();
        if (!this.meta || !this.meta.config) {
            this._super('_render');
            this.scrollContainer = this.$el.find('.console-list-view-table');
        } else {
            this.action = 'list';
            this._super('_render');
        }
    },

    /**
     * Gets the fields metadata from a particular view's metadata.
     *
     * @param {Object} meta The view's metadata.
     * @return {Object[]} The fields metadata or an empty array.
     */
    getFieldMetaForView: function(meta) {
        meta = _.isObject(meta) ? meta : {};
        return !_.isUndefined(meta.panels) ? _.flatten(_.pluck(meta.panels, 'fields')) : [];
    },

    /**
     * @inheritdoc
     *
     * Calls {@link BaseDashletConsoleListView#_stopAutoRefresh} so that the refresh will
     * not continue after the view is disposed.
     *
     * @private
     */
    _dispose: function() {
        this._stopAutoRefresh();
        this._super('_dispose');
    },
}) },
"omnichannel-search-list-bottom": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.OmnichannelSearchListBottomView
 * @alias SUGAR.App.view.views.BaseOmnichannelSearchListBottomView
 * @extends View.Views.Base.ListBottomView
 */
({
	// Omnichannel-search-list-bottom View (base) 

    plugins: ['Pagination'],
    extendsFrom: 'ListBottomView',

    events: {
        'click [data-action="show-more"]': 'showMoreRecords'
    },

    /**
     * Flag for if the loading placeholder text should be hidden or not
     *
     * @property {boolean}
     */
    showLoading: false,

    initialize: function(options) {
        this._super('initialize', [options]);

        // Share the same collection as other views in the parent layout
        this.collection = this.layout.collection;
        this.collection.on('sync', this._renderAfterFetch, this);

        this.action = 'list';

        this._initPagination();

        this._showMoreLabel = this.meta && this.meta.label || 'TPL_SHOW_MORE_MODULE';

        // Listener for when a search is triggered. Show "Loading..."
        app.events.on('omnichannelsearch:bar:search:started', this._showLoading, this);
        this.layout.on('omnichannelsearch:filtering:started', this._showLoading, this);
    },

    /**
     * Handles rerendering the view after the collection has been re-fetched
     *
     * @private
     */
    _renderAfterFetch: function() {
        this.showLoading = false;
        this.render();
    },

    /**
     * Initialize pagination component in order to react the show more link.
     * @private
     */
    _initPagination: function() {
        this.paginationComponent = _.find(this.layout._components, function(component) {
            return _.contains(component.plugins, 'Pagination');
        }, this);
    },

    /**
     * Show "Loading..."
     * @private
     */
    _showLoading: _.debounce(function() {
        this.collection.dataFetched = false;
        this.showLoading = true;
        this.render();
        this.layout.trigger('omnichannelsearch:clear:results');
    }, 200),

    /**
     * Retrieving the next page records by pagination plugin.
     *
     * Please see the {@link app.plugins.Pagination#getNextPagination}
     * for detail.
     */
    showMoreRecords: function() {
        if (!this.paginationComponent) {
            return;
        }

        this.collection.offset = this.collection.next_offset;
        this.collection.showMore = true;
        this._showLoading();
        this.collection.dataFetched = true;
        this.getNext();
        this.render();
    },

    /**
     * Waits for 0.1 seconds before calling getNextPagination
     * from pagination component
     */
    getNext: _.debounce(function(options) {
        this.paginationComponent.getNextPagination(options);
    }, 100),

    /**
     * Assign proper label for 'show more' link.
     * Label should be "More <module name>..." if module_list contains one module.
     * Label should be "More search results..." if module_list contains multiple modules.
     */
    setShowMoreLabel: function() {
        if (!this.collection) {
            return;
        }
        if (this.collection.dataFetched &&
            !_.isEmpty(this.collection.models) &&
            !_.isEmpty(this.collection.module_list)) {
            if (this.collection.module_list.length > 1) {
                this.showMoreLabel = app.lang.get('LBL_SHOW_MORE_RESULTS');
            } else {
                var model = this.collection.models[0] ? this.collection.models[0] : {};
                var module = model ? model.get('_module') : '';
                var context = {
                    count: this.collection.length,
                    offset: this.collection.next_offset >= 0
                };
                if (module) {
                    context.module = new Handlebars.SafeString(
                        app.lang.getModuleName(module, {plural: true}).toLowerCase()
                    );
                }
                this.showMoreLabel = app.lang.get(this._showMoreLabel, module, context);
            }
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.collection.off('sync', this._renderAfterFetch, this);
        app.events.off('omnichannelsearch:bar:search:started', this._showLoading, this);
        this.layout.off('omnichannelsearch:filtering:started', this._showLoading, this);
        this._super('_dispose');
    }
}) },
"massupdate-progress": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MassupdateProgressView
 * @alias SUGAR.App.view.views.BaseMassupdateProgressView
 * @extends View.View
 */
({
	// Massupdate-progress View (base) 

    plugins: ['Editable'],

    events: {
        'click [name=btn-stop]': 'pauseUpdate'
    },

    /**
     * Total number of records.
     *
     * @property
     */
    totalRecord: 0,

    /**
     * Executed datetime in milliseconds.
     *
     * @property
     */
    _startTime: 0,

    /**
     * Speed of last executed job.
     *
     * @property
     */
    _velocity: 0,

    /**
     * HTML Elements that needs to update dynamically.
     *
     * @property
     */
    $holders: {},

    /**
     * Set of labels.
     *
     * @property
     */
    _labelSet: {
        'update': {
            PROGRESS_STATUS: 'TPL_MASSUPDATE_PROGRESS_STATUS',
            DURATION_FORMAT: 'TPL_MASSUPDATE_DURATION_FORMAT',
            FAIL_TO_ATTEMPT: 'TPL_MASSUPDATE_FAIL_TO_ATTEMPT',
            WARNING_CLOSE: 'TPL_MASSUPDATE_WARNING_CLOSE',
            WARNING_INCOMPLETE: 'TPL_MASSUPDATE_WARNING_INCOMPLETE',
            SUCCESS: 'TPL_MASSUPDATE_SUCCESS',
            TITLE: 'TPL_MASSUPDATE_TITLE'
        },
        'delete': {
            PROGRESS_STATUS: 'TPL_MASSDELETE_PROGRESS_STATUS',
            DURATION_FORMAT: 'TPL_MASSDELETE_DURATION_FORMAT',
            FAIL_TO_ATTEMPT: 'TPL_MASSDELETE_FAIL_TO_ATTEMPT',
            WARNING_CLOSE: 'TPL_MASSDELETE_WARNING_CLOSE',
            WARNING_INCOMPLETE: 'TPL_MASSDELETE_WARNING_INCOMPLETE',
            SUCCESS: 'TPL_MASSDELETE_SUCCESS',
            TITLE: 'TPL_MASSDELETE_TITLE'
        }
    },

    /**
     * @inheritdoc
     * Check if current process job is completed.
     *
     * @return {boolean} If this process job is not completed, it returns true.
     */
    hasUnsavedChanges: function() {
        return (this.totalRecord > 0);
    },

    /**
     * Initialize the job collection set.
     *
     * @param {Backbone.Collection} collection Selected set of models.
     */
    initCollection: function(collection) {
        this.unbindData();
        this.collection = collection;
        this.hide();
        this.bindDataChange();
    },

    /**
     * Returns action name.
     *
     * @return {string}
     */
    getCurrentMethod: function() {
        return this.collection.method || this.collection.defaultMethod;
    },

    /**
     * Initialize the labels.
     */
    initLabels: function() {
        this.LABELSET = this._labelSet[this.getCurrentMethod()];
    },

    /**
     * Initialize the dynamic DOM elements into the variable,
     * in order to avoid the multiple jQuery selector.
     */
    initHolders: function() {
        var self = this;
        self.$holders = {};
        this.$('[data-holder]').each(function(holder) {
            var $el = $(this);
            self.$holders[$el.data('holder')] = $el;
        });
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        this.offBefore('start');
        this.off('render', null, this);
        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * @inheritdoc
     * Bind the listeners for each massupdate status.
     */
    bindDataChange: function() {
        if (!this.collection) {
            return;
        }
        this.on('render', this.initHolders, this);
        this.collection.on('massupdate:always', this.updateProgress, this);
        this.collection.on('massupdate:start', this.showProgress, this);
        this.collection.on('massupdate:end', this.hideProgress, this);
        this.collection.on('massupdate:fail', this.checkError, this);
        this.collection.on('massupdate:resume', this.resumeProcess, this);
        this.collection.on('massupdate:pause', this.pauseProcess, this);
    },

    /**
     * Check current job occurs error or not.
     *
     * If api retry the attempt,
     * it displays api failure error message in the alert bar.
     */
    checkError: function() {
        if (this.collection.attempt === 0) {
            this.$holders.bar
                .addClass('progress-info')
                .removeClass('progress-danger');
            return;
        } else if (this.collection.attempt > this.collection.maxAllowAttempt) {
            return;
        }
        this.$holders.bar
            .removeClass('progress-info')
            .addClass('progress-danger');
        app.alert.dismiss('stop_confirmation');
        app.alert.show('stop_confirmation', {
            level: 'error',
            messages: app.lang.get(this.LABELSET['FAIL_TO_ATTEMPT'], this.module, {
                num: this.collection.attempt,
                total: this.collection.maxAllowAttempt
            })
        });
    },

    /**
     * Estimate remaining time.
     *
     * @return {Number} Remaining seconds.
     */
    getEstimate: function() {
        if (!this.collection.chunks) {
            return 0;
        }
        var chunkSize = this.collection.chunks.length,
            remainSize = this.collection.length,
            duration = (new Date().getTime() - this._startTime) / 1000;
        this._startTime = new Date().getTime();
        this._velocity = chunkSize / duration; //amount per sec

        return parseInt(remainSize / this._velocity, 10);
    },

    /**
     * Convert numeric time into the relative time.
     * @param {Number} elapsed Numeric time.
     * @return {String} Converted string time.
     *   Returns empty unless condition is satisfied.
     */
    getRelativeTime: function(elapsed) {
        var msPerMinute = 60,
            msPerHour = msPerMinute * 60,
            msPerDay = msPerHour * 24,
            unitString = '',
            relateTime = 0;

        if (elapsed <= 0) {
            return '';
        }

        if (elapsed < msPerMinute) {
            relateTime = elapsed;
            unitString = app.lang.get('LBL_DURATION_SECONDS');
        } else if (elapsed < msPerHour) {
            relateTime = Math.round(elapsed / msPerMinute);
            unitString = app.lang.get('LBL_DURATION_MINUTES');
        } else if (elapsed < msPerDay) {
            relateTime = Math.round(elapsed / msPerHour);
            unitString = app.lang.get('LBL_DURATION_HOUR');
        } else {
            //too huge
            return '';
        }

        return app.lang.get(this.LABELSET['DURATION_FORMAT'], this.collection.baseModule, {
            time: relateTime,
            unit: unitString
        });
    },

    /**
     * Returns number of total elements for progress.
     *
     * @return {Number} Number of total elements.
     */
    getTotalRecords: function() {
        return this.collection.length;
    },

    /**
     * Calculate remaining records.
     *
     * @return {Number} Remaining size.
     */
    getRemainder: function() {
        var chunkSize = _.isEmpty(this.collection.chunks) ? 0 : this.collection.chunks.length,
            size = _.min([this.collection.models.length, this.collection.length + chunkSize]);

        return size;
    },

    /**
     * Calculate current progress size.
     * Include the completed queue size and current executing chunk size.
     *
     * @return {Number} Progress size.
     */
    getProgressSize: function() {
        var chunkSize = _.isEmpty(this.collection.chunks) ? 0 : this.collection.chunks.length,
            size = _.min([this.totalRecord, this.totalRecord - this.collection.length + chunkSize]);

        return size;
    },

    /**
     * Calculate completed size.
     *
     * @return {Number} Completed size.
     */
    getCompleteRecords: function() {
        return this.totalRecord - this.collection.length;
    },

    /**
     * Calculate number of failed updates.
     *
     * @return {Number} Number of failed updates.
     */
    getFailedRecords: function() {
        return this.collection.numFailures;
    },

    /**
     * Resume the mass job once user were requested to resume.
     * Update screen in proper way.
     */
    resumeUpdate: function() {
        this.collection.resumeFetch();
    },

    /**
     * Request pausing the mass job once user were requested to pause.
     * Update screen in proper way.
     */
    pauseUpdate: function() {
        var stopButton = this.getField('btn-stop');
        stopButton.setDisabled(true);
        this.collection.pauseFetch();
    },

    /**
     * Update the progress view when the job is paused.
     */
    pauseProcess: function() {
        this.$holders.bar.removeClass('active');
        app.alert.dismiss('stop_confirmation');
        app.alert.show('stop_confirmation', {
            level: 'confirmation',
            messages: app.lang.get(this.LABELSET['WARNING_CLOSE'], this.module, {
                num: this.getRemainder()
            }),
            onConfirm: _.bind(this.hideProgress, this),
            onCancel: _.bind(this.resumeUpdate, this),
            autoClose: false
        });
    },

    /**
     * Update the progress view when the job is resumed.
     */
    resumeProcess: function() {
        this.$holders.bar.addClass('active');
        var stopButton = this.getField('btn-stop');
        stopButton.setDisabled(false);
    },

    /**
     * Start displaying the progress view.
     */
    showProgress: function() {
        this.initLabels();
        this.totalRecord = this.getTotalRecords();
        this._startTime = new Date().getTime();

        //restore back previous button status.
        var stopButton = this.getField('btn-stop');
        if (stopButton) {
            stopButton.setDisabled(false);
        }

        var title = app.lang.get(this.LABELSET.TITLE, this.module, {
            module: app.lang.getModuleName(this.module, {plural: true})
        });
        this.$holders.title.text(title);

        this.updateProgress();
        this.show();
    },

    /**
     * Finish displaying the pregress view.
     * Reset current mass job.
     */
    hideProgress: function() {
        var size = this.getCompleteRecords(),
            discardSize = this.collection.discards.length,
            failed = this.getFailedRecords();
        // "failed" records may mean field acl restrictions on "update" action
        if (discardSize > 0 || (this.getCurrentMethod() == 'update' && failed > 0)) {
            //permission warning
            var message = app.lang.get(this.LABELSET['SUCCESS'], this.module, {
                num: this.totalRecord - discardSize - failed
            });
            message += ' ' + app.lang.get('TPL_MASSUPDATE_WARNING_PERMISSION', this.module, {
                remain: discardSize + failed
            });
            app.alert.show('massupdate_final_notice', {
                level: 'warning',
                messages: message,
                autoClose: true,
                autoCloseDelay: 8000
            });
        } else if (this.totalRecord !== size || failed > 0) {
            //incomplete
            app.alert.show('massupdate_final_notice', {
                level: 'warning',
                messages: app.lang.get(this.LABELSET['WARNING_INCOMPLETE'], this.module, {
                    num: this.getRemainder() + failed
                }),
                autoClose: true,
                autoCloseDelay: 8000
            });
        } else {
            //successfully complete
            app.alert.show('massupdate_final_notice', {
                level: 'success',
                messages: app.lang.get(this.LABELSET['SUCCESS'], this.module, {
                    num: size
                }),
                autoClose: true,
                autoCloseDelay: 8000
            });
        }
        this.totalRecord = 0;
        this.collection.resetProgress();
        this.hide();
    },

    /**
     * Update current progress status.
     */
    updateProgress: function() {
        if (!this.collection || this.collection.length === 0) {
            return;
        }

        var estimate = this.getEstimate(),
            estimateMessage = this.getRelativeTime(estimate),
            size = this.getProgressSize(),
            percent = (size * 100 / this.totalRecord),
            message = app.lang.get(this.LABELSET['PROGRESS_STATUS'], this.module, {
                num: size,
                percent: Math.round(percent),
                total: this.totalRecord
            });
        if (!_.isEmpty(estimateMessage)) {
            this.$holders.estimate.text(estimateMessage);
        }
        this.checkError();
        this.$holders.message.text(message);
        this.$holders.progressbar.css({'width': percent + '%'});
    }
}) },
"resolve-conflicts-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ResolveConflictsHeaderpaneView
 * @alias SUGAR.App.view.views.BaseResolveConflictsHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Resolve-conflicts-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    /**
     * Register event handlers for the buttons and set the title.
     * @param options
     */
    initialize: function(options) {
        this.events = _.extend({}, this.events, {
            'click [name=select_button]': 'selectClicked',
            'click [name=cancel_button]': 'cancelClicked'
        });

        this._super('initialize', [options]);

        this.context.on("change:selection_model", this.enableSelectButton, this);
    },

    /**
     * @inheritdoc
     */
    _formatTitle: function(title) {
        var modelToSave = this.context.get('modelToSave'),
            name = modelToSave.get('name') || modelToSave.get('full_name');

        return app.lang.get(title, this.module, {name: name});
    },

    /**
     * Perform action according to whether the client's or database's data was selected.
     * @param event
     */
    selectClicked: function(event) {
        var selected = this.context.get('selection_model'),
            modelToSave = this.context.get('modelToSave'),
            dataInDb = this.context.get('dataInDb'),
            origin;

        if (selected instanceof Backbone.Model) {
            origin = selected.get('_dataOrigin');
            if (origin === 'client') {
                modelToSave.set('date_modified', dataInDb.date_modified);
                app.drawer.close(modelToSave, false);
            } else if (origin === 'database') {
                modelToSave.set(dataInDb);
                // trigger sync so that synced attributes are reset
                modelToSave.trigger('sync');
                app.drawer.close(modelToSave, true);
            }
        }
    },

    /**
     * Enable select button when a row has been selected.
     * @param context
     * @param selected
     */
    enableSelectButton: function(context, selected) {
        if (selected) {
            this.$('[name=select_button]').removeClass('disabled');
        }
    },

    /**
     * Close the drawer when cancel is clicked.
     * @param event
     */
    cancelClicked: function(event) {
        app.drawer.close();
    }
}) },
"contentsearchdashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
* @class View.Views.Base.ContentsearchdashletView
* @alias SUGAR.App.view.views.BaseContentsearchdashletView
* @extends View.View
*/
({
	// Contentsearchdashlet View (base) 

    plugins: ['Dashlet', 'Previewable'],

    events: {
        'click [data-action="create-case"]': 'initCaseCreation',
        'keyup [data-action="search"]': 'searchCases'
    },

    /**
     * Search options.
     * @property {Object}
     */
    searchOptions: {
        max_num: 4,
        module_list: 'KBContents'
    },

    /**
     * Maximum number of characters of search results to display.
     * @property {number}
     */
    maxChars: 500,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this._setPropertiesData();
    },

    /**
     * Set initial properties
     *
     * @private
     */
    _setPropertiesData: function() {
        this.module = 'Cases';
        this.caseDeflection = this.isCaseDeflectionEnabled();
        this.canCreateCase = app.acl.hasAccess('create', this.module);
        this.greeting = this._getGreeting();
        this.searchDropdown = null;

        this.enabled = _.isUndefined(app.config.searchBar) || app.config.searchBar;
        this.bannerBackgroundStyle = app.config.bannerBackgroundStyle || 'default';
        this.bannerBackgroundColor = app.config.bannerBackgroundColor || '#ffffff';
        this.bannerBackgroundImage = app.config.bannerBackgroundImage || '';

        this.context.on('page:clicked', this._search, this);
    },

    /**
     * Additional 'data:preview' callbacks to be invoked from Previewable
     *
     * @param hasChanges
     * @param data
     */
    dataPreviewCallbacks: function(hasChanges, data) {
        if (!hasChanges || !data.properties || _.isEmpty(data.properties)) {
            return;
        }
        var bannerProperties = ['bannerBackgroundStyle', 'bannerBackgroundColor', 'bannerBackgroundImage'];
        var isBannerProperty = _.intersection(data.properties, bannerProperties).length > 0;
        if (isBannerProperty) {
            this.updateBannerBackgroundStyle();
        }
    },

    /**
     * Util to get the text displayed above search bar
     * @return {string}
     * @private
     */
    _getGreeting: function() {
        var greeting = app.config.searchBarText || '';
        if (greeting) {
            return greeting.replace('{{full-name}}', app.user.get('full_name'));
        }
        return app.lang.get(this.meta.default_greeting, this.module, {
            username: app.user.get('full_name')
        });
    },

    /**
     * Gets search and display options from dashlet settings if exist.
     */
    initDashlet: function() {
        this.searchOptions = {
            module_list: this.settings.get('module_list') || this.searchOptions.module_list,
            max_num: this.settings.get('max_num') || this.searchOptions.max_num
        };
        this.maxChars = this.settings.get('max_chars') || this.maxChars;
    },

    /**
     * Checks if case deflection is enabled. In case it is enabled the dashlet
     * will render a search bar for the users, if not it will render a message
     * with the case creation button.
     *
     * @return {boolean} True if case deflection is enabled.
     */
    isCaseDeflectionEnabled: function() {
        return _.isUndefined(app.config.caseDeflection) ||
            app.config.caseDeflection === 'enabled';
    },

    /**
     * Will display the case creation drawer from where
     * the users are able to create a new case.
     */
    initCaseCreation: function() {
        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                module: 'Cases'
            }
        });
    },

    /**
     * Starts a new search and show the search results dropdown.
     */
    searchCases: _.debounce(function() {
        var $input = this.$('input[data-action=search]');
        var term = $input.val().trim();

        if (term === '') {
            if (this.searchDropdown) {
                this.searchDropdown.hide();
            }
            return;
        }

        this.searchOptions.q = term;

        if (_.isNull(this.searchDropdown)) {
            this.searchDropdown = app.view.createLayout({
                context: this.context,
                name: 'contentsearch-dropdown',
                module: 'Cases'
            });
            this.searchDropdown.initComponents();
            this.layout._components.push(this.searchDropdown);
            this.searchDropdown.render();
            $input.after(this.searchDropdown.$el);
        }

        this.searchDropdown.hide();
        this.context.trigger('data:fetching');
        this.searchDropdown.show();
        this._search();
    }, 400),

    /**
     * Calls search api
     *
     * @param {Object} options The search options
     * @private
     */
    _search: function(options) {
        var pageNumber = options && options.pageNum || 1;
        var offset = (pageNumber - 1) * this.searchOptions.max_num;
        var params = _.extend({}, this.searchOptions, {offset: offset});
        var url = app.api.buildURL('genericsearch', null, null, params);
        app.api.call('read', url, null, {
            success: _.bind(function(result) {
                if (this.disposed) {
                    return;
                }
                if (this.context) {
                    var data = this._parseData(result);
                    this.context.trigger('data:fetched', data);
                }
            }, this)
        });
    },

    /**
     * Parses search results.
     *
     * @param {Object} result The search result
     * @return {Object} parsed data
     * @private
     */
    _parseData: function(result) {
        var self = this;
        var totalPages = result.total > 0 ?
            Math.ceil(result.total / this.searchOptions.max_num) : 0;
        var currentPage = result.next_offset > 0 ?
            result.next_offset / this.searchOptions.max_num : totalPages;
        var records = _.map(result.records, function(record) {
            return {
                name: record.name,
                description: self._truncate(record.description),
                url: app.utils.buildUrl(record.url.replace(/^\/+/g, ''))
            };
        });
        return {
            options: this.searchOptions,
            currentPage: currentPage,
            records: records,
            totalPages: totalPages
        };
    },

    /**
     * Truncates search result so it is shorter than the maxChars
     * Only truncate on full words to prevent ellipsis in the middle of words
     * @param {string} text The search result entry to truncate
     * @return {string} the shortened version of an entry
     * @private
     */
    _truncate: function(text) {
        text = text || '';

        if (text.length > this.maxChars) {
            var cut = text.substring(0, this.maxChars);
            // cut at a full word
            while (!(/\s/.test(cut[cut.length - 1])) && cut.length > 0) {
                cut = cut.substring(0, cut.length - 1);
            }
            text = cut + '...';
        }

        return text;
    },

    /**
     * Update the banner background with the specified style.
     */
    updateBannerBackgroundStyle: function() {
        var backgrounds = {
            default: '',
            color: this.bannerBackgroundColor,
            image: 'url(' + this.bannerBackgroundImage + ') center/cover'
        };
        this.$el.css({
            background: backgrounds[this.bannerBackgroundStyle]
        });
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this.updateBannerBackgroundStyle();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.context) {
            this.context.off('page:clicked', null, this);
        }
    }
}) },
"planned-activities": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @inheritdoc
 *
 * Planned Activities dashlet takes advantage of the tabbed dashlet abstraction
 * by using its metadata driven capabilities to configure its tabs in order to
 * display planned activities of specific modules.
 *
 * Besides the metadata properties inherited from Tabbed dashlet, Planned Activities
 * dashlet also supports other properties:
 *
 * - {Array} invitation_actions field def for the invitation actions buttonset
 *           triggers showing invitation actions buttons and corresponding collection
 *
 * - {Array} overdue_badge field def to support overdue calculation, and showing
 *   an overdue badge when appropriate.
 *
 * @class View.Views.Base.PlannedActivitiesView
 * @alias SUGAR.App.view.views.BasePlannedActivitiesView
 * @extends View.Views.Base.HistoryView
 */
({
	// Planned-activities View (base) 

    extendsFrom: 'HistoryView',

    /**
     * Besides defining new DOM events that will be later bound to methods
     * through {@link #delegateEvents, the events method also makes sure parent
     * classes events are explicitly inherited.
     *
     * @property {Function}
     */
    events: function() {
        var prototype = Object.getPrototypeOf(this);
        var parentEvents = _.result(prototype, 'events');

        return _.extend({}, parentEvents, {
            'click [data-action=date-switcher]': 'dateSwitcher'
        });
    },

    /**
     * @inheritdoc
     *
     * @property {Object} _defaultSettings
     * @property {String} _defaultSettings.date Date against which retrieved
     *   records will be filtered, supported values are 'today' and 'future',
     *   defaults to 'today'.
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        date: 'today',
        limit: 10,
        visibility: 'user'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, [
            'LinkedModel'
        ]);
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     *
     * Store current date state in settings.
     */
    initDashlet: function() {
        this._super('initDashlet');
        if (!this.meta.last_state) {
            this.meta.last_state = {
                id: this.dashModel.get('id') + ':' + this.name,
                defaults: {}
            };
        }
        if (this.meta.config) {
            this.layout.before('dashletconfig:save', function() {
                this._saveSetting('date', this.settings.get('date'));
            }, this);
        } else {
            this.settings.on('change:date', function(model, value) {
                this._saveSetting('date', value);
            }, this);
        }

        this.settings.set('date', this.getDate());
        this.tbodyTag = 'ul[data-action="pagination-body"]';
    },

    /**
     * @inheritdoc
     *
     * Once new records are received, prevent rendering new rows until we fetch
     * the invitation collection by calling {@link #updateInvitation}.
     */
    _initEvents: function() {
        this._super('_initEvents');
        this.on('planned-activities:close-record:fire', this.heldActivity, this);
        this.on('linked-model:create', this.loadData, this);

        this.before('render:rows', function(data) {
            this.updateInvitation(this.collection, data);
            return false;
        }, this);

        return this;
    },

    /**
     * Update the invitation collection.
     *
     * @param {BeanCollection} collection Active tab's collection.
     * @param {Array} data Added recordset's data.
     */
    updateInvitation: function(collection, data) {
        var tab = this.tabs[this.settings.get('activeTab')];
        if (!data.length || !tab.invitations) {
            return;
        }
        this._fetchInvitationActions(tab, _.pluck(data, 'id'));
    },

    /**
     * Completes the selected activity.
     *
     * Shows a confirmation alert and sets the activity as `Held` on confirm.
     * Also updates the collection and re-renders the dashlet to remove it from
     * the view.
     *
     * @param {Data.Bean} model Call/Meeting model to be marked as `Held`.
     */
    heldActivity: function(model) {
        var self = this;
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;
        app.alert.show('close_activity_confirmation:' + model.get('id'), {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('LBL_PLANNED_ACTIVITIES_DASHLET_CONFIRM_CLOSE'), [context]),
            onConfirm: function() {
                model.save({status: 'Held'}, {
                    showAlerts: true,
                    success: self._getRemoveModelCompleteCallback()
                });
            }
        });
    },

    /**
     * Create new record.
     *
     * @param {Event} event Click event.
     * @param {Object} params
     * @param {string} params.module Module name.
     * @param {string} params.link Relationship link.
     */
    createRecord: function(event, params) {
        // FIXME: At the moment there are modules marked as bwc enabled though
        // they have sidecar support already, so they're treated as exceptions
        // and drawers are used instead.
        var self = this,
            bwcExceptions = ['Emails'],
            meta = app.metadata.getModule(params.module) || {};

        if (meta.isBwcEnabled && !_.contains(bwcExceptions, params.module)) {
            this._createBwcRecord(params.module, params.link);
            return;
        }

        if (this.module !== 'Home') {
            this.createRelatedRecord(params.module, params.link);
        } else {
            app.drawer.open({
                layout: 'create',
                context: {
                    create: true,
                    module: params.module
                }
            }, function(context, model) {
                if (!model) {
                    return;
                }
                self.context.resetLoadFlag();
                self.context.set('skipFetch', false);
                if (_.isFunction(self.loadData)) {
                    self.loadData();
                } else {
                    self.context.loadData();
                }
            });
        }
    },

    /**
     * Create new record.
     *
     * If we're on Homepage an orphan record is created, otherwise, the link
     * parameter is used and the new record is associated with the record
     * currently being viewed.
     *
     * @param {string} module Module name.
     * @param {string} link Relationship link.
     * @protected
     */
    _createBwcRecord: function(module, link) {
        if (this.module !== 'Home') {
            app.bwc.createRelatedRecord(module, this.model, link);
            return;
        }

        var params = {
            return_module: this.module,
            return_id: this.model.id
        };

        var route = app.bwc.buildRoute(module, null, 'EditView', params);

        app.router.navigate(route, {trigger: true});
    },

    /**
     * @inheritdoc
     * @protected
     */
    _initTabs: function() {
        this._super('_initTabs');

        _.each(this.tabs, function(tab) {
            if (!tab.invitation_actions) {
                return;
            }
            tab.invitations = this._createInvitationsCollection(tab);
        }, this);

        return this;
    },

    /**
     * Create invites collection to set the accept status on the given link.
     *
     * @param {Object} tab Tab properties.
     * @return {Data.BeanCollection} A new instance of bean collection.
     * @protected
     */
    _createInvitationsCollection: function(tab) {
        return app.data.createBeanCollection(tab.module, null, {
            link: {
                name: tab.module.toLowerCase(),
                bean: app.data.createBean('Users', {
                    id: app.user.get('id')
                })
            }
        });
    },

    /**
     * @inheritdoc
     */
    _getRecordsTemplate: function(module) {
        this._recordsTpl = this._recordsTpl || {};

        if (!this._recordsTpl[module]) {
            this._recordsTpl[module] = app.template.getView(this.name + '.records', module) ||
                app.template.getView(this.name + '.records', this.module) ||
                app.template.getView(this.name + '.records') ||
                app.template.getView('history.records', this.module) ||
                app.template.getView('history.records') ||
                app.template.getView('tabbed-dashlet.records', this.module) ||
                app.template.getView('tabbed-dashlet.records');
        }

        return this._recordsTpl[module];
    },

    /**
     * @inheritdoc
     */
    _getFilters: function(index) {

        var today = app.date().formatServer(true);
        var tab = this.tabs[index];
        var filter = {};
        var filters = [];
        var defaultFilters = {
                today: {$lte: today},
                future: {$gt: today}
            };

        filter[tab.filter_applied_to] = defaultFilters[this.getDate()];

        filters.push(filter);

        return filters;
    },

    /**
     * @inheritdoc
     */
    tabSwitcher: function(event) {
        var tab = this.tabs[this.settings.get('activeTab')];
        if (tab.invitations) {
            tab.invitations.dataFetched = false;
        }

        this._super('tabSwitcher', [event]);
    },

    /**
     * @inheritdoc
     *
     * Additional logic on switch visibility event.
     */
    visibilitySwitcher: function() {
        var activeVisibility;
        if (!this.isManager) {
            return;
        }
        activeVisibility = this.getVisibility();
        this.$el.find('[data-action=visibility-switcher]')
            .attr('aria-pressed', function() {
                return $(this).val() === activeVisibility;
            });
    },

    /**
     * Event handler for date switcher.
     *
     * @param {Event} event Click event.
     */
    dateSwitcher: function(event) {
        var date = this.$(event.currentTarget).val();
        if (date === this.getDate()) {
            return;
        }

        this.settings.set('date', date);
        this.loadData();
    },

    /**
     * Saves a setting to local storage.
     *
     * @param {string} setting The setting name.
     * @param {string} value The value to save.
     * @private
     */
    _saveSetting: function(setting, value) {
        var key = app.user.lastState.key(setting, this);
        app.user.lastState.set(key, value);
    },

    /**
     * Get current date state.
     * Returns default value if can't find in last state or settings.
     *
     * @return {string} Date state.
     */
    getDate: function() {
        var date = app.user.lastState.get(
            app.user.lastState.key('date', this),
            this
        );
        return date || this.settings.get('date') || this._defaultSettings.date;
    },

    /**
     * @inheritdoc
     *
     * On load of new data, make sure we reload invitations related data, if
     * it is defined for the current tab.
     */
    loadDataForTabs: function(tabs, options) {
        _.each(tabs, function(tab) {
            if (tab.invitations) {
                tab.invitations.dataFetched = false;
            }
        }, this);

        this._super('loadDataForTabs', [tabs, options]);
    },

    /**
     * Fetch the invitation actions collection for
     * showing the invitation actions buttons
     * @param {Object} tab Tab properties.
     * @param {Array|*} addedIds New added record ids.
     * @private
     */
    _fetchInvitationActions: function(tab, addedIds) {
        this.invitationActions = tab.invitation_actions;
        tab.invitations.filterDef = {
            'id': {'$in': addedIds || this.collection.pluck('id')}
        };

        tab.invitations.fetch({
            relate: true,
            success: _.bind(function(collection) {
                if (this.disposed) {
                    return;
                }

                _.each(collection.models, function(invitation) {
                    var model = this.collection.get(invitation.get('id'));
                    model.set('invitation', invitation);
                }, this);

                if (!_.isEmpty(addedIds)) {
                    _.each(addedIds, function(id) {
                        var model = this.collection.get(id);
                        this._renderRow(model);
                        this._renderAvatars();
                    }, this);
                    return;
                }
                this.render();
                this._renderAvatars();
            }, this),
            complete: function() {
                tab.invitations.dataFetched = true;
            }
        });
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model:
     *
     * - {Boolean} overdue True if record is prior to now.
     * - {Bean} invitation The invitation bean that relates the data with the
     *   Users' invitation statuses. This is the model supplied to the
     *   `invitation-actions` field.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        var tab = this.tabs[this.settings.get('activeTab')];

        if (tab.overdue_badge) {
            this.overdueBadge = tab.overdue_badge;
        }

        if (!this.collection.length || !tab.invitations ||
            tab.invitations.dataFetched) {
            this._super('_renderHtml');
            return;
        }

        this._fetchInvitationActions(tab);
    }
}) },
"config-drawer-howto": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ConfigDrawerHowtoView
 * @alias SUGAR.App.view.views.BaseConfigDrawerHowtoView
 * @extends View.View
 */
({
	// Config-drawer-howto View (base) 

    howtoData: {},

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.context.on('config:howtoData:change', this.onHowtoDataChange, this);
    },

    /**
     * Handles updating the howto data when it changes
     *
     * @param howtoData
     */
    onHowtoDataChange: function(howtoData) {
        this.howtoData = howtoData;
        this.render();
    }
}) },
"header-help": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HeaderHelpView
 * @alias SUGAR.App.view.views.BaseHeaderHelpView
 * @extends View.View
 */
({
	// Header-help View (base) 

    plugins: ['Previewable'],

    /**
     * @inheritdoc
     * @param options
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this._setPropertiesData();
    },

    /**
     * Set initial properties
     *
     * @private
     */
    _setPropertiesData: function() {
        this.buttonColor = null;
        this.label = app.config.newCaseMessage || this.meta.default_label;
        this.enabled = _.isUndefined(app.config.newCaseButton) || app.config.newCaseButton;
        if (this.enabled && app.config.newCaseButtonText && this.meta.buttons.length) {
            this.meta.buttons[0].label = app.config.newCaseButtonText;
        }
    }
}) },
"config-header-buttons": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ConfigHeaderButtonsView
 * @alias SUGAR.App.view.views.BaseConfigHeaderButtonsView
 * @extends  View.View
 */
({
	// Config-header-buttons View (base) 

    events: {
        'click a[name="cancel_button"]': 'cancelConfig',
        'click a[name="save_button"]:not(.disabled)': 'saveConfig'
    },

    /**
     * Holds an object with the current module in it for parsing language strings
     *
     * <pre><code>
     *  { module: this.module }
     * </pre></code>
     */
    moduleLangObj: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = _.extend({}, app.metadata.getView(null, 'config-header-buttons'), options.meta);
        this._super('initialize', [options]);

        this.moduleLangObj = {
            // get the actual plural module name
            module: app.lang.getModuleName(this.module, { plural: true })
        };

        this.before('save', this._beforeSaveConfig, this);
        this.before('cancel', this._beforeCancelConfig, this);
    },

    /**
     * Click handler for the save button, triggers save event
     */
    saveConfig: function() {
        if (this.triggerBefore('save')) {
            this.getField('save_button').setDisabled(true);
            this._saveConfig();
        }
    },

    /**
     * Calls the context model save and saves the config model in case
     * the default model save needs to be overwritten
     *
     * @protected
     */
    _saveConfig: function() {
        app.api.call(
            'create',
            this._getSaveConfigURL(),
            this._getSaveConfigAttributes(),
            {
                success: _.bind(function() {
                    this.showSavedConfirmation();
                    if (app.drawer.count()) {
                        // close the drawer and return to Opportunities
                        app.drawer.close(this.context, this.context.get('model'));
                        // Config changed... reload metadata
                        app.sync();
                    } else {
                        app.router.navigate(this.module, {trigger: true});
                    }
                }, this),
                error: _.bind(function() {
                    this.getField('save_button').setDisabled(false);
                }, this)
            }
        );
    },

    /**
     * Extensible function that returns the module/config URL for save
     *
     * @return {string} The Config Save URL
     * @protected
     */
    _getSaveConfigURL: function() {
        return app.api.buildURL(this.module, 'config');
    },

    /**
     * Extensible function that returns the model attributes for save
     *
     * @return {Object} The Config Save attributes object
     * @protected
     */
    _getSaveConfigAttributes: function() {
        return this.model.toJSON();
    },

    /**
     * Noop for use if model needs updating before save.
     * Gets called before the model actually saves.
     *
     * Override this method to provide custom logic.
     *
     * @protected
     * @template
     * @return {boolean} The default implementation returns `true` allowing the save.
     */
    _beforeSaveConfig: function() {
        return true;
    },

    /**
     * Show the saved confirmation alert
     *
     * @param {Object|Undefined} [onClose] the function fired upon closing.
     */
    showSavedConfirmation: function(onClose) {
        onClose = onClose || function() {};
        var alert = app.alert.show('module_config_success', {
            level: 'success',
            title: app.lang.get('LBL_CONFIG_TITLE_MODULE_SETTINGS', this.module, this.moduleLangObj) + ':',
            messages: app.lang.get('LBL_CONFIG_MODULE_SETTINGS_SAVED', this.module, this.moduleLangObj),
            autoClose: true,
            autoCloseDelay: 10000,
            onAutoClose: _.bind(function() {
                alert.getCloseSelector().off();
                onClose();
            })
        });
        var $close = alert.getCloseSelector();
        $close.on('click', onClose);
        app.accessibility.run($close, 'click');
    },

    /**
     * Cancels the config setup process and redirects back
     */
    cancelConfig: function() {
        if (this.triggerBefore('cancel')) {
            // If we're inside a drawer
            if (app.drawer.count()) {
                // close the drawer
                app.drawer.close(this.context, this.context.get('model'));
            } else {
                app.router.navigate(this.module, {trigger: true});
            }
        }
    },

    /**
     * Noop for use if model needs updating before cancel
     * Gets called before the model actually cancels
     *
     * Override this method to provide custom logic.
     *
     * @protected
     * @template
     * @return {boolean} The default implementation returns `true` allowing the cancel.
     */
    _beforeCancelConfig: function() {
        return true;
    }
}) },
"filtered-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.FilteredListView
 * @alias SUGAR.App.view.views.BaseFilteredListView
 * @extends View.Views.Base.ListView
 */
({
	// Filtered-list View (base) 

    extendsFrom: 'ListView',

    /**
     * Filtered and sorted collection set.
     * @property
     */
    filteredCollection: [],

    /**
     * Typed search keyword.
     * @property
     */
    searchTerm: '',

    /**
     * Convert the available filter to the regular expression.
     * @property
     */
    _patternToReg: {
        startsWith: '^(term)',
        endsWith: '(term)$',
        contains: '(term)'
    },

    /**
     * Filter the metadata in order to initiate the searchable fields.
     * @protected
     */
    _initFilter: function() {
        var filter = this._filter || _.chain(this.getFields())
            .filter(function(field) {
                return field.filter;
            })
            .map(function(field) {
                return {
                    name: field.name,
                    label: app.lang.get(field.label, this.module),
                    filter: field.filter
                };
            }, this)
            .value();
        this.context.trigger('filteredlist:filter:set', _.pluck(filter, 'label'));

        if (_.isEmpty(filter)) {
            return;
        }
        this._filter = filter;
    },

    /**
     * Filtering collection that matches with search term.
     * In order to activate filtering on the field,
     * the filter term should be defined in the metadata.
     * There are three type of filter type (startsWith, contains, endsWith).
     *
     * Examples:
     *
     * <pre><code>
     * array(
     *     'type' => 'base',
     *     'name' => 'field_name',
     *     'filter' => 'startsWith',
     *     ),
     * array(
     *     'type' => 'base',
     *     'name' => 'before_field_value',
     *     'filter' => 'contains',
     *     ),
     * array(
     *     'type' => 'base',
     *     'name' => 'datetime',
     *     'filter' => 'endsWith',
     *     ),
     * </code></pre>
     */
    filterCollection: function() {
        var term = this.searchTerm,
            filter = this._filter;

        if (!_.isEmpty(term) && _.isString(term)) {
            this.filteredCollection = this.collection.filter(function(model) {
                return _.some(filter, function(params) {
                    var pattern = this._patternToReg[params.filter].replace('term', term),
                        tester = new RegExp(pattern, 'i');
                    return tester.test(model.get(params.name));
                }, this);
            }, this);
        }
    },

    /**
     * Set the current search term and then reload the table.
     * @param {String} term Search term.
     */
    setSearchTerm: function(term) {
        this.searchTerm = term;
        this._renderData();
    },

    /**
     * @inheritdoc
     *
     * Sort the collection based on user input.
     * In order to activate sorting on the field,
     * 'sortable' should be defined in the metadata.
     *
     * <pre><code>
     * array(
     *     'type' => 'base',
     *     'name' => 'field_name',
     *     'sortable' => true,
     *     ),
     * </code></pre>
     */
    setOrderBy: function(event) {
        this._super('setOrderBy', [event]);
        this.collection.comparator = function(model) {
            return model.get(this.orderBy.field);
        };
        if (this.orderBy.direction === 'desc') {
            this.collection.sort({silent: true});
            this.collection.models.reverse();
            this.collection.trigger('sort', this.collection);
        } else {
            this.collection.sort();
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.on('render', this._initFilter, this);
        if (this.collection) {
            this.collection.on('reset sort', this._renderData, this);
        }
        this.context.on('filteredlist:search:fired', this.setSearchTerm, this);
    },

    /**
     * Refresh the filtered collection and then refresh the html.
     * @protected
     */
    _renderData: function() {
        this.filteredCollection = this.collection.models;
        this.filterCollection();
        this.render();
    }
}) },
"convert-results": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ConvertResultsView
 * @alias SUGAR.App.view.views.BaseConvertResultsView
 * @extends View.View
 */
({
	// Convert-results View (base) 

    associatedModels: null,

    events:{
        'click .preview-list-item':'previewRecord'
    },

    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        app.events.on("list:preview:decorate", this.decorateRow, this);
        this.associatedModels = app.data.createMixedBeanCollection();
    },

    bindDataChange: function() {
        this.model.on("change", this.populateResults, this);
    },

    /**
     * Build a collection of associated models and re-render the view.
     * Override this method for module specific functionality.
     */
    populateResults: function() {
        this.associatedModels.reset();
        app.view.View.prototype.render.call(this);
    },

    /**
     * Handle firing of the preview render request for selected row
     *
     * @param e
     */
    previewRecord: function(e) {
        var $el = this.$(e.currentTarget),
            data = $el.data(),
            model = app.data.createBean(data.module, {id:data.id});

        model.fetch({
            //Show alerts for this request
            showAlerts: true,
            success: _.bind(function(model) {
                model.module = data.module;
                app.events.trigger("preview:render", model, this.associatedModels);
            }, this)
        });
    },

    /**
     * Decorate a row in the list that is being shown in Preview
     * @param model Model for row to be decorated.  Pass a falsy value to clear decoration.
     */
    decorateRow: function(model){
        this.$("tr.highlighted").removeClass("highlighted current above below");
        if(model){
            var rowName = model.module+"_"+ model.get("id");
            var curr = this.$("tr[name='"+rowName+"']");
            curr.addClass("current highlighted");
            curr.prev("tr").addClass("highlighted above");
            curr.next("tr").addClass("highlighted below");
        }
    }
}) },
"subpanel-map": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Maps widget Top view
 *
 * @class View.Views.Base.SubpanelMapView
 * @alias SUGAR.App.view.views.BaseSubpanelMapView
 * @extends View.Views.Base.BaseListMapView
 */
 ({
	// Subpanel-map View (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'ListMapView',

    /**
     * @inheritdoc
     */
    events: {
        'click [data-action=close]': 'closeDrawer',
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this._initProperties();
    },

    /**
     * Property initialization, nothing to do for this view
     *
     */
    _initProperties: function() {
        this._super('_initProperties');

        this._showCloseButton = false;
        this._showExpandButton = false;
        this._showMapToPdfButton = true;
        this._showMapShareButton = true;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        if (this.layout &&
            this.layout.options &&
            this.layout.options.def &&
            this.layout.options.def.showDirections) {
            this._drawMapDirections();
        } else {
            this._drawMapLocations();
        }
    },

    /**
     * Draw map
     */
    _drawMapLocations: function() {
        const massCollection = this.context.get('mass_collection');
        let selectedRecords = [];

        if (massCollection) {
            selectedRecords = _.extend({}, massCollection.models);
        }

        this.createMap(selectedRecords);
    },

    /**
     * Draw map
     */
    _drawMapDirections: function() {
        const massCollection = this.context.get('mass_collection');
        let selectedRecords = [];

        if (massCollection) {
            selectedRecords = _.extend({}, massCollection.models);
        }

        let mapOptions = {};

        if (this.layout &&
            this.layout.options &&
            this.layout.options.def &&
            this.layout.options.def.startPoint) {
            mapOptions = {
                directions: {
                    startPoint: this.layout.options.def.startPoint,
                },
            };
        }

        this.createMap(selectedRecords, mapOptions);
    },

    /**
     * Close maps directions drawer
     */
    closeDrawer: function() {
        app.drawer.close();
    },
}) },
"quicksearch-results": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchResultsView
 * @alias SUGAR.App.view.views.BaseQuicksearchResultsView
 * @extends View.View
 */
({
	// Quicksearch-results View (base) 

    events: {
        'click .view-all-results': 'viewAllResultsClicked'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * The fields metadata for this view per module.
         *
         * @property
         * @private
         */
        this._fieldsMeta = {};

        /**
         * The collection for executing searches and passing results.
         * This could be shared and used by other components.
         */
        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of layout.collection.
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        this.selectedTags = this.layout.selectedTags || [];

        /**
         * Stores the index of the currently highlighted list element.
         * This is used for keyboard navigation.
         * @{number} {null}
         */
        this.activeIndex = null;

        // Listener for when a search is triggered. Show "Searching..."
        this.layout.on('quicksearch:search:underway', function() {
            this.close();
            this.render();
            this.open();
        }, this);

        // If the layout has `quicksearch:results:close` called on it, we
        // need to hide just the quicksearch results
        this.layout.on('quicksearch:close quicksearch:results:close', function() {
            this.close();
        }, this);

        //Listener for receiving focus for up/down arrow navigation:
        this.on('navigate:focus:receive', function(next) {
            if (next) {
                this.activeIndex = 0;
            } else {
                this.activeIndex = this.countRecordElements() - 1;
            }
            this._highlightActive();
            this.attachKeydownEvent();
        }, this);

        //Listener for losing focus for up/down arrow navigation:
        this.on('navigate:focus:lost', function() {
            this.activeIndex = null;
            this.$('.active').removeClass('active');
            this.disposeKeydownEvent();
        }, this);

        app.events.on('app:sync:complete', this._clearFieldsMeta, this);
    },

    /**
     * Clear the cached fields metadata
     * @private
     */
    _clearFieldsMeta: function() {
        this._fieldsMeta = {};
    },

    /**
     * Parses models when collection resets and renders the view.
     *
     * @override
     */
    bindDataChange: function() {
        // On a collection sync, format the search results and display
        this.collection.on('sync', function(collection) {
            if (this.disposed) {
                return;
            }
            var gsUtils = app.utils.GlobalSearch;

            gsUtils.formatRecords(collection, false);

            _.each(this.collection.models, function(model) {
                model.viewAccess = app.acl.hasAccessToModel('view', model);

                // FIXME: SC-4254 Remove this.layout.v2
                if (this.layout.v2) {
                    var moduleMeta = this._fieldsMeta[model.module] || gsUtils.getFieldsMeta(model.module, {linkablePrimary: false});
                    this._fieldsMeta[model.module] = moduleMeta;
                    model.primaryFields = gsUtils.highlightFields(model, moduleMeta.primaryFields);
                    model.secondaryFields = gsUtils.highlightFields(model, {}, true);

                    model.primaryFields = _.values(model.primaryFields);
                    model.secondaryFields = _.values(model.secondaryFields).slice(0, 3);
                } else {
                    if (model.searchInfo.highlighted) {
                        // Get the highlighted fields. If one is the name, highlight the name. Also, highlight the first
                        // non-name field. If there are multiple non-name highlighted fields, we only use the first.
                        _.find(model.searchInfo.highlighted, function(val, key) {
                            if (key === 'name') {
                                model.name = new Handlebars.SafeString(val.text);
                            } else { // found in a related field
                                model.field_name = app.lang.get(val.label, val.module);
                                model.field_value = new Handlebars.SafeString(val.text);
                                return true;
                            }
                        });
                    }
                }
            }, this);

            // build the link for View all results
            this.searchLink = app.utils.GlobalSearch.buildSearchRoute(collection.query, {
                modules: this.collection.selectedModules,
                tags: _.pluck(this.selectedTags, 'name')
            });
            this.activeIndex = null;
            this.render();
            this.open();

            // If the tags view is shown, move this one down
            var shownTags = _.pluck(collection.tags, 'name');
            var selectedTags = _.pluck(this.selectedTags, 'name');
            shownTags = _.difference(shownTags, selectedTags);
            this.$('.typeahead').toggleClass('tagsShown', shownTags.length > 0);
            this.layout.trigger('quicksearch:tag:' + shownTags.length > 0 ? 'open' : 'close');
        }, this);
    },

    /**
     * Show the quickresults dropdown
     */
    open: function() {
        this.$('.typeahead').show();
    },

    /**
     * Returns true if this view is currently in an open state
     * @return {bool}
     */
    isOpen: function() {
        return this.$('.typeahead').is(':visible');
    },

    /**
     * Hide the quickresults dropdown
     */
    close: function() {
        this.clearActive();
        this.collection.reset();
        this.$('.typeahead').hide();
    },

    /**
     * Clear the active element and dispose key events
     */
    clearActive: function() {
        this.activeIndex = null;
        this.$('.active').removeClass('active');
        this.disposeKeydownEvent();
    },

    /**
     * If we have search results, the view is focusable.
     */
    isFocusable: function() {
        return this.collection.models.length > 0;
    },

    /**
     * Move to the next the active element.
     */
    moveForward: function() {
        // check to make sure we will be in bounds.
        if (this.activeIndex < this.countRecordElements() - 1) {
            // We're in bounds, just go to the next element in this view.
            this.activeIndex++;
            this._highlightActive();
        } else {
            // We're trying to move beyond the elements in this view. We need to try to move to the next view
            this._handleBoundary(true);

        }
    },

    /**
     * Move to the previous the active element.
     */
    moveBackward: function() {
        // check to make sure we will be in bounds.
        if (this.activeIndex > 0) {
            // We're in bounds, just go to the previous element in this view
            this.activeIndex--;
            this._highlightActive();
        } else {
            // We're trying to move beyond the elements in this view. We need to try to move to the previous view
            this._handleBoundary(false);
        }
    },

    /**
     * Highlight the active element and unhighlight the rest of the elements.
     */
    _highlightActive: function() {
        this.$('.active').removeClass('active');
        var nthChild = this.activeIndex + 1;
        this.$('li:nth-child(' + nthChild + ')')
            .addClass('active')
            .find('a').focus();
    },

    /**
     * Retrieve the count of record elements. This can be either the number of records or the number of records plus
     * a 'view all results' element.
     * @return {number}
     * @private
     */
    countRecordElements: function() {
        // If there is no next_offset, it means there are no "see more" option that we need to include.
        var hasMore = (this.collection.next_offset > -1) ? 1 : 0;
        return this.collection.models.length + hasMore;
    },

    /**
     * Handle when the user uses their keyboard to try to navigate outside of the view. This handles both the top and
     * bottom boundaries.
     * @param {boolean} next - If true, we are checking the next element. If false, we are checking the previous.
     * @private
     */
    _handleBoundary: function(next) {
        var event = 'navigate:next:component';
        if (!next) {
            event = 'navigate:previous:component';
        }
        if (this.layout.triggerBefore(event)) {
            this.clearActive();
            this.layout.trigger(event);
        }
    },

    /**
     * Attach the keydown events for the view.
     */
    attachKeydownEvent: function() {
        this.$el.on('keydown', _.bind(this.keydownHandler, this));
    },

    /**
     * Dispose the keydown events for the view.
     */
    disposeKeydownEvent: function() {
        this.$el.off();
    },

    /**
     * Handle the keydown events.
     * @param {event} e
     */
    keydownHandler: function(e) {
        switch (e.keyCode) {
            case 40: // down arrow
                this.moveForward();
                break;
            case 38: // up arrow
                this.moveBackward();
                break;
            case 9: // tab
                this.close();
                this.trigger('navigate:focus:lost');
        }
    },

    /**
     * click event handler for the view all results link
     * @param e
     */
    viewAllResultsClicked: function(e) {
        this.close();
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.disposeKeydownEvent();
        this._super('unbind');
    }
}) },
"sweetspot-config-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SweetspotConfigHeaderpaneView
 * @alias SUGAR.App.view.views.BaseSweetspotConfigHeaderpaneView
 * @extends View.View
 */
({
	// Sweetspot-config-headerpane View (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._bindEvents();
    },

    /**
     * Binds events that this view uses.
     */
    _bindEvents: function() {
        this.context.on('sweetspot:config:enableButtons', this.toggleButtons, this);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this.registerShortcuts();
    },

    /**
     * Toggles the buttons in this view between enabled/disabled states.
     *
     * FIXME: This method should be updated to use `this.buttons` instead of
     * looping over all the fields. Update this when SC-3909 is merged.
     *
     * @param {boolean} [enable=false] Whether to enable or disable the action
     *   buttons. Defaults to `false`.
     */
    toggleButtons: function(enable) {
        var state = !_.isUndefined(enable) ? !enable : false;

        _.each(this.fields, function(field) {
            if (field instanceof app.view.fields.BaseButtonField) {
                field.setDisabled(state);
            }
        });
    },

    /**
     * Register keyboard shortcuts for various headerpane buttons.
     */
    registerShortcuts: function() {
        app.shortcuts.register({
            id: 'SweetSpot:Config:Save',
            keys: ['mod+s','mod+alt+a'],
            component: this,
            description: 'LBL_SHORTCUT_SAVE_CONFIG',
            callOnFocus: true,
            handler: function() {
                var $saveButton = this.$('a[name=save_button]');
                if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                    $saveButton.click();
                }
            }
        });

        app.shortcuts.register({
            id: 'SweetSpot:Config:Cancel',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $cancelButton = this.$('a[name=cancel_button]');
                if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                    $cancelButton.get(0).click();
                }
            }
        });
    }
}) },
"preview-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PreviewHeaderView
 * @alias SUGAR.App.view.views.BasePreviewHeaderView
 * @extends View.View
 */
({
	// Preview-header View (base) 

    className: 'preview-headerbar bg-secondary-content-background',

    events: {
        'click [data-direction]': 'triggerPagination',
        'click .closeSubdetail': 'triggerClose'
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        this.checkACL(this.model);

        this._delegateEvents();
    },

    /**
     * Set up event listeners
     *
     * @private
     */
    _delegateEvents: function() {
        if (this.layout) {
            this.listenTo(this.layout, 'preview:pagination:update', this.render, this);
        }

        if (this.layout.previewEdit) {
            _.extend(this.events, {'click [data-action=edit]': 'triggerEdit'});
            this.listenTo(this.layout, 'preview:edit:complete preview:header:edit', this.toggleSaveAndCancel, this);
        }
    },

    triggerPagination: function(e) {
        var direction = this.$(e.currentTarget).data();
        this.layout.trigger('preview:pagination:fire', direction);
    },

    triggerClose: function() {
        app.events.trigger('list:preview:decorate', null, this);
        app.events.trigger('preview:close');
    },

    /**
     * Call preview view to turn on editing
     */
    triggerEdit: function() {
        this.toggleSaveAndCancel(true);
        this.layout.trigger('preview:edit');
    },

    /**
     * Toggle save, cancel, left, right and x buttons
     *
     * @param {boolean} edit `true` to show save and cancel and hide
     * left, right and X icons
     */
    toggleSaveAndCancel: function(edit) {
        if (edit) {
            this.getField('save_button').show();
            this.getField('cancel_button').show();
            this.$('[data-direction], [data-action=close]').hide();
        } else {
            this.getField('save_button').hide();
            this.getField('cancel_button').hide();
            this.$('[data-direction], [data-action=close]').show();
        }
    },

    /**
     * @inheritdoc
     *
     * @override Overriding to hide preview save/cancel buttons initially
     * @private
     */
    _renderFields: function() {
        this._super('_renderFields');

        if (this.layout.previewEdit) {
            this.getField('save_button').hide();
            this.getField('cancel_button').hide();
        }
    },

    /**
     *  @inheritdoc
     *
     *  @override Overiding render
     */
    _render: function() {
        this.layout.on('previewheader:ACLCheck', this.checkACL, this)
        this._super('_render');
    },

    /**
     * Check if the user has permission to edit the current record
     *
     * @param model Model for preview
     */
    checkACL: function(model) {
        if (app.config.previewEdit && this.layout.meta.editable === true &&
            app.acl.hasAccessToModel('edit', model)) {
            this.layout.previewEdit = true;
        } else {
            this.layout.previewEdit = false;
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.stopListening(this.layout);
        this._super('_dispose');
    }
}) },
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.RecordlistView
 * @alias SUGAR.App.view.views.BaseRecordlistView
 * @extends View.Views.Base.FlexListView
 */
({
	// Recordlist View (base) 

    extendsFrom: 'FlexListView',
    plugins: [
        'SugarLogic',
        'ReorderableColumns',
        'ResizableColumns',
        'ListColumnEllipsis',
        'ErrorDecoration',
        'Editable',
        'MergeDuplicates',
        'Pagination',
        'MassCollection',
        'ActionButton',
        'DocumentMerge',
        'MappableList',
    ],

    /**
     * List of current inline edit models.
     *
     * @property
     */
    toggledModels: null,

    rowFields: {},

    contextEvents: {
        "list:editall:fire": "toggleEdit",
        "list:editrow:fire": "editClicked",
        "list:deleterow:fire": "warnDelete"
    },

    /**
     * Name of the row edit event.
     *
     * @property {string}
     */
    editEventName: 'list:editrow:fire',

    /**
     * @override
     * @param {Object} options
     */
    initialize: function(options) {
        //Grab the record list of fields to display from the base metadata
        var recordListMeta = this._initializeMetadata(options);
        //Allows sub-views to override and use different view metadata if desired
        var subViewMeta = this.combineMeta(recordListMeta, options.meta);
        // Filter given metadata removing non-applicable portions
        options.meta = this._filterMeta(subViewMeta, options);
        this._super("initialize", [options]);

        //Extend the prototype's events object to setup additional events for this controller
        this.events = _.extend({}, this.events, {
            'click [name=inline-cancel]' : 'resize',
            'keydown': '_setScrollPosition',
            'dblclick tr.single': 'doubleClickEdit'
        });

        this.toggledModels = {};

        this._addAdditionalFields();

        this._currentUrl = Backbone.history.getFragment();

        // allow selected records to persist across pages with list-pagination component
        this.setIndependentMassCollection(this.context.get('isUsingListPagination'));

        this._bindEvents();
    },

    /**
     * Bind various events that are associated with this view.
     *
     * @protected
     */
    _bindEvents: function() {
        this.on('render render:rows', this._setRowFields, this);

        //fire resize scroll-width on column add/remove
        this.on('list:toggle:column', this.resize, this);
        this.on('mergeduplicates:complete', this.refreshCollection, this);
        this.on('field:focus:location', this.setPanelPosition, this);

        if (this.layout) {
            this.layout.on('list:mergeduplicates:fire', this.mergeDuplicatesClicked, this);

            // We listen for if the search filters are opened or not. If so, when
            // user clicks show more button, we treat this as a search, otherwise,
            // normal show more for list view.
            this.layout.on('list:filter:toggled', this.filterToggled, this);

            // The `MassCollection` plugin triggers these events when it shows an
            // alert and the table height changes.
            this.layout.on('list:alert:show list:alert:hide', this._refreshReorderableColumns, this);
        }

        app.events.on('sugarApp:' + this.module + ':' + this.name + ':updated', this._sugarAppsUpdatedMetadata, this);

        //event register for preventing actions
        // when user escapes the page without confirming deleting
        app.routing.before('route', this.beforeRouteDelete, this);
        $(window).on('beforeunload.delete' + this.cid, _.bind(this.warnDeleteOnRefresh, this));
    },

    /**
     * Only runs when Sugar Apps are being used and the List View has loaded before the
     * calls come back from manifest and individual MFE servers. This handles updating
     * fields metadata for the MFE fields in the list if they exist
     *
     * @param {Object} fieldsToUpdate The MFE field defs that have come in to update on this view
     */
    _sugarAppsUpdatedMetadata: function(fieldsToUpdate) {
        // update meta with the latest panel fields that have been updated
        // during the MFE Sugar Apps loading metadata-patching process
        _.extend(this.meta, app.metadata.getView(this.module, 'list'));

        var resizableColumns;
        var updatedWidths = false;

        // update the table headers of the external app fields
        _.each(fieldsToUpdate, function(ftu) {
            if (ftu.width) {
                var $el = this.$('th[data-fieldname="' + ftu.name + '"]');
                // clear out the existing styles set by ResizableColumns
                $el.attr('style', '');
                // set the right width class
                $el.addClass('cell-' + ftu.width);
                updatedWidths = true;
            }
        }, this);

        if (updatedWidths) {
            // only do this if we actually updated some table column widths
            resizableColumns = this.$('table').data('resizableColumns');
            // update the cached column widths with the new column sizes
            resizableColumns.saveColumnWidths();
        }

        if (_.size(this.fields) <= 1) {
            // this case handles when the list view has initialized but rows have not
            // been rendered yet but the fields catalog has already been
            // created so we need to loop through that catalog and patch metadata
            // _fields.all also updates _fields.visible
            _.each(this._fields.all, function(field) {
                _.each(fieldsToUpdate, function(ftu) {
                    if (field.name === ftu.name) {
                        _.extend(field, ftu);
                        field.expectedWidth = ftu.width;
                        field.widthClass = 'cell-' + ftu.width;
                    }
                }, this);
            }, this);
        } else {
            // this case handles when the list view has already initialized and rendered fields
            // so loop through the rendered fields and update parent data-type,
            // dispose of the old fields, and create new fields
            _.each(this.fields, function(field) {
                _.each(fieldsToUpdate, function(ftu) {
                    if (field.name === ftu.name) {
                        var options = field.options;
                        var $parent = field.$el.parent();
                        _.extend(options.def, ftu);
                        _.extend(options.viewDefs.def, ftu);
                        _.extend(options.viewDefs, ftu);

                        // set the right data-type on the field
                        $parent.attr('data-type', ftu.type);
                        // get rid of the old field and its DOM elements/templates
                        field.dispose();
                        // create the new field
                        field = app.view.createField(options);

                        var $el = $(field.getPlaceholder().string);
                        $parent.append($el);
                        // set the field to render inside the element
                        field.setElement($el);
                        field.render();
                    }
                }, this);
            }, this);
        }
    },

    /**
     * Update the filter enable status.
     *
     * @param {Boolean} isOpened Value whether the filter is opened.
     */
    filterToggled: function(isOpened) {
        this.context.set('filterOpened', isOpened);
    },

    /**
     * Add the opened filter options to the paginate query.
     * Please see the {@link Pagination#getNextPagination} for detail.
     *
     * @return {Object} Pagination fetch options.
     */
    getPaginationOptions: function() {
        // If in "search mode" (the search filter is toggled open) set q:term param
        var options = this.context.get('filterOpened') ? this.getSearchOptions() : {};

        return options;
    },

    /**
     * Add the previous typed search term.
     *
     * @return {Object} Pagination fetch options.
     */
    getSearchOptions: function() {
        var collection, options, previousTerms, term = '';
        collection = this.context.get('collection');

        // If we've made a previous search for this module grab from cache
        if (app.cache.has('previousTerms')) {
            previousTerms = app.cache.get('previousTerms');
            if (previousTerms) {
                term = previousTerms[this.module];
            }
        }
        // build search-specific options and return
        options = {
            params: {
                q: term
            },
            fields: collection.fields ? collection.fields : this.collection
        };
        return options;
    },

    /**
     * Retrieve the metadata of the recordlist view
     *
     * @return {Object}
     * @private
     */
    _initializeMetadata: function() {
        return app.metadata.getView(null, 'recordlist') || {};
    },

    /**
     * Filters the given meta removing non-applicable portions
     * @param {Object} meta data to be filtered
     * @return {Object}
     * @private
     */
    _filterMeta : function(meta, options) {
        // Don't show the update calc field option if the module has no calculated
        // fields or the user is not a dev for that module
        var context = options.context;
        var isDeveloper = app.acl.hasAccess("developer", context.get("module"));
        var hasCalcFields = context && context.get("model") && !!_.find(context.get("model").fields, function(def) {
            return def && def.calculated && def.calculated != "false";
        });
        // Used in sanitizing subpanel row actions for Tags module
        var isTagsParent = options.context.get('parentModule') === 'Tags';

        if ((!isDeveloper || !hasCalcFields) && meta.selection && meta.selection.actions) {
            meta.selection.actions = _.reject(meta.selection.actions, function(action) {
                return action.name == "calc_field_button";
            });
        }

        // Handle Tags module specific rules. Yes, this is dirty, but given how
        // Subpanels on Tags need to be treated, this is just about the only way
        // to do this
        if (isTagsParent && meta.rowactions && meta.rowactions.actions) {
            // Tags does not support Unlinking of records in subpanels, so we
            // need to traverse the row actions array of options.meta and, if
            // any of the rowactions is a type unlink-action we need to remove
            // it from the rowactions array
            meta.rowactions.actions = _.reject(meta.rowactions.actions, function(row) {
                return row.type === 'unlink-action';
            });
        }

        return meta;
    },

    /**
     * Refresh the current collection set.
     */
    refreshCollection: function() {
        this.collection.fetch();
    },

    addActions:function () {
        if (this.actionsAdded) return;
        this._super("addActions");
        if(_.isUndefined(this.leftColumns[0])){
            //Add blank left column to contain favorite and inline-cancel buttons
            this.leftColumns.push({
                'type':'fieldset',
                'label': '',
                'sortable': false,
                'fields': []
            });
        }
        //Add Favorite to left
        this.addFavorite();

        //Add Save & Cancel
        var firstLeftColumn = this.leftColumns[0];
        if (firstLeftColumn && _.isArray(firstLeftColumn.fields)) {
            //Add Cancel button to left
            firstLeftColumn.fields.push({
                type: 'editablelistbutton',
                label: 'LBL_CANCEL_BUTTON_LABEL',
                name: 'inline-cancel',
                css_class: 'btn-link btn-invisible inline-cancel ellipsis_inline'
            });
            this.leftColumns[0] = firstLeftColumn;
        }
        var firstRightColumn = this.rightColumns[0];
        if (firstRightColumn && _.isArray(firstRightColumn.fields)) {
            //Add Save button to right
            firstRightColumn.css_class = 'overflow-visible';
            firstRightColumn.fields.push({
                type: 'editablelistbutton',
                label: 'LBL_SAVE_BUTTON_LABEL',
                name: 'inline-save',
                css_class: 'btn-primary ellipsis_inline'
            });
            this.rightColumns[0] = firstRightColumn;
        }
        this.actionsAdded = true;
    },

    /**
     * Add favorite column
     */
    addFavorite: function() {
        var favoritesEnabled = app.metadata.getModule(this.module, "favoritesEnabled");
        if (favoritesEnabled !== false
            && this.meta.favorite && this.leftColumns[0] && _.isArray(this.leftColumns[0].fields)) {
            this.leftColumns[0].fields.push({type:'favorite'});
        }
    },

    /**
     * Set, or reset, the collection of fields that contains each row.
     *
     * This function is invoked when the view renders. It will update the row
     * fields once the `Pagination` plugin successfully fetches new records.
     *
     * @private
     */
    _setRowFields: function() {
        this.rowFields = {};
        _.each(this.fields, function(field) {
            if (field.model && field.model.id && _.isUndefined(field.parent)) {
                this.rowFields[field.model.id] = this.rowFields[field.model.id] || [];
                this.rowFields[field.model.id].push(field);
            }
        }, this);
    },

    /**
     * Stores the current scrolling position of the list content when tab key is
     * pressed.
     *
     * @param {Event} event The keydown event.
     * @private
     */
    _setScrollPosition: function(event) {
        if (event.keyCode === 9) {
            var $flexListContent = this.$('.flex-list-view-content');
            $flexListContent.data('previousScrollLeftValue', $flexListContent.scrollLeft());
        }
    },

    /**
     * Retrieves the location of the edges of the list viewport and caches it
     * to `this._bordersPosition`.
     *
     * @return {Object} Object with properties:
     * @return {number} return.left the position left edge.
     * @return {number} return.right the position right edge.
     * @private
     */
    _getBordersPosition: function() {
        if (!this._bordersPosition) {

            /**
             * Object containing the location of left and right edges of the
             * list viewport.
             *
             * @property {Object} _bordersPosition
             * @property {number} _bordersPosition.left The left offset of the
             *   left edge of the viewport.
             * @property {number} _bordersPosition.right The left offset of the
             *   right edge of the viewport.
             * @private
             */
            this._bordersPosition = {};
            var thSelector = {};
            var $scrollPanel = this.$('.flex-list-view-content');
            var rtl = app.lang.direction === 'rtl';

            thSelector.left = rtl ? 'last' : 'first';
            thSelector.right = rtl ? 'first' : 'last';
            this._bordersPosition.left = $scrollPanel.find('thead tr:first th:' + thSelector.left).outerWidth();
            this._bordersPosition.right = $scrollPanel.find('thead tr:first th:' + thSelector.right).children().first()
                .offset().left;
        }
        return this._bordersPosition;
    },

    /**
     * Sets the position of the current list panel.
     *
     * Doesn't adjust panel position if the focused field is fully visible in
     * the viewport.
     *
     * @param {Object} location Position of the focused element relative to its
     *   viewport.
     * @param {number} location.left The distance between the left
     *   border of the focused field and the left border of the viewport.
     * @param {number} location.right The distance between the right
     *   side of the focused field and the left border of the viewport.
     */
    setPanelPosition: function(location) {
        var bordersPosition = this._getBordersPosition();
        var fieldLeft = location.left;
        var fieldRight = location.right;

        if (fieldRight <= bordersPosition.right && fieldLeft >= bordersPosition.left) {
            return;
        }
        this._scrollToMakeFieldVisible(bordersPosition.left, bordersPosition.right, location);
    },

    /**
     * Scrolls the list horizontally to make the clicked field fully visible.
     *
     * @param {number} leftBorderPosition Position of the left edge of the
     *   list viewport.
     * @param {number} rightBorderPosition Position of the right edge of the
     *   list viewport.
     * @param {Object} location Position of the focused element relative to its
     *   viewport.
     * @param {number} location.left The distance between the left
     *   border of the focused field and the left border of the viewport.
     * @param {number} location.right The distance between the right
     *   side of the focused field and the left border of the viewport.
     * @private
     */
    _scrollToMakeFieldVisible: function(leftBorderPosition, rightBorderPosition, location) {
        var $scrollPanel = this.$('.flex-list-view-content');
        var scrollPosition = $scrollPanel.scrollLeft();
        var fieldLeft = location.left;
        var fieldRight = location.right;
        var fieldPadding = location.fieldPadding;
        var distanceToScroll;

        if (fieldLeft < leftBorderPosition) {
            distanceToScroll = fieldLeft - leftBorderPosition - fieldPadding;
        } else if (rightBorderPosition < fieldRight) {
            distanceToScroll = fieldRight - rightBorderPosition + fieldPadding;
        } else {
            return;
        }
        if (app.lang.direction === 'rtl' && $.support.rtlScrollType === 'reverse') {
            distanceToScroll = - distanceToScroll;
        }
        $scrollPanel.scrollLeft(scrollPosition + distanceToScroll);
    },

    /**
     * Delete the model once the user confirms the action
     */
    deleteModel: function() {
        var self = this,
            model = this._modelToDelete;

        model.destroy({
            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': {
                    messages: self.getDeleteMessages(self._modelToDelete).success
                }
            },
            success: function() {
                var redirect = self._targetUrl !== self._currentUrl;
                self._modelToDelete = null;
                self.collection.remove(model, { silent: redirect });
                if (redirect) {
                    self.unbindBeforeRouteDelete();
                    //Replace the url hash back to the current staying page
                    app.router.navigate(self._targetUrl, {trigger: true});
                    return;
                }
                app.events.trigger("preview:close");
                if (!self.disposed) {
                    self.render();
                }

                self.layout.trigger("list:record:deleted", model);
            }
        });
    },

    /**
     * Pre-event handler before current router is changed
     *
     * @return {Boolean} true to continue routing, false otherwise
     */
    beforeRouteDelete: function () {
        if (this._modelToDelete) {
            this.warnDelete(this._modelToDelete);
            return false;
        }
        return true;
    },

    /**
     * Formats the messages to display in the alerts when deleting a record.
     *
     * @param {Data.Bean} model The model concerned.
     * @return {Object} The list of messages.
     * @return {string} return.confirmation Confirmation message.
     * @return {string} return.success Success message.
     */
    getDeleteMessages: function(model) {
        var messages = {};
        var name = Handlebars.Utils.escapeExpression(this._getNameForMessage(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' "' + name + '"';

        messages.confirmation = app.utils.formatString(
            app.lang.get('NTC_DELETE_CONFIRMATION_FORMATTED', this.module),
            [context]
        );
        messages.success = app.utils.formatString(app.lang.get('NTC_DELETE_SUCCESS'), [context]);
        return messages;
    },

    /**
     * Retrieves the name of a record
     *
     * @param {Data.Bean} model The model concerned.
     * @return {string} name of the record.
     */
    _getNameForMessage: function(model) {
        return app.utils.getRecordName(model);
    },

    /**
     * Popup dialog message to confirm delete action
     *
     * @param {Backbone.Model} model the bean to delete
     */
    warnDelete: function(model) {
        var self = this;
        this._modelToDelete = model;

        self._targetUrl = Backbone.history.getFragment();
        //Replace the url hash back to the current staying page
        if (self._targetUrl !== self._currentUrl) {
            app.router.navigate(self._currentUrl, {trigger: false, replace: true});
        }

        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: self.getDeleteMessages(model).confirmation,
            onConfirm: _.bind(self.deleteModel, self),
            onCancel: function() {
                self._modelToDelete = null;
            }
        });
    },

    /**
     * Popup browser dialog message to confirm delete action
     *
     * @return {String} the message to be displayed in the browser dialog
     */
    warnDeleteOnRefresh: function() {
        if (this._modelToDelete) {
            return this.getDeleteMessages(this._modelToDelete).confirmation;
        }
    },

    /**
     * {@link app.plugins.view.editable}
     * Compare with last fetched data and return true if model contains changes.
     * if model contains changed attributes,
     * check whether those are among the editable fields or not.
     *
     * @return {Boolean} True if current inline edit model contains unsaved changes.
     */
    hasUnsavedChanges: function() {
        var firstKey = _.first(_.keys(this.rowFields)),
            formFields = [];

        _.each(this.rowFields[firstKey], function(field) {
            if (field.name) {
                formFields.push(field.name);
            }
            //Inspect fieldset children fields
            if (field.def.fields) {
                formFields = _.chain(field.def.fields)
                    .pluck('name')
                    .compact()
                    .union(formFields)
                    .value();
            }
        }, this);
        return _.some(_.values(this.toggledModels), function(model) {
            var changedAttributes = model.changedAttributes(model.getSynced());

            if (_.isEmpty(changedAttributes)) {
                return false;
            }
            var unsavedFields = _.intersection(_.keys(changedAttributes), formFields);
            return !_.isEmpty(unsavedFields);
        }, this);
    },

    /**
     * Handles merge button.
     */
    mergeDuplicatesClicked: function() {
        this.mergeDuplicates(this.context.get('mass_collection'));
    },

    /**
     * Toggle the selected model's fields when edit is clicked.
     *
     * @param {Backbone.Model} model Selected row's model.
     */
    editClicked: function(model, field) {
        // If a field is locked, we don't allow inline editing. Instead show an alert that links
        // to the record view or editview to make changes there.
        if (!_.isEmpty(model.get('locked_fields'))) {
            this._showLockedFieldWarning(model);
            return;
        }
        if (field && field.def && field.def.full_form) {
            var parentModel = this.context.parent.get('model');
            var link = this.context.get('link');

            // `app.bwc.createRelatedRecord` navigates to the BWC EditView if an
            // id is passed to it.
            app.bwc.createRelatedRecord(this.module, parentModel, link, model.id);
        } else {
            this.toggleRow(model.id, true);
            //check to see if horizontal scrolling needs to be enabled
            this.resize();
        }
        if (!_.isEqual(model.attributes, model._syncedAttributes)) {
            model.setSyncedAttributes(model.attributes);
        }
    },

    /**
     * Handle switching a row to edit mode when double clicked
     * @param event
     */
    doubleClickEdit: function(event) {
        // Do not continue if the row cannot be edited or if the clicked element has some other
        // action associated with it
        if (!this.isRowEditable() || this.isClickableElement(event.target)) {
            return;
        }
        event.stopPropagation();

        // Get the ID of the model from the row
        let row = this.$(event.target).parents('tr');
        let rowNameComponents = row.attr('name') ? row.attr('name').split('_') : [];
        if (rowNameComponents.length < 2) {
            return;
        }

        let modelId = rowNameComponents.pop();

        // Check if the row is already in edit mode
        if (!_.isEmpty(this.toggledModels[modelId])) {
            return;
        }

        let model = this.collection.get(modelId);
        if (_.isEmpty(model)) {
            return;
        }

        if (app.acl.hasAccessToModel('edit', model)) {
            this.context.trigger(this.editEventName, model);

            // Safari will also highlight the text around where the user double clicked - clear that
            if (window.getSelection) {
                window.getSelection().empty();
            }
        }
    },

    /**
     * Checks if list rows are editable. Check the rowactions to see if the action associated with
     * starting a row edit is used.
     * @return {boolean}
     */
    isRowEditable: function() {
        let meta = this.options.meta;
        if (_.isEmpty(meta) || _.isEmpty(meta.rowactions) || _.isEmpty(meta.rowactions.actions)) {
            return false;
        }

        return meta.rowactions.actions.some(action => action.event === this.editEventName);
    },

    /**
     * Checks if the given element is "clickable" - that is, if it is an element that always
     * performs some action, if it is a focus icon, or if it has an event associated in another way
     * @param element
     * @return {boolean}
     */
    isClickableElement: function(element) {
        let tagNames = [element.tagName, element.parentElement.tagName].map(tag => tag.toLowerCase());
        if (['a', 'button', 'input'].some(tag => tagNames.includes(tag))) {
            return true;
        }
        if (element.classList.contains('focus-icon')) {
            return true;
        }
        return ['data-action', 'data-clipboard', 'data-event'].some(attr => {
            return element.getAttribute(attr) || element.parentElement.getAttribute(attr);
        });
    },

    /**
     * Show a warning alert about locked fields on the model. The warning will
     * link to the Sidecar record view in edit mode or BWC edit view
     *
     * @param {Backbone.Model} model the model for the row we are editing
     * @private
     */
    _showLockedFieldWarning: function(model) {
        var route = app.router.buildRoute(model.module, model.id, 'edit');
        var recordName = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model));
        var message = app.lang.get(
            'LBL_LOCKED_FIELD_INLINE_EDIT',
            model.module,
            {link: new Handlebars.SafeString('<a href="javascript:void(0);">' + recordName + '</a>')}
        );
        var module = app.metadata.getModule(model.module);
        app.alert.show('locked_field_inline_edit', {
            level: 'warning',
            messages: message,
            autoClose: false,
            onLinkClick: function() {
                app.alert.dismiss('locked_field_inline_edit');
                var trigger = module.isBwcEnabled;
                if (!trigger) {
                    // We need to load the view here to add lockedFieldWarning to the context
                    // for sidecar modules
                    app.controller.loadView({
                        layout: 'record',
                        module: model.module,
                        modelId: model.id,
                        action: 'edit',
                        lockedFieldsWarning: false
                    });
                }
                app.router.navigate(route, {trigger: trigger});
            }
        });
    },

    /**
     * Toggle editable selected row's model fields.
     *
     * @param {String} modelId Model Id.
     * @param {Boolean} isEdit True for edit mode, otherwise toggle back to list mode.
     */
    toggleRow: function(modelId, isEdit) {
        if (isEdit) {
            this.toggledModels[modelId] = this.collection.get(modelId);
        } else {
            delete this.toggledModels[modelId];
        }
        this.$('tr[name=' + this.module + '_' + modelId + ']').toggleClass('tr-inline-edit', isEdit);
        this.toggleFields(this.getModelRowFields(modelId), isEdit);
    },

    /**
     * Get row fields of particular model
     *
     * @param {string} modelId ID of model
     * @return {Array} list of fields objects
     */
    getModelRowFields: function(modelId) {
        return this.rowFields[modelId];
    },

    /**
     * Detach the event handlers for warning delete
     */
    unbindBeforeRouteDelete: function() {
        app.routing.offBefore("route", this.beforeRouteDelete, this);
        $(window).off("beforeunload.delete" + this.cid);
    },

    /**
     * @override
     * @private
     */
    _dispose: function(){
        this.unbindBeforeRouteDelete();
        this._super('_dispose');
        this.rowFields = null;
    },

    /**
     * Adds additional fields to the context.
     *
     * @private
     */
    _addAdditionalFields: function() {
        if (this.meta.favorite) {
            this.context.addFields(['my_favorite']);
        }

        if (this.meta.following) {
            this.context.addFields(['following']);
        }
    },

    /**
     * Register keyboard shortcuts.
     */
    registerShortcuts: function() {
        var clickButton = function($button) {
            if ($button.is(':visible') && !$button.hasClass('disabled')) {
                $button.click();
            }
        };

        this._super('registerShortcuts');

        app.shortcuts.register({
            id: 'List:Inline:Edit',
            keys: 'e',
            component: this,
            description: 'LBL_SHORTCUT_EDIT_SELECTED',
            handler: function() {
                var self = this;
                if (this.$('.selected [name=inline-cancel]:visible').length === 0) {
                    this.$('.selected [data-toggle=dropdown]:visible').click();
                    this.$('.selected [name=edit_button]:visible').click();
                    _.defer(function() {
                        self.$('.selected input:first').focus();
                    });
                }
            }
        });

        app.shortcuts.register({
            id: 'List:Delete',
            keys: 'd',
            component: this,
            description: 'LBL_SHORTCUT_RECORD_DELETE',
            handler: function() {
                if (this.$('.selected [name=inline-cancel]:visible').length === 0) {
                    this.$('.selected [data-toggle=dropdown]:visible').click().blur();
                    this.$('.selected [name=delete_button]:visible').click();
                }
            }
        });

        app.shortcuts.register({
            id: 'List:Inline:Cancel',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CANCEL_INLINE_EDIT',
            callOnFocus: true,
            handler: function() {
                var $cancelButton = this.$('.selected [name=inline-cancel]'),
                    $focusedInlineEditRow = $(event.target).closest('.tr-inline-edit');

                if ($cancelButton.length > 0) {
                    clickButton($cancelButton);
                } else if ($focusedInlineEditRow.length > 0) {
                    clickButton($focusedInlineEditRow.find('[name=inline-cancel]'));
                }
            }
        });

        app.shortcuts.register({
            id: 'List:Inline:Save',
            keys: ['mod+s','mod+alt+a'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_SAVE',
            callOnFocus: true,
            handler: function() {
                var $saveButton = this.$('.selected [name=inline-save]'),
                    $focusedInlineEditRow = $(event.target).closest('.tr-inline-edit');

                if ($saveButton.length > 0) {
                    clickButton($saveButton);
                } else if ($focusedInlineEditRow.length > 0) {
                    clickButton($focusedInlineEditRow.find('[name=inline-save]'));
                }
            }
        });

        app.shortcuts.register({
            id: 'List:Favorite',
            keys: 'f a',
            component: this,
            description: 'LBL_SHORTCUT_FAVORITE_RECORD',
            handler: function() {
                this.$('.selected .sicon-star-outline:visible').click();
            }
        });

        app.shortcuts.register({
            id: 'List:Follow',
            keys: 'f o',
            component: this,
            description: 'LBL_SHORTCUT_FOLLOW_RECORD',
            handler: function() {
                this.$('.selected [data-toggle=dropdown]:visible').click().blur();
                this.$('.selected [name=follow_button]:visible').click();
            }
        });

        app.shortcuts.register({
            id: 'List:Preview',
            keys: 'p',
            component: this,
            description: 'LBL_SHORTCUT_PREVIEW_SELECTED',
            handler: function() {
                clickButton(this.$('.selected [data-event="list:preview:fire"]:visible'));
            }
        });

        app.shortcuts.register({
            id: 'List:Select',
            keys: 'x',
            component: this,
            description: 'LBL_SHORTCUT_MARK_SELECTED',
            handler: function() {
                var $checkbox = this.$('.selected input[type=checkbox]:first');
                if ($checkbox.is(':visible') && !$checkbox.hasClass('disabled')) {
                    $checkbox.get(0).click();
                }
            }
        });
    },

    /**
     * @inheritdoc
     *
     * Unsets `_bordersPosition` because the value changes on resize and will
     * have to be recalculated if the user toggles inline edit mode.
     */
    resize: function() {
        this._super('resize');
        this._bordersPosition = null;
    },

    /**
     * Refreshes the `ReorderableColumns` when the table height changes.
     *
     * The `ReorderableColumns` plugin listens to the window `resize` event to
     * update and position the handlers correctly.
     *
     * @private
     */
    _refreshReorderableColumns: function() {
        $(window).resize();
    },

    /**
     * Helper function to allow subclasses to override how metadata is combined
     *
     * @param {Object} recordListMeta record-list metaData
     * @param {Object} subViewMeta sub-views metaData
     * @return {Object} Combined metadata with subview props overriding record view props
     */
    combineMeta: function(recordListMeta, subViewMeta) {
        return _.extend({}, recordListMeta, subViewMeta || {});
    },

    /**
     * Set the independentMassCollection property for the MassCollection plugin
     *
     * @param isIndependent
     */
    setIndependentMassCollection: function(isIndependent) {
        this.independentMassCollection = !_.isUndefined(isIndependent) ? isIndependent : false;
    },

    /**
     * Handles pagination events from the list-pagination component
     *
     * @param callback
     */
    handleListPaginationEvents: function(callback) {
        if (_.isFunction(callback)) {
            callback();
        }

        this.toggledModels = {};
    }
}) },
"alert": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Views.Base.AlertView
 * @alias SUGAR.App.view.views.BaseAlertView
 * @extends View.View
 */
({
	// Alert View (base) 

    className: 'alert-wrapper', //override default class

    events: {
        'click [data-action=cancel]': 'cancelClicked',
        'click [data-action=confirm]': 'confirmClicked',
        'click [data-action=close]': 'closeClicked',
        'click a': 'linkClick'
    },

    LEVEL: {
        PROCESS: 'process',
        SUCCESS: 'success',
        WARNING: 'warning',
        INFO: 'info',
        ERROR: 'error',
        CONFIRMATION: 'confirmation'
    },

    /**
     * Initialize alert view.
     *
     * @param {Object} options Options to be passed to the alert view.
     * @param {boolean} options.closeable: boolean flag indicating if the alert
     *   can be closed by the user. Note that non-"info" alerts are closeable by
     *   default if this setting is not specified.
     * @param {Function} options.onConfirm: Handler of action Confirm for
     *   confirmation alerts.
     * @param {Function} options.onCancel: Handler of action Cancel for
     *   confirmation alerts.
     * @param {Function} options.onLinkClicked: Handler for click actions on a
     *   link inside the alert.
     * @param {Function} options.onClose: Handler for the close event on the (x).
     * @param {Object} options.templateOptions: Augment template context with
     *   custom object.
     *
     * @override
     */
    initialize: function(options) {
        app.plugins.attach(this, 'view');

        this.options = options || {};
        this.options.confirm || (this.options.confirm = {});
        this.options.cancel || (this.options.cancel = {});

        this.onConfirm = this.options.onConfirm || this.options.confirm.callback;
        this.confirmLabel = this.options.confirm.label || 'LBL_CONFIRM_BUTTON_LABEL';
        this.onCancel = this.options.onCancel || this.options.cancel.callback;
        this.cancelLabel = this.options.cancel.label || 'LBL_CANCEL_BUTTON_LABEL';
        this.onLinkClick = this.options.onLinkClick;
        this.onClose = this.options.onClose;
        this.templateOptions = this.options.templateOptions;
        this.name = 'alert';
    },

    /**
     * Gets selector for DOM elements that need to be clicked in order to close an alert.
     * @return {Object} jQuery/Zepto selector of the close button.
     */
    getCloseSelector: function() {
        return this.$('.close');
    },

    /**
     * Renders the custom alert view template. Binds `Esc` and `Return` keys for
     * confirmation alerts.
     *
     * @override
     */
    render: function() {
       var options = this.options;

        if (!this.triggerBefore('render')) {
            return false;
        }
        if (_.isUndefined(options)) {
            return this;
        }

        if (options.messages) {
            var messageSize = _.reduce(options.messages, function(memo, message) {
                return memo + message.length;
            }, 0);
            this.templateOptions = this.templateOptions || {};
            this.templateOptions.hasBigMessage = (messageSize > 80);
        }

        var template = this._getAlertTemplate(options, this.templateOptions);

        this.$el.html(template);

        if (options.level === 'confirmation') {
            this.bindCancelAndReturn();
        }

        this.trigger('render');
    },

    /**
     * Dismiss the alert when user clicks `cancel`
     */
    cancel: function() {
        this.trigger('dismiss');
        app.alert.dismiss(this.key);
    },

    /**
     * Executes assigned handlers when user clicks `cancel`.
     *
     * @param {Event} [event]
     */
    cancelClicked: function(event) {
        this.cancel();
        app.events.trigger('alert:cancel:clicked');
        if (_.isFunction(this.onCancel)) {
            this.onCancel(event);
        }
    },

    /**
     * Executes assigned handlers when user clicks `confirm`.
     *
     * @param {Event} [event]
     */
    confirmClicked: function(event) {
        this.cancel();
        app.events.trigger('alert:confirm:clicked');
        if (_.isFunction(this.onConfirm)) {
            this.onConfirm(event);
        }
    },

    /**
     * Fired when a link is clicked
     *
     * @param {Event} event
     */
    linkClick: function(event) {
        if (_.isFunction(this.onLinkClick)) {
            this.onLinkClick(event);
        }
    },

    /**
     * Fired when the close (x) is clicked
     * @param {Event} event
     */
    closeClicked: function(event) {
        if (_.isFunction(this.onClose)) {
            this.onClose(event);
        }
        app.alert.dismiss(this.key);
    },
    /**
     * Gets the HTML string for alert given options.
     *
     * @param {Object} [options] The options object passed to the alert object
     *   when it was created. See {@link #initialize} documentation to know the
     *   available options.
     * @param {string|string[]} [options.messages] The message(s) to be
     *   displayed in the alert dialog.
     * @param {Object} [templateOptions] Optional template options to be passed
     *   to the template.
     * @return {string} The generated template.
     * @private
     */
    _getAlertTemplate: function(options, templateOptions) {
        options = options || {};
        var alert = this._getAlertProps(options);
        var template = alert.templateName ? app.template.getView(alert.templateName) : app.template.empty;
        var seed = _.extend({}, {
            alertClass: alert.cssClass,
            alertIcon: alert.icon,
            title: this.getTranslatedLabels(alert.title),
            messages: this.getTranslatedLabels(options.messages),
            closeable: _.isUndefined(options.closeable) || options.closeable,
            alert: this,
            isLoadingAlert: options.title === app.lang.get('LBL_LOADING')
        }, templateOptions);

        return template(seed);
    },

    /**
     * From the given `options`, this method returns an object with
     * corresponding alert properties.
     *
     * @private
     * @param {Object} [options] Alert options like `title`, `level`, etc.
     * @param {string} [options.level] Alert level e.g. 'success', 'error' etc.
     * @param {string} [options.title] Custom alert title to be used.
     * @return {Object} Alert properties to be used when rendering the alert
     *   template.
     */
    _getAlertProps: function(options) {
        var title = options.title || '';
        if (title.endsWith(':')) {
            title = title.slice(0, -1);
        }
        var defaultTemplateName = this.name + '.error';

        switch (options.level) {
            case this.LEVEL.PROCESS:
                // Remove ellipsis from the end of the string.
                title = title.substr(-3) === '...' ? title.substr(0, title.length - 3) : title;

                return {
                    title: title || 'LBL_ALERT_TITLE_LOADING',
                    templateName: this.name + '.process',
                    cssClass: 'alert-process',
                    icon: ''
                };
            case this.LEVEL.SUCCESS:
                return {
                    title: title || 'LBL_ALERT_TITLE_SUCCESS',
                    templateName: defaultTemplateName,
                    cssClass: 'alert-success',
                    icon: 'sicon-check-circle-line-lg'
                };
            case this.LEVEL.WARNING:
                return {
                    title: title || 'LBL_ALERT_TITLE_WARNING',
                    templateName: defaultTemplateName,
                    cssClass: 'alert-warning',
                    icon: 'sicon-warning-lg'
                };
            case this.LEVEL.INFO:
                return {
                    title: title || 'LBL_ALERT_TITLE_NOTICE',
                    templateName: defaultTemplateName,
                    cssClass: 'alert-info',
                    icon: 'sicon-info-lg'
                };
            case this.LEVEL.ERROR:
                return {
                    title: title || 'LBL_ALERT_TITLE_ERROR',
                    templateName: defaultTemplateName,
                    cssClass: 'alert-danger',
                    icon: 'sicon-error-lg'
                };
            case this.LEVEL.CONFIRMATION:
                return {
                    title: title || 'LBL_ALERT_TITLE_WARNING',
                    templateName: this.name + '.confirmation',
                    cssClass: 'alert-warning',
                    icon: 'sicon-warning-lg'
                };
            default:
                return {
                    title: title,
                    cssClass: '',
                    icon: 'sicon-info'
                };
        }
    },

    /**
     * Get CSS classes given alert level
     *
     * @deprecated Deprecated since 7.8. Will be removed in 7.9.
     * @param {string} level
     * @return {string}
     */
    getAlertClasses: function(level) {
        app.logger.warn('The View.Views.Base.AlertView#getAlertClasses has been deprecated since 7.8.0 and will be ' +
            'removed in 7.9.');

        this._getAlertProps({level: level}).cssClass;
    },

    /**
     * Get the default title given alert level
     *
     * @deprecated Deprecated since 7.8. Will be removed in 7.9.
     * @param {string} level
     * @return {string}
     */
    getDefaultTitle: function(level) {
        app.logger.warn('The View.Views.Base.AlertView#getDefaultTitle has been deprecated since 7.8.0 and will be ' +
            'removed in 7.9.');

        this._getAlertProps({level: level}).title;
    },

    /**
     * Return translated text, given a string or an array of strings.
     * @param {String/Array} stringOrArray
     * @return {String/Array}
     */
    getTranslatedLabels: function(stringOrArray) {
        var result;

        if (_.isArray(stringOrArray)) {
            result = _.map(stringOrArray, function(text) {
                return new Handlebars.SafeString(app.lang.get(text));
            });
        } else {
            result = new Handlebars.SafeString(app.lang.get(stringOrArray));
        }

        return result;
    },

    /**
     * Deprecated. Please use {@link #dispose} instead.
     *
     * @deprecated 9.2.0 and may be removed in 10.2.0 or any subsequent release.
     */
    close: function() {
        app.logger.warn('View.Views.Base.AlertView#close has been deprecated since 9.2.0 and may be ' +
            'removed in 10.2.0 or any subsequent release');
        this.dispose();
    },

    /**
     * Used by confirmation alerts so pressing `Esc` will Cancel, pressing
     * `Return` will Confirm
     */
    bindCancelAndReturn: function() {
        app.shortcuts.saveSession();
        app.shortcuts.createSession([
            'Alert:Confirm',
            'Alert:Cancel'
        ], this);

        app.shortcuts.register({
            id: 'Alert:Confirm',
            keys: 'enter',
            component: this,
            description: 'LBL_SHORTCUT_ALERT_CONFIRM',
            handler: function() {
                this.$('[data-action=confirm]').click();
            }
        });

        app.shortcuts.register({
            id: 'Alert:Cancel',
            keys: 'esc',
            component: this,
            description: 'LBL_SHORTCUT_ALERT_CANCEL',
            handler: function() {
                this.$('[data-action=cancel]').click();
            }
        });
    },

    /**
     * Unbind keyboard shortcuts.
     */
    unbindCancelAndReturn: function() {
        if (this.level === 'confirmation') {
            // make sure we don't wipe out any other components' shortcut session
            var currentShortcutSession = app.shortcuts.getCurrentSession();
            if (currentShortcutSession.layout === this) {
                app.shortcuts.restoreSession();
            }
        }
    },

    /**
     * @override
     */
    bindDataChange: function() {
    },

    /**
     * Unbind keyboard shortcuts before disposing.
     * Also, remove br tags after alerts which are needed to stack alerts
     * vertically.
     *
     * @inheritdoc
     */
    _dispose: function() {
        this.unbindCancelAndReturn();
        if (this.$el) {
            this.$el.next('br').remove();
        }
        this._super('_dispose');
    }
}) },
"activity-timeline-base": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivityTimelineBaseView
 * @alias SUGAR.App.view.views.BaseActivityTimelineBaseView
 * @extends View.View
 */
({
	// Activity-timeline-base View (base) 


    className: 'activity-timeline-base',

    plugins: ['EmailClientLaunch', 'LinkedModel'],

    /**
     * Object icon names for modules
     */
    moduleIcons: {
        Calls: 'sicon-phone-lg',
        Emails: 'sicon-email-lg',
        Meetings: 'sicon-calendar-lg',
        Messages: 'sicon-message-lg',
        Notes: 'sicon-note-lg',
        Cases: 'sicon-case-lg',
        Contacts: 'sicon-contact-lg',
        Accounts: 'sicon-account-lg',
        Leads: 'sicon-lead-lg',
        Opportunities: 'sicon-opportunity-lg',
        Quotes: 'sicon-quote-lg',
        Escalations: 'sicon-escalation-lg',
        Tasks: 'sicon-task-lg'
    },

    /**
     * Array default modules
     */
    defaultModules: [
        'Calls',
        'Emails',
        'Meetings',
        'Messages',
        'Notes',
        'Tasks'
    ],

    /**
     * Default mapping of module to link name
     */
    moduleLinkMapping: {
        Calls: 'calls',
        Emails: 'emails',
        Meetings: 'meetings',
        Messages: 'messages',
        Notes: 'notes',
        Tasks: 'tasks',
        Audit: 'audit'
    },

    /**
     * String id of the expanded model
     */
    expandedModelId: '',

    /**
     * Rendered layout activities
     */
    renderedActivities: [],

    /**
     * Boolean status of whether all models been fetched
     */
    fetchCompleted: false,

    /**
     * Array models of related modules
     */
    models: [],

    /**
     * Fields to show as record date for different modules
     */
    recordDateFields: {},

    /**
     * String param for store selected module in filter
     */
    filter: {
        module: null,
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        if (options.context) {
            this.baseModule = options.context.get('module');
            this.module = this.baseModule;
            this.baseRecord = this._getBaseModel(options);
        }

        if (this.baseModule) {
            this._setActivityModulesAndFields(this.baseModule);
        }

        options.meta = _.extend({}, options.meta,
            {preview: this._getModuleFieldMeta()}
        );

        this._super('initialize', [options]);

        this.events = _.extend({}, this.events, {
            'click .static-contents': 'handleExpandedClick',
            'click .btn.more': 'fetchModels',
        });
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        // listen for activity-card-emailactions
        this.listenTo(this.context, 'emailclient:close', function() {
            this.reloadData();
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Inject the singular module name.
     */
    _render: function() {
        this.disposeActivities();

        this._super('_render');

        if (this.models) {
            this.appendCardsToView(this.models);
        }
    },

    /**
     * Get base model from parent context
     *
     * @param {Object} options
     * @return {Data.Bean} model the base model of the dashlet
     */
    _getBaseModel: function(options) {
        var model;
        var baseModule = options.context.get('module');
        var currContext = options.context;
        while (currContext) {
            var contextModel = currContext.get('rowModel') || currContext.get('model');

            if (contextModel && contextModel.get('_module') === baseModule) {
                model = contextModel;

                var parentHasRowModel = currContext.parent && currContext.parent.has('rowModel');
                if (!parentHasRowModel) {
                    break;
                }
            }

            currContext = currContext.parent;
        }
        return model;
    },

    /**
     * Get the activity-timeline metadata for the baseModule
     *
     * @param {string} baseModule module name
     */
    getModulesMeta: function(baseModule) {
        return app.metadata.getView(baseModule, 'activity-timeline-base');
    },

    /**
     * Set activity modules and module field names
     *
     * @param {string} baseModule module name
     */
    _setActivityModulesAndFields: function(baseModule) {
        var modulesMeta = this.getModulesMeta(baseModule);
        var modules = [];

        if (!modulesMeta) {
            return;
        }

        if (this.filter.module && this.filter.module !== 'all_modules') {
            modules = _.filter(modulesMeta.activity_modules, function(module) {
                return (module.module.toLowerCase() === this.filter.module.toLowerCase());
            }, this);
        } else {
            modules = modulesMeta.activity_modules;
        }

        this.activityModules = _.map(modules, function(module) {
            return module.module;
        });

        if (this.activityModules.length === 0) {
            this.activityModules = this.defaultModules;
        }

        this.moduleFieldNames = {};
        this.recordDateFields = {};
        _.each(modules, function(module) {
            this.moduleFieldNames[module.module] = module.fields;
            this.recordDateFields[module.module] = module.record_date || 'date_entered';
        }, this);
    },

    /**
     * Get preview field metadata or record field metadata to render content
     *
     * @return {Object} fieldMeta view metadata of available fields for related modules
     */
    _getModuleFieldMeta: function() {
        var fieldMeta = {};
        _.each(this.activityModules, function(module) {
            var fieldMap = {};
            _.each(this.moduleFieldNames[module], function(field) {
                fieldMap[field] = true;
            });

            var meta = app.metadata.getView(module, 'preview') ||
                app.metadata.getView(module, 'record') || {};
            var fields = [];
            _.each(meta.panels, function(panel) {
                _.each(panel.fields, function(field) {
                    if (fieldMap[field.name]) {
                        fields.push(field);
                    }
                });
            });

            meta.panels = [{fields: fields}];
            fieldMeta[module] = meta;
        }, this);
        return fieldMeta;
    },

    /**
     * Initialize collection of related records to base record
     * @private
     */
    _initCollection: function() {
        if (!(this.baseModule && this.baseRecord && this.activityModules)) {
            return;
        }
        var self = this;
        var RelatedActivityCollection = app.MixedBeanCollection.extend({
            activityModules: this.activityModules,
            buildURL: _.bind(function(params) {
                params = params || {};

                var url = app.api.serverUrl + '/' + this.baseModule + '/' +
                    this.baseRecord.get('id') + '/' + 'link/related_activities';

                if (this.activityModules.indexOf('Audit') !== -1 && !_.isEmpty(this.moduleFieldNames.Audit)) {
                    params.field_list = {
                        'Audit': this.moduleFieldNames.Audit.join(','),
                    };
                }

                params.module_list = this.activityModules.join(',');

                if (params.module_list === 'Audit') {
                    params.ignore_field_presence = ['assigned_user_id'];
                }

                params = $.param(params);
                if (params.length > 0) {
                    url += '?' + params;
                }
                return url;
            }, this),
            sync: function(method, model, options) {
                options = app.data.parseOptionsForSync(method, model, options);
                if (options.params.fields) {
                    delete options.params.fields;
                }
                options.params.alias_fields = {
                    'record_date': self.recordDateFields
                };
                options.params.order_by = 'record_date:desc';
                var url = this.buildURL(options.params);
                var callbacks = app.data.getSyncCallbacks(method, model, options);

                app.api.call(method, url, options.attributes, callbacks);
            }
        });
        this.relatedCollection = new RelatedActivityCollection();
    },

    /**
     * @inheritdoc
     */
    loadData: function() {
        if (this._mode === 'config' || !this.filter.module) {
            return;
        }

        if (!this.relatedCollection) {
            this._initCollection();
        }

        this.fetchModels();
    },

    /**
     * Fetch models from related collection if not all models had been fetched
     */
    fetchModels: function() {
        if (!this.fetchCompleted && !_.isUndefined(this.relatedCollection)) {
            this.relatedCollection.fetch({
                offset: this.relatedCollection.next_offset,
                success: _.bind(function(coll) {
                    if (this.disposed) {
                        return;
                    }
                    _.each(coll.models, function(model) {
                        model.set('record_date', model.get(this.recordDateFields[model.get('_module')]));
                    }, this);
                    var appendToView = this.models.length !== 0;
                    this.models = this.models.concat(coll.models);
                    this.fetchCompleted = coll.next_offset === -1;
                    if (this.fetchCompleted) {
                        this.$('.dashlet-footer').hide();
                    }

                    if (appendToView) {
                        this.appendCardsToView(coll.models);
                    } else {
                        this.render();
                    }
                }, this)
            });
        }
    },

    /**
     * Set icon class attributess on related collection models base on module type
     */
    _setIconClass: function() {
        if (this.models) {
            _.each(this.models, function(model) {
                // it's a change card if the model's module is Audit, use this.module
                var mod = model.get('_module') == 'Audit' ? this.module : model.get('_module');
                model.set('icon_module', mod);
                model.set('icon_class', this.moduleIcons[mod]);
            }, this);
        }
    },

    /**
     * Set field metadata on related collection models
     *
     * @private
     * @param {Data.Bean} model the model to be patched with fields meta
     */
    _patchFieldsToModel: function(model) {
        var fieldsMeta = this.meta.preview;
        model.set('fieldsMeta', fieldsMeta[model.get('_module')]);
    },

    /**
     * Handle expand/collapse action when expand/collapse icon is clicked
     *
     * @param {Event} event Click event that triggers the action
     */
    handleExpandedClick: function(event) {
        var $element = this.$(event.currentTarget);
        var $parent = $element.closest('.timeline-entry');
        var modelId = $parent.data('id');
        // to toggle chevron up and down
        var $el = $element.find('.expand-collapse');

        // if model is already expanded, reset id and collapse panel
        if (modelId === this.expandedModelId) {
            this.expandedModelId = '';
            $el.removeClass('sicon-chevron-up').addClass('sicon-chevron-down');
            $parent.children('.expanded-contents').addClass('hide');
            $parent.children('.static-contents').removeClass('expanded');
            return;
        }

        // collapse existing expanded model
        if (this.expandedModelId) {
            var $expanded = this.$('.timeline-entry[data-id="' + this.expandedModelId + '"]');
            $expanded.children('.expanded-contents').addClass('hide');
            $expanded.children('.static-contents').removeClass('expanded');
            $expanded.find('.expand-collapse').removeClass('sicon-chevron-up').addClass('sicon-chevron-down');
        }

        var model = _.find(this.models, function(model) {
            return model.get('id') === modelId;
        });
        this.expandedModelId = modelId;

        // if model data fetched, expand; if not fetch then expand
        if (model.get('fullBeanFetched')) {
            $parent.children('.expanded-contents').removeClass('hide');
            $parent.children('.static-contents').addClass('expanded');
            $el.removeClass('sicon-chevron-down').addClass('sicon-chevron-up');
        } else {
            model.fetch({
                view: app.metadata.getView(model.get('_module'), 'preview') ? 'preview' : 'record',
                success: _.bind(function(m) {
                    model.set('fullBeanFetched', true);
                    this._patchFieldsToModel(model);
                    this._render();

                    var $modelEl = this.$('.timeline-entry[data-id="' + modelId + '"]');
                    $modelEl.children('.expanded-contents').removeClass('hide');
                    $modelEl.children('.static-contents').addClass('expanded');
                    $modelEl.find('.expand-collapse').removeClass('sicon-chevron-down').addClass('sicon-chevron-up');
                }, this)
            });
        }
    },

    /**
     * Reload data.
     */
    reloadData: function() {
        if (this.relatedCollection) {
            this.relatedCollection.reset([], {silent: true});
            this.relatedCollection.resetPagination();
        }
        this.fetchCompleted = false;
        this.models = [];
        this.render();
        this.loadData();
    },

    /**
     * Create new record.
     *
     * @param {Event} event Click event.
     * @param {Object} params
     * @param {string} params.module Module name.
     * @param {string} params.link Relationship link.
     */
    createRecord: function(event, params) {
        var self = this;
        var model = this.createLinkModel(this.baseRecord, params.link);

        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                module: params.module,
                model: model
            }
        }, function(context, model) {
            if (!model) {
                return;
            }
            self.reloadData();
        });
    },

    /**
     * Compose an email related to the relevant record.
     *
     * @param {Event} event Event.
     * @param {Object} params Parameters.
     * @param {string} params.module Module name.
     * @param {string} params.link Relationship link.
     */
    composeEmail: function(event, params) {
        if (this.useSugarEmailClient()) {
            this.once('emailclient:close', function() {
                this.reloadData();
            }, this);

            this.launchEmailClient(event);
        } else {
            var options = this._retrieveEmailOptions($(event.currentTarget));
            window.open(this._buildMailToURL(options), '_blank');
        }
    },

    /**
     * Used by EmailClientLaunch as a hook point to retrieve email options that
     * are specific to a view/field.
     *
     * @return {Object} Email options.
     * @private
     */
    _retrieveEmailOptionsFromLink: function() {
        var parentModel = this.baseRecord;
        var emailOptions = {};

        if (parentModel && parentModel.id) {
            // set parent model as option to be passed to compose for To address & relate
            // if parentModel does not have email, it will be ignored as a To recipient
            // if parentModel's module is not an available module to relate, it will also be ignored
            emailOptions = {
                to: [{bean: parentModel}],
                related: parentModel
            };
        }

        return emailOptions;
    },

    /**
     * Create and render card layout
     *
     * @param model
     * @return {Object}
     */
    createCard: function(model) {
        var module = model.get('_module') || model.module || '';

        if (module) {
            model.link = {
                name: this.getModuleLink(module),
                bean: this.baseRecord,
                type: 'card-link',
            };
        } else {
            model.link = {};
        }

        if (module === 'Audit') {
            model.set({
                parent_model: this.model
            });
        }

        var layout = app.view.createLayout({
            type: 'activity-card',
            context: this.context,
            module: module,
            model: model,
            layout: this.layout,
            timelineType: this.name || 'activity-timeline-base'
        });

        layout.initComponents();

        this.renderedActivities.push(layout);

        // cz Seedbed doesn't like it any other way
        layout.render();
        return layout;
    },

    /**
     * Appends cards
     * @param models array of models to be added to the view
     */
    appendCardsToView: function(models) {
        this._setIconClass();

        _.each(models, _.bind(function(model) {
            this._patchFieldsToModel(model);
            var layout = this.createCard(model);

            if (layout) {
                this.$('.activity-timeline-cards').append(layout.el);
            }

            // check menu icon visibilities
            layout.setCardMenuVisibilities();
        }, this));
    },

    /**
     * Get card module link.
     *
     * @param {string} moduleName The name of card module.
     * @return {string} The card module link.
     */
    getModuleLink: function(moduleName) {
        let link;
        let activityModules = this.getModulesMeta(this.baseModule).activity_modules;
        let module = activityModules.find(item => item.module === moduleName);

        if (module) {
            link = module.link || this.moduleLinkMapping[moduleName] || moduleName.toLowerCase();
        }

        return link;
    },

    /**
     * Disposes activities
     */
    disposeActivities: function() {
        _.each(this.renderedActivities, function(component) {
            component.dispose();
        });
        this.renderedActivities = [];
    },
    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.disposeActivities();
        this._super('_dispose');
    }
}) },
"sales-pipeline": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Sales-pipeline View (base) 

    results: {},
    chart: {},
    plugins: ['Dashlet', 'Chart'],

    /**
     * Is the forecast Module setup??
     */
    forecastSetup: 0,

    /**
     * Track if current user is manager.
     */
    isManager: false,

    /**
     * @inheritDoc
     */
    initialize: function(options) {
        this.isManager = app.user.get('is_manager');
        this._initPlugins();
        this._super('initialize', [options]);

        // check to make sure that forecast is configured
        var forecastConfig = app.metadata.getModule('Forecasts', 'config') || {};
        this.forecastSetup = forecastConfig['is_setup'] || 0;
        this.userCurrencyPreference = app.user.getPreference('currency_id');
        this.locale = SUGAR.charts.getUserLocale();
        // create deep copy for tooltip temp use, etc.
        // it will be set to chart.locality() after instantiation
        this.locality = {};
        this.tooltipTemplate = app.template.getView(this.name + '.tooltiptemplate');
    },

    /**
     * {@inheritDoc}
     */
    initDashlet: function(view) {
        var salesStageLabels = app.lang.getAppListStrings('sales_stage_dom');

        if (!this.isManager && this.meta.config) {
            // FIXME: Dashlet's config page is rendered from meta.panels directly.
            // See the "dashletconfiguration-edit.hbs" file.
            this.meta.panels = _.chain(this.meta.panels).filter(function(panel) {
                panel.fields = _.without(panel.fields, _.findWhere(panel.fields, {name: 'visibility'}));
                return panel;
            }).value();
        }

        // get the current timeperiod
        if (this.forecastSetup) {
            app.api.call('GET', app.api.buildURL('TimePeriods/current'), null, {
                success: _.bind(function(currentTP) {
                    this.settings.set({'selectedTimePeriod': currentTP.id}, {silent: true});
                    this.layout.loadData();
                }, this),
                error: _.bind(function() {
                    // Needed to catch the 404 in case there isnt a current timeperiod
                }, this),
                complete: view.options ? view.options.complete : null
            });
        } else {
            this.settings.set({'selectedTimePeriod': 'current'}, {silent: true});
        }

        this.chart = sucrose.charts.funnelChart()
            .showTitle(false)
            .tooltips(true)
            .margin({top: 0})
            .direction(app.lang.direction)
            .tooltipContent(_.bind(function(eo, properties) {
                var point = {};
                var key = this.chart.getKey()(eo);
                var value = this.chart.getValue()(eo);
                var count = this.chart.getCount()(eo);
                point.label = salesStageLabels ? salesStageLabels[key] || key : key;
                point.value = this._formatValue(value);
                point.percent = sucrose.utility.numberFormatPercent(value, properties.total, this.locality);
                point.count = sucrose.utility.numberFormat(count, 0, false, this.locality);
                return this.tooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
            }, this))
            .colorData('class', {step: 2})
            .fmtValue(_.bind(function(d) {
                var y = d.value || (isNaN(d) ? 0 : d);
                return this._formatValue(y, 0);
            }, this))
            .strings({
                legend: {
                    close: app.lang.get('LBL_CHART_LEGEND_CLOSE'),
                    open: app.lang.get('LBL_CHART_LEGEND_OPEN')
                },
                noData: app.lang.get('LBL_CHART_NO_DATA'),
                noLabel: app.lang.get('LBL_CHART_NO_LABEL')
            })
            .locality(this.locale);

        this.locality = this.chart.locality();
    },

    /**
     * This method is called by the chart model in initDashlet
     *
     * @param {number} d  The numeric value to be formatted
     * @param {number} precision  The level of precision to apply
     * @return {string}  A number formatted with current user settings
     * @private
     */
    _formatValue: function(d, precision) {
        return app.currency.formatAmountLocale(d, this.userCurrencyPreference, precision);
    },

    /**
     * Initialize plugins.
     * Only manager can toggle visibility.
     *
     * @return {View.Views.BaseForecastPipeline} Instance of this view.
     * @protected
     */
    _initPlugins: function() {
        if (this.isManager) {
            this.plugins = _.union(this.plugins, [
                'ToggleVisibility'
            ]);
        }
        return this;
    },

    /**
     * {@inheritDoc}
     */
    bindDataChange: function() {
        this.settings.on('change', function(model) {
            // reload the chart
            if (this.$el && this.$el.is(':visible')) {
                this.loadData({});
            }
        }, this);
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }
        // Clear out the current chart before a re-render
        this.$('svg#' + this.cid).children().remove();

        d3sugar.select('svg#' + this.cid)
            .datum(this.results)
            .transition().duration(500)
            .call(this.chart);

        this.chart_loaded = _.isFunction(this.chart.update);
        this.displayNoData(!this.chart_loaded);
    },

    /**
     * @inheritdoc
     *
     * Additional logic on switch visibility event.
     */
    visibilitySwitcher: function() {
        var activeVisibility;
        if (!this.isManager) {
            return;
        }
        activeVisibility = this.getVisibility();
        this.$el.find('[data-action=visibility-switcher]')
            .attr('aria-pressed', function() {
                return $(this).val() === activeVisibility;
            });
    },

    hasChartData: function() {
        return !_.isEmpty(this.results) && this.results.data && this.results.data.length > 0;
    },

    /**
     * @inheritDoc
     */
    loadData: function(options) {
        var timeperiod = this.settings.get('selectedTimePeriod');
        if (timeperiod) {
            var oppsConfig = app.metadata.getModule('Opportunities', 'config');

            if (oppsConfig) {
                var oppsViewBy = oppsConfig['opps_view_by'];
            } else {
                this.results = {};
                this.renderChart();

                return false;
            }

            var url_base = oppsViewBy + '/chart/pipeline/' + timeperiod + '/';

            if (this.isManager) {
                url_base += this.getVisibility() + '/';
            }
            var url = app.api.buildURL(url_base);
            app.api.call('GET', url, null, {
                success: _.bind(function(o) {
                    if (o && o.data) {
                        var salesStageLabels = app.lang.getAppListStrings('sales_stage_dom');

                        // update sales stage labels to translated strings
                        _.each(o.data, function(dataBlock) {
                            if (dataBlock && dataBlock.key && salesStageLabels && salesStageLabels[dataBlock.key]) {
                                dataBlock.key = salesStageLabels[dataBlock.key];
                            }

                        });
                    }
                    this.results = {};
                    this.results = o;
                    this.renderChart();
                }, this),
                error: _.bind(function(o) {
                    this.results = {};
                    this.renderChart();
                }, this),
                complete: options ? options.complete : null
            });
        }
    },

    /**
     * @inheritDoc
     */
    unbind: function() {
        this.settings.off('change');
        this._super('unbind');
    }
}) },
"searchbar-results": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SearchbarResultsView
 * @alias SUGAR.App.view.views.BaseSearchbarResultsView
 * @extends View.Views.Base.ContentsearchResultsView
 */
({
	// Searchbar-results View (base) 

    /**
     * @inheritdoc
     */
    className: 'searchbar-results',

    /**
     * @inheritdoc
     */
    extendsFrom: 'ContentsearchResultsView'
}) },
"stage2-news-preference": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Stage2-news-preference View (base) 

    extendsFrom: 'BaseView',

    className: 'stage2-notifications-pref',

    events: {
        'click [data-action=removePreference]': 'removePreference'
    },

    /**
     * @inheritdoc
     */
    initialize: function(opts) {
        this._super('initialize', [opts]);

        this.setCategoryClass();
        this.supportsPushMessages = opts.pushMessages;
        this.model.on('change:type', _.bind(this.toggleAccountTagsField, this));
        this.model.on('change:browser', _.bind(this.enableNotifications, this));
    },

    /**
     * Trigger the push notification access request process.
     *
     * @param {Event} event The changes event
     * @param {boolean} newValue Browser target value
     */
    enableNotifications: function(event, newValue) {
        if (newValue && this.supportsPushMessages) {
            app.events.trigger('news-preference:enable-notifications', event);
        }
    },

    /**
     * The category class name is used for the first dropdown in the view.
     */
    setCategoryClass: function() {
        this.categoryClass = this.model.get('type') === 'tags' ? ' short' : ' long';
    },

    /**
     * Delegate the remove event handling to the layout.
     *
     * @param {Event} event The click event on the remove button.
     */
    removePreference: function(event) {
        var el = event.currentTarget;
        var cid = el.getAttribute('data-pref-cid');
        app.events.trigger('news-preference:remove', this, cid);
    },

    /**
     * If the accoun tags is selected for the main dropdown we need to show the tags field
     * As per current state a timeout is needed for the re-rendering in order to allow the
     * dropdowns to process the change event with their own listeners.
     */
    toggleAccountTagsField: function() {
        this.setCategoryClass();
        setTimeout(_.bind(this.render, this), 1);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.off('change:type', _.bind(this.render, this));
        this.model.off('change:browser', _.bind(this.enableNotifications, this));
        this._super('_dispose');
    }
}) },
"omnichannel-config-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The layout for the Omnichannel console.
 *
 * @class View.Layouts.Base.OmnichannelConfigHeaderView
 * @alias SUGAR.App.view.layouts.BaseOmnichannelConfigHeaderView
 * @extends View.Layouts.Base.OmnichannelHeaderView
 */
({
	// Omnichannel-config-header View (base) 

    extendsFrom: 'OmnichannelHeaderView',
}) },
"stage2-help": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Stage2-help View (base) 


    plugins: ['Stage2CssLoader'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._specialMessage1 = app.lang.get('LBL_HINT_HELP_MESSAGE1');
        this._specialMessage2 = app.lang.get('LBL_HINT_HELP_MESSAGE2');
        this._specialMessage3 = app.lang.get('LBL_HINT_HELP_MESSAGE3');
        this._specialMessage4 = app.lang.get('LBL_HINT_PREVIEW_QUESTION');
        this.sugarPROFlavor = app.metadata.getServerInfo().flavor === 'PRO';
        this.licensedHint = app.user.hasLicense('HINT');
        this.proNonLicensedUser = !this.licensedHint && this.sugarPROFlavor &&
            app.hint.versionCompare('10.3.0', true) >= 0;

        this._super('initialize', [options]);

        var hintLicense = app.user.hasHintLicense();
        if (!hintLicense) {
            this.before('render', function() {
                this.$el.addClass('hide');
            });
            return;
        }

        this._moduleName = this.context.get('module');
        this._detectAttrsContacts = ['first_name', 'last_name'];
        this._detectAttrsLeads = ['first_name', 'last_name', 'account_name', 'website', 'title', 'phone_work'];
        this._moduleSingular = app.lang.getModuleName(this._moduleName);
        if (this._moduleName === 'Accounts') {
            this._defaultMessage1 = app.lang.get('LBL_HINT_HELP_DEFAULT_MESSAGE1A', null, this);
            this._defaultMessage2 = '';
        } else {
            this._defaultMessage1 = app.lang.get('LBL_HINT_HELP_DEFAULT_MESSAGE1B', this._moduleName, {
                currentModule: this._moduleSingular
            });
            this._defaultMessage2 = '';
        }
        this._nonTriggerFields = [];
        this._relatedModules = ['Contacts', 'Leads', 'Accounts'];
        this._message1 = this._defaultMessage1;
        this._message2 = this._defaultMessage2;
        this.isDarkMode = app.hint.isDarkMode();
        if (this.context) {
            this.listenTo(this.model, 'change', this._detectChange);
            this.context.on('app:preview:stage2-show-notification', function() {
                // Close preview to show helper.
                app.events.trigger('preview:close');
                this._changeMsg();
            }, this);
        }
    },

    /**
     * Set message
     *
     * @param {string} msg1
     * @param {string} msg2
     */
    _setMsg: function(msg1, msg2) {
        this._message1 = msg1;
        this._message2 = msg2;
        this.render();
    },

    /**
     * Change message
     */
    _changeMsg: function() {
        if (this._moduleName === 'Accounts') {
            if (this.model.get('name')) {
                // When website entered and no match found, change message.
                if (this.model.get('website')) {
                    this._setMsg(this._specialMessage1, '');
                } else {
                    this._setMsg(this._specialMessage1, this._specialMessage3);
                }
            } else if (this.model.get('website')) {
                this._setMsg(this._specialMessage1, this._specialMessage3);
            } else {
                this._setMsg(this._defaultMessage1, this._defaultMessage2);
                this._addIndicators();
            }
        } else {
            if (this.model.get('first_name') && this.model.get('last_name')) {
                if (this.model.get('email') && this.model.get('email').length > 0) {
                    this._setMsg(this._specialMessage1, '');
                }
            } else {
                this._setMsg(this._defaultMessage1, this._defaultMessage2);
                this._addIndicators();
            }
        }
    },

    /**
     * Trigger preview
     */
    _triggerPreview: function(attr, value) {
        app.events.trigger('preview:close');
        app.events.trigger('preview:render', this.model);
        app.events.trigger('hint:user-input', true);
        return;
    },

    /**
     * Check is valid domain
     *
     * @param {string} domain
     * @return bool
     */
    _isValidDomain: function(domain) {
        var re = new RegExp(/[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/);
        return domain.match(re);
    },

    /**
     * Detect change
     */
    _detectChange: function() {
        // Once we detected there is only one specific attribute changed in model,
        // we trigger hint preview to update the new enriched data.
        var keys = _.keys(this.model.changedAttributes());
        var self = this;
        if (_.contains(this._relatedModules, this._moduleName) &&
            (keys.length === 1 ||
                (keys.length === 2 && keys[0] === 'first_name' && (keys[1] === 'full_name' || keys[1] === 'name')) ||
                (keys.length === 2 && keys[0] === 'last_name' && (keys[1] === 'full_name' || keys[1] === 'name')))) {

            var val = this.model.changedAttributes()[keys[0]];
            if (this._moduleName === 'Accounts') {
                if (keys[0] === 'website') {
                    if ((val && val.trim() !== '' && this._isValidDomain(val)) || val.trim() === '') {
                        if (this.model.get('website') || this.model.get('name')) {
                            this._triggerPreview(keys[0], val);
                        } else {
                            app.events.trigger('preview:close');
                        }
                    }
                } else if (keys[0] === 'name') {
                    if (val && val.trim() !== '') {
                        if (this.model.get('website') || this.model.get('name')) {
                            this._triggerPreview(keys[0], val);
                        } else {
                            app.events.trigger('preview:close');
                        }
                    }
                }
            } else { // under Contacts and Leads
                if (_.contains(this['_detectAttrs_' + this._moduleName], keys[0])) {
                    var flag = _.contains(this._nonTriggerFields, keys[0]);
                    if (!flag) {
                        app.events.trigger('hint:user-input', false);
                    } else {
                        this._triggerPreview(keys[0], val);
                    }
                }
            }
        }
    },

    /**
     * Add indicators
     */
    _addIndicators: function() {
        var self = this;
        this.$('[data-name="loading"]').removeClass('hidden');
        setTimeout(function() {
            self.$('[data-name="loading"]').addClass('hidden');
        }, 1000);
    },
}) },
"password-expired": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PasswordExpiredView
 * @alias SUGAR.App.view.views.BasePasswordExpiredView
 * @extends View.View
 */
({
	// Password-expired View (base) 

    plugins: ['ErrorDecoration'],
    events: {
        'click [name=save_button]': 'savePassword'
    },
    /**
     * @override
     * @param options
     */
    initialize: function(options){
        var meta = options.meta || {},
            fields = {};
        _.each(_.flatten(_.pluck(meta.panels, "fields")), function(field) {
            fields[field.name] = field;
        });
        this.fieldsToValidate = fields;
        app.view.View.prototype.initialize.call(this, options);
        // Field name in defs doesn't match rendered field name
        // So remove this validation task
        this.model.removeValidationTask('sidecar');
        // This flag allows change-password field to show alerts
        this.model.showPopupAlerts = true;
    },
    /**
     * @override
     * @private
     */
    _render: function() {
        var self = this;
        var message = app.lang.get('LBL_PASSWORD_EXPIRATION_LOGIN');

        //Hack: Gets rid of leftover loading...
        app.alert.dismissAll();
        this.logoUrl = app.metadata.getLogoUrl(app.utils.isDarkMode());

        // Check if we have any password requirements messages and if so
        // push in to our passwordRequirements so hbs displays 'em
        this._showPasswordRequirements = false;
        this.passwordRequirements = [];
        if (app.user && app.user.has('password_requirements')) {
            this._showPasswordRequirements = true;
            var preqs = app.user.get('password_requirements');
            _.each(preqs, function(val, key) {
                self.passwordRequirements.push(val);
            });
        }
        app.view.View.prototype._render.call(this);

        //Render password expired message (after view rendered)
        if (app.user && app.user.has('password_expired_message')) {
            message = app.user.get('password_expired_message');
        }
        this.$('.password-reqs-status').text(message);
        return this;
    },
    savePassword: function() {
        var self = this, callbacks, newPass, oldPass = self.$('[name=current_password]').val();
        app.alert.dismiss('passwords_mismatch');
        self.model.doValidate(this.fieldsToValidate, function(isValid) {
            if (isValid) {
                // A robot has reached into the honey pot. Do not submit (name_field not real)
                if (app.config.honeypot_on && app.config.honeypot_on === true &&
                    (self.$('input[name="name_field"]').val() || self.model.get('name_field'))) return;
                newPass = self.model.get('expired_password_update');//see change-my-password field

                if (newPass) {
                    app.alert.dismiss('changePassword');
                    app.alert.show('passreset', {level: 'process', title: app.lang.get('LBL_CHANGE_PASSWORD'), messages: app.lang.get('LBL_PROCESSING'), autoClose: false});
                    app.api.updatePassword(oldPass, newPass, {
                        success: function(data) {
                            app.alert.dismiss('passreset');
                            app.$contentEl.show();

                            //Password was valid and update successful
                            if (data && data.valid) {
                                callbacks = self.context.get("callbacks");
                                if (callbacks && callbacks.complete) {
                                    callbacks.complete();
                                }
                            } else if (data.message) {
                                //Password was deemed invalid by server. Display provided message
                                app.alert.show('password-invalid', {
                                    level: 'error',
                                    title: data.message
                                });
                            } else {
                                //Server should have provided data.message; use a generic message as fallback
                                app.alert.show('password-invalid', {
                                    level: 'error',
                                    title: app.lang.get('ERR_GENERIC_TITLE') + ': ' +
                                        app.lang.get('ERR_CONTACT_TECH_SUPPORT')
                                });
                            }
                        },
                        error: function(error) {
                            app.alert.dismiss('passreset');
                            app.error.handleHttpError(error, self);
                        }
                    });
                }
            }
        }, self);
    }
}) },
"pagination": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * Pagination view showing prev, next and page numbers.
 * Its extracted from View.Views.Base.Opportunities.ProductQuickPicksView to make it reusable.
 *
 * @class View.Views.Base.PaginationView
 * @alias SUGAR.App.view.views.BasePaginationView
 * @extends View.View
 */
({
	// Pagination View (base) 

    events: {
        'click [data-action=page-clicked]': 'getPageNumClicked',
        'click [data-action=page-nav-clicked]': 'onPageNavClicked'
    },

    /**
     * Pagination items.
     * @property {Object[]}
     */
    pageNumList: [],

    /**
     * Clicked page number.
     * @property {number}
     */
    pageNumClicked: 1,

    /**
     * Total pages.
     * @property {number}
     */
    paginationLength: 0,

    /**
     * Is 'prev' enabled?
     * @property {boolean}
     */
    isPrevDisabled: false,

    /**
     * Is 'next' enabled?
     * @property {boolean}
     */
    isNextDisabled: false,

    /**
     * Is pagination enabled?
     * @property {boolean}
     */
    isPageNumDisabled: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._init();
        this.hide();
        this.context.on('data:fetched', this.show, this);
        this.context.on('data:fetching', this.hide, this);
    },

    /**
     * Initializes pagination.
     *
     * @private
     */
    _init: function() {
        this.pageNumClicked = 1;
        this.paginationLength = 0;
        this.pageNumList = [];
        this.isPrevDisabled = false;
        this.isNextDisabled = false;
        this.isPageNumDisabled = false;
    },

    /**
     * Hides pagination.
     */
    hide: function() {
        this.$el.hide();
    },

    /**
     * Shows pagination based on data to display.
     *
     * @param {Object} data The data to display
     */
    show: function(data) {
        // reset global variables
        this._init();

        if (data.records.length === 0) {
            this.hide();
            return;
        }
        this.$el.show();

        var tmpLeftEllipsesObject = {};
        var tmpRightEllipsesObject = {};

        var currentIndex = 0;
        var startIndex = 0;

        // if some data is returned
        if (data.totalPages > 0) {
            this.paginationLength = data.totalPages;
            this.pageNumClicked = data.currentPage;

            if (this.pageNumClicked === this.paginationLength || this.paginationLength === 1) {
                this.isNextDisabled = true;
            }
            if (this.pageNumClicked === 1 || this.paginationLength === 1) {
                this.isPrevDisabled = true;
            }

            this.isPageNumDisabled = this.pageNumClicked === 1 && this.paginationLength === 1 ? true : false;

            tmpLeftEllipsesObject = {
                isIcon: true,
                listClass: 'pagination-li',
                subListClass: 'left-ellipsis-icon fa fa-ellipsis-h'
            };

            tmpRightEllipsesObject = {
                isIcon: true,
                listClass: 'pagination-li',
                subListClass: 'right-ellipsis-icon fa fa-ellipsis-h'
            };

            // push details for each list item in the pagination
            for (var page = 0; page < data.totalPages; page++) {
                this.pageNumList.push({
                    isIcon: false,
                    listClass: 'pagination-li',
                    subListClass: 'paginate-num-button btn btn-link btn-invisible',
                    pageNum: page + 1,
                    isActive: this.pageNumClicked === page + 1 && !this.isPageNumDisabled ? true : false
                });
            }

            // if more than 4 pages then display just 3 pages with ellipsis
            if (data.totalPages > 4) {
                currentIndex = this.pageNumList.indexOf(this.getCurrentObj());

                if (currentIndex > 0) {
                    startIndex = currentIndex < this.pageNumList.length - 1 ?
                        currentIndex - 1 : this.pageNumList.length - 3;
                } else {
                    startIndex = 0;
                }

                // get just three objects with active item in the center
                this.pageNumList = this.pageNumList.slice(startIndex, startIndex + 3);
                if (startIndex !== 0) {
                    this.pageNumList.unshift(tmpLeftEllipsesObject);
                }
                if (data.totalPages - currentIndex >= 3) {
                    this.pageNumList.push(tmpRightEllipsesObject);
                }
            }
        }

        this.render();
    },

    /**
     * Gets the current pagination number <li> object
     * to be used while showing just three pages with current
     * page at center, in case total pages are more than 4
     *
     * @return {Object} The current pagination number <li> object
     */
    getCurrentObj: function() {
        return _.find(this.pageNumList, function(tmpObj) {
            return tmpObj.pageNum === this.pageNumClicked;
        }, this);
    },

    /**
     * Gets the page Number clicked.
     *
     * @param {Object} evt The click event
     */
    getPageNumClicked: function(evt) {
        evt.preventDefault();
        // To stop the click event as it's not needed any more and may cause the contentsearch-dropdown to be hidden
        // due to race condition, depending on whether the "active" attribute is added by the "show" function here,
        // or the event being handled by contentsearch-dropdown's show()
        evt.stopPropagation();
        var pageId = this.$(evt.target).data('page-id');
        if (this.pageNumClicked === pageId) {
            return;
        }
        this.pageNumClicked = pageId;
        this.context.trigger('page:clicked', {pageNum: this.pageNumClicked});
    },

    /**
     * Event handler for navigantion button click events.
     *
     * @param {Object} evt The click event
     */
    onPageNavClicked: function(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        var $el = this.$(evt.target);
        var currentPageNum = $el.data('page-id');
        if ($el.hasClass('previous-fav') || $el.hasClass('nav-previous')) {
            this.pageNumClicked = currentPageNum - 1;
        } else if ($el.hasClass('next-fav') || $el.hasClass('nav-next')) {
            this.pageNumClicked = currentPageNum + 1;
        }
        this.context.trigger('page:clicked', {pageNum: this.pageNumClicked});
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.context) {
            this.context.off('data:fetching', null, this);
            this.context.off('data:fetched', null, this);
        }
    }
}) },
"saved-reports-chart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SavedReportsChartView
 * @alias SUGAR.App.view.views.BaseSavedReportsChartView
 * @extends View.View
 */
({
	// Saved-reports-chart View (base) 

    plugins: ['Dashlet'],

    events: {
        'click a[name=editReport]': 'editSavedReport'
    },

    /**
     * @inheritdoc
     */
    initDashlet: function(view) {
        // check if we're on the config screen
        if (this.meta.config) {
            this.meta.panels = this.dashletConfig.dashlet_config_panels;
        } else {
            var autoRefresh = this.settings.get('auto_refresh');
            if (autoRefresh > 0) {
                if (this.timerId) {
                    clearTimeout(this.timerId);
                }

                this._scheduleReload(autoRefresh * 1000 * 60);
            }
        }
    },

    /**
     * Schedules chart data reload
     *
     * @param {Number} delay Number of milliseconds which the reload should be delayed for
     * @private
     */
    _scheduleReload: function(delay) {
        this.timerId = setTimeout(_.bind(function() {
            this.context.resetLoadFlag();
            this.loadData({
                success: function() {
                    this._scheduleReload(delay);
                }
            });
        }, this), delay);
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // Holds report data from the server's endpoint once we fetch it
        this.reportData = app.data.createBean();
        this.reportOptions = [];
        this._super('initialize', [options]);
        this.on('chart:complete', this.chartComplete, this);
        this.on('chart:clicked', this.onClickHandler, this);
    },

    /**
     * Route to the bwc edit view of the currently selected Saved Report. If User clicks 'save' or 'cancel' or 'delete'
     * from there, return the user to the current page.
     *
     * @deprecated
     */
    editSavedReport: function() {
        app.logger.warn('View.Views.Base.SavedReportsChartView#editSavedReport' +
            'has been deprecated since 8.0.0.0 and will be removed in a future release');
        var currentTargetId = this.dashModel.get('saved_report_id'),
            params = {
                dashletEdit: 1
            },
            route = app.bwc.buildRoute('Reports', currentTargetId, 'ReportsWizard', params);

        //If this button was clicked too early, the saved_report_id may not be populated. Then we want to return
        //because moving on will result in a php error
        if (!currentTargetId) {
            return;
        }
        app.alert.show('navigate_confirmation', {
            level: 'confirmation',
            messages: 'LBL_NAVIGATE_TO_REPORTS',
            onConfirm: _.bind(function() {
                //Save current location to this so we can use it in the event listener
                this.currentLocation = Backbone.history.getFragment();

                //Add event listener for when the user finishes up the edit
                $(window).one('dashletEdit', _.bind(this.postEditListener, this));

                //Once we've successfully routed to the dashletEdit location,
                //any successive route should be checked. If the user moves away from the edit without
                //either cancelling or finishing the edit, we should forget that we have to come back to the current location
                var dashletEditVisited = false;
                app.router.on('route', function() {
                    var routeLocation = Backbone.history.getFragment();
                    if (routeLocation.indexOf('dashletEdit=1') >= 0) {
                        dashletEditVisited = true;
                    }
                    if (routeLocation.indexOf('dashletEdit=1') < 0 && dashletEditVisited) {
                        app.router.off('route');
                        $(window).off('dashletEdit');
                    }
                });

                //Go to edit page
                app.router.navigate(route, {trigger: true});
            }, this)
        });
    },

    /**
     * Call after the user is done editing the saved report. Return the user to the page that was stored when the
     * event was set
     *
     * @param {Object} jquery event
     */
    postEditListener: function(event) {
        //Go back from whence we came
        if (this.currentLocation) {
            app.router.navigate(this.currentLocation, {trigger: true});
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.meta.config) {
            this.settings.on('change:saved_report_id', function(model) {
                var reportId = model.get('saved_report_id');
                var options;
                if (_.isEmpty(reportId)) {
                    return;
                }
                options = {
                    success: function(data) {
                        var label;
                        this.setChartParams(data, true);
                        // set the title of the dashlet to the report title
                        label = this.$('[name="label"]');
                        if (label.length) {
                            label.val(this.settings.get('label'));
                        }
                    }
                };
                this.getSavedReportById(reportId, options);
            }, this);

            this.settings.on('change:chart_type', function(model) {
                // reset settings xAxisLabel because of line chart
                var reportData = this.reportData.get('rawReportData');
                var chartData = this.reportData.get('rawChartData');
                var axisLabel;
                // report might no be loaded yet
                if (reportData && chartData) {
                    axisLabel = this._getXaxisLabel(
                        reportData.group_defs,
                        chartData.properties[0],
                        model.get('chart_type')
                    );
                    model.set('x_axis_label', axisLabel);
                }
                // toggle display of chart display option controls based on chart type
                this._toggleChartFields();
            }, this);
        }
    },

    /**
     * Check acls to show/hide 'Edit Selected Report' link
     *
     * @deprecated
     */
    updateEditLink: function(reportId) {
        app.logger.warn('View.Views.Base.SavedReportsChartView#updateEditLink' +
            'has been deprecated since 8.0.0.0 and will be removed in a future release');

        var acls = this.reportAcls[reportId || this.settings.get('saved_report_id')],
            showEditLink = !acls || acls['edit'] !== 'no';
        this.$('[name="editReport"]').toggle(showEditLink);
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        options = options || {};
        var reportId = this.settings.get('saved_report_id');

        if (!_.isEmpty(reportId)) {
            // set callback for successful get of report data in getSavedReportById()
            _.extend(options, {
                success: _.bind(function(data) {
                    this.setChartParams(data, false);
                }, this)
            });
            this.getSavedReportById(reportId, options);
        }
    },

    getDefaultSettings: function() {
        // By default, settings only has: label, type, config, module
        // Module is normally null so we want to rehit that
        var settings = _.clone(this.settings.attributes);
        var defaults = {
                allowScroll:     true,
                auto_refresh:    0,
                colorData:       'class',
                config:          true,
                hideEmptyGroups: true,
                reduceXTicks:    true,
                rotateTicks:     true,
                show_controls:   false,
                show_title:      false,
                show_x_label:    false,
                show_y_label:    false,
                showValues:      0,
                staggerTicks:    true,
                wrapTicks:       true,
                x_axis_label:    '',
                y_axis_label:    ''
            };
        return _.defaults(settings, defaults);
    },

    /**
     * Process the chart data from the server
     *
     * @param {Object|String} serverData The Report Data from the server
     * @param {Boolean} [update] Is this an update to the report?
     */
    setChartParams: function(serverData, update) {
        var updated;
        var data;
        var properties;
        var config;
        var params;
        var settings;
        var chartType;

        // only called by bindDataChange when the report id is changed in config panel
        if (!serverData.reportData || !serverData.chartData) {
            if (!this.meta.config && this.chartField) {
                this.chartField.displayNoData(true);
            }
            return;
        }
        updated = _.isUndefined(update) ? false : update;
        data = serverData.reportData;
        properties = serverData.chartData.properties[0];

        config = this.getChartConfig(properties.type); // this is chart type in Report

        // default settings is current settings with defaults
        settings = this.getDefaultSettings();

        // get translation for the chart label if possible
        settings.label = app.lang.get(settings.label, this.module);

        // this does what extend/defaults does but we need it for x_axis_label before
        chartType = updated ? config.chartType : settings.chart_type || config.chartType;

        params = {
            label: data.label,
            chart_type: chartType, // this is renamed chart type from Report
            report_title: properties.title,
            show_legend: properties.legend === 'on' ? true : false,
            stacked: config.barType === 'stacked' || config.barType === 'basic' ? true : false,
            x_axis_label: this._getXaxisLabel(data.group_defs, properties, chartType),
            y_axis_label: this._getYaxisLabel(data),
            module: properties.base_module,
            allow_drillthru: properties.allow_drillthru,
            vertical: config.orientation === 'vertical' ? true : false,
            direction: app.lang.direction
        };

        // override settings when new report is selected
        if (updated) {
            _.extend(settings, params);
        } else {
            _.defaults(settings, params);
        }

        // persist the chart settings for use by SugarCharts
        this.reportData.set('rawChartParams', settings);

        // update the settings model for use by chart field
        this.settings.set(settings);

        // update chart state for drillthru
        if (this.context && this.context.get('chartState') && this.context.get('chartLabels')) {
            var newState = this.getChartState(serverData.chartData);
            if (newState) {
                this.context.set('chartState', newState);
            } else {
                this.context.unset('chartState');
                this.context.unset('chartLabels');
            }
        }

        // toggle display of chart display option controls based on chart type
        this._toggleChartFields();
    },

    /**
     * Gets chart state
     * @param {Object} chartData chart data
     * @return {Object} chart state
     */
    getChartState: function(chartData) {
        var chartState = null;
        var chartLabels = this.context.get('chartLabels');
        var config = this.context.get('dashConfig');
        var reportData = this.context.get('reportData');
        switch (config.chart_type) {
            case 'funnel chart':
            case 'pie chart':
            case 'donut chart':
            case 'treemap chart':
                if (reportData.group_defs.length > 1) {
                    var seriesIndex = _.findIndex(chartData.values, function(value) {
                        return value.label === chartLabels.seriesLabel;
                    });
                    if (seriesIndex >= 0) {
                        chartState = {seriesIndex: chartData.values.length - seriesIndex - 1};
                    }
                } else {
                    var seriesIndex = _.indexOf(chartData.label, chartLabels.seriesLabel);
                    if (seriesIndex >= 0) {
                        chartState = {seriesIndex: chartData.label.length - seriesIndex - 1};
                    }
                }
                break;
            case 'horizontal bar chart':
            case 'bar chart':
                if (reportData.group_defs.length > 1) {
                    var seriesIndex = _.findIndex(chartData.values, function(value) {
                        return value.label === chartLabels.seriesLabel;
                    });
                    if (seriesIndex >= 0) {
                        chartState = {groupIndex: seriesIndex, pointIndex: seriesIndex, seriesIndex: seriesIndex};
                    }
                } else {
                    var groupIndex = _.indexOf(chartData.label, chartLabels.groupLabel);
                    if (groupIndex >= 0) {
                        chartState = {groupIndex: groupIndex, pointIndex: groupIndex, seriesIndex: 0};
                    }
                }
                break;
            case 'horizontal group by chart':
            case 'group by chart':
            case 'stacked group by chart':
            case 'horizontal grouped bar chart':
            case 'vertical grouped bar chart':
                if (reportData.group_defs.length > 1) {
                    var groupIndex = _.findIndex(chartData.values, function(value) {
                        return value.label === chartLabels.groupLabel;
                    });
                    var seriesIndex = _.indexOf(chartData.label, chartLabels.seriesLabel);
                    if (groupIndex >= 0 && seriesIndex >= 0) {
                        chartState = {groupIndex: groupIndex, pointIndex: groupIndex, seriesIndex: seriesIndex};
                    }
                } else {
                    var groupIndex = _.indexOf(chartData.label, chartLabels.groupLabel);
                    if (groupIndex >= 0) {
                        chartState = {groupIndex: groupIndex, pointIndex: groupIndex, seriesIndex: groupIndex};
                    }
                }
                break;
            case 'line chart':
                if (reportData.group_defs.length > 1) {
                    var seriesIndex = _.findIndex(chartData.values, function(value) {
                        return value.label === chartLabels.groupLabel;
                    });
                    var groupIndex = _.indexOf(chartData.label, chartLabels.seriesLabel);
                    if (groupIndex >= 0 && seriesIndex >= 0) {
                        chartState = {groupIndex: groupIndex, pointIndex: groupIndex, seriesIndex: seriesIndex};
                    }
                } else {
                    var groupIndex = _.indexOf(chartData.label, chartLabels.groupLabel);
                    if (groupIndex >= 0) {
                        chartState = {groupIndex: groupIndex, pointIndex: 0, seriesIndex: groupIndex};
                    }
                }
                break;
        }
        return chartState;
    },

    /**
     * Builds the chart config based on the type of chart
     * @return {Mixed}
     */
    getChartConfig: function(chartType) {
        var chartConfig;

        switch (chartType) {
            case 'pie chart':
            case 'donut chart':
            case 'treemap chart':
            case 'gauge chart':
                chartConfig = {
                    chartType: chartType,
                };
                break;

            case 'line chart':
                chartConfig = {
                    lineType: 'grouped',
                    chartType: 'line chart'
                };
                break;

            case 'funnel chart 3D':
                chartConfig = {
                    chartType: 'funnel chart'
                };
                break;

            case 'stacked group by chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'stacked',
                    chartType: 'group by chart'
                };
                break;

            case 'group by chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'grouped',
                    chartType: 'group by chart'
                };
                break;

            case 'bar chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'basic',
                    chartType: 'group by chart'
                };
                break;

            case 'horizontal group by chart':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'stacked',
                    chartType: 'horizontal group by chart'
                };
                break;

            case 'horizontal bar chart':
            case 'horizontal':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'basic',
                    chartType: 'horizontal group by chart'
                };
                break;

            case 'horizontal grouped bar chart':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'grouped',
                    chartType: 'horizontal group by chart'
                };
                break;
            case 'vertical grouped bar chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'grouped',
                    chartType: 'group by chart'
                };
                break;

            default:
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'stacked',
                    chartType: 'bar chart'
                };
                break;
        }

        return chartConfig;
    },

    /**
     * Callback function on chart render complete.
     *
     * @param {Function} chart sucrose chart instance
     * @param {Object} params chart display parameters
     * @param {Object} reportData report data with properties and data array
     */
    chartComplete: function(chart, params, reportData, chartData) {
        app.logger.warn('chartComplete has been deprecated. Chart click event is now handled by onClickHander');
        if (!_.isFunction(chart.seriesClick) || !params.allow_drillthru) {
            return;
        }

        // This seriesClick callback overrides the default set
        // in sugarCharts for use in the Report module charts
        chart.seriesClick(_.bind(function(data, eo, chart, labels) {
            var state = SUGAR.charts.buildChartState(eo, labels);
            if (!_.isFinite(state.seriesIndex)) {
                return;
            }

            if (params.chart_type === 'line chart') {
                params.groupLabel = SUGAR.charts.extractSeriesLabel(state, data);
                params.seriesLabel = SUGAR.charts.extractGroupLabel(state, labels);
            } else {
                params.seriesLabel = SUGAR.charts.extractSeriesLabel(state, data);
                params.groupLabel = SUGAR.charts.extractGroupLabel(state, labels);
            }

            chart.clearActive();
            if (chart.cellActivate) {
                chart.cellActivate(state);
            } else if (chart.seriesActivate) {
                chart.seriesActivate(state);
            } else {
                chart.dataSeriesActivate(eo);
            }
            // keep track of chart state for refresh
            // needed for drillthru chart only
            if (this.context.get('chartState')) {
                this.context.set('chartState', state);
                var chartLabels = {
                    groupLabel: params.groupLabel,
                    seriesLabel: params.seriesLabel
                };
                this.context.set('chartLabels', chartLabels);
            }
            chart.dispatch.call('tooltipHide', this);

            this._handleFilter(chart, params, state, reportData, chartData);
        }, this));
    },

    /**
     * Click handler to open drilldown drawer
     * @param event
     * @param activeElements
     * @param chart
     * @param {BaseChart} wrapper
     * @param reportDef
     */
    onClickHandler: function(event, activeElements, chart, wrapper, reportDef) {
        let groupIndex;
        let groupLabel;
        let seriesIndex;
        let seriesLabel;
        let element;

        let params = Object.assign({}, wrapper.params);

        // funnel chart uses chartjs v2 which has a different signature
        if (wrapper.chartType == 'funnel') {
            if (_.isEmpty(activeElements)) {
                return;
            }
            let internalChart = activeElements[0]._chart;
            let elementClicked = internalChart.getElementAtEvent(event);
            groupIndex = elementClicked[0]._index;
            groupLabel = internalChart.data.labels[groupIndex];
            seriesIndex = elementClicked[0]._datasetIndex;
            seriesLabel = internalChart.data.datasets[seriesIndex].label;
            params.seriesLabel = seriesLabel;
            params.seriesIndex = seriesIndex;
            params.groupLabel = groupLabel;
            params.groupIndex = groupIndex;

            let chartLabels = {
                groupLabel: groupLabel,
                seriesLabel: seriesLabel
            };
            this.context.set('chartLabels', chartLabels);
            this._handleFilter(internalChart, params, null, reportDef, wrapper.rawData);
        } else {
            element = chart.getElementsAtEventForMode(event, 'nearest', {intersect: true}, false);
            if (_.isEmpty(element)) {
                return;
            }
            groupIndex = element[0].index;
            groupLabel = chart.data.labels[groupIndex];
            seriesIndex = element[0].datasetIndex;
            seriesLabel = chart.data.datasets[seriesIndex].label;

            if (params.chart_type === 'line chart') {
                params.groupLabel = seriesLabel;
                params.groupIndex = seriesIndex;
                params.seriesLabel = groupLabel;
                params.seriesIndex = groupIndex;
            } else {
                params.seriesLabel = seriesLabel;
                params.seriesIndex = seriesIndex;
                params.groupLabel = groupLabel;
                params.groupIndex = groupIndex;
            }
            let chartLabels = {
                groupLabel: groupLabel,
                seriesLabel: seriesLabel
            };
            this.context.set('chartLabels', chartLabels);
            this._handleFilter(chart, params, null, reportDef, wrapper.rawData);
        }
    },

    /**
     * Handle either navigating to target module or update list view filter.
     *
     * @param {Function} chart sucrose chart instance
     * @param {Object} params chart display parameters
     * @param {Object} state chart display and data state
     * @param {Object} reportData report data as returned from API
     * @param {Object} chartData chart data with properties and data array
     * @protected
     */
    _handleFilter: function(chart, params, state, reportData, chartData) {
        var module = params.baseModule;
        var reportId = this.settings.get('saved_report_id');

        var enums;
        var groupDefs;
        var drawerContext;

        app.alert.show('listfromreport_loading', {level: 'process', title: app.lang.get('LBL_LOADING')});

        if (this.$el.parents('.drawer.active').length === 0) {
            enums = SUGAR.charts.getEnums(reportData);
            groupDefs = SUGAR.charts.getGrouping(reportData);
            drawerContext = {
                chartData: chartData,
                chartModule: module,
                chartState: state,
                dashModel: null,
                dashConfig: params,
                enumsToFetch: enums,
                filterOptions: {
                    auto_apply: false
                },
                groupDefs: groupDefs,
                layout: 'drillthrough-drawer',
                module: 'Reports',
                reportData: reportData,
                reportId: reportId,
                skipFetch: true,
                useSavedFilters: false
            };

            this.openDrawer(drawerContext);
        } else {
            this.updateList(params, state);
        }
    },

    /**
     * Open a drill through drawer with list and dashlet replica.
     *
     * @param {Object} drawerContext drillthrough content and display parameters
     */
    openDrawer: function(drawerContext) {
        var currentModule = app.drawer.context.get('module');

        // This needs to set to target module for Merge to show the target module fields
        app.drawer.context.set('module', drawerContext.chartModule);

        app.drawer.open({
            layout: 'drillthrough-drawer',
            context: drawerContext
        }, _.bind(function() {
            if (currentModule) {
                // reset the drawer module
                app.drawer.context.set('module', currentModule);
            }
        }, this, currentModule));
    },

    /**
     * Update the record list in drill through drawer.
     *
     * @param {Object} params chart display parameters
     * @param {Object} state chart display and data state
     */
    updateList: function(params, state) {
        var drawer = this.closestComponent('drawer').getComponent('drillthrough-drawer');
        drawer.context.set('dashConfig', params);
        drawer.context.set('chartState', state);
        drawer.updateList();

        if (this.chartField && this.chartField.chart) {
            this.chartField.chart.updateParams(params);
        }
    },

    /**
     * Returns the x-axis label based on report data
     * @return {String}
     */
    _getXaxisLabel: function(groups, properties, chartType) {
        return chartType === 'line chart' ?
            properties.seriesName || _.last([].concat(groups)).label :
            properties.groupName || _.first([].concat(groups)).label;
    },

    /**
     * Returns the y-axis label based on report data
     * @return {String}
     */
    _getYaxisLabel: function(data) {
        var label = '';
        if (data && data.summary_columns) {
            _.each(data.summary_columns, function(column) {
                if (!_.isUndefined(column.group_function)) {
                    label = column.label;
                }
            });
        }
        return label;
    },

    /**
     * Makes a call to filter api to get all reports with chart stored in the saved_reports table
     *
     * @deprecated
     */
    getAllReportsWithCharts: function() {
        app.logger.warn('View.Views.Base.SavedReportsChartView#getAllReportsWithCharts' +
            'has been deprecated since 8.0.0.0 and will be removed in a future release');
        var params = {
                fields: 'id,name,module,report_type,content,chart_type,assigned_user_id',
                order_by: 'name:asc',
                filter: [{chart_type: {$not_equals: 'none'}}],
                // get all reports with charts
                max_num: -1
            },
            url = app.api.buildURL('Reports', null, null, params);

        app.api.call('read', url, null, {
            success: _.bind(this.parseAllSavedReports, this)
        });
    },

    /**
     * Parses items passed back from filter api endpoint into enum options
     *
     * @param {Array} reports an array of saved reports returned from the endpoint
     * @deprecated
     */
    parseAllSavedReports: function(reports) {
        app.logger.warn('View.Views.Base.SavedReportsChartView#parseAllSavedReports' +
            'has been deprecated since 8.0.0.0 and will be removed in a future release');

        reports = reports.records || [];
        this.reportOptions = {};
        this.reportAcls = {};

        _.each(reports, function(report) {
            if (app.acl.hasAccess('view', report.module)) {
                // build the reportOptions key/value pairs
                this.reportOptions[report.id] = report.name;
                this.reportAcls[report.id] = report._acl;
            }
        }, this);

        // find the saved_report_id field
        var reportsField = _.find(this.fields, function(field) {
            return field.name == 'saved_report_id';
        });

        if (reportsField) {
            // set the initial saved_report_id to the first report in the list
            // if there are reports to show and we have not already saved this
            // dashlet yet with a report ID
            if (reports && (!this.settings.has('saved_report_id') || _.isEmpty(this.settings.get('saved_report_id')))) {
                this.settings.set('saved_report_id', _.first(reports).id);
            }

            // set field options and render
            reportsField.items = this.reportOptions;
            reportsField._render();

            // check acls to show or hide 'Edit Selected Report' link
            this.updateEditLink();
        }
    },

    /**
     * Makes a call to Reports/:id/chart to fetch specific saved report data
     *
     * @param {String} reportId the ID for the report we're looking for
     */
    getSavedReportById: function(reportId, options) {
        var dt = this.layout.getComponent('dashlet-toolbar');
        if (dt) {
            // manually set the icon class to spiny
            this.$('[data-action=loading]').removeClass(dt.cssIconDefault).addClass(dt.cssIconRefresh);
        }
        var useSavedFilters = this.context && this.context.get('useSavedFilters') ? 'true' : 'false';
        var url = app.api.buildURL('Reports/' + reportId + '/chart?use_saved_filters=' + useSavedFilters);
        app.api.call('read', url, null, {
            success: _.bind(function(serverData) {
                if (options && options.success) {
                    // options.success is usually setChartParams()
                    // defines this.reportData 'rawChartParams';
                    options.success.apply(this, arguments);
                }

                this.reportData.set('rawReportData', serverData.reportData);
                // set reportData's rawChartData to the chartData from the server
                // this will trigger chart.js' change:rawChartData and the chart will update
                this.reportData.set('rawChartData', serverData.chartData);

                // even if the chart data isn't new, we still want to update the chart to resize
                // if the container's size has changed
                if (_.isEmpty(this.reportData.changed)) {
                    this.reportData.trigger('change:rawChartData', this.reportData, serverData.chartData);
                }
            }, this),
            complete: options ? options.complete : null
        });
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        // if we're in config, or if the chartField doesn't exist yet... render
        // otherwise do not render again as this destroys and re-draws the chart and looks awful
        if (this.meta.config || _.isUndefined(this.chartField)) {
            this._super('_render');
        }
    },

    /**
     * Handle the display of the chart display option controls based on chart type
     *
     * @private
     */
    _toggleChartFields: function() {
        if (this.meta.config) {
            let xOptionsFieldset = this.getField('x_label_options');
            let tickDisplayMethods = this.getField('tickDisplayMethods');
            let yOptionsFieldset = this.getField('y_label_options');
            let showValuesField = this.getField('showValues');
            let showLegendField = this.getField('show_legend');
            let groupDisplayOptions = this.getField('groupDisplayOptions');
            let stackedField = this.getField('stacked');

            let showDimensionOptions = false;
            let showBarOptions = false;
            let showTickOptions = false;
            let showStacked = false;
            let showLegend = true;
            let xOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_XAXIS_LABEL');
            let yOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_YAXIS_LABEL');

            switch (this.settings.get('chart_type')) {
                case 'pie chart':
                case 'donut chart':
                case 'gauge chart':
                case 'funnel chart 3D':
                    showDimensionOptions = false;
                    showBarOptions = false;
                    break;

                case 'treemap chart':
                    showLegend = false;
                    showDimensionOptions = false;
                    showBarOptions = false;
                    break;

                case 'line chart':
                    showDimensionOptions = true;
                    showBarOptions = false;
                    break;

                case 'stacked group by chart':
                case 'horizontal group by chart':
                case 'group by chart':
                case 'vertical grouped bar chart':
                case 'horizontal grouped bar chart':
                    showDimensionOptions = true;
                    showBarOptions = true;
                    showStacked = true;
                    break;

                case 'vertical bar chart':
                case 'vertical':
                case 'bar chart':
                case 'horizontal bar chart':
                case 'horizontal':
                    showDimensionOptions = true;
                    showBarOptions = true;
                    showStacked = false;
                    break;

                default:
                    showDimensionOptions = false;
                    showBarOptions = false;
            }

            if (showDimensionOptions) {
                switch (this.settings.get('chart_type')) {
                    case 'horizontal group by chart':
                    case 'horizontal grouped bar chart':
                    case 'horizontal bar chart':
                    case 'horizontal':
                        showTickOptions = false;
                        xOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_YAXIS_LABEL');
                        yOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_XAXIS_LABEL');
                        break;
                    case 'line chart':
                        showTickOptions = true;
                        break;
                    default:
                        showTickOptions = true;
                        xOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_XAXIS_LABEL');
                        yOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_YAXIS_LABEL');
                }
            }

            if (xOptionsFieldset) {
                xOptionsFieldset.$el.closest('.record-cell').toggleClass('hide', !showDimensionOptions);
                xOptionsFieldset.$el.closest('.record-cell').find('.record-label').text(xOptionsLabel);
                yOptionsFieldset.$el.closest('.record-cell').find('.record-label').text(yOptionsLabel);
            }
            if (tickDisplayMethods) {
                tickDisplayMethods.$el.closest('.record-cell').toggleClass('hide', !showDimensionOptions || !showTickOptions);
                tickDisplayMethods.$el.find('.disabled').find('input').prop( 'checked', true ).prop('disabled', true);
            }

            if (yOptionsFieldset) {
                yOptionsFieldset.$el.closest('.record-cell').toggleClass('hide', !showDimensionOptions);
            }

            if (showValuesField) {
                showValuesField.$el.closest('.record-cell').toggleClass('hide', !showBarOptions);
            }
            if (groupDisplayOptions) {
                groupDisplayOptions.$el.closest('.record-cell').toggleClass('hide', !showBarOptions);
                if (stackedField) {
                    stackedField.$el.toggleClass('hide', !showStacked);
                }
            }

            if (showLegendField) {
                showLegendField.$el.closest('.record-cell').toggleClass('hide', !showLegend);
            }
        }
    },

    /**
     * Handle the conditional display of settings input field based on checkbox toggle state
     *
     * @param {Object} toggle a checkbox control that determines display state of field
     * @param {Object} dependent the input field that holds the setting value
     * @private
     */
    _toggleDepedent: function(toggle, dependent) {
        var inputField = dependent.$el.find(dependent.fieldTag),
            enabled = this.settings.get(toggle.name),
            value = enabled ? this.settings.get(dependent.name) : '';
        inputField
            .prop('disabled', !enabled)
            .val(value);
    },

    /**
     * @inheritdoc
     * When rendering fields, get a reference to the chart field if we don't have one yet
     */
    _renderField: function(field) {
        this._super('_renderField', [field]);

        // Manage display state of fieldsets with toggle
        if (this.meta.config) {

            if (!_.isUndefined(field.def.toggle)) {
                var toggle = this.getField(field.def.toggle),
                    dependent = this.getField(field.def.dependent);

                this._toggleDepedent(toggle, dependent);

                this.settings.on('change:' + toggle.name, _.bind(function(event) {
                    this._toggleDepedent(toggle, dependent);
                }, this));
                this.settings.on('change:' + dependent.name, _.bind(function(event) {
                    this._toggleDepedent(toggle, dependent);
                }, this));
            }
        }

        // hang on to a reference to the chart field
        if (_.isUndefined(this.chartField) && field.name === 'chart') {
            this.chartField = field;
        }
    }
}) },
"orgchart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View that displays a list of models pulled from the context's collection.
 *
 * @class View.Views.Base.OrgchartView
 * @alias SUGAR.App.view.views.BaseOrgchartView
 * @extends View.View
 */
({
	// Orgchart View (base) 

    events: {
        'click .zoom-control': 'zoomChart',
        'click .toggle-control': 'toggleChart'
    },
    plugins: ['Dashlet', 'Chart'],

    // user configurable
    nodetemplate: null,
    reporteesEndpoint: '',
    zoomExtents: null,
    nodeSize: null,

    // private
    jsTree: null,
    slider: null,
    sliderZoomIn: null,
    sliderZoomOut: null,
    container: null,

    /**
     * Initialize the View
     *
     * @constructor
     * @param {Object} options
     */
    initialize: function(options) {
        var self = this;
        this._super('initialize', [options]);

        //TODO: change api to accept id as param or attrib as object to produce
        this.reporteesEndpoint = app.api.buildURL('Forecasts', 'orgtree/' + app.user.get('id'), null, {'level': 2});
        this.zoomExtents = {'min': 0.25, 'max': 1.75};
        this.nodeSize = {'width': 124, 'height': 56};

        this.chart = sucrose.charts.treeChart()
                .duration(0)
                .horizontal(false)
                .getId(function(d) {
                    var metadata = d.metadata || d.data.metadata;
                    return metadata ? metadata.id : 0;
                })
                .nodeSize(this.nodeSize)
                .nodeRenderer(_.bind(this.nodeRenderer, this))
                .nodeClick(function(d) {
                    var nodeData = d.data.metadata;
                    app.router.navigate(nodeData.url, {trigger: true});
                })
                .zoomExtents(this.zoomExtents)
                .zoomCallback(_.bind(this.moveSlider, this));
    },

    /**
     * Returns a url to a user record
     * @param {String} id the User record id.
     * @protected
     */
    _buildUserUrl: function(id) {
        return '#' + app.bwc.buildRoute('Employees', id);
    },

    /**
     * Appends the node content to the tree
     * This should be extended by each implementation
     * @param {String} content tree content container.
     * @param {Object} d tree node metadata.
     * @param {Int} w tree node width.
     * @param {Int} h tree node height.
     */
    nodeRenderer: function(content, d, w, h) {
        var nodeData = d.data.metadata;
        var node = content.append('g').attr('class', 'sc-org-node');
        var container = d3sugar.select('svg#' + this.cid);
        if (!nodeData.img || nodeData.img === '') {
            nodeData.img = 'include/images/user.svg';
        }

        node.append('rect').attr('class', 'sc-org-bkgd')
            .attr('x', 0)
            .attr('y', 0)
            .attr('rx', 2)
            .attr('ry', 2)
            .attr('width', w)
            .attr('height', h);
        node.append('image').attr('class', 'sc-org-avatar')
            .attr('xlink:href', nodeData.img)
            .attr('width', '32px')
            .attr('height', '32px')
            .attr('transform', 'translate(3, 3)')
            .on('error', function() {
                d3.select(this)
                    .style('width', 'auto')
                    .attr('x', '4')
                    .attr('xlink:href', 'include/images/user.svg');
            });
        node.append('text').attr('class', 'sc-org-name')
            .attr('data-url', d.data.url)
            .attr('transform', 'translate(38, 11)')
            .text(function() {
                return sucrose.utility.stringEllipsify(nodeData.full_name, container, 96);
            });
        node.append('text').attr('class', 'sc-org-title')
            .attr('data-url', d.data.url)
            .attr('transform', 'translate(38, 21)')
            .text(function() {
                return sucrose.utility.stringEllipsify(nodeData.title, container, 96);
            });

        node
            .on('mouseenter', function(d) {
                d3.select(this)
                    .select('.sc-org-name')
                        .style('text-decoration', 'underline');
            })
            .on('mouseleave', function(d) {
                d3.select(this)
                    .select('.sc-org-name')
                        .style('text-decoration', 'none');
            });

        return node;
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }

        if (!this.slider) {
            // chart controls
            this.slider = this.$('.btn-slider .noUiSlider');
            this.sliderZoomOut = this.$('.zoom-control[data-control="zoom-out"]');
            this.sliderZoomIn = this.$('.zoom-control[data-control="zoom-in"]');

            //zoom slider
            this.slider.noUiSlider('init', {
                start: 100,
                knobs: 1,
                scale: [this.zoomExtents.min * 100, this.zoomExtents.max * 100],
                connect: false,
                step: 5,
                change: _.bind(function(moveType) {
                    var values, scale;
                    if (!this.chart_loaded) {
                        return;
                    }
                    if (moveType === 'slide') {
                        values = this.slider.noUiSlider('value');
                        scale = this.chart.zoomLevel(values[0] / 100);
                    } else {
                        scale = this.chart.zoomScale();
                    }
                    this.sliderZoomOut.toggleClass('disabled', (scale <= this.zoomExtents.min));
                    this.sliderZoomIn.toggleClass('disabled', (scale >= this.zoomExtents.max));
                }, this)
            });
        }
        this.moveSlider();

        if (this.jsTree) {
            this.jsTree.jstree('destroy');
        }

        //jsTree control for selecting root node
        this.jsTree = this.$('div[data-control="org-jstree"]')
                .jstree({
                    // generating tree from json data
                    'json_data': {
                        'data': this.chartCollection
                    },
                    // plugins used for this tree
                    'plugins': ['json_data', 'ui', 'types'],
                    'core': {
                        'animation': 0
                    },
                    'ui': {
                        // when the tree re-renders, initially select the root node
                        'initially_select': ['jstree_node_' + app.user.get('user_name')]
                    }
                }).on('loaded.jstree', _.bind(function() {
                    // do stuff when tree is loaded
                    this.$('div[data-control="org-jstree"]').addClass('jstree-sugar');
                    this.$('div[data-control="org-jstree"] > ul').addClass('list');
                    this.$('div[data-control="org-jstree"] > ul > li > a').addClass('jstree-clicked');
                }, this))
                .on('click.jstree', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                })
                .on('select_node.jstree', _.bind(function(event, data) {
                    var jsData = data.inst.get_json();

                    this.chart.filter(jQuery.data(data.rslt.obj[0], 'id'));
                    this.forceRepaint();
                    this.moveSlider();

                    this.$('div[data-control="org-jstree-dropdown"] .jstree-label').text(data.inst.get_text());
                    data.inst.toggle_node(data.rslt.obj);
                }, this));
        app.accessibility.run(this.jsTree, 'click');

        this.container = d3sugar.select('svg#' + this.cid);

        this.container
            .datum(this.chartCollection[0])
            .call(this.chart);

        this.chart.resetZoom();

        this.forceRepaint();

        this.$('.sc-expcoll').on('click', _.bind(function() {
            this.forceRepaint();
            this.moveSlider();
        }, this));

        this.chart_loaded = _.isFunction(this.chart.resize);
        this.displayNoData(!this.chart_loaded);
    },

    /**
     * Forces repaint of images using opacity animation to fix
     * issue with rendering foreignObject in SVG
     */
    forceRepaint: function() {
        this.$('.rep-avatar').on('load', function() {
            $(this).removeClass('loaded').addClass('loaded');
        });

        // this.$('img').on('error', function() {
        //     $(this).attr('src', 'include/images/user.svg');
        // });
    },

    /**
     * Move the slider position
     * Use whenever the tree changes size
     */
    moveSlider: function(scale) {
        var s = scale || 1;
        if (this.slider) {
            this.slider.noUiSlider('move', {to: s * 100});
        }
    },

    /**
     * Override the hasChartData method in Chart plugin because
     * this view does not have a total value.
     */
    hasChartData: function() {
        return !_.isEmpty(this.chartCollection);
    },

    /**
     * Override the chartResize method in Chart plugin because
     * orgchart sucrose model uses resize instead of update.
     */
    chartResize: function() {
        this.moveSlider();
        this.chart.resize();
    },

    /**
     * Recursively step through the tree and for each node representing a tree node, run the data attribute through
     * the _postProcessTree function.  This function supports n-levels of the tree hierarchy.
     *
     * @param data The data structure returned from the REST API Forecasts/reportees endpoint
     * @return The modified data structure after all the parent and children nodes have been stepped through
     * @private
     */
    _postProcessTree: function(data) {
        var root = [];

        if (_.isArray(data) && data.length == 2) {
            root.push(data[0]);
            root[0].children.push(data[1]);
        } else {
            root.push(data);
        }

        //protect against admin and other valid Employees
        if (_.isEmpty(root[0].metadata.id)) {
            return null;
        }

        _.each(root, function(entry) {
            var adopt = [];

            //Scan for the nodes with the data attribute.  These are the nodes we are interested in
            if (!entry.data) {
                return;
            }

            entry.metadata.url = this._buildUserUrl(entry.metadata.id);

            if (!entry.metadata.picture || entry.metadata.picture === '') {
                entry.metadata.img = 'include/images/user.svg';
            } else {
                entry.metadata.img = app.api.buildFileURL({
                    module: 'Employees',
                    id: entry.metadata.id,
                    field: 'picture'
                });
            }

            if (!entry.children) {
                return;
            }

            //For each children found (if any) then call _postProcessTree again.
            _.each(entry.children, function(childEntry) {
                var newChild;
                if (entry.metadata.id !== childEntry.metadata.id) {
                    newChild = this._postProcessTree(childEntry);
                    if (!_.isEmpty(newChild)) {
                        adopt.push(newChild[0]);
                    }
                }
            }, this);

            entry.children = adopt;

        }, this);

        return root;
    },

    /**
     * Slider control for zooming chart viewport.
     * @param {e} event The event object that is triggered.
     */
    zoomChart: function(e) {
        var button, step, scale;
        if (!this.chart_loaded) {
            return;
        }

        button = $(e.target).data('control');
        step = 0.25 * (button === 'zoom-in' ? 1 : -1);
        scale = this.chart.zoomStep(step);

        this.moveSlider(scale);
    },

    /**
     * Handle all chart manipulation toggles.
     * @param {e} event The event object that is triggered.
     */
    toggleChart: function(e) {
        var button;
        if (!this.chart_loaded) {
            return;
        }

        //if icon clicked get parent button
        button = $(e.currentTarget).hasClass('btn') ? $(e.currentTarget) : $(e.currentTarget).parent('.btn');

        switch (button.data('control')) {
            case 'orientation':
                this.chart.orientation();
                button.find('i').toggleClass('sicon-arrow-right sicon-arrow-down');
                break;

            case 'show-all-nodes':
                this.chart.showall();
                this.forceRepaint();
                break;

            case 'zoom-to-fit':
                this.chart.resize();
                break;

            default:
        }

        this.moveSlider();
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        app.api.call('get', this.reporteesEndpoint, null, {
            success: _.bind(function(data) {
                this.chartCollection = this._postProcessTree(data);
                if (!this.disposed) {
                    this.renderChart();
                }
            }, this),
            complete: options ? options.complete : null
        });
    },

    /**
     * overriding _dispose to make sure custom added event listeners are removed
     * @private
     */
    _dispose: function() {
        if (this.jsTree) {
            this.jsTree.jstree('destroy');
        }
        if (this.slider) {
            this.slider.off('move');
        }
        this._super('_dispose');
    }
}) },
"active-tasks": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Active tasks dashlet takes advantage of the tabbed dashlet abstraction by
 * using its metadata driven capabilities to configure its tabs in order to
 * display information about tasks module.
 *
 * Besides the metadata properties inherited from Tabbed dashlet, Active tasks
 * dashlet also supports other properties:
 *
 * - {Array} overdue_badge field def to support overdue calculation, and showing
 *   an overdue badge when appropriate.
 *
 * @class View.Views.Base.ActiveTasksView
 * @alias SUGAR.App.view.views.BaseActiveTasksView
 * @extends View.Views.Base.TabbedDashletView
 */
({
	// Active-tasks View (base) 

    extendsFrom: 'TabbedDashletView',

    /**
     * @inheritdoc
     *
     * @property {Object} _defaultSettings
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        limit: 10,
        visibility: 'user'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        options.meta.template = 'tabbed-dashlet';

        this.plugins = _.union(this.plugins, [
            'LinkedModel'
        ]);

        this.tbodyTag = 'ul[data-action="pagination-body"]';

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    _initEvents: function() {
        this._super('_initEvents');
        this.on('active-tasks:close-task:fire', this.closeTask, this);
        this.on('linked-model:create', this.loadData, this);
        this.on('render:rows', this._renderAvatars, this);
        return this;
    },

    /**
     * Completes the selected task.
     *
     * Shows a confirmation alert and sets the task as `Completed` on confirm.
     *
     * @param {Data.Bean} model The task to be marked as completed.
     */
    closeTask: function(model){
        var self = this;
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;
        app.alert.show('complete_task_confirmation:' + model.get('id'), {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('LBL_ACTIVE_TASKS_DASHLET_CONFIRM_CLOSE'), [context]),
            onConfirm: function() {
                model.save({status: 'Completed'}, {
                    showAlerts: true,
                    success: self._getRemoveModelCompleteCallback()
                });
            }
        });
    },

    /**
     * @inheritdoc
     *
     * FIXME: This should be removed when metadata supports date operators to
     * allow one to define relative dates for date filters.
     */
    _initTabs: function() {
        this._super("_initTabs");

        // FIXME: since there's no way to do this metadata driven (at the
        // moment) and for the sake of simplicity only filters with 'date_due'
        // value 'today' are replaced by today's date
        var today = new Date();
        today.setHours(23, 59, 59);
        today.toISOString();

        _.each(_.pluck(_.pluck(this.tabs, 'filters'), 'date_due'), function(filter) {
            _.each(filter, function(value, operator) {
                if (value === 'today') {
                    filter[operator] = today;
                }
            });
        });
    },

    /**
     * Create new record.
     *
     * @param {Event} event Click event.
     * @param {Object} params
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    createRecord: function(event, params) {
        if (this.module !== 'Home') {
            this.createRelatedRecord(params.module, params.link);
        } else {
            var self = this;
            app.drawer.open({
                layout: 'create',
                context: {
                    create: true,
                    module: params.module
                }
            }, function(context, model) {
                if (!model) {
                    return;
                }
                self.context.resetLoadFlag();
                self.context.set('skipFetch', false);
                if (_.isFunction(self.loadData)) {
                    self.loadData();
                } else {
                    self.context.loadData();
                }
            });
        }

    },

    /**
     * New model related properties are injected into each model.
     * Update the picture url's property for model's assigned user.
     *
     * @param {Bean} model Appended new model.
     */
    bindCollectionAdd: function(model) {
        var pictureUrl = app.api.buildFileURL({
            module: 'Users',
            id: model.get('assigned_user_id'),
            field: 'picture'
        });
        model.set('picture_url', pictureUrl);
        this._super('bindCollectionAdd', [model]);
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model:
     *
     * - {Boolean} overdue True if record is prior to now.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        var tab = this.tabs[this.settings.get('activeTab')];

        if (tab && tab.overdue_badge) {
            this.overdueBadge = tab.overdue_badge;
        }

        this._super('_renderHtml');

        this._renderAvatars();
    }
}) },
"maps-widget-dropdowns": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Maps widget view
 *
 * @class View.Views.Base.MapsWidgeDropdownsView
 * @alias SUGAR.App.view.views.BaseMapsWidgetDropdownsView
 * @extends View.View
 */
 ({
	// Maps-widget-dropdowns View (base) 

    /**
     * Event listeners
     */
    events: {
        'change [data-fieldname=modules]': 'moduleChanged',
        'change [data-fieldname=filterBy]': 'filterByChanged',
        'change [data-fieldname=unitType]': 'unitTypeChanged',
        'change [data-fieldname=radius]': 'radiusChanged',
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this._initProperties();
    },

    /**
     * Property initialization
     */
    _initProperties: function() {
        let parentModule = this.context.get('module');

        if (_.has(this.context, 'parent') && !_.isNull(this.context.parent)) {
            parentModule = this.context.parent.get('module');
        }

        this.LOCAL_STORAGE_WIDGET_KEY = `maps_widget_data_${parentModule}`;
        this._filters = {};

        this._updateWidgetData();
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        this._select2 = {};

        _.each(this._dropdowns, function createSelect2(data, key) {
            const queryFunction = `_query${app.utils.capitalize(key)}`;

            let additionalOptions = {
                placeholder: data.placeholder
            };

            if (key === 'radius') {
                additionalOptions.formatSelection = _.bind(this._getSelect2Radius, this);
                additionalOptions.formatResult = _.bind(this._getSelect2Radius, this);
            }

            this.select2(key, queryFunction, additionalOptions);

            if (data.title) {
                let text = key === 'modules' ? data.options[data.title] : data.title;

                this._select2[key].data({
                    id: _.invert(data.options)[data.title],
                    text,
                });
            }
        }, this);
    },

    /**
     * Handle module changes
     *
     * @param {jQuery} e
     */
    moduleChanged: function(e) {
        const selectedModule = e.currentTarget.value;

        this.model.set('modules', selectedModule);
        this.model.set('filterBy', '');

        this._select2.filterBy.val(null);

        this._saveDropdownsState();
        this._updateWidgetData();
    },

    /**
     * Handle filterBy selected
     *
     * @param {jQuery} e
     */
    filterByChanged: function(e) {
        const filterByChanged = e.currentTarget.value;

        this.model.set('filterBy', this._dropdowns.filterBy.options[filterByChanged]);

        this._saveDropdownsState();
        this._updateWidgetData();
    },

    /**
     * Handle unitType selected
     *
     * @param {jQuery} e
     */
    unitTypeChanged: function(e) {
        const unitTypeChanged = e.currentTarget.value;

        this.model.set('unitType', this._dropdowns.unitType.options[unitTypeChanged]);
        this.model.set('radius', '');

        this._select2.radius.val(null);

        this._saveDropdownsState();
        this._updateWidgetData();
    },

    /**
     * Handle radius selected
     *
     * @param {jQuery} e
     */
    radiusChanged: function(e) {
        const radiusChanged = e.currentTarget.value;

        this.model.set('radius', this._dropdowns.radius.options[radiusChanged]);

        this._saveDropdownsState();
        this._updateWidgetData();
    },

    /**
     * Save dropdowns state to user last state
     */
    _saveDropdownsState: function() {
        app.user.lastState.set(this.LOCAL_STORAGE_WIDGET_KEY, {
            modules: this.model.get('modules'),
            filterBy: this.model.get('filterBy'),
            unitType: this.model.get('unitType'),
            radius: this.model.get('radius'),
        });
    },

    /**
     * Update widget data
     */
    _updateWidgetData: function() {
        this._setMapsWidgetData();
        this._dropdowns = this._getDropdownsMeta();

        this._setModuleFilters(this.model.get('modules'));
    },

    /**
     * Build dropdown meta
     *
     * @return {Object}
     */
    _getDropdownsMeta: function() {
        const _availableModules = this._getAvailableModules();
        const _defaultModule = _.chain(_availableModules)
                                .keys()
                                .first()
                                .value();

        if (!this.model.get('modules')) {
            this.model.set('modules', _defaultModule);
        }

        if (!this.model.get('unitType')) {
            this.model.set('unitType', this._getUnitTypesList().miles);
        }

        if (!this.model.get('radius')) {
            this.model.set('radius', '5');
        }

        const modules = this._buildDropdownMeta(
            'modules',
            this.model.get('modules'),
            app.lang.get('LBL_MAP_MODULES'),
            true,
            _availableModules
        );

        const filterBy = this._buildDropdownMeta(
            'filterBy',
            this.model.get('filterBy'),
            app.lang.get('LBL_MAP_FILTER_BY'),
            true,
            {}
        );

        const unitType = this._buildDropdownMeta(
            'unitType',
            this.model.get('unitType'),
            app.lang.get('LBL_MAP_UNIT_TYPE'),
            true,
            this._getUnitTypesList()
        );

        const radius = this._buildDropdownMeta(
            'radius',
            this.model.get('radius'),
            app.lang.get('LBL_MAPS_RADIUS_INPUT'),
            true,
            this._getRadiusList()
        );

        return {
            modules,
            filterBy,
            unitType,
            radius,
        };
    },

    /**
     * Populate the modules list select2 component
     *
     * @param {Object} query
     *
     * @return {Function}
     */
    _queryModules: function(query) {
        return this._query(query, 'modules');
    },

    /**
     * Populate the filters list select2 component
     *
     * @param {Object} query
     *
     * @return {Function}
     */
    _queryFilterBy: function(query) {
        return this._query(query, 'filterBy');
    },

    /**
     * Populate the unit type list select2 component
     *
     * @param {Object} query
     *
     * @return {Function}
     */
    _queryUnitType: function(query) {
        return this._query(query, 'unitType');
    },

    /**
     * Populate the radius list select2 component
     *
     * @param {Object} query
     *
     * @return {Function}
     */
    _queryRadius: function(query) {
        return this._query(query, 'radius');
    },

    /**
     * Generic select2 selection list builder
     *
     * @param {Object} query
     * @param {string} list
     *
     */
    _query: function(query, list) {
        var listElements = this._dropdowns[list].options;
        var data = {
            results: [],
            more: false
        };

        if (_.isObject(listElements)) {
            _.each(listElements, function pushValidResults(element, index) {
                if (query.matcher(query.term, element)) {
                    data.results.push({id: index, text: element});
                }
            });
        } else {
            listElements = null;
        }

        query.callback(data);
    },

    /**
     * Create generic Select2 options object
     *
     * @return {Object}
     */
    _getSelect2Options: function(additionalOptions) {
        var select2Options = _.extend(
            {
                minimumResultsForSearch: -1,
                dropdownAutoWidth: true,
                width: '150px',
                allowClear: true,
            },
            additionalOptions
        );

        return select2Options;
    },

    /**
     * Create generic Select2 component or return a cached select2 element
     *
     * @param {string} fieldname
     * @param {string} queryFunc
     */
    select2: function(fieldname, queryFunc, additionalOptions) {
        if (this._select2 && this._select2[fieldname]) {
            return this._select2[fieldname];
        };

        this._disposeSelect2(fieldname);

        if (queryFunc && this[queryFunc]) {
            additionalOptions.query = _.bind(this[queryFunc], this);
        }

        var el = this.$('[data-fieldname=' + fieldname + ']')
            .select2(this._getSelect2Options(additionalOptions))
            .data('select2');

        this._select2 = this._select2 || {};
        this._select2[fieldname] = el;

        return el;
    },

    /**
     * Format the select2 element
     *
     * @param {Object} item
     * @return {string}
     */
    _getSelect2Radius: function(item) {
        const unitType = this.model.get('unitType') || app.lang.get('LBL_MAP_UNIT_TYPE_MILES');

        return `${item.text} ${unitType}`;
    },

    /**
     * Set saved data from local storage
     */
    _setMapsWidgetData: function() {
        let widgetData = {
            modules: '',
            filterBy: '',
        };

        const savedData = app.user.lastState.get(this.LOCAL_STORAGE_WIDGET_KEY);

        if (savedData) {
            widgetData = savedData;
        }

        this.model.set(widgetData);
    },

    /**
     * Build dropdown metadata
     *
     * @param {string} id
     * @param {string} title
     * @param {string} placeholder
     * @param {boolean} dynamicTitle
     * @param {Object} options
     *
     * @return {Object}
     */
    _buildDropdownMeta: function(id, title, placeholder, dynamicTitle, options) {
        let meta = {
            id,
            title,
            placeholder,
            dynamicTitle,
            options
        };

        return meta;
    },

    /**
     * Get enabled maps modules
     *
     * @return {Object}
     */
    _getAvailableModules: function() {
        const enabledModulesKey = 'enabled_modules';

        if (!_.has(app.config, 'maps')) {
            return {};
        }

        let availableModules = _.map(app.config.maps[enabledModulesKey], function map(module) {
            let option = {};

            option[module] = app.lang.getModuleName(module, {
                plural: true,
            });

            return option;
        });

        availableModules = app.utils.maps.arrayToObject(availableModules);

        return availableModules;
    },

    /**
     * Get unit types
     *
     * @return {Object}
     */
    _getUnitTypesList: function() {
        return {
            'miles': app.lang.get('LBL_MAP_UNIT_TYPE_MILES'),
            'km': app.lang.get('LBL_MAP_UNIT_TYPE_KM'),
        };
    },

    /**
     * Get unit types
     *
     * @return {Object}
     */
    _getRadiusList: function() {
        return {
            '5': '5',
            '10': '10',
            '25': '25',
            '50': '50',
            '75': '75',
            '100': '100',
            '125': '125',
            '150': '150',
            '200': '200',
            '250': '250',
        };
    },

    /**
     * Set available filters for specified module
     *
     * @param {string} module
     */
    _setModuleFilters: function(module) {
        if (this._filters[module]) {
            this._updateSelect2Filters(this._filters[module]);

            return;
        }

        let filtersCollection = app.data.createBeanCollection('Filters');

        filtersCollection.setModuleName(module);
        filtersCollection.load({
            success: _.bind(function success(filters) {
                this._updateSelect2Filters(filters);

                if (this._select2 && this._dropdowns.filterBy.title) {
                    this._select2.filterBy.data({
                        id: _.invert(this._dropdowns.filterBy.options)[this._dropdowns.filterBy.title],
                        text: this._dropdowns.filterBy.title,
                    });
                }

                this._filters[module] = filters;

                this.layout.trigger('maps:subpanel:filter:collection:fetched');
            }, this),
        });
    },

    /**
     * Update select2 filter options
     *
     * @param {Object} filters
     */
    _updateSelect2Filters: function(filters) {
        let select2Filters = _.map(filters.models, function map(filter) {
            let filterData = {};

            filterData[filter.id] = app.lang.get(filter.get('name'), null, {module: filters.moduleName});

            return filterData;
        });

        select2Filters = app.utils.maps.arrayToObject(select2Filters);

        this._dropdowns.filterBy.options = select2Filters;
    },

    /**
     * Get target module filters
     *
     * @return {Object}
     */
    getAvailableFilters: function() {
        const module = this.model.get('modules');

        return this._filters[module];
    },

    /**
     * Dispose a select2 element
     */
    _disposeSelect2: function(name) {
        if (this._select2 && _.isObject(this._select2)) {
            delete this._select2[name];
        }

        this.$('[data-fieldname=' + name + ']').select2('destroy');
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this._disposeSelect2('modules');
        this._disposeSelect2('filterBy');
        this._disposeSelect2('unitType');
        this._disposeSelect2('radius');

        this._select2 = {};

        this._super('_dispose');
    },
}) },
"forecastdetails": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ForecastdetailsView
 * @alias SUGAR.App.view.views.BaseForecastdetailsView
 * @extends View.View
 */
({
	// Forecastdetails View (base) 

    plugins: ['Dashlet'],

    /**
     * Manager totals for likely_adjusted
     */
    likelyTotal: 0,

    /**
     * Manager totals for best_adjusted
     */
    bestTotal: 0,

    /**
     * Manager totals for worst_adjusted
     */
    worstTotal: 0,

    /**
     * If we need to get the rollup or direct forecast data
     */
    shouldRollup: false,

    /**
     * Necessary for Forecast module as the selectedUser can change and be different from currently-loggged-in user
     */
    selectedUser: {},

    /**
     * Has Forecast module been set up
     */
    isForecastSetup: false,

    /**
     * Is the user a Forecast admin
     */
    isForecastAdmin: false,

    /**
     * Track if current user is manager.
     */
    isManager: false,

    /**
     * Holds the subDetails template so the timeperiod field doesn't re-fetch every re-render
     */
    subDetailsTpl: {},

    /**
     * Holds the detailsMsg template
     */
    detailsMsgTpl: {},

    /**
     * Holds the dom values for best/likely/worst show/hide dropdown
     */
    detailsDataSet: {},

    /**
     * Config metadata from Forecasts module
     */
    forecastConfig: {},

    /**
     * If timeperiod dropdown should be shown (not in Forecasts)
     */
    showTimeperiod: true,

    /**
     * Holds if the forecasts config has proper closed won/lost keys
     */
    forecastsConfigOK: false,

    /**
     * Contains the latest saved data from the server
     */
    serverData: {},

    /**
     * The parent module for the dashlet
     */
    currentModule: '',

    /**
     * The span class number to use span12, span4, etc
     */
    spanCSS: '',

    /**
     * Flag for if we've run getInitData yet or not
     */
    initDataLoaded: false,

    /**
     * events on the view for which to watch
     */
    events : {
        'click #forecastsProgressDisplayOptions div.datasetOptions label.radio' : 'changeDisplayOptions'
    },

    /**
     * Holds previous totals for math
     */
    oldTotals: {},

    /**
     * Holds a collection of quota Objects by the quota's record ID
     */
    quotaCollection: undefined,

    /**
     * What to show when we don't have access to the data
     */
    noDataAccessTemplate: undefined,

    /**
     * Holds likely/best/worst field access boolean values
     * ex: { likely: true, best: false, worst: false }
     */
    fieldDataAccess: {},

    /**
     * Managers that are not top-level managers should also
     * show the target quota (exact quota assigned by their mgr)
     */
    showTargetQuota: false,

    /**
     * Holds the forecast isn't set up message if Forecasts hasn't been set up yet
     */
    forecastsNotSetUpMsg: undefined,

    /**
     * Flag for if loadData is currently running
     */
    loading: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.currentModule = app.controller.context.get("module");

        // check to make sure that forecast is configured
        this.forecastConfig = app.metadata.getModule('Forecasts', 'config');
        this.isForecastSetup = this.forecastConfig.is_setup;
        this.forecastsConfigOK = app.utils.checkForecastConfig();
        this.isForecastAdmin = _.isUndefined(app.user.getAcls()['Forecasts'].admin);
        this.isManager = app.user.get('is_manager');

        if(!this.isForecastSetup) {
            this.forecastsNotSetUpMsg = app.utils.getForecastNotSetUpMessage(this.isForecastAdmin);
        }

        if(this.isForecastSetup && this.forecastsConfigOK) {
            this.serverData = new Backbone.Model();

            // Check field access
            var aclModule = this.forecastConfig.forecast_by,
                likelyFieldName = (aclModule == 'RevenueLineItems') ? 'likely_case' : 'amount';
            this.fieldDataAccess = {
                likely: app.acl.hasAccess('read', aclModule, app.user.get('id'), likelyFieldName),
                best: app.acl.hasAccess('read', aclModule, app.user.get('id'), 'best_case'),
                worst: app.acl.hasAccess('read', aclModule, app.user.get('id'), 'worst_case')
            };
            var hasAccess = (this.fieldDataAccess.likely && this.fieldDataAccess.best && this.fieldDataAccess.worst);
            // if any field has no access, get the noaccess field template
            if(hasAccess === false) {
                this.noDataAccessTemplate = app.template.getField('base', 'noaccess')(this);
            }

            // set up the model data
            this.resetModel();

            // since we need the timeperiods from 'Forecasts' set the models module to 'Forecasts'
            this.context.get('model').module = 'Forecasts';

            // use the object version of user not a Model
            this.selectedUser = app.user.toJSON();

            if (this.currentModule != 'Home') {
                // On Forecasts, this is based on whether user is viewing manager or rep worksheet
                this.shouldRollup = this.isManagerView();
            } else {
                // On Home, the dashlet should default to manager data for managers, and rep for non-manager
                this.shouldRollup = this.selectedUser.is_manager;
            }

            // once selectedUser & shouldRollup is set, check if user is a sub-manager
            this.checkShowTargetQuota();

            // set up the subtemplate
            this.subDetailsTpl = app.template.getView('forecastdetails.sub-details');
            this.detailsMsgTpl = app.template.getView('forecastdetails.details-msg');

            this.detailsDataSet = this.setUpShowDetailsDataSet(this.forecastConfig);

            this.checkSpanCSS();
        }
    },

    /**
     * @inheritdoc
     */
    initDashlet: function() {
        this.settings.module = 'Forecasts';
    },

    /**
     * Checks config show_worksheet_ settings for likely/best/worst and sets the spanCSS
     */
    checkSpanCSS: function() {
        var ct = 0;
        _.each([this.forecastConfig.show_worksheet_likely,
            this.forecastConfig.show_worksheet_best,
            this.forecastConfig.show_worksheet_worst], function(val)
        {
            if(val) {
                ct++;
            }
        });

        switch(ct) {
            case 3:
                this.spanCSS = '4';
                break;
            case 2:
                this.spanCSS = '6';
                break;
            case 1:
                this.spanCSS = '12';
                break;
            case 0:
                this.spanCSS = '';
                break;
        }

        this.model.set({spanCSS: this.spanCSS}, {silent: true});
    },

    /**
     * Returns an object of key: value pairs to be used in the select dropdowns to choose Likely/Best/Worst data to show/hide
     *
     * @param cfg Metadata config object for forecasts
     * @return {Object}
     */
    setUpShowDetailsDataSet: function(cfg) {
        var ds = app.metadata.getStrings('app_list_strings')['forecasts_options_dataset'] || [];

        var returnDs = {};
        _.each(ds, function(value, key) {
            if(cfg['show_worksheet_' + key] == 1) {
                returnDs[key] = value
            }
        }, this);
        return returnDs;
    },

    /**
     * Resets the model to default data
     */
    resetModel: function() {
        var model = {
            opportunities : 0,
            closed_amount : undefined,
            quota_amount : undefined,
            target_quota_amount: undefined,
            deficit_amount: undefined,
            worst_details: undefined,
            likely_details: undefined,
            best_details: undefined,
            show_details_likely: this.forecastConfig.show_worksheet_likely,
            show_details_best: this.forecastConfig.show_worksheet_best,
            show_details_worst: this.forecastConfig.show_worksheet_worst,
            spanCSS: this.spanCSS,
            quota_amount_str: undefined,
            target_quota_amount_str: undefined,
            closed_amount_str: undefined,
            deficit_class: undefined,
            deficit_amount_str: undefined,
            isForecastSetup: this.isForecastSetup,
            isForecastAdmin: this.isForecastAdmin
        };
        if(this.context.get('model')) {
            this.context.get('model').set(model)
        } else {
            this.model.set(model);
        }
    },

    /**
     * Builds dashlet url
     *
     * @return {Mixed} url to call
     */
    getProjectedURL: function() {
        var method = this.shouldRollup ? 'progressManager' : 'progressRep',
            url = 'Forecasts/' + this.model.get('selectedTimePeriod') + '/' + method + '/' + this.selectedUser.id,
            params = {};

        // if this is a manager view, send the target_quota param to the endpoint
        if(this.shouldRollup) {
            params = {
                target_quota: (this.showTargetQuota) ? 1 : 0
            };
        }

        return app.api.buildURL(url, 'create', null, params);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if(this.meta.config) {
            return;
        }

        var ctx = this.model;
        if (this.currentModule == 'Forecasts') {
            ctx = this.context.parent || this.context;
            this.showTimeperiod = false;
        } else if (this.currentModule == 'Home') {
            // listen to the TimePeriod field's model changes to set the dashlet
            this.settings.on('change:selectedTimePeriod', function(model) {
                this.updateDetailsForSelectedTimePeriod(model.get('selectedTimePeriod'));
                // reload dashlet data when the selectedTimePeriod changes
                this.loadData({});
            }, this);
        }

        ctx.on('change:selectedTimePeriod', function(model) {
            if(this.currentModule == 'Forecasts') {
                this.updateDetailsForSelectedTimePeriod(model.get('selectedTimePeriod'));
            }
            // reload dashlet data when the selectedTimePeriod changes
            this.loadData({});
        }, this);

        // Home module doesn't have a changing selectedUser
        if(this.currentModule == 'Forecasts') {

            this.quotaCollection = app.utils.getSubpanelCollection(ctx, 'ForecastManagerWorksheets');

            this.quotaCollection.on('reset', this.processQuotaCollection, this);

            this.quotaCollection.on('change:quota', function(data) {
                var oldQuota = (this.getOldTotalFromCollectionById(data.get('user_id'))) ? this.getOldTotalFromCollectionById(data.get('user_id')).quota : 0,
                    newQuota = data.get('quota'),
                    diff = app.math.sub(data.get('quota'), oldQuota),
                    newQuotaTotal = app.math.add(this.serverData.get('quota_amount'), diff);
                // set the new "oldTotals" value
                this.setOldTotalFromCollectionById(data.get('user_id'), {quota: newQuota});
                // calculate and update the Quota on the frontend
                this.calculateData({quota_amount: newQuotaTotal});
            }, this);

            this.processQuotaCollection();

            ctx.on('change:selectedUser', function(model) {
                this.updateDetailsForSelectedUser(model.get('selectedUser'));
                // reload dashlet data when the selectedUser changes
                this.loadData({});
            }, this);

            ctx.on('forecasts:worksheet:totals', function(data) {
                this.calculateData(this.mapAllTheThings(data, true), true);
            }, this);

            // Using LHS Model to store the initial values of the LHS model so we don't have
            // to ping the server every dashlet load for the true original DB values of the LHS model
            if(!_.has(ctx.attributes, 'lhsData')) {
                ctx.set({
                    lhsData: {
                        quotas: this.oldTotals
                    }
                });
            }
        }
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        var ctx;
        if (this.currentModule) {
            if(this.currentModule == 'Forecasts') {
                ctx = this.context.parent || this.context;
                if(this.quotaCollection) {
                    this.quotaCollection.off(null, null, this);
                }
            } else {
                ctx = this.model;
            }

            if(ctx) {
                ctx.off(null, null, this);
            }

            if (this.currentModule == 'Home') {
                this.settings.off(null, null, this);
            }
        }

        this._super('unbindData');
    },

    /**
     * Overrides loadData to load from a custom URL
     *
     * @override
     */
    loadData: function(options) {
        // if in dashlet config, or if Forecasts is not configured properly,
        // do not load data
        if(this.meta.config || !this.forecastsConfigOK || !this.isForecastSetup || this.loading) {
            return;
        }

        if(!this.initDataLoaded) {
            this.getInitData(options);
        }

        if(!_.isEmpty(this.model.get('selectedTimePeriod'))) {
            this.loading = true;
            var url = this.getProjectedURL(),
                cb = {
                    context: this,
                    success: _.bind(function(options, data) {
                        if(options && options.beforeParseData) {
                            data = options.beforeParseData(data);
                            data.parsedData = true;
                        }
                        this.handleNewDataFromServer(data)
                    }, this, options),
                    complete: _.bind(function(){
                        this.loading = false;
                        if (options && options.complete && _.isFunction(options.complete)) {
                            options.complete();
                        }
                    }, this)
                };

            app.api.call('read', url, null, null, cb);
        }
    },

    /**
     * Extensible function for getting initial data
     *
     * @param options
     */
    getInitData: function(options) {
        // get the current timeperiod
        app.api.call('GET', app.api.buildURL('TimePeriods/current'), null, {
            success: _.bind(function(currentTP) {
                // Make sure the model is here when we get back and this isn't mid-pageload or anything
                if(this.model) {
                    this.initDataLoaded = true;
                    this.model.set({selectedTimePeriod: currentTP.id}, {silent: true});
                    this.settings.set({selectedTimePeriod: currentTP.id}, {silent: true});
                    this.loadData();
                }
            }, this),
            error: _.bind(function() {
                // Needed to catch the 404 in case there isnt a current timeperiod
            }, this),
            complete: options ? options.complete : null
        });
    },

    /**
     * Processes this.quotaCollection.models to determine which models IDs should be
     * saved into the closedWonIds array
     */
    processQuotaCollection: function() {
        var model = this.context.get('model') || this.model,
            newQuota = 0,
            oldQuota = model.get('quota_amount'),
            quota = 0;
        this.oldTotals.models = new Backbone.Model();
        _.each(this.quotaCollection.models, function(model) {
            quota = model.get('quota');
            newQuota = app.math.add(newQuota, quota);
            // save all the initial likely values
            this.setOldTotalFromCollectionById(model.get('user_id'), {
                quota: quota
            });
        }, this);

        if(oldQuota !== newQuota) {
            this.calculateData({quota_amount: newQuota});
        }
    },

    /**
     * Gets an object from the oldTotals Model
     *
     * @param id the model ID for the Object
     * @return {Object}
     */
    getOldTotalFromCollectionById: function(id) {
        return this.oldTotals.models.get(id);
    },

    /**
     * Sets a totals Object on the oldTotals Model by id
     *
     * @param id model id
     * @param totals object to set
     * @return {Mixed}
     */
    setOldTotalFromCollectionById: function(id, totals) {
        this.oldTotals.models.set(id, totals);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this.renderSubDetails();
    },

    /**
     * Used to re-render only the projected data inside the dashlet so render doesnt
     * get called and dispose the select2 timeperiod field, which would then go
     * re-fetch its data at least once every render
     */
    renderSubDetails: function() {
        if(this.$el && this.subDetailsTpl) {
            var subEl = this.$el.find('.forecast-details'),
                model = this.context.get('model') || this.model;
            // Check if closed or quota is undefined (during opps/rli loading when those numbers aren't available yet)
            if(!_.isUndefined(model.get('closed_amount')) && !_.isUndefined(model.get('quota_amount'))) {
                subEl.html(this.subDetailsTpl(model.toJSON()));
                this.renderCSSChanges(model);
            } else {
                subEl.html('');
            }
        }
    },

    /**
     * Adds the CSS to elements classes post-render
     *
     * @param {Backbone.Model} [model]          The Model to use
     */
    renderCSSChanges: function(model) {
        model = model || this.context.get('model') || this.model;
        var isDeficit = model.get('is_deficit');

        // using getClassBasedOnAmount and sending 0 or 1 to resolve which class to use so the class names
        // are only in one place
        if(isDeficit) {
            this.$el.find('.deficitRow').addClass(this.getClassBasedOnAmount(0, 1, 'color'));
        } else {
            this.$el.find('.deficitRow').addClass(this.getClassBasedOnAmount(1, 0, 'color'));
        }

        this.checkPropertySetCSS('worst', model);
        this.checkPropertySetCSS('likely', model);
        this.checkPropertySetCSS('best', model);
    },

    /**
     * Checks a property on the config and sets the background color of an element
     * @param {String} prop 'likely', 'best', or 'worst'
     * @param {Backbone.Model} [model]      The model to use
     */
    checkPropertySetCSS: function(prop, model) {
        model = model || this.context.get('model') || this.model;
        // if we're showing the field
        // And this is the mgr view or it's the rep view and the user has access to the field
        if(this.forecastConfig['show_worksheet_' + prop]
            && (this.shouldRollup || (!this.shouldRollup && this.fieldDataAccess[prop]))) {
            var css = this.getClassBasedOnAmount(app.math.add(this.serverData.get(prop), this.serverData.get('closed_amount')), model.get('quota_amount'), 'background-color');
            this.$el.find('#forecast_details_' + prop + '_feedback').addClass(css);
        }
    },

    /**
     * Any variable mapping happens here
     *
     * @param data an Object
     */
    mapAllTheThings: function(data, fromModel) {
        if(this.shouldRollup) {
            // Manager View
            data.likely = data.likely_adjusted || data.likely_case;
            data.best = data.best_adjusted || data.best_case;
            data.worst = data.worst_adjusted || data.worst_case;
        } else {
            // Rep View
            if(fromModel) {
                data.likely = data.likely_case;
            } else {
                data.likely = data.amount;
            }

            data.best = data.best_case;
            data.worst = data.worst_case;
            data.closed_amount = data.won_amount;

            // can happen if data comes fromModel and won_amount isnt there
            if(_.isUndefined(data.closed_amount)) {
                // unset closed_amount so it doesnt impact totals
                delete data.closed_amount;
            }
        }

        if (fromModel) {
            data.worst = app.math.sub(data.worst, (data.closed_amount || 0));
            data.likely = app.math.sub(data.likely, (data.closed_amount || 0));
            data.best = app.math.sub(data.best, (data.closed_amount || 0));
        }

        return data;
    },

    /**
     * Success callback function for loadData to call
     *
     * @param data
     */
    handleNewDataFromServer: function(data) {
        // since the user might add this dashlet after they have changed the quota models, but before they saved it
        // we have to check and make sure that we're accounting for any changes in the dashlet totals that come
        // from the server
        if(this.currentModule == 'Forecasts' && this.context && this.shouldRollup) {
            var lhsData = this.context.get('lhsData');
            if(!lhsData && _.has(this.context, 'parent') && !_.isNull(this.context.parent)) {
                lhsData = this.context.parent.get('lhsData');
            }

            if(lhsData && !_.isEmpty(lhsData.quotas.models.attributes)) {
                var lhsTotal = 0;
                _.each(lhsData.quotas.models.attributes, function(val, key) {
                    lhsTotal = app.math.add(lhsTotal, val.quota);
                }, this);
                if(lhsTotal != parseFloat(data.quota_amount)) {
                    data.quota_amount = app.math.sub(data.quota_amount, app.math.sub(data.quota_amount, lhsTotal));
                }
            }
        }
        this.calculateData(this.mapAllTheThings(data, false));
    },

    /**
     * Handles parsing data objects into model
     *
     * @param data
     * @param fromModel if this request is from the model or the server
     */
    calculateData: function(data, fromModel) {
        fromModel = fromModel || false;
        // update serverData with changes from data
        this.serverData.set(data);

        // update data with any values serverData had but data doesn't
        // we create a new variable here, since we don't want to update the data param back on the worksheet table
        // and maybe break something
        var d = _.extend({}, data, this.serverData.toJSON());

        this.likelyTotal = d.likely;
        this.bestTotal = d.best;
        this.worstTotal = d.worst;

        d.quota_amount_str = app.currency.formatAmountLocale(d.quota_amount);
        d.closed_amount_str = app.currency.formatAmountLocale(d.closed_amount);

        if(this.showTargetQuota) {
            d.target_quota_amount_str = app.currency.formatAmountLocale(d.target_quota_amount);
        } else {
            this.serverData.unset('target_quota_amount_str');
        }
        d.showTargetQuota = this.showTargetQuota;

        // handle deficit
        d.deficit_amount = Math.abs(app.math.sub(d.quota_amount, d.closed_amount));
        d.deficit_amount_str = app.currency.formatAmountLocale(d.deficit_amount);
        d.is_deficit = (parseFloat(d.quota_amount) > parseFloat(d.closed_amount));

        var deficitLabelKey = (d.is_deficit) ? 'LBL_FORECAST_DETAILS_DEFICIT' : 'LBL_FORECAST_DETAILS_SURPLUS';
        d.deficit_label = app.lang.get(deficitLabelKey, 'Forecasts');

        // convert detailsForCase params to html template
        d.worst_details = this.detailsMsgTpl(this.getDetailsForCase('worst', this.worstTotal, d.quota_amount, d.closed_amount, fromModel));
        d.likely_details = this.detailsMsgTpl(this.getDetailsForCase('likely', this.likelyTotal, d.quota_amount, d.closed_amount, fromModel));
        d.best_details = this.detailsMsgTpl(this.getDetailsForCase('best', this.bestTotal, d.quota_amount, d.closed_amount, fromModel));

        if(this.shouldRollup && !_.isEmpty(this.selectedUser.reports_to_id)) {
            d.quota_label = app.lang.get('LBL_QUOTA_ADJUSTED', 'Forecasts');
        } else {
            d.quota_label = app.lang.get('LBL_QUOTA', 'Forecasts');
        }

        if(this.context || this.model) {
            var model = this.context.get('model') || this.model;
            if(model) {
                model.set(d);
                this.renderSubDetails();
            }
        }
    },

    /**
     * Determine if one value is bigger than another then build the language string to be used
     *
     * @param caseStr case string "likely", "best", or "worst"
     * @param caseValue the value of the case
     * @param stageValue the value of the quota or closed amount
     * @param closedAmt the value of closed_amount from the model
     * @param fromServer if this is coming from the model or the server
     * @return {Object} params for details-msg template
     */
    getDetailsForCase: function (caseStr, caseValue, stageValue, closedAmt, fromModel) {
        var params = {},
            // get Number versions of values for comparison
            caseValueN = app.math.add(caseValue, closedAmt),
            stageValueN = parseFloat(stageValue),
            openPipeline = 0,
            calcValue = 0;

        params.label = app.lang.get(`LBL_${caseStr.toUpperCase()}`, 'Forecasts');
        params.spanCSS = this.spanCSS;
        params.case = caseStr;
        params.shortOrExceed = '&nbsp;';
        params.openPipeline = '&nbsp;';
        params.feedbackLn1 = '';
        params.feedbackLn2 = '';

        var hasAccess = true;
        // if this is the rep view and the user doesnt have access to this field set to false
        if(!this.shouldRollup && !this.fieldDataAccess[caseStr]) {
            hasAccess = false;
        }
        // Check field access, in 2 of 3 cases below this works, otherwise it gets overwritten
        // in caseValueN == 0 && stageValueN == 0
        if(hasAccess)
        {
            if (caseValue) {
                params.amount = app.currency.formatAmountLocale(caseValue);
                params.labelAmount = params.label + ': ' + params.amount.toString();
            }

            if (caseValueN == 0 && stageValueN == 0) {
                // if we have no data
                params.amount = app.lang.get('LBL_FORECAST_DETAILS_NO_DATA', "Forecasts");
            } else if (caseValueN != 0 && stageValueN != 0 && caseValueN == stageValueN) {
                // if the values are equal but we have data
                params.shortOrExceed = app.lang.get('LBL_FORECAST_DETAILS_MEETING_QUOTA', "Forecasts");
            } else {
                /**
                 *  The bottom rectangles are supposed to tell the user if there is sufficient open pipeline in the current quarter to cover the deficit or not.
                 *  If there is surplus (meaning there is no deficit), the open pipeline will actually take the user above quota and that is always represented with green color.
                 */
                //if we are exceeding, we need to subtract to get the amount we exceed by
                if (caseValueN > stageValueN) {
                    params.shortOrExceed = app.lang.get('LBL_FORECAST_DETAILS_EXCEED', "Forecasts");
                    calcValue = app.math.sub(caseValueN, stageValueN);
                } else {
                    params.shortOrExceed = app.lang.get('LBL_FORECAST_DETAILS_SHORT', "Forecasts");
                    calcValue = app.math.sub(stageValueN, caseValueN);
                }

                params.percent = this.getPercent(calcValue, stageValueN);
                params.openPipeline = '(' + app.currency.formatAmountLocale(calcValue) + ')';

            }

            params.feedbackLn1 = params.shortOrExceed;

            if (params.percent) {
                params.feedbackLn1 += ' ' + params.percent;
            }

            params.feedbackLn2 = params.openPipeline;
        } else {
            params.amount = this.noDataAccessTemplate;
            params.labelAmount = params.label + ': ' + app.lang.get('LBL_NO_FIELD_ACCESS');
        }

        return params;
    },

    /**
     * Return the difference of two values and make sure it's a positive value
     *
     * used as a shortcut function for determine best/likely to closed/quota
     * @param caseValue
     * @param stageValue
     * @return {Number}
     */
    getAbsDifference: function (caseValue, stageValue) {
        return app.currency.formatAmountLocale(Math.abs(stageValue - caseValue));
    },

    /**
     * Gets a css class based on the amount relative to stageValue
     *
     * @param {Number} caseValue the value to check
     * @param {Number} stageValue the value to check against
     * @param {String} type the property to get
     * @return {string}
     */
    getClassBasedOnAmount: function (caseValue, stageValue, type) {
        var cssClass = '';
        // convert values to Numbers for comparison
        caseValue = parseFloat(caseValue);
        stageValue = parseFloat(stageValue);
        if(type == 'color') {
            if(caseValue == stageValue) {
                //
            } else if(caseValue > stageValue) {
                cssClass = 'font-green';
            } else {
                cssClass = 'font-red'
            }
        } else if(type == 'background-color') {
            if(caseValue == stageValue) {
                cssClass = 'grayLight';
            } else if(caseValue > stageValue) {
                cssClass = 'green';
            } else {
                cssClass = 'red';
            }
        }

        return cssClass;
    },

    /**
     * Returns a percent string based on the best/likely/worst case number vs. quota/closed amount
     *
     * @param caseValue likely/best/worst case value
     * @param stageValue the closed/quota amount from the model
     * @return {String}
     */
    getPercent: function (caseValue, stageValue) {
        var percent = 0,
            calcValue = caseValue;
        if (stageValue > 0 && caseValue > 0) {


            // divide the numbers and multiply times 100
            percent = (calcValue / stageValue) * 100;

            if (percent > 1) {
                // round to a whole number
                percent = Math.round(percent);
            } else {
                // Round the less-than-one percent to two decimal places
                // eg. percent=0.1234 -- percent*100 = 12.34, Math.round makes that 12
                // then percent/100 makes that back to 0.12
                percent = Math.round(percent*100)/100;
            }
        }
        return Math.abs(percent) + '%';
    },

    /**
     * Checks the selectedUser to see if they are a sub-manager
     */
    checkShowTargetQuota: function() {
        if(this.shouldRollup && this.selectedUser.is_manager && !this.selectedUser.is_top_level_manager) {
            this.showTargetQuota = true;
        } else {
            this.showTargetQuota = false;
        }
    },

    /**
     * checks the selectedUser to make sure it's a manager and if we should show the manager view
     * @return {Boolean}
     */
    isManagerView: function () {
        var isMgrView = false;
        if (this.currentModule == 'Forecasts') {
            // Forecasts has a more dynamic state, so make sure we check which worksheet is showing now
            if (this.context && this.context.parent && this.context.parent.has('model')) {
                isMgrView = this.context.parent.get('model').get('forecastType') == 'Rollup';
            }
        } else if(this.selectedUser.is_manager == true
            && (this.selectedUser.showOpps == undefined || this.selectedUser.showOpps === false))
        {
            isMgrView = true;
        }

        return isMgrView;
    },

    /**
     * Set the new time period
     *
     * @param {String} timePeriod id in string form
     */
    updateDetailsForSelectedTimePeriod: function (timePeriod) {
        // setting the model will trigger loadData()
        this.model.set({selectedTimePeriod: timePeriod});
    },

    /**
     * Set the new selected user
     *
     * @param {Object} selectedUser
     */
    updateDetailsForSelectedUser: function (selectedUser) {
        // don't directly set model selectedUser so we can handle selectedUser param in case it comes in as
        // just an id or something from somewhere else, so we can set it the right way for this dashlet
        this.selectedUser.last_name = selectedUser.last_name;
        this.selectedUser.first_name = selectedUser.first_name;
        this.selectedUser.full_name = selectedUser.full_name;
        this.selectedUser.id = selectedUser.id;
        this.selectedUser.is_manager = selectedUser.is_manager;
        this.selectedUser.reportees = selectedUser.reportees;
        this.selectedUser.showOpps = selectedUser.showOpps;
        this.selectedUser.user_name = selectedUser.user_name;
        this.selectedUser.reports_to_id = selectedUser.reports_to_id;
        this.selectedUser.reports_to_name = selectedUser.reports_to_name;
        this.selectedUser.is_top_level_manager = selectedUser.is_top_level_manager;

        this.shouldRollup = this.isManagerView();

        // update showTargetQuota on every user change
        this.checkShowTargetQuota();

        // setting the model will trigger loadData()
        this.model.set({selectedUser: selectedUser});
    },

    /**
     * Event handler to update which dataset is used.
     *
     * @param {jQuery.Event} evt click event
     */
    changeDisplayOptions : function(evt) {
        evt.preventDefault();
        this.handleOptionChange(evt);
    },

    /**
     * Handle the click event for the options menu
     *
     * @param {jQuery.Event} evt click event
     */
    handleOptionChange: function(evt) {
        var $el = $(evt.currentTarget),
            changedSegment = $el.attr('data-set');

        //check what needs to be done to the target
        if($el.hasClass('checked')) {
            //item was checked, uncheck it
            $el.removeClass('checked');
            $('div .projected_' + changedSegment).hide();
        } else {
            //item was unchecked and needs checked now
            $el.addClass('checked');
            $('div .projected_' + changedSegment).show();
        }
    }
}) },
"omnichannel-record-link": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.OmnichannelRecordLinkView
 * @alias SUGAR.App.view.views.BaseOmnichannelRecordLinkView
 * @extends View.View
 */
({
	// Omnichannel-record-link View (base) 

    className: 'omni-record-link',

    events: {
        'click .btn-sugarlive-link.unlinked': 'handleRecordLink'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.setOptions(options);
    },

    /**
     * Set options.
     * @param {Object} options
     */
    setOptions: function(options) {
        options = options || {};

        this.model = options.model || this.model || {};
        this.tooltip = options.tooltip || '';
        this.className = options.className || 'unlinked';
        this.icon = this.className === 'linked' ? 'sicon-check' : 'sicon-link';
    },

    /**
     * Link the record when the button is clicked
     */
    handleRecordLink: function() {
        if (app.omniConsole && this.model && this.model.get('id')) {
            app.omniConsole.trigger('omniconsole:record-link:clicked', this.model);

            this.setOptions({
                tooltip: app.lang.get('LBL_OMNICHANNEL_LINKED'),
                className: 'linked'
            });
            this.render();
        }
    }
}) },
"user-wizard-page": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * User Profile wizard page for the FirstLoginWizard.
 *
 * @class View.Views.Base.UserWizardPageView
 * @alias SUGAR.App.view.views.BaseUserWizardPageView
 * @extends View.Views.Base.WizardPageView
 */
({
	// User-wizard-page View (base) 

    extendsFrom: "WizardPageView",

    /**
     * Always show the page at start.
     *
     * @inheritdoc
     */
    showPage: true,

    /**
     * is IDM mode enabled?
     * @var boolean
     */
    isIDMModeEnabled: false,

    /**
     * @override
     * @param options
     */
    initialize: function(options) {
        //Load the default wizard page template, if you want to.
        options.template = app.template.getView('wizard-page');
        this._super('initialize', [options]);
        this.fieldsToValidate = this._fieldsToValidate(options.meta);
        this.action = 'edit';
        this.isIDMModeEnabled = App.metadata.getConfig().idmModeEnabled || false;
    },
    /**
     * @override
     * @return {boolean}
     */
    isPageComplete: function(){
        return this.areAllRequiredFieldsNonEmpty;
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.listenTo(this.model, 'sync', this.render);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (!this.model.dataFetched) {
            return this;
        }
        this._super('_render');
    },

    /**
     * @inheritdoc
     */
    _renderField: function(field, $fieldEl) {
        this._super('_renderField', [field, $fieldEl]);
        if (this.isIDMModeEnabled && field.def.idm_mode_disabled) {
            field.setDisabled(true);
        }
    },

    /**
     * Prepares HTTP payload
     * @return {Object} Payload with fields we want to update
     * @protected
     */
    _prepareRequestPayload: function() {
        var payload = {},
            self = this,
            fields = _.keys(this.fieldsToValidate);
        _.each(fields, function(key) {
            payload[key] = self.model.get(key);
        });
        return payload;
    },
    /**
     * Called before we allow user to proceed to next wizard page. Does the validation and profile update.
     * @param {Function} callback The callback to call once HTTP request is completed.
     * @override
     */
    beforeNext: function(callback) {
        var self = this;
        this.getField("next_button").setDisabled(true); // temporarily disable
        this.model.doValidate(this.fieldsToValidate,
            _.bind(function(isValid) {
                var self = this;
                if (isValid) {
                    var payload = self._prepareRequestPayload();
                    app.alert.show('wizardprofile', {level: 'process', title: app.lang.get('LBL_LOADING'), autoClose: false});
                    app.user.updateProfile(payload, function(err) {
                        app.alert.dismiss('wizardprofile');
                        self.updateButtons(); //re-enable buttons
                        if (err) {
                            app.logger.debug("Wizard profile update failed: " + err);
                            callback(false);
                        } else {
                            callback(true);
                        }
                    });
                } else {
                    callback(false);
                }
            }, self)
        );
    }

}) },
"maps-manual-geocoding": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MapsManualGeocodingView
 * @alias SUGAR.App.view.views.BaseMapsManualGeocodingView
 * @extends  View.Views.Base.ConfigHeaderButtonsView
*/
({
	// Maps-manual-geocoding View (base) 

    extendsFrom: 'ConfigHeaderButtonsView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this._initProperties();

        this._fetchRecordLocationData(_.bind(this._storeLocationDataAndCreateMap, this));
    },

    /**
     * Property initialization, nothing to do for this view
     *
     */
    _initProperties: function() {
        this._rendered = false;
        this._queryOptions = {};
        this._matchedAddresses = [];
        this._geocodeRecord = null;
        this._mapController = null;
    },

    /**
     * Store the record location locally then create the map
     *
     * @param {Data.BeanCollection[]} collection
     */
    _storeLocationDataAndCreateMap: function(collection) {
        const hasGeocodeRecord = collection.length > 0;

        if (hasGeocodeRecord) {
            this._geocodeRecord = collection.models[0];
        } else {
            this._geocodeRecord = app.data.createBean('Geocode');
            this._populateGeocodeFromRecord();
        }

        this._createMap();
    },

    /**
     * Set location data when the record is not geocoded
     */
    _populateGeocodeFromRecord: function() {
        const moduleData = app.config.maps.modulesData[this.module];

        if (!moduleData) {
            return;
        }

        const mappings = moduleData.mappings;
        let address = {};

        _.each(mappings, function createAddress(fieldName, fieldKey) {
            address[fieldKey] = this.model.get(fieldName);
        }, this);

        const location = {
            'parent_id': this.model.get('id'),
            'parent_type': this.module,
            'parent_name': this.model.get('name'),
            'parent_user_name': this.model.get('assigned_user_name'),
        };

        this._geocodeRecord.set(location);
    },

    /**
     * Update UI coords widget element
     */
    _updateWidget: function() {
        this.$('[data-fieldname="longitude"]').val(this._geocodeRecord.get('longitude') || '');
        this.$('[data-fieldname="latitude"]').val(this._geocodeRecord.get('latitude') || '');

        this._select2['search-by-address'].clear();

        if (this._geocodeRecord.get('address')) {
            this._select2['search-by-address'].data({'id': 1, 'text': this._geocodeRecord.get('address')});
        }
    },

    /**
     * Create the map controller
     */
    _createMap: function() {
        if (!this._geocodeRecord || !this._rendered) {
            return;
        }

        this._disposeMap();

        this._updateWidget();

        var fieldContainer = this.$('div[data-container="main-map-container"]');
        fieldContainer.empty();

        this._mapController = app.view.createField({
            def: {
                type: 'bing-map',
                name: 'BingMap'
            },
            view: this,
            viewName: 'main-map-container',
        });

        this._mapController.render();
        this._mapController.createMap();

        this.listenTo(this._mapController, 'map:load:complete', this.onMapReady, this);
        this.listenTo(this._mapController, 'map:map:click', this.onMapClick, this);

        this.$('[data-widget=manual-geocode-loading]').hide();
        fieldContainer.append(this._mapController.$el);
    },

    /**
     * Create map location and the pushpins
     */
    _createLocation: function() {
        this._mapController.clearMap();
        this._mapController.createLocation(this._geocodeRecord.toJSON());
        this._mapController.createPushPins();
        this._mapController.drawPushPins();
    },

    /**
     * Called when Map is loaded
     */
    onMapReady: function() {
        this._createLocation();
        this._mapController.centerMap();
    },

    /**
     * Called when Map is clicked
     *
     * @param {Event} e
     */
    onMapClick: function(e) {
        this._mapController.getAddressFromPoint(
            e.location,
            _.bind(this.updateGeocode, this, e.location),
            _.bind(this.updateGeocodeFailed, this)
        );
    },

    /**
     * Update data related to geocode
     *
     * @param {Object} exactLocation
     * @param {Object} data
     */
    updateGeocode: function(exactLocation, data) {
        this._geocodeRecord.set('latitude', exactLocation.latitude);
        this._geocodeRecord.set('longitude', exactLocation.longitude);
        this._geocodeRecord.set('postalcode', data.address.postalCode);
        this._geocodeRecord.set('address', data.address.formattedAddress);
        this._geocodeRecord.set('country', data.address.countryRegion);

        this._createLocation();
        this._updateWidget();

        const savedButtonFieldController = this.getField('save_button');

        if (savedButtonFieldController) {
            savedButtonFieldController.setDisabled(false);
        }
    },

    /**
     * Callback for invalid location
     *
     * @param {Object} location
     */
    updateGeocodeFailed: function(location) {
        app.alert.show('invalid-location', {
            level: 'warning',
            messages: 'EXCEPTION_REQUEST_FAILURE',
            autoClose: true,
            autoCloseDelay: 3000
        });
    },

    /**
     * Get current record location
     *
     * @param {Function} successCallback
     */
    _fetchRecordLocationData: function(successCallback) {
        const geocodeCollection = app.data.createBeanCollection('Geocode');

        geocodeCollection.filterDef = {
            '$and': [{
                'parent_type': this.model.module,
            }, {
                'parent_id': this.model.get('id'),
            }]
        };

        geocodeCollection.fetch({
            success: successCallback
        });
    },

    /**
     * Create generic Select2 options object
     *
     * @return {Object}
     */
    _getSelect2Options: function(additionalOptions) {
        var select2Options = {};

        select2Options.placeholder = app.lang.get('LBL_MAP_SEARCH_BY_ADDRESS');
        select2Options.dropdownAutoWidth = true;

        select2Options = _.extend({}, additionalOptions);

        return select2Options;
    },

    /**
     * Create generic Select2 component or return a cached select2 element
     *
     * @param {string} fieldname
     * @param {Function} callback
     */
    select2: function(fieldname, callback) {
        const delay = 500;

        if (this._select2 && this._select2[fieldname]) {
            return this._select2[fieldname];
        };

        this._disposeSelect2();

        let additionalOptions = {};

        additionalOptions.query = _.debounce(_.bind(this._queryAddresses, this), delay);

        var el = this.$('[data-action=' + fieldname + ']')
            .select2(this._getSelect2Options(additionalOptions))
            .data('select2');

        this._select2 = this._select2 || {};
        this._select2[fieldname] = el;

        el.onSelect = (function select(fn) {
            return function returnCallback(data, options) {
                if (callback) {
                    callback(data);
                }

                return fn.apply(this, arguments);
            };
        })(el.onSelect);

        return el;
    },

    /**
     * Select2 selection list builder
     *
     * @param {Object} options
     *
     */
    _queryAddresses: function(options) {
        this._queryOptions = options;

        const queryTerm = options.term;

        this._mapController.searchByAddress(
            queryTerm,
            _.bind(this._queryAddressesSuccess, this),
            _.bind(this._queryAddressesError, this)
        );
    },

    /**
     * Populate select2 list and store matched addresses
     *
     * @param {Object} geocodeResult
     */
    _queryAddressesSuccess: function(geocodeResult) {
        if (this._queryOptions) {
            let results = _.map(geocodeResult.results, function getAddress(result, key) {
                return {
                    id: key,
                    text: result.address.formattedAddress
                };
            });

            this._queryOptions.callback({
                results,
                more: false,
            });

            this._queryOptions = null;
            this._matchedAddresses = geocodeResult.results;
        }
    },

    /**
     * Clear addresses for invalid input
     *
     * @param {Object} geocodeRequest
     */
    _queryAddressesError: function(geocodeRequest) {
        if (this._queryOptions) {
            this._queryOptions.callback({
                results: [],
                more: false,
            });

            this._queryOptions = null;
            this._matchedAddresses = [];
        }
    },

    /**
     * The new selected location on the map
     *
     * @param {Object} data
     */
    _onAddressSelected: function(data) {
        const {id} = data;

        const address = this._matchedAddresses[id];
        const {latitude, longitude} = address.location;

        this._geocodeRecord.set('latitude', latitude);
        this._geocodeRecord.set('longitude', longitude);
        this._geocodeRecord.set('postalcode', address.address.postalCode);
        this._geocodeRecord.set('address', address.address.formattedAddress);

        const {width, height} = address.bestView;

        this._createLocation();
        this._mapController.centerMap({width, height});
        this._updateWidget();

        const savedButtonFieldController = this.getField('save_button');

        if (savedButtonFieldController) {
            savedButtonFieldController.setDisabled(false);
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        this._rendered = true;
        this._select2 = null;

        const savedButtonFieldController = this.getField('save_button');

        if (savedButtonFieldController) {
            savedButtonFieldController.setDisabled(true);
        }

        this.select2('search-by-address', _.bind(this._onAddressSelected, this));

        this._createMap();
    },

    /**
     * @inheritdoc
     */
    _saveConfig: function() {
        if (this._geocodeRecord.get('geocoded')) {
            app.alert.show('alert-already-geocoded', {
                level: 'confirmation',
                messages: app.lang.get('LBL_MAP_ALREADY_GEOCODED'),
                autoClose: false,
                onConfirm: _.bind(function overwriteGeocoding() {
                    this._saveAndCloseDrawer();
                }, this),
            });
        } else {
            this._saveAndCloseDrawer();
        }
    },

    /**
     * Save the new geocoding and close the current drawer
     */
    _saveAndCloseDrawer: function() {
        this._geocodeRecord.set({
            'status': 'COMPLETED',
            'geocoded': true,
        });

        this._geocodeRecord.save({}, {showAlerts: true});
        this.cancelConfig();
    },

    /**
     * Dispose map element
     */
    _disposeMap: function() {
        if (this._mapController) {
            this._mapController.dispose();
            this._mapController = null;
        }
    },

    /**
     * Dispose select2 elements
     */
    _disposeSelect2: function() {
        this.$('[data-action=search-by-address]').select2('destroy');
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this._disposeSelect2();
        this._disposeMap();
        this._super('_dispose');
    },
}) },
"filter-module-dropdown-selection-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Adds ability switch modules with filter module dropdown.
 *
 * Part of {@link View.Layouts.Base.SelectionListModuleSwitchLayout}.
 *
 * @class View.Views.Base.FilterModuleDropdownSelectionListView
 * @alias SUGAR.App.view.views.BaseFilterModuleDropdownSelectionListView
 * @extends View.Views.Base.FilterModuleDropdownView
 */
({
	// Filter-module-dropdown-selection-list View (base) 

    extendsFrom: 'FilterModuleDropdownView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.template = app.template.get('filter-module-dropdown');
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     * @return {Object}
     */
    getFilterList: function() {
        var filterList = this.context.get('filterList');

        if (this.layout.showingActivities) {
            filterList = this._super('getFilterList');
        }

        return filterList;
    },

    /**
     * @inheritdoc
     * @return {boolean}
     */
    shouldDisableFilter: function() {
        return false;
    },

    /**
     * Set the value of the filter to be the current module.
     * @private
     */
    _renderDropdown: function() {
        this._super('_renderDropdown');
        if (this.filterNode) {
            this.filterNode.select2('val', this.module);
        }
    },

    /**
     * Trigger event to reload the layout when the module changes.
     * @param {String} linkModuleName
     * @param {String} linkName
     * @param {Boolean} silent
     */
    handleChange: function(linkModuleName, linkName, silent) {
        if (!silent) {
            this.context.trigger('selection-list:reload', linkModuleName);
        }
    },

    /**
     * Always returns the module with a downward-facing chevron button for
     * selecting other modules.
     *
     * @return {string}
     */
    getSelectionLabel: function() {
        return app.lang.get('LBL_MODULE') + '<i class="sicon sicon-chevron-down"></i>';
    }
}) },
"baseedit": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View that displays edit view on a model
 * @class View.Views.Base.BaseeditView
 * @alias SUGAR.App.view.views.BaseBaseeditView
 * @extends View.View
 */
({
	// Baseedit View (base) 

    /**
     * Resets the error messages for all fields that have been changed and sent on the models change event.
     * @param {object} model that was changed.
     * @param {object} object that holds the changed fields.
     */
    clearValidationError: function(model, fields) {
        var self = this;
        if(!_.isEmpty(fields.changes)){
            _.each(fields.changes, function (num, key) {
                var field = self.getField(key);

                if (field) {
                    var controlGroup = field.$el.parents('.control-group:first');

                    if (controlGroup) {
                        controlGroup.removeClass("error");
                        controlGroup.find('.add-on').remove();
                        controlGroup.find('.help-block').html("");
                    }
                }
            });
        }
    },

    /**
     * Highlights all fields that fails field validation during save.
     * @param {object} Object containing the fields that failed validation.
     */
    handleValidationError:function (errors) {
        var self = this;

        _.each(errors, function (fieldErrors, fieldName) {
            //retrieve the field by name
            var field = self.getField(fieldName);
            var ftag = this.fieldTag || '';

            if (field) {
                var controlGroup = field.$el.parents('.control-group:first');

                if (controlGroup) {
                    controlGroup.addClass("error");
                    controlGroup.find('.add-on').remove();
                    controlGroup.find('.help-block').html("");

                    if (field.$el.parent().parent().find('.input-append').length > 0) {
                        field.$el.unwrap()
                    }
                    // Add error styling
                    field.$el.wrap('<div class="input-append  '+ftag+'">');

                    _.each(fieldErrors, function (errorContext, errorName) {
                        controlGroup.find('.help-block').append(app.error.getErrorString(errorName, errorContext));
                    });

                    $('<span class="add-on"><i class="sicon sicon-warning-circle"></i></span>').insertBefore(
                        controlGroup.find('.help-block')
                    );
                }
            }
        });
    }
}) },
"pii": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PiiView
 * @alias SUGAR.App.view.views.BasePiiView
 * @extends View.Views.Base.FilteredListView
 */
({
	// Pii View (base) 

    extendsFrom: 'FilteredListView',

    fallbackFieldTemplate: 'list-header',

    /**
     * @inheritdoc
     * Initialize and override the Pii collection.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.baseModule = this.context.get('pModule');
        this.baseRecord = this.context.get('pId');
        if (!this.collection) {
            this._initCollection();
        }
    },

    /**
     * Initialize the collection.
     *
     * @protected
     */
    _initCollection: function() {
        var self = this;
        var PiiCollection = app.BeanCollection.extend({
            baseModule: this.baseModule,
            baseRecordId: this.baseRecord,
            sync: function(method, model, options) {
                options.params = _.extend(options.params || {}, {erased_fields: true});
                var url = app.api.buildURL(this.baseModule, 'pii', {id: this.baseRecordId}, options.params);
                var callbacks = app.data.getSyncCallbacks(method, model, options);
                var defaultSuccessCallback = app.data.getSyncSuccessCallback(method, model, options);
                callbacks.success = function(data, request) {
                    data.records = self.mergePiiFields(data.fields);
                    self.applyDataToRecords(data);
                    return defaultSuccessCallback(data, request);
                };
                app.api.call(method, url, options.attributes, callbacks);
            }
        });
        this.collection = new PiiCollection();
    },

    /**
     * Combine module's fields with response data so we show all fields regardless of ACLs
     *
     * @param {Array} responseFields Fields from the PII endpoint
     * @return {Array} All PII fields for the baseModule
     */
    mergePiiFields: function(responseFields) {
        var piiFields = _.where(app.metadata.getModule(this.baseModule, 'fields'), {pii: true});

        var fields = [];
        _.each(piiFields, function(field) {
            var fieldName = field.name;
            var dataFields = _.where(responseFields, {field_name: fieldName});
            if (dataFields.length > 0) {
                _.each(dataFields, function(dataField) {
                    fields.push(_.extend({field_name: fieldName}, dataField));
                });
            } else {
                // We likely don't have ACL access but still want to show the field (without a value)
                fields.push({field_name: fieldName});
            }
        });
        return fields;
    },

    /**
     * @inheritdoc
     */
    loadData: function() {
        if (this.collection.dataFetched) {
            return;
        }
        this.collection.fetch();
    },

    /**
     * @inheritdoc
     *
     * Patch pii models fields with information of
     * original field available within parent model, in order to render
     * properly.
     */
    _renderData: function() {
        var fields = app.metadata.getModule(this.baseModule).fields;

        _.each(this.collection.models, function(model) {
            model.fields = app.utils.deepCopy(this.metaFields);

            var value = _.findWhere(model.fields, {name: 'value'});
            _.extend(value, fields[model.get('field_name')], {name: 'value'});
            if (_.contains(['multienum', 'enum'], value.type) && value.function) {
                value.type = 'base';
            }

            model.fields = app.metadata._patchFields(
                this.module,
                app.metadata.getModule(this.module),
                model.fields
            );
        }, this);

        this._super('_renderData');
    },

    /**
     * @override
     *
     * Overriding to return Pii view metadata, so filteredListView
     * can properly initialize filter when vardef is not available.
     */
    getFields: function() {
        return this._super('getFields', ['Pii']);
    },

    /**
     * Apply ACL and erased field information to the given record data.
     *
     * @param {Object} data Record data.
     */
    applyDataToRecords: function(data) {
        if (data._acl && data._acl.fields) {
            this._applyACLToRecords(data._acl.fields, data.records);
        }
        this._applyErasedFieldsToRecords(data._erased_fields, data.records);
    },

    /**
     * Apply ACLs to the given records.
     *
     * @param {Object} aclFields ACL fields object.
     * @param {Object[]} records Records to which you want ACLs applied.
     *
     * @private
     */
    _applyACLToRecords: function(aclFields, records) {
        _.each(records, function(record) {
            var fieldName = record.field_name;
            if (fieldName in aclFields) {
                record._acl = {
                    fields: {
                        value: aclFields[fieldName]
                    }
                };
            }
        });
    },

    /**
     * Apply erased field list to records.
     *
     * @param {string[]} erasedFields List of erased fields.
     * @param {Object[]} records The records where you want erased fields
     *  applied.
     *
     * @private
     */
    _applyErasedFieldsToRecords: function(erasedFields, records) {
        if (_.isEmpty(erasedFields)) {
            return;
        }
        var erasedFieldsMap = _.reduce(erasedFields, function(map, field) {
            map[field] = true;
            return map;
        }, {});
        _.each(records, function(record) {
            var fieldName = record.field_name;
            if (fieldName in erasedFieldsMap) {
                record._erased_fields = ['value'];
            }
        });
    }
}) },
"activitystream-omnibar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivitystreamOmnibarView
 * @alias SUGAR.App.view.views.BaseActivitystreamOmnibarView
 * @extends View.View
 */
({
	// Activitystream-omnibar View (base) 

    events: {
        'click .addPost': 'addPost',
        'keyup .sayit': '_handleContentChange', //type text
        'change .sayit': '_handleContentChange', //drag text in
        'paste .sayit': '_handleContentPaste' //for IE - right click, paste
    },

    className: 'omnibar',

    plugins: ['DragdropAttachments', 'Taggable', 'Pagination'],

    initialize: function(options) {
        // regular expression to find all non-breaking spaces
        this.nbspRegExp = new RegExp(String.fromCharCode(160), 'g');

        app.view.View.prototype.initialize.call(this, options);

        // Assets for the activity stream post avatar
        this.user_id = app.user.get('id');
        this.full_name = app.user.get('full_name');
        this.picture_url = app.user.get('picture') ? app.api.buildFileURL({
            module: 'Users',
            id: this.user_id,
            field: 'picture'
        }) : '';

        this.toggleSubmitButton = _.debounce(this.toggleSubmitButton, 200);
        this.on('attachments:add attachments:remove attachments:end', this.toggleSubmitButton, this);
        this.on('attachments:start', this.disableSubmitButton, this);
    },

    /**
     * Initialize Taggable plugin so that it knows which record the tags are
     * associated with.
     */
    bindDataChange: function() {
        if (this.context.parent) {
            this.context.parent.on('change', function(context) {
                var moduleName = context.get('module'),
                    modelId = context.get('model').get('id');

                this.setTaggableRecord(moduleName, modelId);
            }, this);
        }
        app.view.View.prototype.bindDataChange.call(this);
    },

    /**
     * Remove events added in bindDataChange().
     */
    unbindData: function() {
        if (this.context.parent) {
            this.context.parent.off(null, null, this);
        }
        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        if (!app.config.activityStreamsEnabled) {
            this.$el.addClass('hide');
        }

        return this;
    },

    /**
     * Creates a new post.
     */
    addPost: function() {
        var self = this,
            parentId = this.context.parent.get('model').id,
            parentType = this.context.parent.get('model').module,
            attachments = this.$('.activitystream-pending-attachment'),
            bean;

        // Process "Home" and "Activity" layouts as global activity stream types
        if (parentType == 'Home' || parentType == 'Activities') {
            parentType = null;
            parentId = null;
        }

        var payload = {
            activity_type: 'post',
            parent_id: parentId || null,
            parent_type: parentType,
            data: {}
        };

        if (!this.isSubmitDisabled()) {
            payload.data = this.getPost();

            if (payload.data.value && (payload.data.value.length > 0)) {
                this.disableSubmitButton();
                bean = app.data.createBean('Activities');
                bean.save(payload, {
                    success: function(model) {
                        self.$('div.sayit')
                            .empty()
                            .trigger('change')
                            .focus();

                        model.set('picture', app.user.get('picture'));
                        self.collection.add(model);
                        self.context.trigger('activitystream:post:prepend', model);
                    },
                    complete: function() {
                        self.enableSubmitButton();
                    },
                    showAlerts: true
                });
            }

            this.trigger("attachments:process");
        }
    },

    /**
     * Retrieve the post entered inside content editable and translate any tags into text format
     * so that it can be saved in the database as JSON string.
     *
     * @return {string}
     */
    getPost: function() {
        var post = this.unformatTags(this.$('div.sayit'));

        // Need to replace all non-breaking spaces with a regular space because the EmbedLinkService.php
        // treats spaces and non-breaking spaces differently. Having non-breaking spaces causes to parse
        // URLs incorrectly.
        post.value = post.value.replace(this.nbspRegExp, ' ');

        return post;
    },

    /**
     * Check to see if the Submit button should be disabled/enabled.
     */
    isSubmitDisabled: function() {
        var post = this.getPost(),
            attachments = this.getAttachments();

        return post.value.length === 0 && _.size(attachments) === 0;
    },

    /**
     * Toggle the Submit button disabled/enabled state.
     */
    toggleSubmitButton: function() {
        if (this.isSubmitDisabled()) {
            this.disableSubmitButton();
        } else {
            this.enableSubmitButton();
        }
    },

    /**
     * Enable Submit button
     */
    enableSubmitButton: function() {
        this.$('.addPost')
            .removeClass('disabled')
            .attr('aria-disabled', false)
            .attr('tabindex', 0);
    },

    /**
     * Disable Submit button
     */
    disableSubmitButton: function() {
        this.$('.addPost')
            .addClass('disabled')
            .attr('aria-disabled', true)
            .attr('tabindex', -1);
    },

    /**
     * Show or hide the placeholder and toggle the submit button in response to
     * a content change in the input field.
     *
     * @param e
     * @private
     */
    _handleContentChange: function(e) {
        // We can't use any of the jQuery methods or use the dataset property to
        // set this attribute because they don't seem to work in IE 10. Dataset
        // isn't supported in IE 10 at all.
        var el = e.currentTarget;
        if (el.textContent) {
            el.setAttribute('data-hide-placeholder', 'true');
        } else {
            el.removeAttribute('data-hide-placeholder');
        }
        this.toggleSubmitButton();
    },

    /**
     * Wrapper around _handleContentChange to defer until paste event completes
     * Paste event needed for IE (right click, paste)
     *
     * @param e
     * @private
     */
    _handleContentPaste: function(e) {
        _.defer(_.bind(this._handleContentChange, this), e);
    }
}) },
"pii-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PiiHeaderpaneView
 * @alias SUGAR.App.view.views.BasePiiHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Pii-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click a[name=close_button]': 'close'
    },

    /**
     * @inheritdoc
     *
     * Initialize and bind close drawer shortcut keys.
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        app.shortcuts.register({
            id: 'PiiHeaderPanel:Close',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $closeButton = this.$('a[name=close_button]');
                if ($closeButton.is(':visible') && !$closeButton.hasClass('disabled')) {
                    $closeButton.click();
                }
            }
        });
    },

    /**
     * Closes the drawer.
     */
    close: function() {
        app.drawer.close();
    },

    /**
     * @override
     *
     * Overriding to show record name on title header if it is available;
     * if not, use the standard title.
     */
    _formatTitle: function(title) {
        var model = this.context.parent.get('model');
        var recordName = app.utils.getRecordName(model);
        if (recordName) {
            return app.lang.get('TPL_DATAPRIVACY_PII_TITLE', model.module, {name: recordName});
        } else if (title) {
            return app.lang.get(title, this.module);
        } else {
            return '';
        }
    }
}) },
"themerollerpreview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This view is used in Administration > Studio Portal > Theme Portal
 * in order to show a preview of the custom theme being edited.
 *
 * @class View.Views.Base.ThemerollerpreviewView
 * @alias SUGAR.App.view.views.BaseThemerollerpreviewView
 * @extends View.View
 *
 * @deprecated Since 11.1.0
 * Please use {@link View.Views.Base.AdministrationPortalThemeConfigView} instead
 *
 * This component was used in the Administration > Studio Portal > Theme Portal side
 * pane to display a preview of Portal within an iFrame. Starting in 11.1.0, the side pane
 * will be replaced with AdministrationPortalThemeConfigView. The new component is a
 * metadata driven record view that allows the user to configure the Portal theme
 */
({
	// Themerollerpreview View (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        /**
         * The name of the theme being edited.
         *
         * @property {string}
         */
        this.customTheme = 'default';
        this.context.on('change:colors', this.reloadIframeBootstrap, this);
    },

    /**
     * Makes a request to get new CSS based on the themeable colors, and updates
     * the theme preview on success.
     */
    reloadIframeBootstrap: function() {
        var self = this;
        var params = {
            preview: new Date().getTime(),
            platform: app.config.platform,
            themeName: this.customTheme
        };
        _.extend(params, this.context.get('colors'));
        var cssLink = app.api.buildURL('css/preview', '', {}, params);
        var $iframe = this.$('iframe#previewTheme');
        var $alert = this.$('.ajaxLoading');

        $iframe.hide();
        $alert.show();

        $.get(cssLink)
            .success(function(data) {
                if (self.disposed) {
                    return;
                }
                data = self._fixRelativeUrls(data);
                $iframe.contents().find('style').text(data);
                $alert.hide();
                $iframe.show();
            });
        $iframe.contents().find('body').css('backgroundColor', 'transparent');
    },

    /**
     * Clean up the css by fixing the scope of relative urls
     * @param {string} css
     * @return {string}
     * @private
     */
    _fixRelativeUrls: function(css) {
        // The css relative urls are like ../../../../../styleguide/assets/.... because
        // we expect the css to be loaded from /cache/themes/clients/PLATFORM/THEMENAME/FILE.css
        // In the iframe, we insert the css directly into the style tag so the scope is the iframe's
        // src url which is <instance>/styleguide/themes/theming_preview.html. Therefore we must
        // replace the relative urls in the css
        var url = '../../';
        // matches ../../../../../
        var regex = /\.\.\/\.\.\/\.\.\/\.\.\/\.\.\//g;
        return css.replace(regex, url);
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        if (!app.acl.hasAccess('admin', 'Administration')) {
            return;
        }
        this._super('_renderHtml');
    }
}) },
"hint-config-logger-panel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HintConfigPanelView
 * @alias SUGAR.App.view.views.BaseHintConfigPanelView
 * @extends View.Views.Base.ConfigPanelView
 */
({
	// Hint-config-logger-panel View (base) 

    extendsFrom: 'ConfigPanelView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // force Administration module labels
        if (this.meta.label) {
            this.titleViewNameTitle = app.lang.get(this.meta.label, 'Administration');
        }
    }
}) },
"history": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * History dashlet takes advantage of the tabbed dashlet abstraction by using
 * its metadata driven capabilities to configure its tabs in order to display
 * historic information about specific modules.
 *
 * @class View.Views.Base.HistoryView
 * @alias SUGAR.App.view.views.BaseHistoryView
 * @extends View.Views.Base.TabbedDashletView
 */
({
	// History View (base) 

    extendsFrom: 'TabbedDashletView',

    /**
     * @inheritdoc
     *
     * @property {Object} _defaultSettings
     * @property {Number} _defaultSettings.filter Number of past days against
     *   which retrieved records will be filtered, supported values are '7',
     *   '30' and '90' days, defaults to '7'.
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        filter: 7,
        limit: 10,
        visibility: 'user'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        options.meta.template = 'tabbed-dashlet';

        this._super('initialize', [options]);
        this.tbodyTag = 'ul[data-action="pagination-body"]';
    },

    /**
     * Retrieves custom filters.
     *
     * @param {number} index Tab index.
     * @return {Array} Custom filters.
     * @protected
     */
    _getFilters: function(index) {
        var filterStr = app.date().subtract(this.settings.get('filter'), 'days').formatServer(true);

        var tab = this.tabs[index],
            filter = {},
            filters = [];

        filter[tab.filter_applied_to] = {$gte: filterStr};

        filters.push(filter);

        return filters;
    },

    /**
     * New model related properties are injected into each model.
     * Update the picture url's property for model's assigned user.
     *
     * @param {Bean} model Appended new model.
     */
    bindCollectionAdd: function(model) {
        var pictureUrl = app.api.buildFileURL({
            module: 'Users',
            id: model.get('assigned_user_id'),
            field: 'picture'
        });
        model.set('picture_url', pictureUrl);
        this._super('bindCollectionAdd', [model]);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.$('.select2').select2('destroy');

        this._super("_dispose");
    },

    /**
     * Open up a drawer to archive email.
     * @param event
     * @param params
     */
    archiveEmail: function(event, params) {
        var metadata = app.metadata.getModule(this.model.module) || {};
        var fields = metadata.fields || {};
        var modelCanBeRecipient = _.some(fields, function(field) {
            return field.type === 'email';
        });
        var data = {
            related: this.model
        };

        if (modelCanBeRecipient) {
            // Don't set email_address_id. It will be set when the email is
            // archived.
            data.to = app.data.createBean('EmailParticipants', {
                _link: 'to',
                parent: _.extend({type: this.model.module}, app.utils.deepCopy(this.model)),
                parent_type: this.model.module,
                parent_id: this.model.get('id'),
                parent_name: app.utils.getRecordName(this.model)
            });
        }

        app.utils.openEmailCreateDrawer('create', data, _.bind(function(model) {
            var links;

            if (model) {
                this.layout.reloadDashlet();
                links = app.utils.getLinksBetweenModules(this.context.parent.get('module'), 'Emails');

                _.each(links, function(link) {
                    this.context.parent.trigger('panel-top:refresh', link.name);
                }, this);
            }
        }, this));
    }
}) },
"record-map": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Record View Map
 *
 * @class View.Views.Base.BaseRecordMapView
 * @alias SUGAR.App.view.views.BaseRecordMapView
 * @extends View.View
 */
 ({
	// Record-map View (base) 

    extendsFrom: 'ListMapView',

    events: {
        'click [data-action=close]': 'closeDrawer',
    },

    /**
     * Property initialization, nothing to do for this view
     *
     * @param {Object} options
     */
    _initProperties: function() {
        this._super('_initProperties', arguments);

        this._showCloseButton = false;
        this._showExpandButton = false;
        this._showMapToPdfButton = true;
        this._showMapShareButton = true;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        if (this._showDirections) {
            this._createAndShowDirections();
        } else {
            this._createAndShowMap();
        }
    },

    /**
     * Create the map and display it
     */
    _createAndShowMap: function() {
        const records = _.extend({}, this.context.get('collection').models);

        this.createMap(records);
    },

    /**
     * Create the map and show the optimal route
     */
    _createAndShowDirections: function() {
        const records = _.extend({}, this.context.get('collection').models);

        this.createMap(records, {
            directions: {
                startPoint: {
                    module: 'Users',
                    id: app.user.id,
                },
            },
        });
    },

    /**
     * Close maps directions drawer
     */
    closeDrawer: function() {
        app.drawer.close();
    },
}) },
"list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View that displays a list of models pulled from the context's collection.
 *
 * @class View.Views.Base.ListView
 * @alias SUGAR.App.view.views.BaseListView
 * @extends View.View
 */
({
	// List View (base) 

    className: 'list-view',

    plugins: ['Pagination'],

    events: {
        'click [class*="orderBy"]':'setOrderBy'
    },

    defaultLayoutEvents: {
        "list:search:fire": "fireSearch",
        "list:filter:toggled": "filterToggled",
        "list:alert:show": "showAlert",
        "list:alert:hide": "hideAlert",
        "list:sort:fire": "sort"
    },

    /**
     * @inheritdoc
     */
    dataView: 'list',

    defaultContextEvents: {},

    // Model being previewed (if any)
    _previewed: null,
    //Store left column fields
    _leftActions: [],
    //Store right column fields
    _rowActions: [],
    //Store default and available(+visible) field names
    _fields: {},

    initialize: function(options) {
        //Grab the list of fields to display from the main list view (assuming initialize is being called from a subclass)
        var listViewMeta = app.metadata.getView(options.module, 'list') || {};
        //Extend from an empty object to prevent polution of the base metadata
        options.meta = _.extend({}, listViewMeta, options.meta || {});
        // FIXME: SC-5622 we shouldn't manipulate metadata this way.
        options.meta.type = options.meta.type || 'list';
        options.meta.action = 'list';
        options = this.parseFieldMetadata(options);

        if (options.meta.hasExternalFields) {
            this.plugins = _.union(this.plugins || [], ['ExternalApp']);
        }

        app.view.View.prototype.initialize.call(this, options);

        this.viewName = 'list';

        /**
         * View name that corresponds to the list of fields API should retrieve.
         * @property {string} dataViewName
         * @deprecated Use {@link #dataView} instead
         */
        if (this.dataViewName) {
            app.logger.warn('`dataViewName` is deprecated, please use `dataView`.');
            this.context.set('dataView', this.dataViewName);
        }

        this.attachEvents();
        this.orderByLastStateKey = app.user.lastState.key('order-by', this);
        this.orderBy = this._initOrderBy();
        if(this.collection) {
            this.collection.orderBy = this.orderBy;
        }
        // Dashboard layout injects shared context with limit: 5.
        // Otherwise, we don't set so fetches will use max query in config.
        this.limit = this.context.has('limit') ? this.context.get('limit') : null;
        this.metaFields = this.meta.panels ? _.first(this.meta.panels).fields : [];

        this.context.set('isUsingListPagination', this.hasListPagination());

        this.registerShortcuts();
    },

    /**
     * Initializes the {@link #orderBy} property.
     *
     * Retrieves the last state from the local storage and verifies the field
     * is still sortable.
     *
     * @return {Object}
     * @return {string} return.field The field name to sort by.
     * @return {string} return.direction The direction to sort by (either `asc`
     *   or `desc`).
     * @protected
     */
    _initOrderBy: function() {
        var lastStateOrderBy = app.user.lastState.get(this.orderByLastStateKey) || {},
            lastOrderedFieldMeta = this.getFieldMeta(lastStateOrderBy.field);

        if (_.isEmpty(lastOrderedFieldMeta) || !app.utils.isSortable(this.module, lastOrderedFieldMeta)) {
            lastStateOrderBy = {};
        }

        // if no access to the field, don't use it
        if (!_.isEmpty(lastStateOrderBy.field) && !app.acl.hasAccess('read', this.module, app.user.get('id'), lastStateOrderBy.field)) {
            lastStateOrderBy = {};
        }

        return _.extend({
                field : '',
                direction : 'desc'
            },
            this.meta.orderBy,
            lastStateOrderBy
        );
    },

    /**
     * @override
     * @private
     */
    _render: function () {
        app.view.View.prototype._render.call(this);
        //If user has no `list` access, render `noaccess.hbs` template
        if (!app.acl.hasAccessToModel(this.action, this.model)) {
            this._noAccessTemplate = this._noAccessTemplate || app.template.get("list.noaccess");
            this.$el.html(this._noAccessTemplate());
        }
    },

    /**
     * Parses the field's metadata to make sure that the following attributes
     * respect specific standards:
     *
     *  - `align`: accepted values are `left`, `center` and `right`.
     *  - `width`: the value can be a default width (e.g. `small` or `large`) or
     *  a number in pixels. Percentage widths are ignored.
     *
     * The method will add (or append to) two properties to each field's
     * metadata:
     *
     * - `classes`: css classes that should be set on the column header.
     * - `styles`: inline style that should be set on the column header.
     *
     * To render properly, make sure that the template sets them on the
     * column headers.
     *
     * @param {Object} options The `options` object passed in
     *   {@link #initialize}.
     * @param {Object} options.meta The metadata that we want to parse.
     * @return {Object} The `options` object with the metadata parsed and
     *   patched.
     */
    parseFieldMetadata: function(options) {
        // standardize the align and width param in the defs if they exist
        _.each(options.meta.panels, function(panel, panelIdx) {
            _.each(panel.fields, function(field, fieldIdx) {
                var fieldFromMeta = options.meta.panels[panelIdx].fields[fieldIdx];
                // FIXME align should be handled by the field directly - SC-3588
                if (!_.isUndefined(field.align)) {
                    if (_.contains(['left', 'center', 'right'], field.align)) {
                        fieldFromMeta.align = 't' + field.align;
                    } else {
                        delete fieldFromMeta.align;
                    }
                }

                // The width field in Studio is defined as a percentage which is
                // deprecated for SugarCRM modules. Check to see if module list
                // view metadata has been defined as percentage and if so,
                // ignore.
                if (!_.isUndefined(field.width)) {
                    // check to see if it's a percentage
                    // match beginning, decimal of 0 to 3 places, percent sign, end
                    var percent = field.width.toString().match(/^(\d{0,3})\%$/);
                    // ignore if defined as percent
                    if (!percent && !_.isEmpty(field.width+'')) {
                        var width = parseInt(field.width, 10);
                        if (!_.isNaN(width) && _.isNumber(width)) {
                            var styles = 'max-width:' + width + 'px;min-width:' + width + 'px';
                            fieldFromMeta.styles = styles;
                            fieldFromMeta.expectedWidth = width;
                        } else {
                            fieldFromMeta.widthClass = 'cell-' + field.width;
                            fieldFromMeta.expectedWidth = field.width;
                        }
                    }
                }
            }, this);
        }, this);

        return options;
    },

    /**
     * Takes the defaultListEventMap and listEventMap and binds the events. This is to allow views that
     * extend ListView to specify their own events.
     */
    attachEvents: function() {
        this.layoutEventsMap = _.extend(this.defaultLayoutEvents, this.layoutEvents); // If undefined nothing will be added.
        this.contextEventsMap = _.extend(this.defaultContextEvents, this.contextEvents);

        if (this.layout) {
            _.each(this.layoutEventsMap, function(callback, event) {
                this.layout.on(event, this[callback], this);
            }, this);

            this.layout.off('list:paginate:previous list:paginate:next list:paginate:input', null);
            this.layout.on('list:paginate:previous list:paginate:next list:paginate:input', function(callback) {
                let isUnchanged = true;

                if (_.isFunction(this.beforeContainerChange) && _.isFunction(this.handleListPaginationEvents)) {
                    isUnchanged = this.beforeContainerChange({
                        callback: _.bind(this.handleListPaginationEvents, this, callback),
                        message: 'LBL_WARN_UNSAVED_CHANGES'
                    });
                }

                if (isUnchanged) {
                    callback();
                }
            }, this);
        }

        if (this.context) {
            _.each(this.contextEventsMap, function(callback, event) {
                this.context.on(event, this[callback], this);
            }, this);
        }

        this.context.on('focusRow', this.focusRow, this);
        this.context.on('unfocusRow', this.unhighlightRows, this);
    },

    /**
     * Focus a row in the list
     * @param {string} id The id of the record to focus on
     */
    focusRow: function(id) {
        var $row = this.getRowDomForModelId(id);

        if ($row.length) {
            this.makeRowVisible($row);
        }
        this.highlightRow($row);
    },

    /**
     * Get the DOM for the row that represents a model. Override this for different row HTML
     * @param {string} id The model id
     * @return {jQuery}
     */
    getRowDomForModelId: function(id) {
        return this.$(`tr[name="${this.module}_${id}"]`);
    },

    /**
     * Highlights a row by making the row blue. Also removes the highlight from
     * any other row.
     * @param {jQuery} $el The element for the row to highlight
     */
    highlightRow: function($el) {
        this.unhighlightRows();
        if ($el.length) {
            $el.addClass('highlight-row');
        }
    },

    /**
     * Un-highlight all currently selected rows.
     */
    unhighlightRows: function() {
        let highlightedRows = this.$('tr.highlight-row');
        if (highlightedRows.length) {
            highlightedRows.removeClass('highlight-row');
        }
    },

    sort: function() {
        //When sorting the list view, we need to close the preview panel
        app.events.trigger("preview:close");
    },

    showAlert: function(message) {
        this.$("[data-target=alert]").html(message);
        this.$("[data-target=alert-container]").removeClass("hide");
    },

    hideAlert: function() {
        this.$("[data-target=alert-container]").addClass("hide");
        this.$("[data-target=alert]").empty();
    },
    filterToggled:function (isOpened) {
        this.filterOpened = isOpened;
    },
    fireSearch:function (term) {
        term = term || "";
        var options = {
            limit: this.limit || null,
            query: term
        };
        this.context.get("collection").resetPagination();
        this.context.resetLoadFlag({recursive: false});
        this.context.set('skipFetch', false);
        this.context.loadData(options);
    },

    /**
     * Sets order by on collection and view.
     *
     * The event is canceled if an element being dragged is found.
     *
     * @param {Event} event jQuery event object.
     */
    setOrderBy: function(event) {
        if ($(event.currentTarget).find('ui-draggable-dragging').length) {
            return;
        }

        var collection, options, eventTarget, orderBy;
        var self = this;

        collection = self.collection;
        eventTarget = self.$(event.currentTarget);

        // first check if alternate orderby is set for column
        orderBy = eventTarget.data('orderby');
        // if no alternate orderby, use the field name
        if (!orderBy) {
            orderBy = eventTarget.data('fieldname');
        }
        if (!_.isEmpty(orderBy) && !app.acl.hasAccess('read', this.module, app.user.get('id'), orderBy)) {
            // no read access to the orderBy field, don't bother to reload data
            return;
        }

        // if same field just flip
        if (orderBy === self.orderBy.field) {
            self.orderBy.direction = self.orderBy.direction === 'desc' ? 'asc' : 'desc';
        } else {
            self.orderBy.field = orderBy;
            self.orderBy.direction = 'desc';
        }

        collection.orderBy = self.orderBy;

        collection.resetPagination();

        options = self.getSortOptions(collection);

        if(this.triggerBefore('list:orderby', options)) {
            self._setOrderBy(options);
        }
    },

    /**
     * Run the order by on the collection
     *
     * @param {Object} options
     * @private
     */
    _setOrderBy: function(options) {
        if(this.orderByLastStateKey) {
            app.user.lastState.set(this.orderByLastStateKey, this.orderBy);
        }
        // refetch the collection
        this.context.resetLoadFlag({recursive: false});
        this.context.set('skipFetch', false);
        this.context.loadData(options);
    },
    /**
     * Gets options for fetch call for list sorting
     * @param collection
     * @return {Object}
     */
    getSortOptions: function(collection) {
        var self = this, options = {};
        // Treat as a "sorted search" if the filter is toggled open
        options = self.filterOpened ? self.getSearchOptions() : {};

        //Show alerts for this request
        options.showAlerts = true;

        // If injected context with a limit (dashboard) then fetch only that
        // amount. Also, add true will make it append to already loaded records.
        options.limit = self.limit || null;
        options.success = function (collection, response, options) {
            self.layout.trigger("list:sort:fire", collection, self);
        };

        // if we have a bunch of models already fetch at least that many
        if (collection.offset) {
            options.limit = collection.offset;
            options.offset = 0;
        }

        let isUsingListPagination = this.context.get('isUsingListPagination') || this.hasListPagination();

        // if we are using list pagination then set the limit to maximum allowed records
        if (isUsingListPagination && !options.limit) {
            options.limit = !_.isUndefined(this.context.get('limit')) ?
                this.context.get('limit') : app.config.maxQueryResult;
        } else {
            options.limit = options.limit || collection.length;
        }

        return options;
    },
    getSearchOptions:function () {
        var collection, options, previousTerms, term = '';
        collection = this.context.get('collection');

        // If we've made a previous search for this module grab from cache
        if (app.cache.has('previousTerms')) {
            previousTerms = app.cache.get('previousTerms');
            if (previousTerms) {
                term = previousTerms[this.module];
            }
        }
        // build search-specific options and return
        options = {
            params:{},
            fields:collection.fields ? collection.fields : this.collection
        };
        if (term) {
            options.params.q = term;
        }
        if (this.context.get('link')) {
            options.relate = true;
        }
        return options;
    },
    bindDataChange:function () {
        if (this.collection) {
            this.collection.on("reset", this.render, this);
        }
    },

    _dispose: function() {
        this._fields = null;
        app.view.View.prototype._dispose.call(this);
    },

    /**
     * Select next or previous row.
     * @param {Boolean} down
     */
    selectRow: function(down) {
        var $rows = this.$('.dataTable tbody tr'),
            $selected,
            $next;

        if ($rows.hasClass('selected')) {
            $selected = $rows.filter('.selected');
            $next = down ? $selected.next() : $selected.prev();
            if($next.length > 0) {
                $selected.removeClass('selected');
                $next.addClass('selected');
                this.makeRowVisible($next);
            }
        } else {
            $rows.first().addClass('selected');
            this.makeRowVisible();
        }
    },

    /**
     * Scroll list view such that the selected row is visible.
     * @param {jQuery} $selected
     */
    makeRowVisible: function($selected) {
        var $mainpane = this.$el.closest('.main-pane'),
            mainpaneHeight,
            selectedHeight,
            selectedTopPosition,
            selectedOffsetParent;

        if (_.isUndefined($selected)) {
            $mainpane.scrollTop(0);
            return;
        }

        mainpaneHeight = $mainpane.height();
        selectedHeight = $selected.height();
        selectedOffsetParent = $selected.offsetParent();
        selectedTopPosition = $selected.position().top + selectedOffsetParent.position().top;

        if ((selectedTopPosition + selectedHeight) > mainpaneHeight) {
            $mainpane.scrollTop($mainpane.scrollTop() + mainpaneHeight/2);
        }

        if (selectedTopPosition < 0) {
            $mainpane.scrollTop($mainpane.scrollTop() - mainpaneHeight/2);
        }
    },

    /**
     * Scroll list view either right or left.
     * @param {Boolean} right
     */
    scrollHorizontally: function(right) {
        var $scrollableDiv = this.$('.flex-list-view-content'),
            scrollEnabled = this.$el.hasClass('scroll-width'),
            nextScrollPosition,
            increment = 60;

        if (scrollEnabled) {
            if (right) {
                nextScrollPosition = $scrollableDiv.scrollLeft() + increment;
            } else {
                nextScrollPosition = $scrollableDiv.scrollLeft() - increment;
            }

            $scrollableDiv.scrollLeft(nextScrollPosition);
        }
    },

    /**
     * Determine if this layout is using the list-pagination component
     *
     * @return {boolean}
     */
    hasListPagination: function() {
        if (!this.layout || !this.layout.meta || !this.layout.meta.components) {
            return false;
        }

        return !_.isUndefined(_.find(this.layout.meta.components, component =>
            component.view &&
            (component.view === 'list-pagination' || component.view.name === 'list-pagination')
        ));
    },

    /**
     * Register shortcut keys.
     */
    registerShortcuts: function() {
        app.shortcuts.register({
            id: 'List:Select:Down',
            keys: 'j',
            component: this,
            description: 'LBL_SHORTCUT_NAVIGATE_DOWN',
            handler: function() {
                this.selectRow(true);
            }
        });

        app.shortcuts.register({
            id: 'List:Select:Up',
            keys: 'k',
            component: this,
            description: 'LBL_SHORTCUT_NAVIGATE_UP',
            handler: function() {
                this.selectRow(false);
            }
        });

        app.shortcuts.register({
            id: 'List:Scroll:Left',
            keys: 'h',
            component: this,
            description: 'LBL_SHORTCUT_SCROLL_LEFT',
            handler: function() {
                this.scrollHorizontally(false);
            }
        });

        app.shortcuts.register({
            id: 'List:Scroll:Right',
            keys: 'l',
            component: this,
            description: 'LBL_SHORTCUT_SCROLL_RIGHT',
            handler: function() {
                this.scrollHorizontally(true);
            }
        });

        app.shortcuts.register({
            id: 'List:Select:Open',
            keys: 'o',
            component: this,
            description: 'LBL_SHORTCUT_OPEN',
            handler: function() {
                if (this.$('.selected [data-type=name] a:visible').length > 0) {
                    this.$('.selected [data-type=name] a:visible').get(0).click();
                } else if (this.$('.selected [data-type=fullname] a:visible').length > 0) {
                    this.$('.selected [data-type=fullname] a:visible').get(0).click();
                }
            }
        });
    }
}) },
"dupecheck-list-edit": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckListEditView
 * @alias SUGAR.App.view.views.BaseDupecheckListEditView
 * @extends View.Views.Base.DupecheckListView
 */
({
	// Dupecheck-list-edit View (base) 

    extendsFrom: 'DupecheckListView',
    additionalTableClasses: 'duplicates-selectedit',

    addActions: function() {
        if (this.actionsAdded) return;
        this._super('addActions');

        var firstRightColumn = this.rightColumns[0];
        if (firstRightColumn && _.isArray(firstRightColumn.fields)) {
            //Prepend Select and Edit action
            firstRightColumn.fields.unshift({
                type: 'rowaction',
                label: 'LBL_LISTVIEW_SELECT_AND_EDIT',
                css_class: 'btn btn-invisible btn-link ellipsis_inline',
                tooltip: 'LBL_LISTVIEW_SELECT_AND_EDIT',
                event: 'list:dupecheck-list-select-edit:fire'
            });
            this.rightColumns[0] = firstRightColumn;
        }
        this.actionsAdded = true;
    }
}) },
"stage2-news-preferences-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Stage2NewsPreferencesHeaderpaneView
 * @alias SUGAR.App.view.views.BaseStage2NewsPreferencesHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Stage2-news-preferences-headerpane View (base) 

    events: {
        'click a[name=cancel_button]': 'close',
        'click a[name=save_button]': 'save'
    },

    /**
     * @inheritdoc
     * Add shortcuts for the save and close buttons.
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        app.shortcuts.register({
            id: 'Stage2:News:Preferences:Cancel',
            keys: ['esc', 'mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $cancelButton = this.$('a[name=cancel_button]');
                if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                    $cancelButton.click();
                }
            }
        });

        app.shortcuts.register({
            id: 'Stage2:News:Preferences:Save',
            keys: ['mod+s', 'mod+alt+a'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_SAVE',
            callOnFocus: true,
            handler: function() {
                var $saveButton = this.$('a[name=save_button]');
                if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                    $saveButton.click();
                }
            }
        });
    },

    /**
     * Save trigger
     */
    save: function() {
        app.events.trigger('news-preferences:save');
    },

    /**
     * Cancel trigger
     */
    close: function() {
        app.events.trigger('news-preferences:cancel');
    }
}) },
"dashboard-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashboardHeaderpaneView
 * @alias SUGAR.App.view.views.BaseDashboardHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 * @deprecated 7.9 It will be removed in 7.11.
 *   Please use {@link View.Views.Dashboards.DashboardHeaderpaneView} instead.
 */
({
	// Dashboard-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',
    buttons: null,
    editableFields: null,
    className: 'preview-headerbar',
    events: {
        'click [name=edit_button]': 'editClicked',
        'click [name=cancel_button]': 'cancelClicked',
        'click [name=create_cancel_button]': 'createCancelClicked',
        'click [name=delete_button]': 'deleteClicked',
        'click [name=add_button]': 'addClicked',
        'click [name=collapse_button]': 'collapseClicked',
        'click [name=expand_button]': 'expandClicked'
    },
    initialize: function(options) {
        app.logger.warn('The class `View.Views.Base.DashboardHeaderpaneView`' +
            'has been deprecated since 7.9.0.0 and will be removed in 7.11.0.0. ' +
            'Please use `View.Views.Dashboards.DashboardHeaderpaneView` instead.');
        if(options.context.parent) {
            options.meta = app.metadata.getView(options.context.parent.get("module"), options.name);
            options.template = app.template.getView(options.name);
        }
        this._super("initialize", [options]);
        this.model.on("change change:layout change:metadata", function() {
            if (this.inlineEditMode) {
                this.changed = true;
            }
        }, this);
        this.model.on("error:validation", this.handleValidationError, this);

        if(this.context.get("create")) {
            this.changed = true;
            this.action = 'edit';
            this.inlineEditMode = true;
        } else {
            this.action = 'detail';
        }
        this.buttons = {};

        this._bindEvents();
    },

    /**
     * Binds the events that are necessary for this view.
     *
     * @protected
     */
    _bindEvents: function() {
        this.context.on('record:set:state', this.setRecordState, this);
    },

    /**
     * Handles the logic done when the state changes in the record.
     * This is the callback for the `record:set:state` event.
     *
     * @param {string} state The state that the record is set to.
     */
    setRecordState: function(state) {
        this.model.trigger('setMode', state);
        this.setButtonStates(state);
        this.inlineEditMode = state === 'edit';
        this.toggleEdit(this.inlineEditMode);
    },

    editClicked: function(evt) {
        this.previousModelState = app.utils.deepCopy(this.model.attributes);
        this.inlineEditMode = true;
        this.setButtonStates('edit');
        this.toggleEdit(true);
        this.model.trigger("setMode", "edit");
    },
    cancelClicked: function(evt) {
        this.changed = false;
        this.model.unset('updated');
        this.clearValidationErrors();
        this.setButtonStates('view');
        this.handleCancel();
        this.model.trigger("setMode", "view");
    },

    /**
     * Compare with last fetched data and return true if model contains changes
     *
     * See {@link app.plugins.view.editable}.
     *
     * @return true if current model contains unsaved changes
     */
    hasUnsavedChanges: function() {
        if (this.model.get('updated')) {
            return true;
        }
        if (this.model.isNew()) {
            return this.model.hasChanged();
        }
        return !_.isEmpty(this.model.changedAttributes(this.model.getSynced()));
    },

    /**
     * The save function is handled by {@link View.Layouts.Base.DashboardLayout#handleSave}.
     *
     * @override
     */
    saveClicked: $.noop,

    createCancelClicked: function(evt) {
        if(this.context.parent) {
            this.layout.navigateLayout('list');
        } else {
            app.navigate(this.context);
        }
    },
    deleteClicked: function(evt) {
        this.handleDelete();
    },
    addClicked: function(evt) {
        if(this.context.parent) {
            this.layout.navigateLayout('create');
        } else {
            var route = app.router.buildRoute(this.module, null, 'create');
            app.router.navigate(route, {trigger: true});
        }
    },
    collapseClicked: function(evt) {
        this.context.trigger("dashboard:collapse:fire", true);
    },
    expandClicked: function(evt) {
        this.context.trigger("dashboard:collapse:fire", false);
    },
    _render: function() {
        app.view.View.prototype._render.call(this);

        this._setButtons();
        this.setButtonStates(this.context.get("create") ? 'create' : 'view');
        this.setEditableFields();
    },
    handleCancel: function() {
        this.inlineEditMode = false;
        if (!_.isEmpty(this.previousModelState)) {
            this.model.set(this.previousModelState);
        }
        this.toggleEdit(false);
    },
    handleDelete: function() {
        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_DELETE_DASHBOARD_CONFIRM', this.module),
            onConfirm: _.bind(function() {
                var message = app.lang.get('LBL_DELETE_DASHBOARD_SUCCESS', this.module, {
                    name: app.lang.get(this.model.get('name'), this.module)
                });
                this.model.destroy({
                    success: _.bind(function() {
                        //dispose safe
                        if (this.disposed) {
                            return;
                        }
                        if (this.context.parent) {
                            var contextBro = this.context.parent.getChildContext({module: 'Home'});
                            contextBro.get('collection').remove(this.model);
                            this.layout.navigateLayout('list');
                        } else {
                            var route = app.router.buildRoute(this.module);
                            app.router.navigate(route, {trigger: true});
                        }
                    }, this),
                    error: function() {
                        app.alert.show('error_while_save', {
                            level: 'error',
                            title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                            messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                        });
                    },
                    //Show alerts for this request
                    showAlerts: {
                        'process': true,
                        'success': {
                            messages: message
                        }
                    }
                });
            }, this)
        });
    },

    bindDataChange: function() {
        //empty out because dashboard header does not need to switch the button sets while model is changed
    },
    toggleEdit: function(isEdit) {
        this.toggleFields(this.editableFields, isEdit);
    }
}) },
"attachments": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Attachment dashlet displays Notes and Attachments records that is related to the LHS record.
 * The following items are configurable.
 *
 * - {Integer} limit Limit imposed to the number of records pulled.
 * - {Integer} auto_refresh How often (minutes) should refresh the data collection.
 *
 * @class View.Views.Base.AttachmentsView
 * @alias SUGAR.App.view.views.BaseAttachmentsView
 * @extends View.View
 */
({
	// Attachments View (base) 

    plugins: ['LinkedModel', 'Dashlet', 'Pagination'],
    events: {
        'click [data-event=create_button]': 'createRelatedNote',
        'click [data-event=select_button]': 'openSelectDrawer'
    },

    /**
     * Default options used when none are supplied through metadata.
     *
     * Supported options:
     * - timer: How often (minutes) should refresh the data collection.
     * - limit: Limit imposed to the number of records pulled.
     *
     * @property {Object}
     * @protected
     */
    _defaultOptions: {
        limit: 5,
        timer: 0
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        if (options.context) {
            this.baseModule = options.context.get('module');
            this.module = this.baseModule;
            this.baseRecord = this._getBaseModel(options);
        }

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     *
     * @param {String} viewName view name.
     */
    initDashlet: function(viewName) {
        this._initOptions();
        if (!this.meta.config && this.context.get('collection')) {
            this.context.set('skipFetch', false);
            this.context.set('limit', this.limit);
        }
        if (!this.meta.config && !this.meta.preview) {
            this.context.on('attachment:view:fire', this.previewRecord, this);
            this.on('attachment:unlinkrow:fire', this.unlinkClicked, this);
            if (this.timer > 0) {
                //disabled previous interval
                this._disableAutoRefresh();
                this._enableAutoRefresh(this.timer);
            }
        }
    },

    /**
     * Initialize options, default options are used when none are supplied
     * through metadata.
     *
     * @return {Backbone.View} Instance of this view.
     * @protected
     */
    _initOptions: function() {
        this.tbodyTag = 'ul[data-action="pagination-body"]';
        var options = _.extend(this._defaultOptions, this.settings.attributes || {});
        this.timer = parseInt(options['auto_refresh'], 10) * 60 * 1000;
        this.limit = options.limit;
        return this;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (_.has(this.collection, 'models')) {
            _.each(this.collection.models, function(model) {
                model.fields.name.link = true;
            }, this);
        }
        this._super('_render');
    },

    /**
     * Open create drawer to create new record.
     */
    openCreateDrawer: function() {
        var self = this;
        var module = this.context.get('module');
        var link = this.context.get('link');
        var model = this.createLinkModel(this.baseRecord, link);

        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                module: module,
                model: model
            }
        }, function(context, model) {
            if (!model) {
                return;
            }
            self._reloadData();
        });
    },

    /**
     * Get base model from parent context
     *
     * @param {Object} options
     * @return {Data.Bean} model the base model of the dashlet
     * @private
     */
    _getBaseModel: function(options) {
        var model;
        var baseModule = options.context.get('parentModule');
        var currContext = options.context;
        while (currContext) {
            var contextModel = currContext.get('rowModel') || currContext.get('model');

            if (contextModel && contextModel.get('_module') === baseModule) {
                model = contextModel;

                var parentHasRowModel = currContext.parent && currContext.parent.has('rowModel');
                if (!parentHasRowModel) {
                    break;
                }
            }
            currContext = currContext.parent;
        }
        return model;
    },

    /**
     * Get the list of field names to render the dashlet correctly
     * @return {string[]} The list of fields we need to fetch
     * @override
     */
    getFieldNames: function() {
        // FIXME TY-920: we shouldn't have to override this per-dashlet
        return this.dashletConfig && this.dashletConfig.dashlets[0].fields || [];
    },

    /**
     * Disable activated refresh interval
     * @protected
     */
    _disableAutoRefresh: function() {
        if (this.timerId) {
            clearInterval(this.timerId);
            this.timerId = null;
        }
        return this;
    },

    /**
     * Activate auto refresh data fetch.
     *
     * @param {Integer} msec Interval time in milli seconds(msec > 0).
     * @protected
     */
    _enableAutoRefresh: function(msec) {
        if (msec <= 0) {
            app.logger.error('Invalid interval timer: ' + msec);
            return this;
        }

        if (!_.isEmpty(this.timerId)) {
            app.logger.error('Trying to enable an already enabled auto-refresh dashlet.');
            return this;
        }

        this.timerId = setInterval(_.bind(function() {
            this.context.resetLoadFlag();
            this.layout.loadData();
        }, this), msec);
        return this;
    },

    /**
     * Apply svg icon plugin.
     */
    applySvgIcon: function() {
        var self = this,
            svgIconTemplate = app.template.get('attachments.svg-icon', this.module) ||
                app.template.get('attachments.svg-icon');
        this.$('[data-mime]').each(function() {
            var mimeType = $(this).data('mime'),
                filetype = self.dashletConfig.supportedImageExtensions[mimeType] || self._getFileType(mimeType);
            $(this).attr('data-filetype', filetype).html(svgIconTemplate());
        });
    },

    /**
     * Convert file mime type to file format
     *
     * @param {String} mimeType file mime type.
     * @return {String} file type.
     * @private
     */
    _getFileType: function(mimeType) {
        var filetype = mimeType.substr(mimeType.lastIndexOf('/') + 1).toUpperCase();
        return filetype ? filetype : this.dashletConfig.defaultType.toUpperCase();
    },

    /**
     * @inheritdoc
     *
     * Once collection is reset, the view should be refreshed.
     */
    bindDataChange: function() {
        if (this.collection) {
            this.collection.on('reset', this.render, this);
        }
        this.on('render', this.applySvgIcon, this);
        this.on('linked-model:create', this._reloadData, this);
    },

    /**
     * Re-fetches the data for the context's collection.
     *
     * FIXME: This will be removed when SC-4775 is implemented.
     *
     * @private
     */
    _reloadData: function() {
        this._prepContextForLoad();
        this.context.reloadData();
    },

    /**
     * Choose the attachment from the existing module list
     */
    openSelectDrawer: function() {
        var parentModel = this.context.get('parentModel'),
            linkModule = this.context.get('module'),
            link = this.context.get('link'),
            self = this;

        app.drawer.open({
            layout: 'selection-list',
            context: {
                module: linkModule
            }
        }, function(model) {
            if (!model) {
                return;
            }
            var relatedModel = app.data.createRelatedBean(parentModel, model.id, link),
                options = {
                    // Show alerts for this request
                    showAlerts: true,
                    relate: true,
                    success: function() {
                        self.context.resetLoadFlag();
                        self._prepContextForLoad();
                        self.context.loadData();
                    },
                    error: function() {
                        app.alert.show('server-error', {
                            level: 'error',
                            messages: 'ERR_GENERIC_SERVER_ERROR'
                        });
                    }
                };
            relatedModel.save(null, options);
        });
    },

    /**
     * Create new attachment record
     */
    createRelatedNote: function() {
        var link =  this.context.get('link'),
            parentModel = this.context.get('parentModel');
        this.createRelatedRecord(app.data.getRelatedModule(parentModel.module, link), link);
    },

    /**
     * Fix the fields on the context to prevent conflict with list-bottom
     * Also set `skipFetch` on the context since it is needed before most loads
     * @private
     */
    _prepContextForLoad: function() {
        this.context.set('fields', this.getFieldNames());
        this.context.set('skipFetch', false);
    },

    /**
     * Unlinks (removes) the selected model from the list view's collection.
     *
     * We trigger reset after removing the model in order to update html as well.
     *
     * @param {Data.Bean} model Selected model.
     */
    unlinkClicked: function(model) {
        var self = this;
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;
        app.alert.show(model.get('id') + ':unlink_confirmation', {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('NTC_UNLINK_CONFIRMATION_FORMATTED'), [context]),
            onConfirm: function() {
                model.destroy({
                    //Show alerts for this request
                    showAlerts: true,
                    relate: true,
                    success: function() {
                        if (self.disposed) {
                            return;
                        }
                        self.collection.remove(model);
                        self.render();
                    }
                });
            }
        });
    },

    /**
     * @inheritdoc
     *
     * Dispose the interval timer as well.
     */
    _dispose: function() {
        this._disableAutoRefresh();
        app.view.View.prototype._dispose.call(this);
    }
}) },
"link-moduleselect": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.LinkModuleselectView
 * @alias SUGAR.App.view.views.BaseLinkModuleselectView
 * @extends View.View
 */
({
	// Link-moduleselect View (base) 

    linkModules: [],
    events: {
        'click label[for=relationship]': 'setFocus'
    },
    initialize: function (options) {
        app.view.View.prototype.initialize.call(this, options);
        this.linkModules = this.context.get("linkModules");
    },
    setFocus: function (e) {
        this.$("#relationship").select2("open");
    },
    _renderHtml: function (ctx, options) {
        var self = this;
        app.view.View.prototype._renderHtml.call(this, ctx, options);
        this.$(".select2").select2({
            width: '100%',
            allowClear: true,
            placeholder: app.lang.get("LBL_SEARCH_SELECT")
        }).on("change", function (e) {
            if (_.isEmpty(e.val)) {
                self.context.trigger("link:module:select", null);
            } else {
                var meta = self.linkModules[e.val];
                self.context.trigger("link:module:select", {link: meta.link, module: meta.module});
            }
        });
    },
    _dispose: function() {
        this.$(".select2").select2('destroy');
        app.view.View.prototype._dispose.call(this);
    }
}) },
"massupdate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MassupdateView
 * @alias SUGAR.App.view.views.BaseMassupdateView
 * @extends View.View
 */
({
	// Massupdate View (base) 

    events: {
        'click [data-action="add"]' : 'addItem',
        'click [data-action="remove"]' : 'removeItem',
        'click .btn[name=update_button]' : 'saveClicked',
        'click .btn.cancel_button' : 'cancelClicked'
    },
    visible: false,
    fieldOptions: null,
    fieldValues: null,
    defaultOption: null,
    fieldPlaceHolderTag: '[name=fieldPlaceHolder]',
    massUpdateViewName: 'massupdate-progress',
    className: 'extend',

    /**
     * Default settings used when none are supplied through metadata.
     *
     * Supported settings:
     * - {Number} mass_delete_chunk_size Number of records per chunk while
     *   performing mass delete.
     * - {Number} mass_update_chunk_size Number of records per chunk while
     *   performing mass update.
     * - {Number} max_records_to_merge Default number of records we can merge.
     *
     * Example:
     * <pre><code>
     * // ...
     * 'settings' => array(
     *     'mass_delete_chunk_size' => 20,
     *     'mass_update_chunk_size' => 20,
     *     'max_records_to_merge' => 5,
     *     //...
     * ),
     * //...
     * </code></pre>
     *
     * If 'mass_delete_chunk_size' or 'mass_update_chunk_size' aren't supplied
     * default values fallback to 'app.config.massDeleteChunkSize' and
     * 'app.config.massUpdateChunkSize' respectively.
     *
     * @property {Object}
     * @protected
     */
    _defaultSettings: {
        max_records_to_merge: 5,
        mass_delete_chunk_size: 20,
        mass_update_chunk_size: 500
    },

    /**
     * @inheritdoc
     *
     * Try to find the `massupdate` template
     * falls back to `edit` when it does not exist
     */
    fallbackFieldTemplate: 'edit',

    /**
     * @inheritdoc
     * Retrieves metadata from sugarTemplate and then able to override it from
     * the core metadata. `panels` will only be supported on the core metadata.
     *
     * Each module can override the massupdate default metadata definitions.
     * To do this, please use the following path:
     * `{custom/,}modules/{module}/clients/{platform}/view/massupdate/massupdate.php`
     *
     * Core massupdate metadata (non-module based) doesn't support the `panels` and
     * `fields` properties, since we don't support generic default fields to be added.
     * Keep that in mind when defining your metadata on:
     * `{custom/,}clients/{platform}/view/massupdate/massupdate.php`
     */
    initialize: function(options) {
        var genericMeta = _.omit(app.metadata.getView(null, options.name), 'panels');
        options.meta = _.extend(
            {},
            genericMeta,
            options.meta
        );
        this.fieldValues = [{}];
        this.setMetadata(options);

        // FIXME massupdate shouldn't mess with the main context (should have own context)
        // this is a hack to prevent the massupdate fields to be added to the
        // context
        this.dataView = true;

        this._super('initialize', [options]);
        this._initSettings();

        this.setDefault();

        this.delegateListFireEvents();
        this.before('render', this.isVisible);

        //event register for preventing actions
        // when user escapes the page without confirming deleting
        app.routing.before("route", this.beforeRouteDelete, this);
        $(window).on("beforeunload.delete" + this.cid, _.bind(this.warnDeleteOnRefresh, this));
    },

    /**
     * Initialize settings, default settings are used when none are supplied
     * through metadata.
     *
     * @return {View.Views.BaseMassupdateView} Instance of this view.
     * @protected
     */
    _initSettings: function() {

        var configSettings = {};
        if (app.config.massActions) {
            if (app.config.massActions.massDeleteChunkSize) {
                configSettings.mass_delete_chunk_size = app.config.massActions.massDeleteChunkSize;
            }
            if (app.config.massActions.massUpdateChunkSize) {
                configSettings.mass_update_chunk_size = app.config.massActions.massUpdateChunkSize;
            }
        }

        this._settings = _.extend(
            {},
            this._defaultSettings,
            configSettings,
            this.meta && this.meta.settings || {}
        );

        return this;
    },

    delegateListFireEvents: function() {
        this.layout.on("list:massupdate:fire", this.show, this);
        this.layout.on("list:massaction:hide", this.hide, this);
        this.layout.on("list:massdelete:fire", this.warnDelete, this);
        this.layout.on("list:massexport:fire", this.massExport, this);
        this.layout.on("list:updatecalcfields:fire", this.updateCalcFields, this);
    },

    /**
     * Filter and patch the mass update fields.
     *
     * If the view definition contains an empty list of fields, it will pull all
     * the fields from the module metadata and add those with `massupdate = true`
     *
     * @param {Object} options The options object passed in 'initialize'.
     * @deprecated This will be removed on future versions.
     * Please see {@link view.fields.BaseBoolField} how you should define
     * your fields to be rendered on with a massupdate template.
     */
    //FIXME: remove this method when SC-2554 is implemented
    setMetadata: function(options) {
        var fieldList,
            massFields = [],
            metadataModule = app.metadata.getModule(options.module);
        if (!metadataModule) {
            app.logger.error('Failed to get module ' + options.module);
            return;
        }
        options.meta.panels = options.meta.panels || [{fields: []}];
        fieldList = metadataModule.fields;

        if (!_.isEmpty(options.meta.panels[0].fields)) {
            fieldList = _.map(options.meta.panels[0].fields, function(fieldDef) {
                var def = _.extend({}, fieldList[fieldDef.name], fieldDef);
                return def;
            });
        }
        _.each(fieldList, function(field) {
            // Only fields that are marked with massupdate set to true AND
            // that are not readonly should be used
            if (!field.massupdate || field.readonly) {
                return;
            }

            //we clone the metadata definition
            //to make sure we don't change the original metadata
            //FIXME we should not be faking metadata - (SC-2554)
            var cloneField = app.utils.deepCopy(field);
            cloneField.label = cloneField.label || cloneField.vname;
            massFields.push(cloneField);
        });

        // Patch the fields so that types like multienum and text use the correct templates
        options.meta.panels[0].fields = app.metadata._patchFields(options.module, metadataModule, massFields);
    },

    _render: function() {
        var result = app.view.View.prototype._render.call(this),
            self = this;

        if (this.$(".select2.mu_attribute")) {
            this.$(".select2.mu_attribute")
                .select2({
                    width: '100%',
                    minimumResultsForSearch: 5
                })
                .on("change", function(evt) {
                    var $el = $(this),
                        name = $el.select2('val'),
                        index = $el.data('index');
                    var option = _.find(self.fieldOptions, function(field){
                        return field.name == name;
                    });
                    self.replaceUpdateField(option, index);
                    self.placeField($el);
                });
            this.$(".select2.mu_attribute").each(function(){
                self.placeField($(this));
            });
        }

        if(this.fields.length == 0) {
            this.hide();
        }
        return result;
    },
    isVisible: function() {
        return this.visible;
    },
    placeField: function($el) {
        var name = $el.select2('val'),
            index = $el.data('index'),
            fieldEl = this.getField(name).$el;

        if($el.not(".disabled") && fieldEl) {
            var holder = this.$(this.fieldPlaceHolderTag + "[index=" + index + "]");
            this.$("#fieldPlaceHolders").append(holder.children());
            holder.html(fieldEl);
        }
    },
    addItem: function(evt) {
        if(!$(evt.currentTarget).hasClass("disabled")) {
            this.addUpdateField();
            // this will not be called in an async process so no need to
            // check for the view to be disposed
            this.render();
        }
    },
    removeItem: function(evt) {
        var index = $(evt.currentTarget).data('index');
        this.removeUpdateField(index);
        // this will not be called in an async process so no need to
        // check for the view to be disposed
        this.render();
    },
    addUpdateField: function() {
        this.fieldValues.splice(this.fieldValues.length - 1, 0, this.defaultOption);
        this.defaultOption = null;
        this.setDefault();
    },

    /**
     * Removes the field value at the provided index.
     *
     * @param {integer} index
     */
    removeUpdateField: function(index) {
        var fieldValue = this.fieldValues[index];

        if (_.isUndefined(fieldValue)) {
            return;
        }
        // If the fieldValue has a name, we need to remove it from the model and
        // the fieldValues object.
        if (fieldValue.name) {
            this.model.unset(fieldValue.name);
            // For relate fields, we need to clear fieldValue.id_name.
            // Note that if fieldValue.id_name is undefined, this is still safe.
            this.model.unset(fieldValue.id_name);
            this.fieldValues.splice(index, 1);
        // If the fieldValue does not have a name, reset the default option to
        // the last item, which should be empty
        } else {
            var removed = this.fieldValues.splice(index - 1, 1);
            this.defaultOption = removed[0];
        }

        // If there is a populate_list (i.e. this is a relate field)
        // clear the related data.
        // Fixme: This should be cleaned up on the relate field. See TY-651
        if (!_.isUndefined(fieldValue.populate_list)) {
            _.each(fieldValue.populate_list, function(key) {
                this.model.unset(key);
            }, this);
        }
        this.setDefault();
    },

    replaceUpdateField: function(selectedOption, targetIndex) {
        var fieldValue = this.fieldValues[targetIndex];

        if(fieldValue.name) {
            this.model.unset(fieldValue.name);
            this.fieldOptions.push(fieldValue);
            this.fieldValues[targetIndex] = selectedOption;
        } else {
            this.model.unset(this.defaultOption.name);
            this.fieldOptions.push(this.defaultOption);
            this.defaultOption = selectedOption;
        }
    },
    setDefault: function() {
        var assignedValues = _.pluck(this.fieldValues, 'name');
        if(this.defaultOption) {
            assignedValues = assignedValues.concat(this.defaultOption.name);
        }
        //remove the attribute options that has been already assigned
        this.fieldOptions = (this.meta) ? _.reject(_.flatten(_.pluck(this.meta.panels, 'fields')), function(field){
            return (field) ? _.contains(assignedValues, field.name) : false;
        }) : [];
        //set first item as default
        this.defaultOption = this.defaultOption || this.fieldOptions.splice(0, 1)[0];
    },

    /**
     * Create the Progress view unless it is initialized.
     * Return the progress view component in the same layout.
     *
     * @return {Backbone.View} MassupdateProgress view component.
     */
    getProgressView: function() {
        var progressView = this.layout.getComponent(this.massUpdateViewName);
        if (!progressView) {
            progressView = app.view.createView({
                context: this.context,
                type: this.massUpdateViewName,
                layout: this.layout
            });
            this.layout._components.push(progressView);
            this.layout.$el.append(progressView.$el);
        }
        progressView.render();
        return progressView;
    },

    /**
     * Create massupdate collection against the parent module.
     * Design the model synchronizing progressively.
     *
     * @param {String} baseModule parent module name.
     * @return {Backbone.Collection} Massupdate collection.
     */
    getMassUpdateModel: function(baseModule) {
        var massModel = this.context.get('mass_collection'),
            progressView = this.getProgressView(),
            massCollection = massModel ? _.extend({}, massModel, {
                defaultMethod: 'update',
                module: 'MassUpdate',
                baseModule: baseModule,

                /**
                 * Maximum number of retrial attempt.
                 *
                 * @property
                 */
                maxAllowAttempt: 3,

                /**
                 * Chunk for each execution.
                 *
                 * @property
                 */
                chunks: null,

                /**
                 * Discarded records due to the permission.
                 *
                 * @property
                 */
                discards: [],

                /**
                 * Current trial attempt number.
                 *
                 * @property
                 */
                attempt: 0,

                /**
                 * Pause status.
                 * If current job is on progress,
                 * the next queue will be paused.
                 *
                 * @property
                 */
                paused: false,

                /**
                 * Number of records per chunk, defaults to '20'.
                 *
                 * @property {Number} chunkSize Number of records.
                 * @protected
                 */
                 _chunkSize: 20,

                /**
                 * Number of update failures
                 *
                 * @property {Number} numFailures Number of failures.
                 * @protected
                 */
                 numFailures: 0,

                /**
                 * Set number of records per chunk.
                 *
                 * @param {Number} chunkSize Number of records.
                 */
                setChunkSize: function(chunkSize) {
                    this._chunkSize = parseInt(chunkSize, 10);
                },

                /**
                 * Reset mass job.
                 */
                resetProgress: function() {
                    massModel.reset();
                    this.length = 0;
                },

                /**
                 * Update current progress job.
                 */
                updateProgress: function() {
                    this.remove(this.chunks.splice(0));
                    massModel.length = this.length;
                },

                /**
                 * Update the next chunk queue.
                 */
                updateChunk: function() {
                    if (!this.chunks) {
                        this.chunks = this.slice(0, this._chunkSize);
                        this.trigger('massupdate:start');
                    }
                    if (_.isEmpty(this.chunks)) {
                        this.chunks = this.slice(0, this._chunkSize);
                    }
                },

                /**
                 * Resume the job from the previous paused status.
                 */
                resumeFetch: function() {
                    if (!this._pauseOptions) {
                        return;
                    }
                    this.paused = false;
                    this.trigger('massupdate:resume');
                    this.fetch(this._pauseOptions);
                },

                /**
                 * Request pausing mass job.
                 */
                pauseFetch: function() {
                    this.paused = true;
                },

                /**
                 * @inheritdoc
                 * Instead of fetching entire set,
                 * split entire set into small chunks
                 * and repeat fetching until entire set is completed.
                 */
                sync: function(default_method, model, options) {
                    if (model.paused) {
                        this._pauseOptions = options;
                        this.trigger('massupdate:pause');
                        return;
                    }
                    this.method = options.method;

                    //split set into chunks.
                    this.updateChunk();
                    var callbacks = {
                            success: function(data, response) {
                                model.numFailures += data.failed;
                                model.updateProgress();
                                model.trigger('massupdate:done');
                                if (model.length === 0) {
                                    model.trigger('massupdate:end');
                                    if (_.isFunction(options.success)) {
                                        //setting data to null since backbone reset will add the data object to the collection
                                        //using the respoonse as options for callback
                                        options.status = response.status;
                                        options.success();
                                    }
                                } else {
                                    model.fetch(options);
                                }
                            },
                            error: function(xhr) {
                                model.attempt++;
                                model.trigger('massupdate:fail');
                                if (model.attempt <= model.maxAllowAttempt) {
                                    model.fetch(options);
                                } else if (_.isFunction(options.error)) {
                                    model.trigger('massupdate:end');
                                    options.error(xhr);
                                }
                            },
                            complete: function(xhr) {
                                model.trigger('massupdate:always');
                                if (_.isFunction(options.complete)) {
                                    options.complete(xhr);
                                }
                            }
                    };
                    var method = options.method || this.defaultMethod;
                    var data = this.getAttributes(options.attributes, method);

                    if (_.isEmpty(data.massupdate_params.uid)) {
                        // No records to update, end the mass update.
                        model.trigger('massupdate:end');
                        return;
                    }
                    var url = app.api.buildURL(baseModule, this.module, data, options.params);
                    app.api.call(method, url, data, callbacks);
                },

                /**
                 * Convert collection attributes into MassUpdate API format.
                 * @param {Object} attributes Collection attributes.
                 * @return {Object} MassUpdate data format.
                 */
                getAttributes: function(attributes, action) {
                    return {
                        massupdate_params: _.extend({
                            'uid': this.getAvailableList(action)
                        }, attributes)
                    };
                },

                /**
                 * Check the access role for entire selection.
                 * Return only available model ids and store the discarded ids.
                 *
                 * @param action
                 * @return {Array} List of available model ids.
                 */
                getAvailableList: function(action) {
                    var action2permission = {
                            'update': 'edit',
                            'delete': 'delete'
                        },
                        list = [];
                    _.each(this.chunks, function(model) {
                        if (app.acl.hasAccessToModel(action2permission[action], model) !== false) {
                            list.push(model.id);
                        } else {
                            this.discards.push(model.id);
                        }
                    }, this);
                    return list;
                }
            }) : null;
        progressView.initCollection(massCollection);
        return massCollection;
    },

    /**
     * Popup dialog message to confirm delete action
     */
    warnDelete: function() {
        this._modelsToDelete = this.getMassUpdateModel(this.module);
        this._modelsToDelete.setChunkSize(this._settings.mass_delete_chunk_size);

        this._targetUrl = Backbone.history.getFragment();
        //Replace the url hash back to the current staying page
        if (this._targetUrl !== this._currentUrl) {
            app.router.navigate(this._currentUrl, {trigger: false, replace: true});
        }

        this.hideAll();

        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('NTC_DELETE_CONFIRMATION_MULTIPLE', this.module),
            onConfirm: _.bind(this.deleteModels, this),
            onCancel: _.bind(function() {
                app.analytics.trackEvent('click', 'mass_delete_cancel');
                this._modelsToDelete = null;
                app.router.navigate(this._targetUrl, {trigger: false, replace: true});
            }, this)
        });
    },

    /**
     * Popup browser dialog message to confirm delete action
     *
     * @return {String} the message to be displayed in the browser dialog
     */
    warnDeleteOnRefresh: function() {
        if (this._modelsToDelete) {
            return app.lang.get('NTC_DELETE_CONFIRMATION_MULTIPLE');
        }
    },

    /**
     * Delete the model once the user confirms the action
     */
    deleteModels: function() {
        var self = this,
            collection = self._modelsToDelete;
        var lastSelectedModels = _.clone(collection.models);

        app.analytics.trackEvent('click', 'mass_delete_confirm');
        if(collection) {
            // massupdate:end could be triggered without triggering success event on collection.
            // For example, when we user has no permissions to perform delete.
            // That's why we need to clear modelsToDelete when massupdate:end triggered too.
            collection.once('massupdate:end', function() {
                self._modelsToDelete = null;
            }, this);

            collection.fetch({
                //Don't show alerts for this request
                showAlerts: false,
                method: 'delete',
                error: function() {
                    app.alert.show('error_while_mass_update', {
                        level:'error',
                        title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                        messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                    });
                },
                success: function(data, response, options) {
                    self.layout.trigger("list:records:deleted", lastSelectedModels);
                    var redirect = self._targetUrl !== self._currentUrl;
                    if (options.status === 'done') {
                        //TODO: Since self.layout.trigger("list:search:fire") is deprecated by filterAPI,
                        //TODO: Need trigger for fetching new record list
                        self.layout.context.reloadData({showAlerts: false});
                    } else if (options.status === 'queued') {
                        app.alert.show('jobqueue_notice', {level: 'success', title: app.lang.get('LBL_MASS_UPDATE_JOB_QUEUED'), autoClose: true});
                    }
                    self._modelsToDelete = null;
                    if (redirect) {
                        self.unbindBeforeRouteDelete();
                        //Replace the url hash back to the current staying page
                        app.router.navigate(self._targetUrl, {trigger: true});
                    }
                }
            });
        }
    },

    /**
     * Pre-event handler before current router is changed
     *
     * @return {Boolean} true to continue routing, false otherwise
     */
    beforeRouteDelete: function () {
        if (this._modelsToDelete) {
            this.warnDelete(this._modelsToDelete);
            return false;
        }
        return true;
    },

    /**
     * Called to allow admins to resave records and update thier calculated fields.
     */
    updateCalcFields: function() {
        this.hideAll();
        this.save(true);
    },

    /**
     * Performs mass export on selected records
     */
    massExport: function() {
        this.hideAll();
        var massExport = this.context.get("mass_collection");

        if (massExport) {
            app.alert.show('massexport_loading', {level: 'process', title: app.lang.get('LBL_LOADING')});

            app.api.exportRecords({
                    module: this.module,
                    uid: massExport.pluck('id')
                },
                this.$el,
                {
                    complete: function(data) {
                        app.alert.dismiss('massexport_loading');
                    }
                });
        }
    },

    /**
     * Called to start the massupdate process. Checks for validation errors
     * before sending down the modified attributes and starting the job queue.
     *
     * @param {Boolean} [forCalcFields=false] Causes the massupdate model to
     *   fetch with empty attributes, prior to saving the records.
     */
    save: function(forCalcFields) {
        forCalcFields = !!forCalcFields;
        var massUpdate = this.getMassUpdateModel(this.module),
            self = this;

        massUpdate.setChunkSize(this._settings.mass_update_chunk_size);

        this.once('massupdate:validation:complete', function(validate) {
            var errors = validate.errors,
                emptyValues = validate.emptyValues,
                confirmMessage = app.lang.get('LBL_MASS_UPDATE_EMPTY_VALUES'),
                attributes = validate.attributes || this.getAttributes();

            this.$(".fieldPlaceHolder .error").removeClass("error");
            this.$(".fieldPlaceHolder .help-block").hide();

            if (_.isEmpty(errors)) {
                confirmMessage += '<br>[' + emptyValues.join(',') + ']<br>' + app.lang.get('LBL_MASS_UPDATE_EMPTY_CONFIRM') + '<br>';
                if (massUpdate) {
                    var fetchMassupdate = _.bind(function() {
                        var successMessages = this.buildSaveSuccessMessages(massUpdate);
                        massUpdate.fetch({
                            //Show alerts for this request
                            showAlerts: true,
                            attributes: attributes,
                            error: function() {
                                app.alert.show('error_while_mass_update', {
                                    level: 'error',
                                    title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                                    messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                                });
                            },
                            success: function(data, response, options) {
                                self.hide();
                                if (options.status === 'done') {
                                    //TODO: Since self.layout.trigger("list:search:fire") is deprecated by filterAPI,
                                    //TODO: Need trigger for fetching new record list
                                    self.collection.fetch({
                                        //Don't show alerts for this request
                                        showAlerts: false,
                                        remove: true,
                                        // Boolean coercion.
                                        relate: !!self.layout.collection.link
                                    });
                                } else if (options.status === 'queued') {
                                    app.alert.show('jobqueue_notice', {level: 'success', messages: successMessages[options.status], autoClose: true});
                                }
                            }
                        });
                    }, this);
                    if (emptyValues.length === 0) {
                        fetchMassupdate.call(this);
                    } else {
                        app.alert.show('empty_confirmation', {
                            level: 'confirmation',
                            messages: confirmMessage,
                            onConfirm: fetchMassupdate
                        });
                    }
                }
            } else {
                this.handleValidationError(errors);
            }
        }, this);

        if (forCalcFields) {
            this.trigger('massupdate:validation:complete', {
                errors: [],
                emptyValues: [],
                attributes: {}
            });
        } else {
            this.checkValidationError();
        }
    },

    /**
     * Build dynamic success messages to be displayed if the API call is successful
     * This is overridden by massaddtolist view which requires different success messages
     *
     * @param massUpdateModel - contains the attributes of what records are being updated (used by override in massaddtolist)
     */
    buildSaveSuccessMessages: function(massUpdateModel) {
        return {
            done: app.lang.get('LBL_MASS_UPDATE_SUCCESS'),
            queued: app.lang.get('LBL_MASS_UPDATE_JOB_QUEUED')
        };
    },

    /**
     * By default attributes are retrieved directly off the model, but broken out to allow for manipulation before handing off to the API
     */
    getAttributes: function() {
        var values = [this.defaultOption].concat(this.fieldValues),
            attributes = [],
            fieldFilter = function(field) {
                return field && field.name;
            };
        values = _.chain(values)
            //Grab the field arrays from any fields that have child fields
            //and merge them with the top level field list
            .union(_.chain(values)
                .pluck("fields")
                .compact()
                .flatten()
                .value()
            )
            //Remove any dupes or empties
            .uniq(fieldFilter)
            .filter(fieldFilter)
            .value();

        _.each(values, function(value) {
            attributes = _.union(attributes,
                _.values(_.pick(value, 'name', 'id_name'))
            );
            //FIXME: remove these hard coded conditions (SC-2836)
            if (value.name === 'parent_name') {
                attributes.push('parent_id', 'parent_type');
            } else if (value.name === 'team_name') {
                attributes.push('team_name_type');
            } else if (value.name === 'tag') {
                attributes.push('tag_type');
            } else if (value.isMultiSelect) {
                attributes.push(value.name + '_replace');
            }
        }, this);
        return _.pick(this.model.attributes, attributes);
    },

    /**
     * Get fields to validate.
     * @return {Object}
     * @private
     */
    _getFieldsToValidate: function() {
        var fields = _.initial(this.fieldValues).concat(this.defaultOption);
        return _.filter(fields, function(f) {
            return f.name;
        })
    },

    checkValidationError: function() {
        var self = this,
            emptyValues = [],
            errors = {},
            validator = {},
            i = 0;

        var fieldsToValidate = this._getFieldsToValidate();

        if (_.size(fieldsToValidate)) {
            _.each(fieldsToValidate, function(field) {
                i++;
                validator = {};
                validator[field.name] = field;
                field.required = (_.isBoolean(field.required) && field.required) || (field.required && field.required == 'true') || false;
                var value = this.model.get(field.name);
                // check if value represents emptiness
                if ((!_.isBoolean(value) && !value) || (_.isArray(value) && value.length === 0)) {
                    // If value is empty, but it's being appended, don't add it to empty values
                    // use == because the value may be a string
                    var appendCheck = this.model.get(field.name + '_type');
                    if (!appendCheck || appendCheck == 0) {
                        emptyValues.push(app.lang.get(field.label, this.model.module));
                        //don't set model if field is a relate collection
                        if (!field.relate_collection) {
                            this.model.set(field.name, '', {silent: true});
                            if (field.id_name) {
                                this.model.set(field.id_name, '', {silent: true});
                            }
                        }
                    }
                }
                this.model._doValidate(validator, errors, function(didItFail, fields, errors, callback) {
                    if (i === _.size(fieldsToValidate)) {
                        self.trigger('massupdate:validation:complete', {
                            errors: errors,
                            emptyValues: emptyValues
                        });
                    }
                });
            }, this);
        } else {
            this.trigger('massupdate:validation:complete', {
                errors: errors,
                emptyValues: emptyValues
            });
        }

        return;
    },
    handleValidationError: function(errors) {
        var self = this;
        _.each(errors, function (fieldErrors, fieldName) {
            var field = self.getField(fieldName);
            if (!_.isUndefined(field)) {
                var fieldEl = field.$el,
                    errorEl = fieldEl.find('.help-block');
                fieldEl.addClass('error');
                if(errorEl.length == 0) {
                    errorEl = $('<span>').addClass('help-block');
                    errorEl.appendTo(fieldEl);
                }
                errorEl.show().html('');
                _.each(fieldErrors, function (errorContext, errorName) {
                    errorEl.append(app.error.getErrorString(errorName, errorContext));
                });
            }
        });
    },
    show: function() {
        this.hideAll();
        this.visible = true;
        this.defaultOption = null;
        this.model.clear();
        var defaults = _.extend({}, this.model._defaults, this.model.getDefault());
        this.model.set(defaults);
        this.setDefault();

        var massModel = this.context.get('mass_collection');
        massModel.off(null, null, this);
        massModel.on('add remove reset massupdate:estimate', this.setDisabled, this);
        massModel.on('massupdate:start massupdate:end', this.setDisabledOnUpdate, this);

        // show will be called only on context.trigger("list:massupdate:fire").
        // therefore this should never be called in a situation in which
        // the view is disposed.
        this.$el.show();
        this.render();

        this.createShortcutSession();
        this.registerShortcuts();
    },
    /**
     * Hide all views that make up the list mass action section (ie. massupdate, massaddtolist)
     */
    hideAll: function() {
        this.layout.trigger("list:massaction:hide");
    },
    hide: function() {
        if (this.disposed) {
            return;
        }
        this.visible = false;
        this.$el.hide();

        this.clearAndRestorePreviousShortcuts();
    },
    /**
     * Create new shortcut session.
     */
    createShortcutSession: function() {
        app.shortcuts.saveSession();
        app.shortcuts.createSession([
            'MassUpdate:Add',
            'MassUpdate:Remove',
            'MassUpdate:Cancel',
            'MassUpdate:Update'
        ], this);
    },
    /**
     * Register shortcuts for mass update inline drawer.
     */
    registerShortcuts: function() {
        app.shortcuts.register({
            id: 'MassUpdate:Add',
            keys: '+',
            component: this,
            description: 'LBL_SHORTCUT_MASS_UPDATE_ADD',
            handler: function() {
                this.$('[data-action=add]').last().click();
            }
        });
        app.shortcuts.register({
            id: 'MassUpdate:Remove',
            keys: '-',
            component: this,
            description: 'LBL_SHORTCUT_MASS_UPDATE_REMOVE',
            handler: function() {
                this.$('[data-action=remove]').last().click();
            }
        });
        app.shortcuts.register({
            id: 'MassUpdate:Cancel',
            keys: ['esc', 'mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_MASS_UPDATE_CANCEL',
            callOnFocus: true,
            handler: function() {
                this.$('a.cancel_button').click();
            }
        });
        app.shortcuts.register({
            id: 'MassUpdate:Update',
            keys: ['mod+s', 'mod+alt+a'],
            component: this,
            description: 'LBL_SHORTCUT_MASS_UPDATE_SAVE',
            callOnFocus: true,
            handler: function() {
                this.$('[name=update_button]:not(.disabled)').click();
            }
        });
    },
    /**
     * Clear shortcuts and restore previous shortcut session.
     */
    clearAndRestorePreviousShortcuts: function() {
        var activeShortcutSession = app.shortcuts.getCurrentSession();
        if (activeShortcutSession && (activeShortcutSession.layout === this)) {
            app.shortcuts.restoreSession();
        }
    },
    setDisabledOnUpdate: function() {
        var massUpdate = this.context.get('mass_collection');
        if (massUpdate.length == 0) {
            this.$('.btn[name=update_button]').removeClass('disabled');
        } else {
            this.$('.btn[name=update_button]').addClass('disabled');
        }
    },
    setDisabled: function() {
        var massUpdate = this.context.get('mass_collection');
        if (massUpdate.isEmpty() || massUpdate.fetched === false) {
            this.$('.btn[name=update_button]').addClass('disabled');
        } else {
            this.$('.btn[name=update_button]').removeClass('disabled');
        }
    },
    saveClicked: function(evt) {
        if(this.$(".btn[name=update_button]").hasClass("disabled") === false) {
            this.save();
        }
    },
    cancelClicked: function(evt) {
        this.hide();
    },
    unbindData: function() {
        var massModel = this.context.get("mass_collection");
        if (massModel) {
            massModel.off(null, null, this);
        }
        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * Detach the event handlers for warning delete
     */
    unbindBeforeRouteDelete: function() {
        app.routing.offBefore("route", this.beforeRouteDelete, this);
        $(window).off("beforeunload.delete" + this.cid);
    },

    /**
     * Verifies mass-update if service start date exceeds service end date when add-on-to is selected.
     *
     * @return Boolean
     */
    isEndDateEditableByStartDate: function() {
        var massUpdateModels = this.getMassUpdateModel(this.module).models;
        var fieldsToValidate = this._getFieldsToValidate();
        var checkField = 'service_start_date';
        var updatedValues = {};
        // Fields and their values selected for mass-update.
        _.each(fieldsToValidate, function(field) {
            updatedValues[field.name] = this.model.get(field.name);
            if (!_.isUndefined(field.id_name) && this.model.has(field.id_name)) {
                updatedValues[field.id_name] = this.model.get(field.id_name);
            }
        }, this);
        // Verify each record selected in mass-update.
        return _.every(massUpdateModels, function(model) {
            if (model.get('add_on_to_id') && updatedValues[checkField]) {
                var startDate = app.date(updatedValues[checkField]);
                var endDate = app.date(model.get('service_end_date'));
                if (!startDate.isSameOrBefore(endDate)) {
                    return false;
                }
            }
            return true;
        }, this);
    },

    /**
     * Display error message in when service start date is after service end date.
     */
    handleUnEditableEndDateErrorMessage: function() {
        app.alert.show('stop_mass_update_for_service_start_date', {
            level: 'error',
            messages: app.lang.get('LBL_MASS_UPDATE_WARNING_SERVICE_START_DATE'),
            cancel: {
                label: app.lang.get('LBL_CANCEL')
            },
        });
    },

    _dispose: function() {
        this.unbindBeforeRouteDelete();
        this.$('.select2.mu_attribute').select2('destroy');
        app.view.View.prototype._dispose.call(this);
    }
}) },
"dashboard-fab": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashboardFabView
 * @alias SUGAR.App.view.views.BaseDashboardFabView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Dashboard-fab View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click [name=duplicate_button]': 'duplicateClicked',
        'click [name=delete_button]': 'deleteClicked',
        'click [name=add_button]': 'addClicked',
        'click [name=collapse_button]': 'collapseClicked',
        'click [name=expand_button]': 'expandClicked',
        'click [name=edit_module_tabs_button]': 'editModuleTabsClicked',
        'click [name=restore_dashboard_button]': 'restoreDashboardClicked',

        'click .dfab-content .dfab-icon, .dfab-content .dfab-label': 'closeFABs',
        'click .dfab-pin': 'togglePinPosition',
        'click .dfab-title .dfab-icon': 'toggleFAB'
    },

    /**
     * Indicator showing where the button is pinned (default: bottom).
     *
     * @property {string}
     */
    pinnedTo: 'bottom',

    /**
     * The height of the buttons. It is used in calculating the animation position.
     *
     * @property {number}
     */
    baseHeight: 40,

    /**
     * The margin in between the buttons.
     *
     * @property {number}
     */
    interButtonMargin: 15,

    /**
     * The icon used when the button is expanded.
     */
    defaultCloseIcon: 'sicon-close-lg',

    /**
     * Floating action buttons by default will load the metadata described in the Home module.
     * To load any module specific metadata, the loadModule property should updated accordingly.
     * The parent module does not matter in this regard.
     * For more details please see: {@link View.Views.Dashboards.DashboardHeaderpaneView}.
     *
     * @param {Object} options Standard options for initializing a component.
     * @return {Object} The initialization options with the context metadata.
     */
    overrideOptions: function(options) {
        if (options.context.parent) {
            var ctxParentModule = options.context.parent.get('module');
            options.meta = app.metadata.getView(ctxParentModule, options.type, options.loadModule);
            options.template = app.template.getView(options.type);
        }
        return options;
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options = this.overrideOptions(options);
        this._super('initialize', [options]);
        this.bindEvents();
        this.fabCloseHandler = _.bind(this.closeFABsOnWindowClick, this);
    },

    /**
     * On metadata update and on changing the active tab of the tabbed dsahboard
     * change the visibility of buttons.
     */
    bindEvents: function() {
        if (this.layout && this.layout.model) {
            this.layout.model.on('change:metadata', this.render, this);
        }
        this.context.on('tabbed-dashboard:update', this.updateButtonVisibilities, this);
        this.context.on('tabbed-dashboard:switch-tab', this.updateButtonVisibilities, this);
    },

    /**
     * Do not render the component if there is no metadata. Otherwise set the buttons visibilities.
     * Attach an event handler to the window.
     */
    render: function() {
        if (!this.layout.model.get('metadata') || this.context.get('create')) {
            return;
        }

        this.pinnedTo = this.getCachePinnedTo() || this.pinnedTo;

        this._super('render');

        this._setButtons();
        this.setButtonStates(this.context.get('create') ? 'create' : 'view');
        this.toggleMainButton();
        $(window).on('mousedown', this.fabCloseHandler);
    },

    /**
     * Shows/hides the main floating action button depending on
     * if there are any action buttons held inside.
     */
    toggleMainButton: function() {
        this.updateButtonVisibilities();

        var hasVisibleButtons = _.any(this.buttons, function(button) {
            return button.isVisible && button.isVisible();
        });

        this.$el.toggle(hasVisibleButtons);
    },

    /**
     * Pin top/bottom action. Clicking on the Pin to Top button will move the
     * floatin action control button to the top.
     */
    togglePinPosition: function() {
        var contentWrapper = this.$el.find('.dfab');

        if (this.pinnedTo === 'bottom') {
            this.pinnedTo = 'top';
            contentWrapper.toggleClass('top bottom');
        } else {
            this.pinnedTo = 'bottom';
            contentWrapper.toggleClass('bottom top');
        }

        this.setCachePinnedTo(this.pinnedTo);
    },

    /**
     * Switch between the expanded/collapsed state of the floating action button.
     */
    toggleFAB: function() {
        var contentWrapper = this.$el.find('.dfab');
        if (contentWrapper.hasClass('expanded')) {
            this.closeFABs();
            return;
        }
        this.openFABs();
    },

    /**
     * Collapse the floating action button.
     * It will set the inner buttons to the initial state and reset the classes.
     */
    closeFABs: function() {
        var contentWrapper = this.$el.find('.dfab');
        var items = contentWrapper.find('.dfab-content > *');

        _.each(items, function(item) {
            $(item).css('transform', 'translateY(0px)');
        });

        contentWrapper.removeClass('expanded');
        var mainIcon = this.$el.find('.dfab-title .dfab-icon.sicon');
        mainIcon.removeClass(this.defaultCloseIcon).addClass(this.meta.icon);
    },

    /**
     * Expand the floating action button.
     * It will change css classes on elements to realize the animation.
     * Based on the pinned position it will calculate the individual position of each inner button.
     */
    openFABs: function() {
        var nrOfVisibleItems = 0;
        var contentWrapper = this.$el.find('.dfab');
        var items = contentWrapper.find('.dfab-content > *').get().reverse();
        var direction = this.pinnedTo === 'bottom' ? -1 : 1;

        _.each(items, function(item) {
            var child = $($(item).find('> *'));
            if (child.length && !child.hasClass('hide') && !child.hasClass('disabled')) {
                nrOfVisibleItems++;
                var value = direction * (this.baseHeight + this.interButtonMargin) * nrOfVisibleItems;
                $(item).css('transform', 'translateY(' + value + 'px)');
            }
        }, this);

        contentWrapper.addClass('expanded');
        var mainIcon = this.$el.find('.dfab-title .dfab-icon.sicon');
        mainIcon.removeClass(this.meta.icon).addClass(this.defaultCloseIcon);
    },

    /**
     * Clicking anywhere on the document will close the fab.
     * In order to cover a dragging action this handler will listen to mousedown.
     *
     * @param {Object} event The mousedown event object.
     */
    closeFABsOnWindowClick: function(event) {
        if (this.disposed) {
            return;
        }

        var eTarget = $(event.target);
        var isLabel = eTarget.hasClass('dfab-label') || eTarget.parent('.dfab-label').length;
        var isIcon = eTarget.hasClass('dfab-icon');

        if (isIcon || isLabel) {
            return;
        }

        this.closeFABs();
    },

    /**
     * Create a duplicate of current dashboard and assign it to the user,
     * so that the user can make own modification on top of existing dashboards
     *
     * Some attributes are changed during the duplication:
     *  id, name, assigned_user_id, assigned_user_name, team, default_dashboard, my_favorite
     */
    duplicateClicked: function() {
        var newModel = app.data.createBean('Dashboards');
        newModel.copy(this.model);

        var oldName = app.lang.get(newModel.get('name'), newModel.get('dashboard_module'));
        var newName = app.lang.get('LBL_COPY_OF', 'Dashboards', {name: oldName});
        var newAttributes = {
            name: newName,
            my_favorite: true
        };
        // Using void 0 to follow the convention in backbone.js
        var clearAttributes = {
            id: void 0,
            assigned_user_id: void 0,
            assigned_user_name: void 0,
            team_name: void 0,
            default_dashboard: void 0
        };

        newModel.unset(clearAttributes, {silent: true});
        newModel.save(newAttributes, {
            error: this.handleFailedSave,
            success: _.bind(this.handleSuccessfulSave, this, 'add', newModel)
        });
    },

    /**
     * Find the name of the current dashboard.
     *
     * @return {string} The dashboard name.
     */
    getDashboardName: function() {
        var label = this.model.get('name');
        var module = this.model.get('dashboard_module');
        return app.lang.get(label, module);
    },

    /**
     * This method handles the deletion of a dashboard. It alerts the user
     * before deleting the dashboard, and if the user chooses to delete the
     * dashboard, it handles the deletion logic as well.
     */
    deleteClicked: function() {
        var messages = app.lang.get('LBL_DELETE_DASHBOARD_CONFIRM', 'Dashboards', {name: this.getDashboardName()});

        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: messages,
            onConfirm: _.bind(this.deleteDashboard, this)
        });
    },

    /**
     * Deletes the current active dashboard.
     */
    deleteDashboard: function() {
        var message = app.lang.get('LBL_DELETE_DASHBOARD_SUCCESS', this.module, {
            name: this.getDashboardName()
        });

        this.model.destroy({
            success: _.bind(this.handleSuccessfulSave, this, 'delete', this.model),
            error: this.handleFailedSave,
            showAlerts: {
                'process': true,
                'success': {
                    messages: message
                }
            }
        });
    },

    /**
     * It will navigate to the dashboard create layout.
     */
    addClicked: function() {
        if (this.context.parent) {
            this.layout.navigateLayout('create');
        } else {
            var route = app.router.buildRoute(this.module, null, 'create');
            app.router.navigate(route, {trigger: true});
        }
    },

    /**
     * It will trigger an event for collapsing all dashlets.
     */
    collapseClicked: function() {
        this.context.trigger('dashboard:collapse:fire', true);
    },

    /**
     * It will trigger an event for expanding all dashlets.
     */
    expandClicked: function() {
        this.context.trigger('dashboard:collapse:fire', false);
    },

    /**
     * Event handler for button 'Edit Module Tabs'.
     */
    editModuleTabsClicked: function() {
        app.drawer.open({
            layout: 'config-drawer',
            context: {
                module: 'ConsoleConfiguration',
            }
        });
    },

    /**
     * Handler for saving success, it navigates to the layout or
     * the page based on the context
     *
     * @param {string} change The change that's made to the model
     *  This is either 'delete' or 'add'.
     * @param {Data.Bean} model The model that's changed.
     */
    handleSuccessfulSave: function(change, model) {
        if (this.disposed) {
            return;
        }
        // If we don't have a this.context.parent, that means we are
        // navigating to a Home Dashboard, otherwise it's a RHS Dashboard
        if (!this.context || !this.context.parent) {
            var id = change === 'add' ? model.get('id') : null;
            var route = app.router.buildRoute(this.module, id);
            app.router.navigate(route, {trigger: true});
            return;
        }

        var contextBro = this.context.parent;
        if (!_.contains(['multi-line', 'focus'], contextBro.get('layout'))) {
            contextBro = contextBro.getChildContext({module: 'Home'});
        }

        if (change === 'delete') {
            contextBro.get('collection').remove(model);
            this.layout.navigateLayout('list');
        } else if (change === 'add') {
            contextBro.get('collection').add(model);
            this.layout.navigateLayout(model.get('id'));
        }
    },

    /**
     * Error handler for Dashboard saving
     */
    handleFailedSave: function() {
        app.alert.show('error_while_save', {
            level: 'error',
            title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
            messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
        });
    },

    /**
     * Check if this is a tabbed dashboard and active tab is a dashboard.
     *
     * @return {bool} True if this is not a tabbed dashboard
     * or active tab is a dashboard, false otherwise.
     */
    isDashboard: function() {
        var tabs = this.context.get('tabs');

        if (!tabs) {
            return true;
        }

        var tabIndex = this.context.get('activeTab') || 0;

        if (!tabs[tabIndex]) {
            return true;
        }

        var isStandardDashboard = !!tabs[tabIndex].dashlets;
        var isConsoleDashboard = !!(tabs[tabIndex].components && tabs[tabIndex].components[0].rows);

        return isStandardDashboard || isConsoleDashboard;
    },

    /**
     * Util to get the current active dashboard tab.
     * @return {number}
     * @private
     */
    _getActiveDashboardTab: function() {
        return this.context.get('activeTab');
    },

    /**
     * Show/hide fab buttons provided in the list as input.
     *
     * @param {Array} btnNameList array of button names to be shown/hidden
     * @param {bool} state True to show, false to hide
     */
    toggleFabButton: function(btnNameList, state) {
        _.each(btnNameList, function(btnName) {
            var button = _.find(this.fields, function(field) {
                return field.name === btnName;
            });
            if (button) {
                button.setDisabled(!state);
                button.isHidden = !state;
            }
        }, this);
    },

    /**
     * Trigger the logic responsible for the visibility of certain inner buttons.
     */
    updateButtonVisibilities: function() {
        var isDashboard = this.isDashboard();
        var btnList = ['add_dashlet_button', 'restore_dashboard_button'];
        this.toggleFabButton(btnList, isDashboard);
    },

    /**
     * Handle restore tab button click
     */
    restoreDashboardClicked: function() {
        app.alert.show('restore_tab_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_RESTORE_DEFAULT_DASHBOARD_CONFIRM', 'Dashboards'),
            onConfirm: _.bind(function() {
                this.restoreDashboardDashlets(this._getActiveDashboardTab());
            }, this)
        });
    },

    /**
     * Gets the bean id for the dashboard
     *
     * @param component {Object} dashboard component for which id is required
     * @return {string} dashboard bean id
     * @private
     */
    _getDashboardBeanId: function(component) {
        var model = component ? component.model : null;
        return model ? model.get('id') : '';
    },

    /**
     * Restores dashlets on the active tab for tabbed dashboards
     *
     * @param tabIndex {number} index of the tab for which metadata needs to be reset
     */
    restoreDashboardDashlets: function(tabIndex) {
        var component = this.closestComponent('dashboard');
        if (component) {
            component.context.trigger('dashboard:restore-dashboard:clicked', tabIndex);
        }
    },

    /**
     * Get fixed position ('pinnedTo') of current
     * dashboard menu from cache (Local Storage)
     */
    getCachePinnedTo: function() {
        var cache = app.cache.get('dashboardsMenuPinnedTo');
        if (!cache) {
            return null;
        }

        cache = JSON.parse(cache);
        var dashboardModelName = this.model.get('name');

        return cache[dashboardModelName] || null;
    },

    /**
     * Set position ('pinnedTo') of current
     * dashboard menu in cache (Local Storage)
     *
     * @param {string}
     */
    setCachePinnedTo: function(value) {
        var cache = app.cache.get('dashboardsMenuPinnedTo');
        cache = (cache) ? JSON.parse(cache) : {};

        var dashboardModelName = this.model.get('name');
        cache[dashboardModelName] = value;

        app.cache.set('dashboardsMenuPinnedTo', JSON.stringify(cache));
    },

    /**
     * Detach window event handler.
     *
     * @inheritdoc
     */
    dispose: function() {
        $(window).off('mousedown', this.fabCloseHandler);
        this._super('dispose');
    },

}) },
"search-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Headerpane view for the {@link View.Layouts.Base.SearchLayout
 * Search layout}.
 *
 * @class View.Views.Base.SearchHeaderpaneView
 * @alias SUGAR.App.view.views.BaseSearchHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Search-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.context.on('change:searchTerm change:tagParams', function(model, value) {
            var tagParams = this.context.get('tagParams') || [];
            this.searchTerm = {term: this.context.get('searchTerm'), tags: tagParams.join(', ')};
            this.render();
        }, this);

        // Let this.searchTerm hold searchTerm and tag data for headerpane title
        var tagParams = this.context.get('tagParams') || [];
        this.searchTerm = {term: this.context.get('searchTerm'), tags: tagParams.join(', ')};
    },

    /**
     * Formats the title passing the search term.
     *
     * @override
     */
    _formatTitle: function(title) {
        if (!title) {
            return '';
        }
        return app.lang.get(title, this.module, {
            searchTerm: new Handlebars.SafeString(this.searchTerm)
        });
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this._super('unbind');
        $(window).off('resize.searchheader');
        this.layout.off('headerpane:adjust_fields', this.adjustTitle);
    }
}) },
"modal-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ModalHeaderView
 * @alias SUGAR.App.view.views.BaseModalHeaderView
 * @extends View.View
 */
({
	// Modal-header View (base) 

    events: {
        'click .close' : 'close'
    },
    close: function() {
        this.layout.hide();
    },
    setTitle: function(title) {
        this.title = title;
    },
    setButton: function(buttons) {
        this.buttons = buttons;
    }
}) },
"quicksearch-taglist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchTagListView
 * @alias SUGAR.App.view.views.BaseQuicksearchTagListView
 * @extends View.View
 */
({
	// Quicksearch-taglist View (base) 

    className: 'table-cell',

    events: {
        'click .tag-remove': 'removeTagClicked',
        'click .tag-name': 'highlightTagClicked'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.selectedTags = this.layout.selectedTags || [];

        this.activeIndex = null;

        // Listener for quicksearch tag additions
        this.layout.on('quicksearch:tag:add', this.addTag, this);

        this.layout.on('quicksearch:tags:remove', this.removeAllTags, this);

        //Listener for receiving focus for up/down arrow navigation:
        this.on('navigate:focus:receive', function(next) {
            if (next) {
                this.activeIndex = 0;
            } else {
                this.activeIndex = this.selectedTags.length - 1;
            }
            this._highlightActive();
            this.attachKeydownEvent();
        }, this);

        // Listener for losing focus for up/down arrow navigation:
        this.on('navigate:focus:lost', function() {
            this.activeIndex = null;
            this.$('.tag-wrapper').removeClass('highlight');
            this.disposeKeydownEvent();
        }, this);

        app.events.on('app:sync:complete', function() {
            this.layout.off('route:search', this.populateTagsFromContext);
            this.layout.on('route:search', this.populateTagsFromContext, this);
        }, this);

        this.context.on('tagsearch:fire:new', this.populateTagsFromContext, this);
    },

    /**
     * Populate the taglist with the tags specified in the context. Call a search if param is true
     */
    populateTagsFromContext: function() {
        var tagNames = this.context.get('tagParams');
        // If no tagNames, just move onto the regular search
        if (!tagNames || !tagNames.length) {
            this.selectedTags.splice(0, this.selectedTags.length);
            this.render();
            this.context.set('tags', []);
            this.context.trigger('search:fire:new');
            return;
        }
        var tags = app.data.createBeanCollection('Tags');
        var self = this;
        var tagNamesLowerCase = _.map(tagNames, function(tagName) {
            return tagName.toLowerCase();
        });

        tags.filterDef = {
            'filter': [{
                'name_lower': { '$in': tagNamesLowerCase }
            }]
        };

        tags.fetch({
            // Arbitrary large number, in case user wants to search by more than 20 tags.
            limit: 100,
            success: function(collection) {
                //Remove internal tag list and then re add the ones that should be there
                self.selectedTags.splice(0, self.selectedTags.length);
                _.each(collection.models, function(tag) {
                    self.selectedTags.push({id: tag.get('id'), name: tag.get('name')});
                });
                self.render();

                //Push completed tag objects to context
                self.context.set('tags', self.selectedTags);
                self.layout.trigger('quicksearch:button:toggle', false);

                self.context.trigger('search:fire:new');
            },
            error: function() {
                app.alert.show('collections_error', {
                    level: 'error',
                    messages: 'LBL_TAG_FETCH_ERROR'
                });
            }
        });
    },

    /**
     * Returns true if there are tags to focus. Otherwise, false.
     */
    isFocusable: function() {
        return this.selectedTags && this.selectedTags.length;
    },

    /**
     * Attach the keydown events for the view.
     */
    attachKeydownEvent: function() {
        $(document).on('keydown.' + this.cid, _.bind(this.keydownHandler, this));
    },

    /**
     * Dispose the keydown events for the view.
     */
    disposeKeydownEvent: function() {
        $(document).off('keydown.' + this.cid);
    },

    /**
     * Handle the keydown events.
     * @param {Event} e
     */
    keydownHandler: function(e) {
        switch (e.keyCode) {
            case 37: // left arrow
                this.moveLeft();
                break;
            case 39: // right arrow
                this.moveRight();
                break;
            case 8:  // backspace
            case 46: // del
                this.handleBackspace();
                e.stopPropagation();
                e.preventDefault();
                break;
            default:
                this.layout.trigger('navigate:to:component', 'quicksearch-bar');
                break;
        }
    },

    /**
     * Handler for the backspace/delete keys. Removes tag if one is highlighted, then highlights a new tag
     * or re-focuses the search bar
     */
    handleBackspace: function() {
        this.removeTag(false);

        if (this.selectedTags.length) {
            // If there is a tag to the left of the removed tag, highlight it
            // If tagIndex is 0, highlight whatever is left at index 0.
            if (this.activeIndex > 0) {
                this.activeIndex--;
            }
            this._highlightActive();
        } else {
            // If no tags are left, automatically give focus back to whatever is to the right
            this.moveRight();
        }
    },

    /**
     * Adds a tag to the page
     * @param {Object} tag
     */
    addTag: function(tag) {
        if (tag && tag.name) {
            // If tag already exists do nothing
            if (!_.find(this.selectedTags, function(tagToCheck) {
                return tagToCheck.name === tag.name;
            })) {
                this.selectedTags.push(tag);
                this.render();
                this.layout.trigger('quicksearch:fire:search', true);
            }
        }
    },

    /**
     * Remove a specific tag
     * @param {jQuery || boolean} $tagParam - jQuery representation of tag pill. Optional
     * (if it doesn't exist, default to activeIndex)
     */
    removeTag: function($tagParam) {
        // Only continue if we have either a $tag param or an activeIndex
        if (!$tagParam && _.isNull(this.activeIndex)) {
            return;
        }

        var $tag = $tagParam || this.$('.tag-wrapper:eq(' + this.activeIndex + ')');

        // Remove the selected tag from the internal tag list
        var index = _.indexOf(_.pluck(this.selectedTags, 'name'), $tag.attr('tag-name'));
        this.selectedTags.splice(index, 1);

        // Remove the selected tag from the DOM
        $tag.remove();

        this.layout.trigger('quicksearch:fire:search', true);
    },

    /**
     * Click handler for tag removal element
     * @param {Event} e
     */
    removeTagClicked: function(e) {
        e.preventDefault();
        e.stopPropagation();
        var $tag = this.$(e.target).parent();
        this.removeTag($tag);
        this.$('.tag-wrapper').removeClass('highlight');

        // Go back to the quicksearch bar to prevent any shenanigans (only on click)
        this.layout.trigger('navigate:to:component', 'quicksearch-bar');
    },

    /**
     * Removes all tags from search bar (When searchbar's "X" is clicked)
     */
    removeAllTags: function() {
        // Remove all tags from the tags array (and the layout tag array since other views share that)
        this.selectedTags.splice(0, this.selectedTags.length);
        this.activeIndex = null;
        this.$('.tag-wrapper').remove();
    },


    /**
     * Click handler for tag highlighting
     * @param {Event} e
     */
    highlightTagClicked: function(e) {
        this.requestFocus();

        // Set highlight class
        this.$('.tag-wrapper').removeClass('highlight');
        var $tag = this.$(e.target).parent();
        $tag.addClass('highlight');

        // Set activeIndex
        this.activeIndex = _.indexOf(_.pluck(this.selectedTags, 'name'), $tag.attr('tag-name'));
    },

    /**
     * Highlights a specific tag element.
     */
    _highlightActive: function() {
        this.$('.tag-wrapper').removeClass('highlight');
        this.$('.tag-wrapper:eq(' + this.activeIndex + ')').addClass('highlight');
    },

    /**
     * Request focus from the layout. This is used primarily for mouse clicks.
     */
    requestFocus: function() {
        this.layout.trigger('navigate:to:component', this.name);
    },

    /**
     * Move to the next the active element.
     */
    moveRight: function() {
        // check to make sure we will be in bounds.
        if (this.activeIndex < this.selectedTags.length - 1) {
            // We're in bounds, just go to the next element in this view.
            this.activeIndex++;
            this._highlightActive();
        } else {
            // We're trying to move beyond the elements in this view. We need to try to move to the next view
            this._handleBoundary(true);

        }
    },

    /**
     * Move to the previous the active element.
     */
    moveLeft: function() {
        // check to make sure we will be in bounds.
        if (this.activeIndex > 0) {
            // We're in bounds, just go to the previous element in this view
            this.activeIndex--;
            this._highlightActive();
        } else {
            // We're trying to move beyond the elements in this view. We need to try to move to the previous view
            this._handleBoundary(false);
        }
    },

    /**
     * Handle when the user uses their keyboard to try to navigate outside of the view. This handles both the top and
     * bottom boundaries.
     * @param {boolean} next - If true, we are checking the next element. If false, we are checking the previous.
     * @private
     */
    _handleBoundary: function(next) {
        var event = 'navigate:next:component';
        if (!next) {
            event = 'navigate:previous:component';
        }
        if (this.layout.triggerBefore(event)) {
            this.clearActive();
            this.layout.trigger(event);
        }
    },

    /**
     * Clear the active element and dispose key events
     */
    clearActive: function() {
        this.activeIndex = null;
        this.$('.tag-wrapper').removeClass('highlight');
        this.disposeKeydownEvent();
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.disposeKeydownEvent();
        this._super('unbind');
    }
}) },
"pipeline-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PipelineHeaderpaneView
 * @alias SUGAR.App.view.views.BasePipelineHeaderpaneView
 * @extends View.Views.Base.PipelineHeaderpaneView
 */
({
	// Pipeline-headerpane View (base) 

    events: {
        'click .tab-badgeable > a[name=pipelineBtn]': 'changePipeline',
    },

    /**
     * Initializes various pipelineType fields and the table_header
     * @param options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.context.on('button:pipeline_create_button:click', this.createNewRecord, this);
        this.pipelineTypes = [];
        this.table_header = app.metadata.getModule('VisualPipeline','config').table_header[this.module];
        _.each(this.meta.fields, function(field) {
            this.pipelineTypes.push(field);
        }, this);
        this.pipelineStateKey = app.user.lastState.buildKey('last-tab', 'pipeline', this.module);

        // default to the config-set table header
        var pipelineType = this.table_header;
        if (this.module === 'Opportunities') {
            // unless we're in Opps then try to set the pipelineType by the last state first
            pipelineType = app.user.lastState.get(this.pipelineStateKey) || 'date_closed';
        }

        this.context.get('model').set('pipeline_type', pipelineType);
    },

    /**
     * Gets triggered when switching pipeline tabs
     * Changes the css classes to reflect the selected tab
     * @param event
     */
    changePipeline: function(event) {
        var $currentTarget = this.$(event.currentTarget);
        if ($currentTarget.hasClass('active')) {
            return;
        }

        this.$('.tab.active').removeClass('active');
        $currentTarget.addClass('active');
        var pipelineType = $currentTarget.data('pipeline');

        // set the new last state
        app.user.lastState.set(this.pipelineStateKey, pipelineType);

        this.context.get('model').set('pipeline_type', pipelineType);

        // apply filter
        var filterPanel = this.layout.getComponent('filterpanel');
        if (filterPanel) {
            filterPanel.trigger('filter:apply');
        }
    },

    /**
     * Opens the create drawer for the user to create a new record when the create button on headerpane is clicked
     */
    createNewRecord: function() {
        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                module: this.module,
            }
        }, _.bind(function(context, model) {
            if (model && model.dataFetched) {
                this.context.trigger('pipeline:recordlist:model:created', model);
            }
        }, this));
    }
}) },
"quicksearch-bar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchBarView
 * @alias SUGAR.App.view.views.BaseQuicksearchBarView
 * @extends View.View
*/
({
	// Quicksearch-bar View (base) 


    className: 'table-cell quicksearch-bar-wrapper',
    /**
     * The minimum number of characters before the search bar attempts to
     * retrieve results.
     *
     * @property {number}
     */
    minChars: 1,

    searchModules: [],
    events: {
        'focus input[data-action=search_bar]': 'requestFocus',
        'click input[data-action=search_bar]': 'searchBarClickHandler'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * The collection for executing searches and passing results.
         * This could be shared and used by other components.
         */
        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of layout.collection.
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        this.selectedTags = this.layout.selectedTags || [];

        /**
         * The default number of maximum results to display.
         *
         * You can override this value by providing a `limit` property in the
         * metadata.
         *
         * @type {number}
         * @property
         */
        this.limit = 5;
        if (this.meta && this.meta.limit) {
            this.limit = this.meta.limit;
        }

        /**
         * Used for keyboard up/down arrow navigation between components of `globalsearch` layout
         *
         * @property {boolean}
         */
        this.isFocusable = true;


        /**
         * The current search term.
         * When a search term is typed, the term is immediately stored to this variable. After the 500ms debounce, the
         * term is used to execute a search.
         * @type {string}
         * @private
         */
        this._searchTerm = '';

        /**
         * The previous search term.
         * This is stored to check against `this._searchTerm`. If `this._searchTerm === this._oldSearchTerm`, we do
         * not need to retrieve new results. This protects us against keystrokes that do not change the search term.
         * @type {string}
         * @private
         */
        this._oldSearchTerm = '';

        /**
         * The previous query term.
         * This is the last search term used to get results, and as such, is the term that produced the currently
         * displayed results. If `this._searchTerm === this._currentQueryTerm` when the search is executed (after
         * the 500ms debounce), we do not need to execute a new search.
         * @type {string}
         * @private
         */
        this._currentQueryTerm = '';

        app.events.on('app:sync:complete', this.populateModules, this);

        // Listener for receiving focus for up/down arrow navigation:
        this.on('navigate:focus:receive', function() {
            // if the input doesn't have focus, give it focus.
            var inputBox = this.$input[0];
            if (inputBox !== $(document.activeElement)[0]) {
                inputBox.focus();
            } else {
                this.attachKeyEvents();
            }
        }, this);

        // Listener for losing focus for up/down arrow navigation:
        this.on('navigate:focus:lost', function() {
            this.disposeKeyEvents();
        }, this);

        // Listener for `quicksearch:close`. This aborts in progress
        // searches
        this.layout.on('quicksearch:close', function() {
            this._searchTerm = '';
            this._currentQueryTerm = '';
            this._oldSearchTerm = '';
            this.collection.abortFetchRequest();
            this.$input.blur();
        }, this);

        this.layout.on('quicksearch:bar:clear', this.clearSearch, this);

        this.layout.on('quicksearch:bar:clear:term', this.clearSearchTerm, this);

        this.layout.on('quicksearch:bar:search', this.goToSearchPage, this);

        this.layout.on('route:search', this.populateSearchTerm, this);

        this.layout.on('quicksearch:fire:search', function() {
            // In case we are already in the middle of a search
            this.collection.abortFetchRequest();
            this._oldSearchTerm = null;
            this._currentQueryTerm = null;
            this._validateAndSearch();
        }, this);
    },

    /**
     * Renders a view onto the page.
     *
     * @protected
     */
    _renderHtml: function() {
        this._super('_renderHtml');
        this.$input = this.$('input[data-action=search_bar]');
    },

    /**
     * Checks to see if we're in the search context. If we are, populate the search
     * bar with the search term.
     */
    populateSearchTerm: function() {
        var inputBar = this.$input;
        var searchTerm = this.context.get('searchTerm');
        if (inputBar.val() !== searchTerm) {
            inputBar.val(searchTerm);
        }
    },

    /**
     * Request focus from the layout. This is used primarily for mouse clicks.
     */
    requestFocus: function() {
        this.layout.trigger('navigate:to:component', this.name);
    },

    /**
     * Function to attach the keydown and keyup events.
     */
    attachKeyEvents: function() {
        var searchBarEl = this.$input;
        // for arrow key navigation
        searchBarEl.on('keydown', _.bind(this.keydownHandler, this));

        // for searchbar typeahead
        searchBarEl.on('keyup', _.bind(this.keyupHandler, this));
    },

    /**
     * Function to dispose the keydown and keyup events.
     */
    disposeKeyEvents: function() {
        this.$input.off('keydown keyup');
    },

    /**
     * Handles the keydown event for up, down, and ignores tab.
     *
     * @param {Event} e The `keydown` event
     * @private
     */
    keydownHandler: function(e) {
        switch (e.keyCode) {
            case 40: // down arrow
                this.moveForward();
                e.preventDefault();
                e.stopPropagation();
                break;
            case 38: // up arrow
                e.preventDefault();
                e.stopPropagation();
                break;
            case 37: // left arrow
            case 8:  //backspace
                // If there's text in the input bar, don't add any special handling
                var term = this.$input.val();
                if (term === '') {
                    this.moveBackward();
                    // Prevent double event calling when element to the left attaches its keydown handler
                    e.stopPropagation();
                    e.preventDefault();
                }
                break;
        }
    },

    /**
     * Handles the keyup event for typing, and ignores tab
     *
     * @param {Event} e The `keyup event
     */
    keyupHandler: function(e) {
        switch (e.keyCode) {
            case 40: // down arrow
                break;
            case 38: // up arrow
                break;
            case 9: // tab
                break;
            case 16: // shift
                break;
            case 13: // enter
                this.goToSearchPage();
                break;
            case 27: // esc
                this.layout.trigger('quicksearch:close');
                break;
            default:
                this._validateAndSearch();
        }
    },

    /**
     * Goes to the search page and displays results.
     */
    goToSearchPage: function() {
        // navigate to the search results page
        var term = this.$input.val();
        var route = '';
        this._searchTerm === this._currentQueryTerm;
        this._currentQueryTerm = term;
        if (this.layout.v2) {
            route = app.utils.GlobalSearch.buildSearchRoute(term, {
                modules: this.collection.selectedModules,
                tags: _.pluck(this.selectedTags, 'name')
            });
        } else {
            var moduleString = this.collection.selectedModules.join(',');
            route = 'bwc/index.php?module=Home&append_wildcard=true&action=spot&full=true' +
                '&q=' + term +
                '&m=' + moduleString;
        }
        this.collection.abortFetchRequest();
        app.router.navigate(route, {trigger: true});
    },
    /**
     * Handler for clicks on the search bar.
     *
     * Expands the bar and toggles the search icon.
     */
    searchBarClickHandler: function() {
        this.requestFocus();
        _.defer(_.bind(this.layout.expand, this.layout));
    },

    /**
     * Navigate to the next component
     */
    moveForward: function() {
        if (this.layout.triggerBefore('navigate:next:component')) {
            this.disposeKeyEvents();
            this.layout.trigger('navigate:next:component');
        }
    },

    /**
     * Navigate to the previous component
     */
    moveBackward: function() {
        if (this.layout.triggerBefore('navigate:previous:component')) {
            this.disposeKeyEvents();
            this.layout.trigger('navigate:previous:component');
        }
    },

    /**
     * Waits & debounces for 0.5 seconds before firing a search. This is primarily used on the
     * keydown event for the typeahead functionality.
     *
     * @param {string} term The search term.
     * @private
     * @method
     */
    _debounceSearch: _.debounce(function() {
        // Check if the search term is falsy (empty string)
        // or the search term is the same as the previously searched term
        // If either of those conditions are met, we do not need to execute a new search.
        if ((!this._searchTerm && this.selectedTags.length === 0)
            || this._searchTerm === this._currentQueryTerm) {
            return;
        }
        this._currentQueryTerm = this._searchTerm;
        this.fireSearchRequest();
    }, 500),


    /**
     * Collects the search term, validates that a search is appropriate, and executes a debounced search.
     * First, it checks the search term length, to ensure it meets the minimum length requirements.
     * Second, it checks the search term against the previously typed search term. If the search term hasn't changed
     * (for example, for keyboard shortcuts) then there is no need to rerun the search.
     * If the above conditions are met, `_validateAndSearch` runs a debounced search.
     *
     * @private
     */
    _validateAndSearch: function() {
        var term = this.$input.val();
        this._searchTerm = term;

        // if the term is too short, don't search
        if (term.length < this.minChars && this.selectedTags.length === 0) {
            this._searchTerm = '';
            this._currentQueryTerm = '';
            this._oldSearchTerm = '';
            // We trigger `quicksearch:results:close` instead of
            // `quicksearch:close` because we only want to close the dropdown
            // and keep the bar expanded. That means we only want the listener
            // in `quicksearch-results.js` to be called, not the other ones.
            this.collection.abortFetchRequest();
            this.layout.trigger('quicksearch:results:close');
            this.collection.abortFetchRequest();
            return;
        }

        // shortcuts might trigger multiple `keydown` events, to do some actions like blurring the input, but since the
        // input value didn't change we don't want to trigger a new search.
        var hasInputChanged = (this._searchTerm !== this._oldSearchTerm);
        if (hasInputChanged) {
            this.collection.dataFetched = false;
            this.layout.trigger('quicksearch:search:underway');
            this.layout.expand();
            this._oldSearchTerm = term;
            this._debounceSearch();
        }
    },

    /**
     * Executes a search using `this._searchTerm`.
     * TODO: Move this function into the layout so that we can sandbox out tags from the bar
     */
    fireSearchRequest: function() {
        var term = this._searchTerm;
        // FIXME: SC-4254 Remove this.layout.v2
        var limit = this.layout.v2 ? this.limit : 5;
        limit = app.config && app.config.maxSearchQueryResult || limit;
        var options = {
            query: term,
            module_list: this.collection.selectedModules,
            limit: limit,
            params: {
                tags: true
            },
            apiOptions: {
                useNewApi: true
            }
        };

        if (this.selectedTags.length > 0) {
            _.extend(options.apiOptions, {
                    data: {
                        tag_filters: _.pluck(this.selectedTags, 'id')
                    },
                    fetchWithPost: true
            });
        }

        // FIXME: SC-4254 Remove this.layout.v2
        if (!this.layout.v2) {
            options.fields = ['name', 'id'];
        }
        this.collection.query = term;
        this.collection.fetch(options);
    },

    /**
     * Clears out search upon user following search result link in menu
     */
    clearSearch: function() {
        this.$input.val('');
        this._searchTerm = '';
        this._oldSearchTerm = '';
        this._currentQueryTerm = '';
        this.layout.trigger('quicksearch:tags:remove');
        this.disposeKeyEvents();
    },

    clearSearchTerm: function() {
        this.$input.val('');
        this._searchTerm = '';
        this._oldSearchTerm = '';
        this._currentQueryTerm = '';
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.disposeKeyEvents();
        this._super('unbind');
    }
}) },
"notifications": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Notifications will pull information from the server based on a given delay.
 *
 * Supported properties:
 *
 * - {Number} delay How often (minutes) should the pulling mechanism run.
 * - {Number} limit Limit imposed to the number of records pulled.
 *
 * Example:
 * <pre><code>
 * // ...
 *     array(
 *         'delay' => 5,
 *         'limit' => 4,
 *     ),
 * //...
 * </code></pre>
 *
 * @class View.Views.Base.NotificationsView
 * @alias SUGAR.App.view.views.BaseNotificationsView
 * @extends View.View
 */
({
	// Notifications View (base) 

    plugins: ['Dropdown', 'RelativeTime'],

    /**
     * Notifications bean collection.
     *
     * @property {Data.BeanCollection}
     */
    collection: null,

    /**
     * Collections for additional modules.
     */
    _alertsCollections: {},

    /**
     * @property {number} Interval ID for checking reminders.
     */
    _remindersIntervalId: null,

    /**
     * @property {number} Timestamp of last time when we checked reminders.
     */
    _remindersIntervalStamp: 0,

    /**
     * Interval ID defined when the pulling mechanism is running.
     *
     * @property {Number}
     * @protected
     */
    _intervalId: null,

    /**
     * Default options used when none are supplied through metadata.
     *
     * Supported options:
     * - delay: How often (minutes) should the pulling mechanism run.
     * - limit: Limit imposed to the number of records pulled.
     * - enable_favicon: Enables/disables notifications in favicon, enabled by default.
     *
     * @property {Object}
     * @protected
     */
    _defaultOptions: {
        delay: 5,
        limit: 4,
        enable_favicon: true
    },

    /**
     * The Maximum delay in minutes
     * Max 32bit Integer size is 2147483647 so this delayMax value prevents any
     * user-added custom delay values from overflowing the max size of the variable.
     */
    delayMax: 35791,

    /**
     * The Minimum delay in minutes.
     * Setting to <= 0 results in infinite polling.
     */
    delayMin: 1,

    events: {
        'click [data-action=is-read-handler]': 'isReadHandler'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.module = 'Notifications';

        this._super('initialize', [options]);
        app.events.on('app:sync:complete', this._bootstrap, this);
        app.events.on('app:logout', this.stopPulling, this);
    },

    /**
     * Bootstrap feature requirements.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     * @protected
     */
    _bootstrap: function() {
        this._initOptions();
        this._initCollection();
        this._initReminders();
        this._initFavicon();

        //Start pulling data after 1 second so that other more important calls to
        //the server can be processed first.
        window.setTimeout(_.bind(this.startPulling, this), 1000);

        this.collection.on('change:is_read', this.render, this);
        return this;
    },

    /**
     * Initialize options, default options are used when none are supplied
     * through metadata.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     * @protected
     */
    _initOptions: function() {
        var options = _.extend({}, this._defaultOptions, this.meta || {});

        // doing some simple bounds checking to make sure
        // delay is within the values that we're expecting.
        // Delay must be between 1 and 35791 minutes
        if (options.delay > this.delayMax) {
            options.delay = this.delayMax;
        } else if (options.delay < this.delayMin) {
            options.delay = this.delayMin;
        }

        this.delay = options.delay * 60 * 1000;
        this.limit = options.limit;
        this.enableFavicon = options.enable_favicon;

        return this;
    },

    /**
     * Initialize feature collection.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     * @protected
     */
    _initCollection: function() {
        this.collection = app.data.createBeanCollection(this.module);
        this.collection.options = {
            params: {
                order_by: 'date_entered:desc'
            },
            limit: this.limit,
            myItems: true,
            fields: [
                'date_entered',
                'id',
                'is_read',
                'name',
                'severity'
            ],
            apiOptions: {
                skipMetadataHash: true
            }
        };

        this.collection.filterDef = [{
            is_read: {$equals: false}
        }];

        return this;
    },

    /**
     * Initialize reminders for Calls and Meetings.
     *
     * Setup the reminderMaxTime that is based on maximum reminder time option
     * added to the pulls delay to get a big interval to grab for possible
     * reminders.
     * Setup collections for each module that we support with reminders.
     *
     * FIXME this will be removed when we integrate reminders with
     * Notifications on server side. This is why we have modules hardcoded.
     * We also don't check for meta as optional because it is required.
     * We will keep all this code private because we don't want to support it
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     * @private
     */
    _initReminders: function() {

        var timeOptions = _.keys(app.lang.getAppListStrings('reminder_time_options'));
        var max = _.max(timeOptions, function(key) {
            return parseInt(key, 10);
        });

        this.reminderMaxTime = parseInt(max, 10) + this.delay / 1000;
        this.reminderDelay = 30 * 1000;

        _.each(['Calls', 'Meetings'], function(module) {
            this._alertsCollections[module] = app.data.createBeanCollection(module);
            this._alertsCollections[module].options = {
                limit: this.meta && parseInt(this.meta.remindersLimit, 10) || 100,
                fields: ['date_start', 'id', 'name', 'reminder_time', 'location', 'parent_name']
            };
        }, this);

        return this;
    },

    /**
     * Initializes the favicon using the Favico library.
     *
     * This will listen to the collection reset and update the favicon badge to
     * match the value of the notification element.
     *
     * @private
     */
    _initFavicon: function() {

        if (!this.enableFavicon) {
            return;
        }

        this.favicon = new Favico({animation: 'none', bgColor: '#cd4503'});
        this.collection.on('reset', function() {
            var badge = this.collection.length;
            if (this.collection.next_offset > 0) {
                badge = badge + '+';
            }
            this.favicon.badge(badge);
        }, this);

        this.on('render', function(){
            if (!app.api.isAuthenticated() || app.config.appStatus === 'offline') {
                this.favicon.reset();
            }
        });
    },

    /**
     * Start pulling mechanism, executes an immediate pull request and defines
     * an interval which is responsible for executing pull requests on time
     * based interval.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     */
    startPulling: function() {
        if (!_.isNull(this._intervalId)) {
            return this;
        }
        this._remindersIntervalStamp = new Date().getTime();

        this.pull();
        this._intervalId = window.setTimeout(_.bind(this._pullAction, this), this.delay);
        this._remindersIntervalId = window.setTimeout(_.bind(this.checkReminders, this), this.reminderDelay);
        return this;
    },

    /**
     * Pulling functionality.
     *
     * @protected
     */
    _pullAction: function() {
        if (!app.api.isAuthenticated()) {
            this.stopPulling();
            return;
        }

        this._intervalId = window.setTimeout(_.bind(this._pullAction, this), this.delay);

        this.pull();
    },

    /**
     * Stop pulling mechanism.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     */
    stopPulling: function() {
        if (!_.isNull(this._intervalId)) {
            window.clearTimeout(this._intervalId);
            this._intervalId = null;
        }
        if (!_.isNull(this._remindersIntervalId)) {
            window.clearTimeout(this._remindersIntervalId);
            this._remindersIntervalId = null;
        }
        return this;
    },

    /**
     * Pull notifications and reminders via bulk API. Render notifications
     * if view isn't disposed or dropdown isn't open.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     */
    pull: function() {
        if (this.disposed || this.isOpen()) {
            return this;
        }

        var self = this;
        var bulkApiId = _.uniqueId();

        this.collection.fetch({
            success: function() {
                if (self.disposed || self.isOpen()) {
                    return this;
                }

                self.render();
            },
            apiOptions: {
                bulk: bulkApiId
            }
        });

        this._pullReminders(bulkApiId);

        app.api.triggerBulkCall(bulkApiId);

        return this;
    },

    /**
     * Pull next reminders from now to the next remindersMaxTime.
     *
     * This will give us all the reminders that should be triggered during the
     * next maximum reminders time (with pull delay).
     *
     * @param {string} bulkApiId Bulk ID that the reminders should be a part of
     */
    _pullReminders: function(bulkApiId) {

        if (this.disposed || !_.isFinite(this.reminderMaxTime)) {
            return this;
        }

        var date = new Date();
        var startDate = date.toISOString();
        var endDate;

        date.setTime(date.getTime() + this.reminderMaxTime * 1000);
        endDate = date.toISOString();

        _.each(['Calls', 'Meetings'], function(module) {

            this._alertsCollections[module].filterDef = _.extend({},
                this.meta.remindersFilterDef || {},
                {
                    'date_start': {'$dateBetween': [startDate, endDate]},
                    'users.id': {'$equals': app.user.get('id')}
                }
            );
            this._alertsCollections[module].fetch({
                silent: true,
                merge: true,
                //Notifications should never trigger a metadata refresh
                apiOptions: {
                    skipMetadataHash: true,
                    bulk: bulkApiId
                }
            });
        }, this);

        return this;
    },

    /**
     * Check if there is a reminder we should show in the near future.
     *
     * If the reminder exists we immediately show it.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     */
    checkReminders: function() {
        if (!app.api.isAuthenticated()) {
            this.stopPulling();
            return this;
        }
        var date = (new Date()).getTime();
        var diff = this.reminderDelay - (date - this._remindersIntervalStamp) % this.reminderDelay;
        this._remindersIntervalId = window.setTimeout(_.bind(this.checkReminders, this), diff);
        _.each(this._alertsCollections, function(collection) {
            _.chain(collection.models)
                .filter(function(model) {
                    var needDate = (new Date(model.get('date_start'))).getTime() -
                        parseInt(model.get('reminder_time'), 10) * 1000;
                    return needDate > this._remindersIntervalStamp && needDate - this._remindersIntervalStamp <= diff;
                }, this)
                .each(this._showReminderAlert, this);
        }, this);
        this._remindersIntervalStamp = date + diff;
        return this;
    },

    /**
     * Show reminder alert based on given model.
     *
     * @param {Backbone.Model} model Model that is triggering a reminder.
     *
     * @private
     */
    _showReminderAlert: function(model) {
        var url = app.router.buildRoute(model.module, model.id);
        var dateFormat = app.user.getPreference('datepref') + ' ' + app.user.getPreference('timepref');
        var dateValue = app.date.format(new Date(model.get('date_start')), dateFormat);
        var template = app.template.getView('notifications.notifications-alert');
        var message = template({
                title: new Handlebars.SafeString(app.lang.get('LBL_REMINDER_TITLE', model.module)),
                module: model.module,
                name: new Handlebars.SafeString(model.get('name')),
                location: new Handlebars.SafeString(model.get('location')),
                description: model.get('description'),
                dateStart: dateValue,
                parentName: new Handlebars.SafeString(model.get('parent_name'))
            });
        _.defer(function() {
            if (confirm(message)) {
                app.router.navigate(url, {trigger: true});
            }
        });
    },

    /**
     * Check if dropdown is open.
     *
     * @return {Boolean} `True` if dropdown is open, `false` otherwise.
     */
    isOpen: function() {
        return this.$('[data-name=notifications-list-button]').hasClass('open');
    },

    /**
     * Event handler for notifications.
     *
     * Whenever the user clicks a notification, its `is_read` property is
     * defined as read.
     *
     * We're doing this instead of a plain save in order to
     * prevent the case where an error could occur before the notification get
     * rendered, thus making it as read when the user didn't actually see it.
     *
     * @param {Event} event Click event.
     */
    isReadHandler: function(event) {
        var element = $(event.currentTarget),
            id = element.data('id'),
            notification = this.collection.get(id),
            isRead = notification.get('is_read');

        if (!isRead) {
            notification.set({is_read: true});
        }
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        if (!app.api.isAuthenticated() ||
            app.config.appStatus === 'offline' ||
            !app.acl.hasAccess('view', this.module)) {
            return;
        }

        this._super('_renderHtml');
    },

    /**
     * @inheritdoc
     *
     * Stops pulling for new notifications and disposes all reminders.
     */
    _dispose: function() {
        this.stopPulling();
        this._alertsCollections = {};

        this._super('_dispose');
    }
}) },
"merge-widget-action": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MergeWidgetActionView
 * @alias SUGAR.App.view.views.BaseMergeWidgetActionView
 * @extends View.View
 */
({
	// Merge-widget-action View (base) 

    /**
    * @property {string}
    */
    tagName: 'span',

    /**
     * The layout for the widget
     *
     * @property {Layout}
     */
    _documentMergeWidgetLayout: null,

    events: {
        'click [data-action=merges]': 'toggleDocumentMergeWidget'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', arguments);
        this._isVisible = false;

        app.events.on('document_merge:show_widget', this.showWidget, this);
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this.isAvailable = this._isAvailable();

        this._super('_renderHtml');
    },

    /**
     * Util to determine if Document Merging is available for this instance
     *
     * @return {boolean} True if Document Merging should be available
     * @private
     */
    _isAvailable: function() {
        return app.api.isAuthenticated() && app.user.isSetupCompleted();
    },

    /**
     * Displays the widget
     */
    showWidget: function() {
        if (this.isVisible() === false) {
            this.toggleDocumentMergeWidget();
        }

        this._documentMergeWidgetLayout.reload();
    },

    /**
     * Initializes the widget layout
     */
    _initializeWidgetLayout: function() {
        if (!this._documentMergeWidgetLayout || this._documentMergeWidgetLayout.disposed === true) {
            this._createDocumentMergeWidgetLayout();
        }
    },

    /**
     * Toggles the display of the widget
     *
     * @param {Event} e
     */
    toggleDocumentMergeWidget: function(e) {
        if (!_.isUndefined(e) && e.originalEvent instanceof Event) {
            e.stopPropagation();
            e.preventDefault();
        }

        if (!app.isSynced) {
            return;
        }

        if (this.$el.hasClass('disabled')) {
            return;
        }

        this._initializeWidgetLayout();

        this._documentMergeWidgetLayout.toggle();
    },

    /**
     * Creates the document merge widget layout.
     *
     * @private
     */
    _createDocumentMergeWidgetLayout: function() {
        this._documentMergeWidgetLayout = app.view.createLayout({
            module: 'DocumentMerges',
            type: 'merge-widget',
            button: this.$el
        });
        this._documentMergeWidgetLayout.initComponents();
        this._documentMergeWidgetLayout._initPopover(this.$el);

        this.listenTo(this._documentMergeWidgetLayout, 'show hide', function(view, active) {
            this.$el.toggleClass('active', active);
        });
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this._documentMergeWidgetLayout) {
            this._documentMergeWidgetLayout.dispose();
        }

        this._super('_dispose');
    }
}) },
"stage2-history": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Stage2-history View (base) 

    plugins: ['EllipsisInline', 'Stage2CssLoader'],

    _modules: {
        Meetings: {
            icon: 'calendar',
        },
        Calls: {
            icon: 'phone',
        },
        Emails: {
            icon: 'envelope',
        },
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var self = this;
        options.collection = this._createCollection();
        // skipping fetch for now, since this needs to be rewritten in 7.8+
        options.context.set('forceNew', true);
        options.context.set('skipFetch', true);

        this._super('initialize', [options]);

        if (!app.hint.isEnrichedModel(options.module)) {
            return;
        }

        this.context.parent.on('change:model', function(ctx, model) {
            this._getHistory(model);
        }, this);

        this._getHistory(this.context.parent.get('model'));
    },

    /**
     * Create collection
     */
    _createCollection: function() {
        var self = this;
        var HistoryCollection = app.data.mixedBeanCollection.extend({

            _buildURL: _.bind(function(params) {
                params = params || {};

                var url = app.api.serverUrl + '/' +
                    self._parentModule + '/' +
                    self._parentId + '/' +
                    'link/history';

                params = $.param(params);
                if (params.length > 0) {
                    url += '?' + params;
                }
                return url;
            }, this),

            sync: function(method, model, options) {
                options = app.data.parseOptionsForSync(method, model, options);
                var url = this._buildURL(options.params);
                var callbacks = app.data.getSyncCallbacks(method, model, options);

                app.api.call(method, url, options.attributes, callbacks);
            }
        });

        HistoryCollection.module_list = _.keys(this._modules);
        return new HistoryCollection();
    },

    /**
     * Get history
     *
     * @param {Object} model
     */
    _getHistory: function(model) {
        var self = this;
        this._parentModule = model.module;
        this._parentId = model.id;
        this.isHintRequestLoading = true;
        this.render();
        if (!this.collection) {
            return;
        }
        this.collection.fetch({
            module_list: _.keys(self._modules),
            //SF-724, explicitly specifying name field causes 500 on oracle..
            fields: [],
            success: _.bind(function() {
                if (!this.disposed) {
                    async.forEach(this.collection.models, function(model, callback) {
                        model.fetch({
                            success: function() {
                                var date = _.isUndefined(model.get('date_start')) ? app.date(model.get('date_sent')) :
                                    app.date(model.get('date_start'));

                                // set dynamic attributes for easy hbs file... this should be done with fields...
                                model.set({
                                    '_icon': self._modules[model.module] ? self._modules[model.module].icon :
                                        'chevron-right',
                                    '_date_record': date,
                                    '_link': '#' + model.module + '/' + model.get('id'),
                                    'status': app.lang.getAppListStrings(app.metadata.getModule(model.module,
                                        'fields').status.options)[model.get('status')],
                                });

                                callback.call();
                            }
                        });
                    }, function() {
                        self.isHintRequestLoading = false;
                        // Sort the models in collection by date.
                        self.collection.comparator = function(model) {
                            return -(new Date(model.get('_date_record')).getTime());
                        };
                        self.collection.sort();
                        self.render();
                    });
                }
            }, this)
        });
    },
}) },
"activity-card-detail": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivityCardDetailView
 * @alias SUGAR.App.view.views.BaseActivityCardDetailView
 * @extends View.Views.Base.ActivityCardView
 */
({
	// Activity-card-detail View (base) 

    extendsFrom: 'ActivityCardView',

    className: 'activity-card-detail',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.initDateDetails();
    },

    /**
     * Initializes hbs date variables with date_entered
     */
    initDateDetails: function() {
        let fieldName;
        if (this.activity) {
            if (this.meta.panels[0].dateTimeStamp) {
                fieldName = this.meta.panels[0].dateTimeStamp.name;
                this.detailDateTimeTooltip = this.meta.panels[0].dateTimeStamp.tooltip;
                if (!this.detailDateTimeTooltip) {
                    let field = app.metadata.getField({module: this.activity.module, name: fieldName});
                    this.detailDateTimeTooltip = field.label || field.vname;
                }
            } else {
                fieldName = 'date_entered';
                this.detailDateTimeTooltip = 'LBL_LIST_DATE_ENTERED';
            }
            this.setDateDetails(this.activity.get(fieldName));
        }
    },

    /**
     * Set date variables for use in the hbs template
     *
     * @param dateString the date string
     */
    setDateDetails: function(dateString) {
        if (dateString) {
            var date = app.date(dateString);

            this.detailDay = date.format('dddd');
            this.detailDateTime = date.formatUser();
        }
    }
}) },
"product-catalog-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ProductCatalogDashletView
 * @alias SUGAR.App.view.views.BaseProductCatalogDashletView
 * @extends View.Views.Base.ProductCatalogView
 */
({
	// Product-catalog-dashlet View (base) 

    extendsFrom: 'ProductCatalogView',

    plugins: [
        'CanvasDataRenderer',
        'Dashlet'
    ],

    /**
     * Boolean if this is the dashlet config view or not
     */
    isConfig: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.isConfig = !!this.meta.config;
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        if (this.isConfig) {
            return;
        }
        this._super('loadData', [options]);
    },

    /**
     * @inheritdoc
     */
    toggleLoading: function(startLoading, showPhaserLoading) {
        if (this.layout.disposed === true) {
            return;
        }
        var $el = this.layout.$('i[data-action=loading]');
        if (startLoading) {
            $el.removeClass('sicon-settings');
            $el.addClass('sicon-refresh sicon-is-spinning');
        } else {
            $el.removeClass('sicon-refresh sicon-is-spinning');
            $el.addClass('sicon-settings');
        }
    }
}) },
"side-drawer-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SideDrawerHeaderView
 * @alias SUGAR.App.view.views.BaseSideDrawerHeaderView
 * @extends View.Views.Base.HeaderpaneView
 * @deprecated SideDrawerHeader View is deprecated as of 11.2.0. Use SideDrawerHeaderpane instead.
 */
({
	// Side-drawer-header View (base) 

    /**
     * This is a special header for side drawers that contain a dashlet.
     * Such drawers need a header with just the minimum setup.
     * This file is a partial copy of {@link View.Views.Dashboards.DashboardHeaderpaneView}.
     */
    extendsFrom: 'HeaderpaneView',

    editableFields: null,

    display: false,

    className: 'preview-headerbar',

    events: {
        'click [name=edit_button]': 'editClicked',
        'click [name=cancel_button]': 'cancelClicked'
    },

    initialize: function(options) {
        app.logger.warn('SideDrawerHeader View is deprecated as of 11.2.0. Use SideDrawerHeaderpane instead.');
        if (options.context.parent) {
            options.meta = app.metadata.getView(options.context.parent.get('module'), options.type, options.loadModule);
            options.template = app.template.getView(options.type);
        }
        this._super('initialize', [options]);
        this.context.set('dataView', '');
        this.model.on('change change:layout change:metadata', function() {
            if (this.inlineEditMode) {
                this.changed = true;
            }
        }, this);
        this.model.on('error:validation', this.handleValidationError, this);
        this.action = 'detail';
        this.bindEvents();
    },

    /**
     * Binds the events that are necessary for this view.
     */
    bindEvents: function() {
        this.context.on('record:set:state', this.setRecordState, this);
        app.events.on('drawer:edit', this.showEditHeader, this);
    },

    /**
     * Handles the logic done when the state changes in the record.
     *
     * @param {string} state The state that the record is set to.
     */
    setRecordState: function(state) {
        this.model.trigger('setMode', state);
        this.setButtonStates(state);
        this.inlineEditMode = state === 'edit';
        this.toggleFields(this.editableFields, this.inlineEditMode);
        if (state === 'view') {
            this.hideHeader();
            app.events.trigger('drawer:enable:actions');
        }
    },

    /**
     * Sets edit mode on the dashboard.
     */
    editClicked: function() {
        this.previousModelState = app.utils.deepCopy(this.model.attributes);
        this.inlineEditMode = true;
        this.setButtonStates('edit');
        this.toggleFields(this.editableFields, true);
        this.model.trigger('setMode', 'edit');
    },

    /**
     * Sets view mode on the dashboard and resets to the state before edit.
     */
    cancelClicked: function() {
        this.changed = false;
        this.model.unset('updated');
        this.clearValidationErrors();
        this.setButtonStates('view');
        this.handleCancel();
        this.model.trigger('setMode', 'view');
        app.events.trigger('drawer:enable:actions');
    },

    /**
     * Compare with last fetched data and return true if model contains changes.
     *
     * @return {boolean} True if current model contains unsaved changes.
     */
    hasUnsavedChanges: function() {
        if (this.model.get('updated')) {
            return true;
        }

        if (this.model.isNew()) {
            return this.model.hasChanged();
        }

        var changes = this.model.changedAttributes(this.model.getSynced());

        return !_.isEmpty(changes);
    },

    /**
     * @override
     *
     * The save function is handled by {@link View.Layouts.Dashboards.DashboardLayout#handleSave}.
     */
    saveClicked: $.noop,

    /**
     * Render the view manually.
     *
     * This function handles the responsibility typically handled in _render,
     * but unlike `_render`, it is not called automatically.
     *
     * See #_render for more information.
     */
    _renderHeader: function() {
        app.view.View.prototype._render.call(this);
        this._setButtons();
        this.setButtonStates('view');
        this.setEditableFields();
    },

    /**
     * Handle the cancellation of edit mode.
     */
    handleCancel: function() {
        this.inlineEditMode = false;
        if (!_.isEmpty(this.previousModelState)) {
            this.model.set(this.previousModelState);
        }
        this.toggleFields(this.editableFields, false);
        this.hideHeader();
    },

    /**
     * Will display the header in edit mode with the cancel and save buttons present.
     */
    showEditHeader: function() {
        this.display = true;
        this._renderHeader();
        this.editClicked();
    },

    /**
     * Will remove the header from the parent view.
     */
    hideHeader: function() {
        this.display = false;
        this._renderHeader();
    }
}) },
"activity-card": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivityCardView
 * @alias SUGAR.App.view.views.BaseActivityCardView
 * @extends View.View
 */
({
	// Activity-card View (base) 

    /**
     * The activity model
     */
    activity: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.setActivityModel();
        this.setFieldsToRenderForPanels();
    },

    /**
     * Gets the name of the timeline view
     */
    getViewNameForMeta: function() {
        return this.getActivityCardLayout().getTimelineType();
    },

    /**
     * Get the activity-card layout
     *
     * @return {Object}
     */
    getActivityCardLayout: function() {
        return this.closestComponent('activity-card');
    },

    /**
     * Set the activity model from the activity-card layout
     */
    setActivityModel: function() {
        var layout = this.getActivityCardLayout();

        if (layout && layout.model) {
            this.activity = layout.model;
        }
    },

    /**
     * Get the field definition from fieldsMeta
     *
     * @param name
     * @return {Object}
     */
    getFieldDefFromFieldMeta: function(name) {
        var def = {};
        var fieldsetFieldDef = {};

        var fieldMeta = this.activity && this.activity.get('fieldsMeta') ?
            this.activity.get('fieldsMeta') : {};

        if (!fieldMeta) {
            return def;
        }

        _.some(fieldMeta.panels, function(panel) {
            def = _.find(panel.fields, function(field) {
                var found = field.name === name;

                // if not found and the field is a fieldset, also check the fieldset's fields
                if (!found && field.type === 'fieldset') {
                    fieldsetFieldDef = _.find(field.fields, function(fieldsetField) {
                        return fieldsetField.name === name;
                    });

                    found = !!fieldsetFieldDef;
                }

                return found;
            });

            // if def is not empty and def name does not match, that means a
            // fieldset field was found
            if (!_.isEmpty(def) && def.name !== name && !_.isEmpty(fieldsetFieldDef)) {
                def = fieldsetFieldDef;
            }

            return !!def;
        }, this);

        return def || {};
    },

    /**
     * Set and pick fields from fieldsMeta
     *
     * panel.fields will be replaced with the picked fields while the default fields
     * will be stored in panel.defaultFields
     */
    setFieldsToRenderForPanels: function() {
        if (!this.meta || !this.meta.panels) {
            return;
        }

        _.each(this.meta.panels, function(panel) {
            // store a copy of default fields metadata
            panel.defaultFields = panel.fields;

            var pickedFields = [];

            _.each(panel.defaultFields, function(field) {
                var meta = this.getFieldDefFromFieldMeta(field.name);

                if (!_.isEmpty(meta)) {
                    meta = _.extend(meta, field);
                    pickedFields.push(meta);
                }
            }, this);

            // replace panel fields with picked fields
            panel.fields = pickedFields;
        }, this);
    },

    /**
     * Get the specified panel from metadata
     *
     * @param panelName the panel to find
     * @return {Object}
     */
    getMetaPanel: function(panelName) {
        if (!this.meta || !this.meta.panels) {
            return {};
        }

        return _.find(this.meta.panels, function(panel) {
            return panel.name === panelName;
        });
    },
}) },
"help-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for managing the help component's header bar.
 *
 * @class View.Views.Base.HelpHeaderView
 * @alias SUGAR.App.view.views.BaseHelpHeaderView
 * @extends View.View
 */
({
	// Help-header View (base) 

    /**
     * @deprecated Since 7.9. Will be removed in 7.11.
     * Please use {@link View.Layouts.Base.HelpLayout.close} instead.
     */
    triggerClose: function() {
        app.logger.warn('The function `View.Layouts.Base.Help-HeaderView.triggerClose`' +
            ' is deprecated in 7.9.0.0 and will be removed in 7.11.0.0.' +
            'Please use `View.Layouts.Base.HelpLayout.close` instead.');
        app.events.trigger('app:help:toggle', false, this);
    }
}) },
"pipeline-recordlist-content": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PipelineRecordlistContentView
 * @alias SUGAR.App.view.views.BasePipelineRecordlistContentView
 * @extends View.Views.Base.PipelineRecordlistContentView
 */
({
	// Pipeline-recordlist-content View (base) 

    className: 'my-pipeline-content',
    monthsToDisplay: 6,

    events: {
        'click a[name=arrow-left]': 'navigateLeft',
        'click a[name=arrow-right]': 'navigateRight'
    },

    resultsPerPageColumn: 7,

    tileVisualIndicator: {
        'outOfDate': '#bb0e1b', // We can use any CSS accepted value for color, e.g: #CC1E13
        'nearFuture': '#ff9445',
        'inFuture': '#056f37',
        'default': '#145c95'
    },

    //used to force api to return these fields also for a proper coloring.
    tileVisualIndicatorFields: {
        'Opportunities': 'date_closed',
        'Tasks': 'date_due',
        'Leads': 'status',
        'Cases': 'status'
    },

    hasAccessToView: true,

    dataFetched: false,

    totalRecords: 0,

    /**
     * Cached fieldnames to retrieve for tile view
     * This does not include fields from record view
     */
    _fieldsToFetch: [],

    /**
     * Initialize various pipelineConfig variables and set action listeners
     *
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.startDate = app.date().format('YYYY-MM-DD');
        this.pipelineConfig = app.metadata.getModule('VisualPipeline', 'config');
        this.meta = _.extend(
            this.meta || {},
            app.metadata.getView(null, 'pipeline-recordlist-content'),
            app.metadata.getView(this.module, 'pipeline-recordlist-content')
        );
        this.pipelineFilters = [];
        this.hiddenHeaderValues = [];
        this.action = 'list';
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        this.context.on('pipeline:recordlist:model:created', this.handleTileViewCreate, this);
        this.context.on('pipeline:recordlist:filter:changed', this.buildFilters, this);
        this.context.on('button:delete_button:click', this.deleteRecord, this);
        this.context.on('pipeline:recordlist:resizeContent', this.resizeContainer, this);
        this.resizeContainerHandler = _.bind(this.resizeContainer, this);
        window.addEventListener('resize', this.resizeContainerHandler);
    },

    /**
     * Triggers a re-fetch for the model added by the create drawer.
     * @param {Data.Bean} model The model created through the drawer.
     */
    handleTileViewCreate: function(model) {
        this._callWithTileModel(model, 'addModelToCollection');
    },

    /**
     * Builds metadata for each tile in the recordlist view
     */
    buildTileMeta: function() {
        var tileDef = this.meta.tileDef || [];
        var tileBodyArr = [];
        var fieldMetadata = app.metadata.getModule(this.module, 'fields');

        _.each(tileDef.panels, function(panel) {
            if (panel.is_header) {
                panel.fields = [fieldMetadata[this.pipelineConfig.tile_header[this.module]]];
            } else {
                var tileBodyField = this.pipelineConfig.tile_body_fields[this.module];
                _.each(tileBodyField, function(tileBody) {
                    var tileFieldMeta = app.utils.deepCopy(fieldMetadata[tileBody]);
                    if (_.isObject(tileFieldMeta.displayParams)) {
                        _.extend(tileFieldMeta, tileFieldMeta.displayParams);
                        delete tileFieldMeta.displayParams;
                    }
                    tileBodyArr.push(tileFieldMeta);
                }, this);
                panel.fields = tileBodyArr;
            }
        }, this);

        this.meta.tileDef = tileDef;
    },

    /**
     * Sets number of results to be displayed for a column in the page
     * @param {integer} resultsNum
     */
    setResultsPerPageColumn: function(resultsNum) {
        var recordsPerColumn = this.pipelineConfig.records_per_column[this.module];
        resultsNum = resultsNum || recordsPerColumn;
        var results = parseInt(resultsNum);
        if (!isNaN(results)) {
            this.resultsPerPageColumn = results;
        }
    },

    /**
     * Sets values to be hidden in the tile
     * @param {Array} hiddenValues an array of values to be hidden
     */
    setHiddenHeaderValues: function(hiddenValues) {
        hiddenValues =
            hiddenValues || this.pipelineConfig.hidden_values[this.module] || [];
        if (_.isEmpty(hiddenValues)) {
            return;
        }

        this.hiddenHeaderValues = hiddenValues;
    },

    /**
     * Builds filter definition for the tiles to be recordlist to be displayed and reloads the data
     * @param {Array} filterDef
     */
    buildFilters: function(filterDef) {
        this.pipelineType = this.context.get('model').get('pipeline_type');
        this.pipelineFilters = filterDef || [];
        this.offset = 0;
        this.loadData();
    },

    /**
     * Checks if the user has access to view and loads data to be displayed on the recordlist
     */
    loadData: function() {
        this.recordsToDisplay = [];
        this.buildTileMeta();
        this.setResultsPerPageColumn();
        this.setHiddenHeaderValues();

        this.getTableHeader();
        if (this.hasAccessToView) {
            this.buildRecordsList();
        }
    },

    /**
     * Sets records to display.
     *
     * @param {string} headerField The header field
     * @param {Array} options List of options
     */
    _setRecordsToDisplay: function(headerField, options) {
        // Get all the whitelisted column names for current module
        if (!_.isUndefined(this.pipelineConfig.available_columns) &&
            !_.isUndefined(this.pipelineConfig.available_columns[this.module])) {
            var items = this.pipelineConfig.available_columns[this.module][headerField];
            var index = 0;
            _.each(items, function(item, key) {
                index = index <= 11 ? index : index % 12;
                if (!_.isEmpty(options[key]) && (_.indexOf(this.hiddenHeaderValues, item) === -1)) {
                    this.recordsToDisplay.push({
                        'headerName': options[key],
                        'headerKey': key,
                        'records': [],
                        'colorIndex': index,
                    });
                    index++;
                }
            }, this);
        } else {
            var items = _.difference(options, this.hiddenHeaderValues);
            _.each(options, function(option, key) {
                var index = _.indexOf(items, option);
                index = index <= 11 ? index : index % 12;
                if (!_.isEmpty(key) && (_.indexOf(this.hiddenHeaderValues, key) === -1)) {
                    this.recordsToDisplay.push({
                        'headerName': option,
                        'headerKey': key,
                        'records': [],
                        'colorIndex': index,
                    });
                }
            }, this);
        }
    },

    /**
     * Gets the table headers for all the columns being displayed on the page
     */
    getTableHeader: function() {
        if (this.pipelineType !== 'date_closed') {
            var headerField = this.pipelineConfig.table_header[this.module] || '';

            if (!app.acl.hasAccessToModel('read', this.model, headerField)) {
                this.context.trigger('open:config:fired');
                return;
            }

            if (headerField) {
                var moduleFields = app.metadata.getModule(this.module, 'fields');
                var optionsList = moduleFields[headerField].options;

                if (optionsList) {
                    var options = app.lang.getAppListStrings(optionsList) || [];
                }

                if (!_.isEmpty(options)) {
                    this._setRecordsToDisplay(headerField, options);
                } else {
                    // call enum api
                    app.api.enumOptions(this.module, headerField, {
                        success: _.bind(function(data) {
                            if (!this.disposed) {
                                this._setRecordsToDisplay(headerField, data);
                                this._super('_render');
                                if (this.hasAccessToView) {
                                    this.buildRecordsList();
                                }
                            }
                        }, this)
                    });
                }
            }

            this.headerField = headerField;
        } else {
            var self = this;
            var currDate = app.date(this.startDate);

            this.recordsToDisplay.push({
                'headerName': currDate.format('MMMM YYYY'),
                'headerKey': currDate.format('MMMM YYYY'),
                'records': [],
                'colorIndex': 0,
            });

            for (var i = 1; i < this.monthsToDisplay; i++) {
                currDate.add(1, 'months');
                self.recordsToDisplay.push({
                    'headerName': currDate.format('MMMM YYYY'),
                    'headerKey': currDate.format('MMMM YYYY'),
                    'records': [],
                    'colorIndex': i,
                });
            }
            this.headerField = 'date_closed';
        }

        this.hasAccessToView = app.acl.hasAccessToModel('read', this.model, this.headerField) ? true : false;
        this._super('render');
    },

    /**
     * Gets the colors for each of the column headers
     * @return {string[]|null|Array} an array of hexcode for the colors
     * @deprecated Since 10.3.0
     */
    getColumnColors: function() {
        app.logger.warn(
            'getColumnColors() is deprecated in 10.3.0. ' +
            'Please use the utility CSS class: .pipeline-bg-color-n where n is 0-11.'
        );
        var columnColor = this.pipelineConfig.header_colors;
        if (_.isEmpty(columnColor) || columnColor == 'null') {
            columnColor = {};
        }

        return columnColor;
    },

    /**
     * Sets offset to 0 before render
     */
    preRender: function() {
        this.offset = 0;
    },

    /**
     * Call the render method from the super class to render the view between the calls to preRender and postRender
     * @inheritdoc
     */
    render: function() {
        this.preRender();
        this._super('render');
        this.postRender();
    },

    /**
     * Calls methods to add draggable action to the tile and bind scroll to the view
     */
    postRender: function() {
        this.resizeContainer();
        this.buildDraggable();
        this.bindScroll();
    },

    /**
     * Adds a newly created model to the view.
     * @param {Object} model Model that should be added to a column.
     */
    addModelToCollection: function(model) {
        var collection = this.getColumnCollection(model);

        if (collection && collection.records) {
            var literal = this.addTileVisualIndicator([model.toJSON()]);
            model.set('tileVisualIndicator', literal[0].tileVisualIndicator);

            collection.records.add(model, {at: 0});
            this.dataFetched = true;
            this.totalRecords = this.totalRecords + 1;
        }

        this._super('render');
        this.postRender();
    },

    /**
     * Returns the collection of the column to which a new opportunity is being added
     * @param {Object} model for the newly created opportunity
     * @return {*} a collection object
     */
    getColumnCollection: function(model) {
        if (this.pipelineType === 'date_closed') {
            return _.findWhere(this.recordsToDisplay, {
                headerName: app.date(model.get(this.headerField)).format('MMMM YYYY')
            });
        }

        return _.findWhere(this.recordsToDisplay, {headerKey: model.get(this.headerField)});
    },

    /**
     * Shows the loading cell and calls method to fetch all the records to be displayed on the page
     */
    buildRecordsList: function() {
        app.alert.show('pipeline-records-loading', {
            level: 'process'
        });
        this.getRecords();
    },

    /**
     * Returns an array of all the filters to be applied on the records
     * @param {Object} column contains details like headerName, headerKey etc. about a column of records
     * @return {Array}
     */
    getFilters: function(column) {
        var filter = [];
        var filterObj = {};

        if (this.pipelineType !== 'date_closed') {
            filterObj[this.headerField] = {'$equals': column.headerKey};
            filter.push(filterObj);
            _.each(this.pipelineFilters, function(filterDef) {
                filter.push(filterDef);
            }, this);
        } else {
            var startMonth = app.date(column.headerName, 'MMMM YYYY').startOf('month').format('YYYY-MM-DD');
            var endMonth = app.date(column.headerName, 'MMMM YYYY').endOf('month').format('YYYY-MM-DD');
            filterObj[this.headerField] = {'$dateBetween': [startMonth, endMonth]};
            filter.push(filterObj);

            _.each(this.pipelineFilters, function(filterDef) {
                filter.push(filterDef);
            }, this);
        }

        return filter;
    },

    /**
     * Return an array of fields to be fetched and displayed on each tile
     * @return {Array} an array of fields
     */
    getFieldsForFetch: function() {
        if (!_.isEmpty(this._fieldsToFetch)) {
            return this._fieldsToFetch;
        }
        var fields =
            _.flatten(
                _.map(_.flatten(_.pluck(this.meta.tileDef.panels, 'fields')), function(field) {
                    if (field === undefined) {
                        return;
                    }
                    return _.union(_.pluck(field.fields, 'name'), _.flatten(field.related_fields), [field.name]);
                })
            );

        fields.push(
            this.headerField,
            this.tileVisualIndicatorFields[this.module]
        );

        var fieldMetadata = app.metadata.getModule(this.module, 'fields');
        if (fieldMetadata) {
            // Filter out all fields that are not actual bean fields
            fields = _.reject(fields, function(name) {
                return _.isUndefined(fieldMetadata[name]);
            });
        }

        return this._fieldsToFetch = _.uniq(fields);
    },

    /**
     * Uses fields to get the requests for the data to be fetched
     */
    getRecords: function() {
        var fields = this.getFieldsForFetch();
        var requests = this.buildRequests(fields);
        this.fetchData(requests);
    },

    /**
     * Uses fields, filters and other properties to build requests for the data to be fetched
     * @param {Array} fields to be displayed on each tile
     * @return {Array} an array of request objects with dataType, method and url
     */
    buildRequests: function(fields) {
        var requests = {};
        requests.requests = [];

        _.each(this.recordsToDisplay, function(column) {
            var filter = this.getFilters(column);

            var getArgs = {
                filter: filter,
                fields: fields,
                'max_num': this.resultsPerPageColumn,
                'offset': this.offset,
                'order_by': {date_modified: 'DESC'}
            };

            var req = {
                'url': app.api.buildURL(this.module, null, null, getArgs).replace('rest/', ''),
                'method': 'GET',
                'dataType': 'json'
            };

            requests.requests.push(req);
        }, this);

        return requests;
    },

    /**
     * Makes the api call to get the data for the tiles
     * @param {Array} requests an array of request objects
     */
    fetchData: function(requests) {
        var self = this;
        this.moreData = false;
        app.api.call('create', app.api.buildURL(null, 'bulk'), requests, {
            success: function(dataColumns) {
                app.alert.dismiss('pipeline-records-loading');
                if (dataColumns.length !== self.recordsToDisplay.length) {
                    // the data being returned is not for this view
                    // user must've clicked several tabs before data finished loading
                    return;
                }
                self.dataFetched = true;
                self.totalRecords = 0;
                _.each(self.recordsToDisplay, function(column, index) {
                    var records = app.data.createBeanCollection(self.module);
                    if (!_.isEmpty(column.records.models)) {
                        records = column.records;
                    }
                    var contents = dataColumns[index].contents;
                    var augmentedContents = self.addTileVisualIndicator(contents.records);
                    records.add(augmentedContents);
                    column.records = records;
                    self.totalRecords = self.totalRecords + records.length;

                    if (contents.next_offset > -1 && !self.moreData) {
                        self.moreData = true;
                    }
                }, self);

                self._super('render');
                self.postRender();

                if (self.moreData) {
                    self.offset += self.resultsPerPageColumn;
                }
            }
        });
    },

    resizeContainer: function() {
        var $parent = this.$el.parents('.main-pane');
        var $searchFilter = $parent.find('.search-filter');
        var height = $parent.height() - $searchFilter.height();

        this.$el.height(height + 'px');
        this.$('.pipeline-column').height((height - 150) + 'px');
    },

    /**
     * Gives the ability for a tile to be dragged and moved to other columns on the page
     */
    buildDraggable: function() {
        if (!app.acl.hasAccessToModel('edit', this.model) ||
            !app.acl.hasAccessToModel('edit', this.model, this.headerField)) {
            return;
        }

        this.$('.column').sortable({
            connectWith: '.column',
            handle: '.pipeline-tile',
            cancel: '.portlet-toggle',
            placeholder: 'portlet-placeholder ui-corner-all',
            receive: _.bind(function(event, ui) {
                var modelId = this.$(ui.item).data('modelid');
                var oldCollection = _.findWhere(this.recordsToDisplay, {
                    headerKey: this.$(ui.sender).attr('data-column-name')
                });
                var newCollection = _.findWhere(this.recordsToDisplay, {
                    headerKey: this.$(ui.item).parent('ul').attr('data-column-name')
                });
                var model = oldCollection.records.get(modelId);
                if (!app.acl.hasAccessToModel('edit', model)) {
                    app.alert.show('not_authorized', {
                        level: 'error',
                        messages: 'Not allowed to perform action "save" on this record',
                        autoClose: true,
                    });

                    this.$(ui.sender).sortable('cancel');
                    return;
                }
                var success = _.bind(function() {
                    this.switchCollection(oldCollection, model, newCollection);
                    this.saveModel(model, {
                        ui: ui,
                        oldCollection: oldCollection,
                        newCollection: newCollection
                    });
                }, this);
                var error = _.bind(function() {
                    this.$(ui.sender).sortable('cancel');
                    this.$('.column').sortable('enable');
                }, this);
                var complete = function() {
                    app.alert.dismiss('model_loading');
                };

                // Run any functionality necessary before the change is processed
                this._preChange();

                model.fetch({
                    view: 'record',
                    fields: this.getFieldsForFetch(),
                    success: success,
                    error: error,
                    complete: complete
                });
            }, this)
        });

        this.$('.portlet')
            .addClass('ui-widget ui-widget-content ui-helper-clearfix ui-corner-all')
            .find('.span12')
            .addClass('ui-widget-header ui-corner-all');
    },

    /**
     * Gets called when a tile is dragged to another column
     * Removes the tile from the former column collection and adds it to the later one
     * @param {Object} oldCollection Collection object for the column to which the tile previously belonged
     * @param {Object} model model of the tile being moved
     * @param {Object} newCollection Collection object for the column to which the tile is moved
     */
    switchCollection: function(oldCollection, model, newCollection) {
        oldCollection.records.remove(model);
        newCollection.records.add(model, {at: 0});
    },

    /**
     * Gets called to save the model once it switches columns
     * @param {Object} model for the tile to be saved
     * @param {Object} pipelineData contains info about the pipeline ui and collections involved in the change
     */
    saveModel: function(model, pipelineData) {
        var self = this;

        // Set the changes on the model before validating and saving. If validation
        // fails, the updated model will be opened in a record view drawer which causes
        // the synced attributes to change, so we need to store a backup of the
        // previous values for changed fields on the model in case we need to revert
        this._setNewModelValues(model, pipelineData.ui);
        model.oldValues = _.pick(model.previousAttributes(), function(value, key) {
            return key in model.changed;
        });

        // Validate the model according to the record view validation rules. For
        // accurate validation which takes SugarLogic dependencies into account,
        // we need to actually open the record view. Here we load the view into
        // the side drawer (without opening it), then validate it. If validation
        // is successful, the model/collection change is saved. Otherwise, the
        // record view is opened in a regular drawer for the user to fix the
        // invalid fields
        var sideDrawer = this._getSideDrawer();
        var beanCollection = app.data.createBeanCollection(this.module, [model]);
        if (sideDrawer) {
            sideDrawer.showComponent({
                layout: 'tile-validation-drawer',
                context: {
                    skipRouting: true,
                    model: model,
                    collection: beanCollection,
                    module: self.module,
                    saveImmediately: true,
                    validationCallback: function(isValid) {
                        self._handleValidationResults(isValid, model, pipelineData);
                    },
                    saveCallback: function(saved) {
                        self._callWithTileModel(model, '_postChange', [!saved, pipelineData]);
                    }
                }
            });
        }
    },

    /**
     * Sets the changed values on the model before validation and saving. This is
     * useful to override in case custom action must be taken to handle field changes
     * (for example, converting "January 2020" to "01/31/2020" before setting the
     * value on the model)
     * @param {Object} model the model to set the values on
     * @param (Object} ui an object with the ui details of the tiles like originalPosition, offset, etc.
     * @private
     */
    _setNewModelValues: function(model, ui) {
        model.set(this.headerField, this.$(ui.item).parent('ul').attr('data-column-name'));
    },

    /**
     * Gets the side drawer component associated with the layout
     * @return {Object} The side drawer, or undefined if it does not exist
     * @private
     */
    _getSideDrawer: function() {
        if (!this.sideDrawer) {
            this.sideDrawer = this.layout.getComponent('side-drawer');
        }
        return this.sideDrawer;
    },

    /**
     * Opens a drawer to the record view to fix any invalid fields on the model
     * after switching the model to a new column
     * @param isValid boolean indicating whether the model passed validation
     * @param {Object} model the model that was validated
     * @param {Object} pipelineData contains info about the pipeline ui and collections involved in the change
     * @private
     */
    _handleValidationResults: function(isValid, model, pipelineData) {
        if (!isValid) {
            var self = this;
            var beanCollection = app.data.createBeanCollection(this.module, [model]);
            app.drawer.open({
                layout: 'tile-validation-drawer',
                context: {
                    skipRouting: true,
                    module: self.module,
                    model: model,
                    collection: beanCollection,
                    noEditFields: [self.headerField],
                    saveImmediately: true,
                    saveCallback: function(saved) {
                        app.drawer.close(saved);
                    },
                    cancelCallback: function() {
                        app.drawer.close(false);
                    },
                    editOnly: true
                }
            }, function(saved) {
                self._callWithTileModel(model, '_postChange', [!saved, pipelineData]);
            });
        }
    },

    /**
     * Utility function that runs before a column change is processed
     * @private
     */
    _preChange: function() {
        // Disable dragging while the change is being processed to prevent any
        // potential issues due to multiple simultaneous drag/drops
        this.$('.column').sortable('disable');

        // Display a loading message while the model data is being fetched
        app.alert.show('model_loading', {
            level: 'process',
        });
    },

    /**
     * Utility function. It fetches a model with only the fields required by the view.
     * @param {Object} model A model that is passed to the view from elsewhere.
     * @param {string} methodName The name of the method that should be called with the tile view compatible model.
     * This method should has to accept at least 1 parameter, the first being a model.
     * @param {Array} params Any other params that should be passed to the method called.
     * @private
     */
    _callWithTileModel: function(model, methodName, params) {
        this._preChange();
        var tileModel = app.data.createBean(this.module, {
            id: model.get('id')
        });
        tileModel.fetch({
            view: 'record',
            fields: this.getFieldsForFetch(),
            success: _.bind(function() {
                var newParams = _.union([tileModel], params || []);
                this[methodName].apply(this, newParams);
            }, this),
            error: _.bind(function() {
                this.$('.column').sortable('enable');
            }, this),
            complete: function() {
                app.alert.dismiss('model_loading');
            }
        });
    },

    /**
     * Utility function that runs after a column change is processed
     * @param {Object} model the model involved in the column change
     * @param {boolean} shouldRevert indicates whether the change needs to be reverted
     * @param {Object} pipelineData contains info about the pipeline ui and collections involved in the change
     * @private
     */
    _postChange: function(model, shouldRevert, pipelineData) {
        var validCollection = this.getColumnCollection(model);
        if (shouldRevert) {
            this._revertChanges(model, pipelineData);
        } else if (validCollection.headerKey !== pipelineData.newCollection.headerKey) {
            this.switchCollection(pipelineData.newCollection, model, validCollection);
        }

        // Since both this view and the record view make changes to the model,
        // sync its final attributes here to avoid "unsaved changes" warnings
        model.setSyncedAttributes(model.attributes);

        this._super('render');
        this.postRender();
        this.$('.column').sortable('enable');
    },

    /**
     * Reverts the changes to the model and collections made by a column move
     * @param {Object} model the model involved in the change
     * @param {Object} pipelineData contains info about the pipeline ui and collections involved in the change
     * @private
     */
    _revertChanges: function(model, pipelineData) {
        model.set(model.oldValues);
        this.switchCollection(pipelineData.newCollection, model, pipelineData.oldCollection);
        this.$(pipelineData.ui.sender).sortable('cancel');
    },

    /**
     * Action listener when the delete button is clicked on the tile
     * Asks for user confirmation and delete the tile record from the view
     * @param {Object} model model object of the tile to be deleted
     */
    deleteRecord: function(model) {
        var collection = model.collection;
        var self = this;

        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: self.getDeleteMessages(model).confirmation,
            onConfirm: function() {
                model.destroy({
                    showAlerts: {'process': true, 'success': {messages: self.getDeleteMessages(model).success}},
                    success: function(data) {
                        self.totalRecords = self.totalRecords - 1;
                        self._super('render');
                        self.postRender();
                    }
                });
            },
            onCancel: function() {
                return;
            }
        });
    },

    /**
     * Gets called when a tile record is successfully deleted
     * Displays the delete confirmation and success message
     * @param {Object} model model object of the deleted tile
     */
    getDeleteMessages: function(model) {
        var messages = {};
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;
        messages.confirmation = app.utils.formatString(app.lang.get('NTC_DELETE_CONFIRMATION_FORMATTED'), [context]);
        messages.success = app.utils.formatString(app.lang.get('NTC_DELETE_SUCCESS'), [context]);
        return messages;
    },

    /**
     * Binds scroll to the recordlist pane
     */
    bindScroll: function() {
        this.$el.on('scroll', _.bind(this.listScrolled, this));
    },

    /**
     * Listens to the scroll event on the list
     * Checks and displays if more data is present on the page
     * @param event
     */
    listScrolled: function(event) {
        var elem = $(event.currentTarget);
        var isAtBottom = (elem[0].scrollHeight - elem.scrollTop()) <= elem.outerHeight();

        if (isAtBottom && this.moreData) {
            this.buildRecordsList();
        }
    },

    /**
     * Adds the visual indicator to all the tiles based on the status or date depending on the modules
     * @param {Array} modelsList a list of all the tile models
     * @return {Array} updated model list with all the indicator values
     */
    addTileVisualIndicator: function(modelsList) {
        var self = this;
        var updatedModel = {};
        var dueDate = app.date();
        var expectedCloseDate = app.date();

        return _.map(modelsList, function(model) {
            switch (model._module) {
                case 'Cases':
                    updatedModel = self.addIndicatorBasedOnStatus(model);
                    break;
                case 'Leads':
                    updatedModel = self.addIndicatorBasedOnStatus(model);
                    break;
                case 'Opportunities':
                    expectedCloseDate = app.date(model.date_closed, 'YYYY-MM-DD');
                    updatedModel = self.addIndicatorBasedOnDate(model, expectedCloseDate);
                    break;
                case 'Tasks':
                    dueDate = app.date.parseZone(model.date_due);
                    updatedModel = self.addIndicatorBasedOnDate(model, dueDate);
                    break;
                default:
                    model.tileVisualIndicator = self.tileVisualIndicator.default;
                    updatedModel = model;
            }

            return updatedModel;
        });
    },

    /**
     * Adds indicator based on the date_closed or date_due
     * @param {Object} model model object for the tile to which the indicator is being added
     * @param {string} date date string related to the model
     * @return {Object} updated model with visual indicator
     */
    addIndicatorBasedOnDate: function(model, date) {
        var now = app.date();
        var aMonthFromNow = app.date().add(1, 'month');

        if (date.isBefore(now)) {
            model.tileVisualIndicator = this.tileVisualIndicator.outOfDate;
        }
        if (date.isAfter(aMonthFromNow)) {
            model.tileVisualIndicator = this.tileVisualIndicator.inFuture;
        }
        if (date.isBetween(now, aMonthFromNow)) {
            model.tileVisualIndicator = this.tileVisualIndicator.nearFuture;
        }

        return model;
    },

    /**
     * Adds indicator based on the Opportunity status
     * @param {Object} model model object for the tile to which the indicator is being added
     * @return {Object} updated model with visual indicator
     */
    addIndicatorBasedOnStatus: function(model) {
        // Group statuses in 3 categories:
        var inFuture = ['New', 'Converted'];
        var outOfDate = ['Dead', 'Closed', 'Rejected', 'Duplicate', 'Recycled'];
        var nearFuture = ['Assigned', 'In Process', , 'Pending Input', ''];

        if (_.indexOf(outOfDate, model.status) !== -1) {
            model.tileVisualIndicator = this.tileVisualIndicator.outOfDate;
        }
        if (_.indexOf(inFuture, model.status) !== -1) {
            model.tileVisualIndicator = this.tileVisualIndicator.inFuture;
        }
        if (_.indexOf(nearFuture, model.status) !== -1) {
            model.tileVisualIndicator = this.tileVisualIndicator.nearFuture;
        }

        return model;
    },

    /**
     * Listens to the arrow-left button click
     * Updates the start date to 5 months prior
     * Sets offset to 0
     * Reloads the data in the recordlist view
     */
    navigateLeft: function() {
        this.startDate = app.date(this.startDate).subtract(5, 'month').format('YYYY-MM-DD');
        this.offset = 0;
        this.loadData();
    },

    /**
     * Listens to the arrow-right button click
     * Updates the start date to next 5 months
     * Sets offset to 0
     * Reloads the data in the recordlist view
     */
    navigateRight: function() {
        this.startDate = app.date(this.startDate).add(5, 'month').format('YYYY-MM-DD');
        this.offset = 0;
        this.loadData();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        window.removeEventListener('resize', this.resizeContainerHandler);

        this.context.off('pipeline:recordlist:model:created', null, this);
        this.context.off('pipeline:recordlist:filter:changed', null, this);
        this.context.off('button:delete_button:click', null, this);
        this.context.off('pipeline:recordlist:resizeContent', null, this);

        this.$el.off('scroll');

        this._super('_dispose');
    }
}) },
"impersonation-banner": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Indicate to sudoer(crm admin) that started impersonation session.
 *
 * @class View.Views.Base.ImpersonationBannerView
 * @alias SUGAR.App.view.views.ImpersonationBannerView
 * @extends View.View
 */
({
	// Impersonation-banner View (base) 

    sudoer: '',

    message: '',

    cache: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.cache = app[app.config.authStore || 'cache'];

        this._super('initialize', [options]);

        if (app.isSynced && !app.metadata.isSyncing()) {
            this.loadSudoer();
        }else {
            app.once('app:sync:complete', this.loadSudoer.bind(this));
        }
    },

    /**
     * Load Sudoer(admin that started impersonation session)
     */
    loadSudoer: function() {
        if (!this.cache.has('ImpersonationFor')) {
            return;
        }

        var url = app.api.buildURL(
            'Users',
            null,
            {id: this.cache.get('ImpersonationFor')},
            {fields: ['full_name', 'first_name']}
        );
        app.api.call('read', url, {},
            {
                success: function(res) {
                    this.sudoer = !_.isEmpty(res.first_name) ? res.first_name : res.full_name;
                    this._render();
                }.bind(this)
            }
        );

    },

    /**
     * @override
     * @private
     */
    _render: function() {

        if (!this.cache.has('ImpersonationFor')) {
            return ;
        }

        if ('' !== this.sudoer) {
            this.message = app.lang.get(
                'LBL_YOU_ARE_CURRENTLY_IMPERSONATING',
                null,
                {
                    sudoer: this.sudoer,
                    user: SUGAR.App.user.get('full_name'),
                }
            );
        }

        this._super('_render');
    }
}) },
"activity-filter-module-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivityFilterModuleDropdownView
 * @alias SUGAR.App.view.views.BaseActivityFilterModuleDropdownView
 * @extends View.Views.Base.FilterModuleDropdownView
 */
({
	// Activity-filter-module-dropdown View (base) 

    extendsFrom: 'FilterModuleDropdownView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.template = app.template.get('filter-module-dropdown');

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     * @return {Object}
     */
    getFilterList: function() {
        return this.context.get('filterList');
    },

    /**
     * @inheritdoc
     * @return boolean
     */
    shouldDisableFilter: function() {
        return false;
    },

    /**
     * Trigger event to reload the layout when the module changes.
     * @param {string} linkModuleName
     * @param {string} linkName
     * @param {boolean} silent
     */
    handleChange: function(linkModuleName, linkName, silent) {
        linkModuleName = linkModuleName || this.layout.name;

        var cacheKey = app.user.lastState.key(this.layout.name, this.layout);

        if (linkName) {
            app.user.lastState.set(cacheKey, linkName);
        } else {
            app.user.lastState.remove(cacheKey);
        }

        this._super('handleChange', [linkModuleName, linkName, silent]);
    },
}) },
"commentlog-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * Contextual dashlet to show comments for a record
 *
 * @class View.Views.Base.CommentlogDashletView
 * @alias SUGAR.App.view.views.BaseCommentlogDashletView
 * @extends View.View
 */
({
	// Commentlog-dashlet View (base) 

    plugins: ['Dashlet', 'Editable'],

    /**
     * Default settings for dashlet
     */
    _defaultSettings: {
        limit: 3
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.meta = _.extend(this.meta, app.metadata.getView(null, this.name));
    },

    /**
     * Set up the comment log collection when init dashlet
     */
    initDashlet: function(viewName) {
        this._mode = viewName;
        this.setUpCollection();
    },

    /**
     * Set up the comment log collection
     */
    setUpCollection: function() {
        this.collection = app.data.createRelatedCollection(this._getClonedModel(), 'commentlog_link');
    },

    /**
     * Get the contextual model for the dashlet
     *
     * @return {Data.Bean|undefined} The context, if it exists.
     * @private
     */
    _getContextModel: function() {
        if (this._contextModel) {
            return this._contextModel;
        }
        var model;
        var baseModule = this.context.get('module');
        var currContext = this.context;
        while (currContext) {
            var contextModel = currContext.get('rowModel') || currContext.get('model');

            if (contextModel && contextModel.get('_module') === baseModule) {
                model = contextModel;

                var parentHasRowModel = currContext.parent && currContext.parent.has('rowModel');
                if (!parentHasRowModel) {
                    break;
                }
            }

            currContext = currContext.parent;
        }
        return this._contextModel = model || app.controller.context.get('model');
    },

    /**
     * Create a new model with the id of the context model to stop changing the context model
     *
     * @return {Data.Bean}
     * @private
     */
    _getClonedModel: function() {
        var model = this._getContextModel();
        return app.data.createBean(model.module, {id: model.get('id')});
    },

    /**
     * Will reset the dataFetched flag of the commentlog field
     * and re-render the field in order to show appropriate content.
     */
    updateFieldsCollection: function() {
        _.each(this.fields, function(field) {
            field.collection.dataFetched = true;
            field.render();
        });
    },

    /**
     * Through options, the refresh button will be reset on complete.
     * Through the success callback we will be able to update the comment field.
     *
     * The property `loadAll` sent through options
     * if set to true will allow to load all comments.
     *
     * @param {Object} options Call options for reading comments.
     */
    getExtendedOptions: function(options) {
        var limit = options && options.loadAll ? -1 : this._defaultSettings.limit;
        return _.extend(options || {}, {
            limit: limit,
            success: _.bind(this.updateFieldsCollection, this),
            error: _.bind(this.updateFieldsCollection, this)
        });
    },

    /**
     * Load the comment log collection.
     *
     * @param {Object} options Call options for reading comments.
     */
    loadData: function(options) {
        var extendedOptions = this.getExtendedOptions(options);
        this.collection.fetch(extendedOptions);
    },

    /**
     * Determine if this dashlet has an unsaved comment in process.
     *
     * @return {boolean} `true` if there are unsaved comments. `false` otherwise.
     */
    hasUnsavedChanges: function() {
        return _.any(this.fields, function(field) {
            return _.isFunction(field.getCurrentCommentText) && !_.isEmpty(field.getCurrentCommentText().trim());
        }, this);
    }
}) }
}}
,
"layouts": {
"base": {
"activitystream": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ActivitystreamLayout
 * @alias SUGAR.App.view.layouts.BaseActivitystreamLayout
 * @extends View.Layout
 */
({
	// Activitystream Layout (base) 

    className: "block filtered activitystream-layout",

    initialize: function(opts) {
        this.renderedActivities = {};
        this.isActivtyStreamsEnabled = app.config.activityStreamsEnabled;

        this._super('initialize', [opts]);

        this.setCollectionOptions();
        this.exposeDataTransfer();

        this.context.on("activitystream:post:prepend", this.prependPost, this);
        this.context.on('activitystream:paginate', this.paginate, this);

        // Remove active state from all preview buttons
        app.events.on('preview:close', function() {
            this.clearRowDecorations();
        }, this);
    },

    /**
     * Removes highlighted styling from stream activities.
     */
    clearRowDecorations: function() {
        if (_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)) {
            var activities = this.$('.activitystream-posts-comments-container');
            activities.removeClass('highlighted');
            activities.find('.preview-btn')
                .removeClass('active')
                .attr('aria-pressed', false);
        }
    },

    /**
     * Set endpoint and the success callback for retrieving activities.
     */
    setCollectionOptions: function() {
        var self = this;
        var endpoint = function(method, model, options, callbacks) {
            var real_module = self.context.parent.get('module'),
                layoutType = self.context.parent.get('layout'),
                modelId = self.context.parent.get('modelId'),
                action = model.module, // equal to 'Activities'
                url;
            switch (layoutType) {
                case "activities":
                    url = app.api.buildURL(real_module, null, {}, options.params);
                    break;
                case "records":
                    url = app.api.buildURL(real_module, action, {}, options.params);
                    break;
                case "record":
                    url = app.api.buildURL(real_module, null, {id: modelId, link: 'activities'}, options.params);
                    break;
            }
            return app.api.call("read", url, null, callbacks);
        };

        this.context.get('collection').setOption({
            endpoint: endpoint,
            success: function(collection) {
                collection.each(function(model) {
                    self.renderPost(model);
                });
            },
            error: function() {
                self.collection.dataFetched = true;
                self.collection.reset();
            }
        });
    },

    /**
     * Expose the dataTransfer object for drag and drop file uploads.
     */
    exposeDataTransfer: function() {
        jQuery.event.props.push('dataTransfer');
    },

    bindDataChange: function() {
        if (this.collection) {
            this.collection.on('add', function(model) {
                this.renderPost(model);
            }, this);
            this.collection.on('reset', function() {
                this.disposeAllActivities();
                this.collection.each(function(post) {
                    this.renderPost(post);
                }, this);
            }, this);
        }

        if (this.context.parent) {
            var model = this.context.parent.get("model");
            this.listenTo(model, "sync", _.once(function() {
                // Only attach to the sync event after the inital sync is done.
                this.listenTo(model, "sync", function() {
                    var options = this.context.get("collectionOptions");
                    this.collection.fetch(options);
                });
            }));
        }
    },

    prependPost: function(model) {
        var view = this.renderPost(model);
        view.$el.parent().prepend(view.$el);
    },

    loadData: function(options) {
        // We want to ensure the data related to this activity loads before the
        // stream for a better user experience.
        var parentCol = this.context.parent.get("collection");
        if (parentCol.isEmpty()) {
            parentCol.once("sync", function(){
                this._load(options);
            }, this);
        } else {
            this._load(options);
        }
    },

    _load: function(options) {
        if (_.isUndefined(this.context.parent.get('layout'))) {
            return;
        }
        options = _.extend({}, options, this.context.get('collectionOptions'));
        this.collection.fetch(options);
    },

    renderPost: function(model, readonly) {
        var view;
        if(_.has(this.renderedActivities, model.id)) {
            view = this.renderedActivities[model.id];
        } else {
            view = app.view.createView({
                context: this.context,
                type: "activitystream",
                module: this.module,
                layout: this,
                model: model,
                readonly: readonly
            });
            this.addComponent(view);
            this.renderedActivities[model.id] = view;
            view.render();
        }
        return view;
    },

    _placeComponent: function(component) {
        if (this.disposed)
            return;

        if(component.name === "activitystream") {
            this.$el.find(".activitystream-list").append(component.el);
        } else if (component.name === 'activitystream-bottom') {
            this.$el.append(component.el);
            component.render();
        } else {
            this.$el.prepend(component.el);
        }
    },

    unbindData: function() {
        var model, collection;

        if (this.context.parent) {
            model = this.context.parent.get("model");
            collection = this.context.parent.get("collection");

            if (model) {
                model.off("change sync", null, this);
            }
            if (collection) {
                collection.off("sync", null, this);
            }
        }

        app.view.Layout.prototype.unbindData.call(this);
    },

    /**
     * Dispose all previously rendered activities
     */
    disposeAllActivities: function() {
        var nonActivities = [];
        _.each(this._components, function(component) {
            if (component.name !== 'activitystream') {
                nonActivities.push(component);
            } else {
                component.dispose();
            }
        });
        this._components = nonActivities;
        this.renderedActivities = {};
    },

    /**
     * Get the next set of activity stream posts.
     */
    paginate: function() {
        this.collection.paginate({
            add: true
        });
    }
}) },
"dashletselect": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Dashletselect Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: ['Dashlet:Select:Cancel']
}) },
"module-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Module list sets all the user defined modules visible in the main menu.
 *
 * This layout is responsible to keep the all the menus (created using
 * {@link View.Views.BaseModuleMenuView}) in a valid state.
 * It shows the menu in the main bar as well as in the dropdown (show more)
 * and keeps it in sync to provide the best user experience possible, while
 * keeping the DOM changes to a minimum.
 *
 * @class View.Layouts.Base.ModuleListLayout
 * @alias SUGAR.App.view.layouts.BaseModuleListLayout
 * @extends View.Layout
 */
({
	// Module-list Layout (base) 

    className: 'module-list',
    plugins: ['Dropdown'],

    /**
     * The catalog of modules linked to their menus (short and long).
     *
     * The menu element is to the partial created at {@link #_placeComponent}
     * method.
     *
     * @property {Object} A hash of module name with each short and long menus:
     * <pre><code>
     *     {
     *         'Home': {long: el1, short: el2},
     *         'Accounts': {long: el3, short: el4},
     *         //...
     *     }
     * </code></pre>
     *
     * @protected
     */
    _catalog: {},

    /**
     * The cached `[data-action=more-modules]` since this view can be quite
     * big.
     *
     * @property {jQuery} The jQuery element pointing to our
     *   `[data-action=more-modules]` element.
     *
     * @protected
     */
    _$moreModulesDD: undefined,

    /**
     * @inheritdoc
     *
     * Hooks to `app:sync:complete` to handle the refresh of the menu items
     * that are available after a complete sync.
     * Hooks to `app:view:change` to keep the active module highlighted.
     */
    initialize: function(options) {

        app.events.on('app:sync:complete', this._resetMenu, this);
        app.events.on('app:view:change', this.handleViewChange, this);

        this._super('initialize', [options]);

        if (this.layout) {
            this.toggleResize(true);
        }
    },

    /**
     * Toggles the resize listener on or off.
     * Pass `true` to turn the listener on, or `false` to turn the listener off.
     * @param {boolean} resize
     */
    toggleResize: function(resize) {
        this.layout.off('view:resize');
        if (resize) {
            this.layout.on('view:resize', this.resize, this);
        }
    },

    /**
     * Method called on `app:view:change` hooked in
     * {@link BaseModuleListLayout#initialize}.
     *
     * It sets the active module to the one set in the context and fires a
     * `header:update:route` event to it's parent layout.
     */
    handleViewChange: function() {
        var module = app.controller.context.get('module');
        var component = app.drawer.getActive();
        if (component && component.context.get('fromRouter')) {
            module = component.context.get('module');
        }

        this._setActiveModule(module);
        this.layout.trigger('header:update:route');
    },

    /**
     * @inheritdoc
     *
     * If it is a `module-menu` component, we wrap it with our `list` template
     * and place it before the `more-modules` drop down or inside the drop down
     * if we are handling a short version of the menu.
     * The short version is always hidden, since it will be toggled on the
     * first resize call (when it overflows the existing width).
     *
     * @param {View.View/View.Layout} component View or layout component.
     * @protected
     */
    _placeComponent: function(component) {
        if (component.name !== 'module-menu') {
            this.$el.append(component.el);
            return;
        }

        var tpl = this._getListTemplate(component);
        var $content = $(tpl({module: component.module})).append(component.el);

        // initialize catalog if isn't initialized
        this._catalog[component.module] = this._catalog[component.module] || {};

        if (component.meta && component.meta.short) {
            $content.addClass('hidden');
            this._catalog[component.module].short = $content;
            this._$moreModulesDD.find('[data-container="overflow"]').append($content);
        } else {
            this._catalog[component.module].long = $content;
            this.$('[data-action="more-modules"]').before($content);
        }
    },

    /**
     * Get the list template to wrap our `module-menu` components.
     * @param {View.View} component
     * @return {Layout.Template} list template for this layout
     * @private
     */
    _getListTemplate: function(component) {
        return app.template.getLayout(this.name + '.list', component.module) ||
            app.template.getLayout(this.name + '.list');
    },

    /**
     * Resets the menu based on new metadata information.
     *
     * It resets components, catalog and template (html), and calls
     * {@link #resize} with the last known space available for this view.
     *
     * @protected
     */
    _resetMenu: function() {

        this._components = [];
        this._catalog = {};
        this.$el.html(this.template(this, this.options));

        // cache the more-dropdown now
        this._$moreModulesDD = this.$('[data-action="more-modules"]');

        this._addDefaultMenus();
        this._setActiveModule(app.controller.context.get('module'));
        this.render();
        this.resize(this._width);
    },

    /**
     * Adds all default menu views as components in both full and short
     * version.
     *
     * This will set the menu as sticky to differentiate from the others that
     * are added based on navigation/reference only.
     *
     * @private
     */
    _addDefaultMenus: function() {

        var moduleList = app.metadata.getModuleNames({filter: 'display_tab', access: 'read'});

        _.each(moduleList, function(module) {
            this._addMenu(module, true);
        }, this);
    },

    /**
     * Adds a menu as a component. Sticky menus aren't added to `more-modules`
     * list.
     *
     * @param {String} module The module
     * @param {Boolean} [sticky=false] Set to `true` if this is a menu that is
     *   part of user preferences.
     * @return {Object} The `menu.long` and `menu.short` components created.
     *   If `sticky` param is `false`, then no `menu.short` is provided.
     * @private
     */
    _addMenu: function(module, sticky) {
        var menu = {};

        var def = {
            view: {
                type: 'module-menu',
                sticky: sticky,
                short: false
            }
        };
        menu.long = this.createComponentFromDef(def, null, module);
        this.addComponent(menu.long, def);

        if (!sticky) {
            return menu;
        }

        def = {
            view: {
                type: 'module-menu',
                short: true
            }
        };
        menu.short = this.createComponentFromDef(def, null, module);
        this.addComponent(menu.short, def);

        return menu;
    },

    /**
     * Resize the module list to the specified width and move the extra module
     * names to the `more-modules` drop down.
     *
     * @param {number} width The width that we have available.
     */
    resize: function(width) {
        /**
         * Cached version of last width available for this view.
         *
         * @type {number}
         * @private
         */
        this._width = width;

        if (width <= 0 || _.isEmpty(this._components)) {
            return;
        }

        var $moduleList = this.$('[data-container=module-list]'),
            $dropdown = this._$moreModulesDD.find('[data-container=overflow]');

        if ($moduleList.outerWidth(true) >= width) {
            this.removeModulesFromList($moduleList, width);
        } else {
            this.addModulesToList($moduleList, width);
        }
        this._$moreModulesDD.toggleClass('hidden', $dropdown.children('li').not('.hidden').length === 0);
    },

    /**
     * Computes the minimum width required for the module list.
     * This includes: the cube, the current module, and the more modules drop down.
     * @return {number}
     */
    computeMinWidth: function() {
        var minWidth = 0;
        var $moduleChildren = this.$('[data-container=module-list]').children();

        // The cube
        var $first = $moduleChildren.first();
        minWidth += $first.outerWidth() + 1;

        // The current active module
        var firstModule = $moduleChildren.filter('.active').not($first);
        if (firstModule.length) {
            minWidth += firstModule.outerWidth() + 1;
        } else {
            // or the first module
            minWidth += $moduleChildren.eq(1).outerWidth() + 1;
        }

        // More Modules dropdown
        minWidth += $moduleChildren.last().outerWidth() + 1;
        return minWidth;
    },

    /**
     * Move modules from the dropdown to the list to fit the specified width.
     * @param {jQuery} $modules The jQuery element that contains all the
     *   modules.
     * @param {Number} width The current width we have available.
     */
    addModulesToList: function($modules, width) {
        var $dropdown = this._$moreModulesDD.find('[data-container=overflow]'),
            $toHide = $dropdown.children('li').not('.hidden').first(),
            currentWidth = $modules.outerWidth(true);

        while (currentWidth < width && $toHide.length > 0) {
            this.toggleModule($toHide.data('module'), true);

            $toHide = $dropdown.children('li').not('.hidden').first();

            currentWidth = $modules.outerWidth(true);
        }

        if (currentWidth >= width) {
            this.removeModulesFromList($modules, width);
        }
    },

    /**
     * Move modules from the list to the dropdown to fit the specified width
     * @param {jQuery} $modules The jQuery element that contains all the
     *   modules.
     * @param {Number} width The current width we have available.
     */
    removeModulesFromList: function($modules, width) {

        var $toHide = this._$moreModulesDD.prev();

        while ($modules.outerWidth(true) > width && $toHide.length > 0) {
            if (!this.isRemovableModule($toHide.data('module'))) {
                $toHide = $toHide.prev();
                continue;
            }

            this.toggleModule($toHide.data('module'), false);

            $toHide = $toHide.prev();
        }
    },

    /**
     * Toggle module menu given. This will make sure it will be always in sync.
     *
     * We decided to assume that the `more-modules` drop down is the master of
     * the information to keep in sync.
     *
     * If we don't have a short menu version (on `more-modules` drop down),
     * it means that we don't need to keep it in sync and just show/hide based
     * on the module name. Think at this as a cached menu until we get another
     * `app:sync:complete` event.
     *
     * @param {String} module The module you want to turn on/off.
     * @param {Boolean} [state] `true` to show it on mega menu, `false`
     *   otherwise. If no state given, will toggle.
     *
     * @chainable
     */
    toggleModule: function(module, state) {
        // cache version only
        if (!this._catalog[module].short) {
            state = !_.isUndefined(state) ? !state : undefined;
            this._catalog[module].long.toggleClass('hidden', state);
            return this;
        }

        // keep it in sync
        var newState = this._catalog[module].short.toggleClass('hidden', state).hasClass('hidden');
        this._catalog[module].long.toggleClass('hidden', !newState);

        return this;
    },

    /**
     * Sets the module given as active and shown in the main nav bar.
     *
     * This waits for the full `this._components` to be set first. If we fail
     * to do that, we will see the current module context as the first menu.
     *
     * The module to be shown as active in the main nav bar is mapped by
     * {@link Core.MetadataManager#getTabMappedModule} to be displayed.
     *
     * Cached versions of the modules are always hidden if not active.
     *
     * @param {String} module the Module to set as Active on the menu.
     *
     * @protected
     * @chainable
     */
    _setActiveModule: function(module) {
        if (_.isEmpty(this._components)) {
            // wait until we have the mega menu in place
            return this;
        }

        let tabMap = app.metadata.getModuleTabMap();
        let mappedModule = _.isUndefined(tabMap[module]) ? module : tabMap[module];
        let $activeModule = this.$('[data-container=module-list]').children('.active').removeClass('active');
        let activeModule = $activeModule.data('module');
        let moduleList = app.metadata.getFullModuleList();
        let inModuleList = !_.isUndefined(moduleList[mappedModule]);

        if (this._catalog[activeModule] && !this._catalog[activeModule].short) {
            // hide the cached version only module
            this.toggleModule(activeModule, false);
        }

        // If this is a tab-mapped module, but not mapped to anything
        // or invalid mapping, don't continue execution.
        if (!mappedModule || !inModuleList) {
            return this;
        }

        if (!this._catalog[mappedModule]) {
            this._addMenu(mappedModule, false).long.render();
        }

        this._catalog[mappedModule].long.addClass('active');
        this.toggleModule(mappedModule, true);

        return this;
    },

    /**
     * Returns `true` if a certain module can be removed from the main nav bar,
     * `false` otherwise.
     *
     * Currently we can't remove the Home module (sugar cube) neither the
     * current active module.
     *
     * @param {String} module The module to check.
     *
     * @return {Boolean} `true` if the module is safe to be removed.
     */
    isRemovableModule: function(module) {
        return !(module === 'Home' || this.isActiveModule(module));
    },

    /**
     * Returns `true` when the module is active in main nav bar, `false`
     * otherwise.
     *
     * This is normally based on the `App.controller.context` current module
     * and then sets a fallback mechanism to determine which module it is,
     * that you can see described in {@link #_setActiveModule}.
     *
     * @param {String} module The module to check.
     *
     * @return {Boolean} `true` if the module is safe to be removed.
     */
    isActiveModule: function(module) {
        return this._catalog[module].long.hasClass('active');
    }

}) },
"config-drawer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ConfigDrawerLayout
 * @alias SUGAR.App.view.layouts.BaseConfigDrawerLayout
 * @extends View.Layout
 */
({
	// Config-drawer Layout (base) 


    /**
     * Holds an object with the current module in it for parsing language strings
     *
     * <pre><code>
     *  { module: this.module }
     * </pre></code>
     */
    moduleLangObj: undefined,

    /**
     * Check to make sure the module actually has a config in metadata
     */
    configMetadataOK: false,

    /**
     * If User access to this module is OK
     */
    accessUserOK: false,

    /**
     * If User's access to module-specific ACLs are OK
     */
    accessModuleOK: false,

    /**
     * If DB or other module-specific configuration are OK
     */
    accessConfigOK: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.moduleLangObj = {
            module: this.module
        };

        if (this.checkAccess()) {
            // get the context model
            var ctxModel = options.context.get('model'),
                metadata = app.metadata.getModule(this.module);
            // empty the model
            ctxModel.clear({silent: true});

            if (_.has(metadata, 'config')) {
                // load the model with module's config
                ctxModel.set(metadata.config);
            }

            this.loadConfig(options);
        }
    },

    /**
     * @inheritdoc
     * @private
     */
    _render: function() {
        if (this.checkAccess()) {
            this._super('_render');
        } else {
            this.blockModule();
        }
    },

    /**
     * Continues initializing Config and loads data
     *
     * @param {Object} [options] The `options` param passed in to initialize
     */
    loadConfig: function(options) {
        this._super('loadData');
    },

    /**
     * Checks if User has access to this module
     * Should be overridden in modules to provide module-specific access requirements
     *
     * @return {boolean}
     */
    checkAccess: function() {
        this.configMetadataOK = this._checkConfigMetadata();
        this.accessUserOK = this._checkUserAccess();
        this.accessModuleOK = this._checkModuleAccess();
        this.accessConfigOK = this._checkModuleConfig();
        return (this.configMetadataOK && this.accessUserOK && this.accessModuleOK && this.accessConfigOK);
    },

    /**
     * Checks if there's actually config in the metadata for the current module
     *
     * @return {boolean}
     * @private
     */
    _checkConfigMetadata: function() {
        return !_.isEmpty(app.metadata.getModule(this.module, 'config'));
    },

    /**
     * Checks if the User has access to the current module
     *
     * @return {boolean}
     * @private
     */
    _checkUserAccess: function() {
        return !_.has(app.user.getAcls()[this.module], 'access');
    },

    /**
     * Allow modules to have specific access checks to allow configuration
     * Ex. Forecasts is only configurable by SystemAdmins & Forecasts Developers, not Forecasts admins
     *
     * @return {boolean}
     * @private
     */
    _checkModuleAccess: function() {
        return true;
    },

    /**
     * Adds an extra level for if the config cannot be loaded because of some module-specific case
     * Ex. Forecasts config doesn't have the right Sales Stage Won/Lost
     *
     * @return {boolean}
     * @private
     */
    _checkModuleConfig: function() {
        return true;
    },

    /**
     * Blocks config from continuing to load
     */
    blockModule: function() {
        var title = app.lang.get('LBL_CONFIG_BLOCKED_TITLE', this.module, this.moduleLangObj),
            msg;

        if (!this.configMetadataOK) {
            msg = app.lang.get('LBL_CONFIG_BLOCKED_DESC_NO_CONFIG_METADATA', this.module, this.moduleLangObj);
        } else if (!this.accessUserOK) {
            msg = app.lang.get('LBL_CONFIG_BLOCKED_DESC_USER_ACCESS', this.module, this.moduleLangObj);
        } else if (!this.accessModuleOK) {
            msg = app.lang.get('LBL_CONFIG_BLOCKED_DESC_MODULE_ACCESS', this.module, this.moduleLangObj);
        } else if (!this.accessConfigOK) {
            msg = app.lang.get('LBL_CONFIG_BLOCKED_DESC_CONFIG_ACCESS', this.module, this.moduleLangObj);
        }

        this.displayNoAccessAlert(title, msg);
    },

    /**
     * Displays an Error Alert with the passed in title and message
     *
     * @param {String} title Already-translated language string for the Alert's title
     * @param {String} msg Already-translated language string for the Alert's message
     */
    displayNoAccessAlert: function(title, msg) {
        var alert = app.alert.show('no_access_to_module_' + this.module, {
            level: 'error',
            title: title,
            messages: [msg]
        });

        var $close = alert.getCloseSelector();
        $close.on('click', function() {
            $close.off();
            app.router.navigate('#Home', {trigger: true});
        });
        app.accessibility.run($close, 'click');

        app.drawer.close(this.context, this.module);
    },

    /**
     * Overrides loadData to defer it running until we call it in _onceInitSelectedUser
     *
     * @override
     */
    loadData: function() {
    }
}) },
"dupecheck-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DupecheckFilterLayout
 * @alias SUGAR.App.view.layouts.BaseDupecheckFilterLayout
 * @extends View.Layouts.Base.Filter
 */
({
	// Dupecheck-filter Layout (base) 

    extendsFrom: 'FilterLayout',
    initialFilter: 'all_records',

    initialize: function(options) {
        this._super('initialize', [options]);
        this.name = 'filter';

        //initialize the last filter to show all duplicates before allowing user to change the filter
        this.setLastFilter(this.module, this.layoutType, this.initialFilter);
    },

    /**
     * @inheritdoc
     *
     * Override getting relevant context logic in order to filter on current
     * context.
     */
    getRelevantContextList: function() {
        return [this.context];
    },

    /**
     * @inheritdoc
     *
     * Override getting last filter in order to retrieve found duplicates for
     * initial set.
     */
    getLastFilter: function() {
        var lastFilter = this._super('getLastFilter', arguments);
        return (_.isUndefined(lastFilter)) ? this.initialFilter : lastFilter;
    }
}) },
"maps-widget": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Maps widget layout
 *
 * @class View.Layouts.Base.MapsWidgetLayout
 * @alias SUGAR.App.view.layouts.BaseMapsWidgetLayout
 * @extends View.Layouts.Base.SubpanelLayout
 */
({
	// Maps-widget Layout (base) 

    extendsFrom: 'SubpanelLayout',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        const module = this._getMapsContextModule();
        const mapsModule = `${module}/maps`;

        /**
         * Replace standard subpanel context with a no link supanel context
         */
        options.context = new app.Context({
            module: module,
            collection: app.data.createBeanCollection(mapsModule),
            model: app.data.createBean('Maps')
        });

        options.context.parent = app.controller.context;

        this._super('initialize', [options]);
    },

    /**
     * Get current context module
     *
     * @return {string}
     */
    _getMapsContextModule: function() {
        const module = app.controller.context.get('module');
        const LOCAL_STORAGE_WIDGET_KEY = `maps_widget_data_${module}`;

        const savedData = app.user.lastState.get(LOCAL_STORAGE_WIDGET_KEY);

        if (savedData && _.has(savedData, 'modules')) {
            return savedData.modules;
        }

        return module;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        //add maps supanel to sortable list
        this.$el.attr({
            'data-subpanel-link': 'maps'
        });
    }
}) },
"subpanels": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SubpanelsLayout
 * @alias SUGAR.App.view.layouts.BaseSubpanelsLayout
 * @extends View.Layout
 */
({
	// Subpanels Layout (base) 

    /**
     * @inheritdoc
     */
    className: 'subpanels-layout',

    /**
     * Default settings used for the sortable plugin.
     *
     * - `{Boolean} sortable` Whether or not this layout should be sortable.
     * - `{Boolean} showAlerts` Whether or not to show alerts when the subpanel
     *   ordering is changed.
     *
     * These defaults can be overridden through the metadata (shown below) or by
     * customizing this layout.
     *
     *     // ...
     *     'settings' => array(
     *         'sortable' => false,
     *         //...
     *     ),
     *     //...
     *
     * @property {Object}
     * @protected
     */
    _defaultSettings: {
        showAlerts: true,
        sortable: true
    },

    /**
     * Settings after applying metadata settings on top of
     * {@link #_defaultSettings}.
     *
     * @property {Object}
     * @protected
     */
    _settings: {},

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initSettings();
        this._bindEvents();
    },

    /**
     * Merges settings defined in the metadata with {@link #_defaultSettings}.
     *
     * @protected
     * @chainable
     */
    _initSettings: function() {
        this._settings = _.extend({},
            this._defaultSettings,
            this.meta && this.meta.settings || {}
        );
        return this;
    },

    /**
     * Binds events that this layout uses.
     *
     * @protected
     */
    _bindEvents: function() {
        if (this.layout) {
            this.listenTo(this.layout, 'subpanel:change', this.showSubpanel);
        }

        this.on('subpanels:reordered', this._saveNewOrder, this);
    },

    /**
     * Initializes the jQuery Sortable plugin to this layout, only if the
     * `sortable` property on the {@link #_settings} object is set to `true`.
     *
     * By default, the `handle` to drag subpanels is specified as the
     * `panel-top` component. The `helper` attribute is set to `clone` because
     * Firefox dispatches a click event when the dragged element is removed and
     * inserted by jQuery, see:
     * [bug ticket](https://bugzilla.mozilla.org/show_bug.cgi?id=787944).
     *
     * @protected
     * @chainable
     */
    _initSortablePlugin: function() {
        if (this._settings && this._settings.sortable === true) {
            this.$el.sortable({
                axis: 'y',
                containment: this.$el,
                handle: '[data-sortable-subpanel=true]',
                tolerance: 'pointer',
                scrollSensitivity: 50,
                scrollSpeed: 15,
                update: _.bind(this.handleSort, this)
            });
        }
        return this;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this._initSortablePlugin();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (!_.isEmpty(this.$el.data('sortable'))) {
            this.$el.sortable('destroy');
        }
        this._super('_dispose');
    },

    /**
     * The subpanels list is saved into local storage.
     *
     * Displays a `success` alert message if the `showAlerts` setting is `true`.
     *
     * This method is called by the `subpanel:reordered` event, see
     * {@link #initialize}.
     *
     * @protected
     * @param {Object} component The `subpanel` component
     * @param {String[]} order The new order of `subpanel` components.
     */
    _saveNewOrder: function(component, order) {
        var key = app.user.lastState.buildKey('order', 'subpanels', this.module);
        app.user.lastState.set(key, order);

        if (this._settings.showAlerts === true) {
            app.alert.show('subpanel_order_updated', {
                level: 'success',
                messages: app.lang.get('LBL_SAVED_LAYOUT', this.module),
                autoClose: true
            });
        }
    },

    /**
     * Handler for subpanel re-order.
     *
     * @param {Event} evt The jQuery update event.
     * @param {Object} ui The jQuery UI object.
     */
    handleSort: function(evt, ui) {
        var newOrder = this.$el.sortable('toArray', {
                attribute: 'data-subpanel-link'
            });

        this.trigger('subpanels:reordered', this, newOrder);
    },

    /**
     * Removes subpanels that user doesn't have access to. SP-924: Error message when opening subpanel
     * user doesn't have access to.
     *
     * @param {Array} components list of child components from layout definition
     * @return {Object} pruned components
     * @private
     * @override
     */
    _pruneNoAccessComponents: function(components) {
        var prunedComponents = [];
        var layoutFromContext = this.context ? this.context.get('layout') || this.context.get('layoutName') : null;
        this.layoutType = layoutFromContext ? layoutFromContext : app.controller.context.get('layout');
        this.aclToCheck = this.aclToCheck || 'list';
        _.each(components, function(component) {
            var relatedModule,
                link = component.context ? component.context.link : null;
            if (link) {
                relatedModule = app.data.getRelatedModule(this.module, link);
                if (!relatedModule || relatedModule && app.acl.hasAccess(this.aclToCheck, relatedModule)) {
                    prunedComponents.push(component);
                }
            }
        }, this);
        return prunedComponents;
    },

    /**
     *
     * Removes hidden subpanels from list of components before adding them to layout
     *
     * @param {Array} components list of child components from layout definition
     * @return {Object} pruned components
     * @private
     * @override
     */
    _pruneHiddenComponents: function(components) {
        var hiddenSubpanels = app.metadata.getHiddenSubpanels();
        var visibleSubpanels = _.filter(components, function(component) {
            if (!component || !component.context) {
                app.logger.error('Unable to load subpanel component: component or context is missing');
                return false;
            }
            var relatedModule = app.data.getRelatedModule(this.module, component.context.link);
            return _.isEmpty(_.find(hiddenSubpanels, function(hiddenPanel){
                if (relatedModule !== false) {
                    //hidden subpanels seem to come back in lower case, so we do a case insenstiive compare of module names
                    return hiddenPanel.toLowerCase() === relatedModule.toLowerCase();
                }
                return true;
            }));
        }, this);
        return visibleSubpanels;
    },

    /**
     * @inheritdoc
     *
     * We override this method which is called early in the Sidecar framework to
     * prune any hidden or acl prohibited components.
     */
    _addComponentsFromDef: function(components, context, module) {
        // First checks for hidden components, then checks for ACLs on those components.
        var allowedComponents = this._pruneHiddenComponents(components);
        allowedComponents = this._pruneNoAccessComponents(allowedComponents);
        allowedComponents = this._addMapsSubpanel(allowedComponents);
        allowedComponents = this.reorderSubpanels(allowedComponents);

        // Call original Layout with pruned components
        this._super('_addComponentsFromDef', [allowedComponents, context, module]);
        this._markComponentsAsSubpanels();
        this._disableSubpanelToggleButton(allowedComponents);
    },

    /**
     * Add maps subpanel if it's enabled for current module
     *
     * @param {Object} allowedComponents
     * @return {Object} allowedComponents;
     */
    _addMapsSubpanel: function(allowedComponents) {
        const fromCreate = this.context.get('create');

        if (app.utils.maps.isMapsModuleEnabled(this.module) && !fromCreate && app.user.hasMapsLicense()) {
            const subpanelMeta = {
                layout: 'maps-widget',
                label: 'LBL_MAP_MAP',
                context: {link: 'maps'},
            };

            allowedComponents.push(subpanelMeta);
        }

        return allowedComponents;
    },

    /**
     * Orders the `subpanel` components and strips out any components from the
     * specified `order` that are no longer available.
     *
     * @param {Array} components The list of `subpanel` component objects.
     * @return {Array} The ordered list of `subpanel` component objects.
     */
    reorderSubpanels: function(components) {
        var key = app.user.lastState.buildKey('order', 'subpanels', this.module),
            order = app.user.lastState.get(key);

        if (_.isEmpty(order)) {
            return components;
        }

        var componentOrder = _.pluck(_.pluck(components, 'context'), 'link');
        order = _.intersection(order, componentOrder);

        _.each(order, function(link, index) {
            var comp = _.find(components, function(comp) {
                return comp.context.link === link;
            });
            comp.position = ++index;
        });

        components = _.sortBy(components, function(comp) {
            return comp.position;
        });

        return components;
    },

    /**
     * If no subpanels are left after pruning hidden and ACL-prevented
     * subpanels, we disable the filter panel's subpanel toggle button.
     *
     * @param {Array} allowedComponents The pruned subpanels.
     */
    _disableSubpanelToggleButton: function(allowedComponents) {
        if (!this.layout || !_.isEmpty(allowedComponents)) {
            return;
        }

        this.layout.trigger('filterpanel:change', 'activitystream', true, true);
        this.layout.trigger('filterpanel:toggle:button', 'subpanels', false);
    },

    /**
     * Show the subpanel for the given linkName and hide all others
     * @param {String} linkName name of subpanel link
     */
    showSubpanel: function(linkName) {
        if (!app.config.collapseSubpanels) {
            // this.layout is the filter layout which subpanels is child of; we
            // use it here as it has a last_state key in its meta
            // FIXME: TY-499 will address removing the dependancy on this.layout
            var cacheKey = app.user.lastState.key('subpanels-last', this.layout);
            if (linkName) {
                app.user.lastState.set(cacheKey, linkName);
            } else {
                // Fixes SP-836; esentially, we need to clear subpanel-last-<module>
                // anytime 'All' selected.
                app.user.lastState.remove(cacheKey);
            }
        }

        _.each(this._components, function(component) {
            var link = component.context.get('link');
            if (!linkName) {
                component.show();
            } else if (linkName === link) {
                component.show();
                component.context.set('collapsed', false);
            } else {
                component.hide();
            }
        });
    },

    /**
     * Mark component context as being subpanels
     */
    _markComponentsAsSubpanels: function() {
        _.each(this._components, function(component) {
            component.context.set("isSubpanel", true);
        });
    },

    /**
     * Load data for all subpanels. Need to override the layout's loadData() because
     * it calls loadData() for the context, which we do not want to do here.
     * @param options
     */
    loadData: function(options) {
        var self = this,
            load = function(){
                _.each(this._components, function(component) {
                    component.loadData(options);
                });
            };
        if (self.context.parent && !self.context.parent.isDataFetched()) {
            var parent = this.context.parent.get("model");
            parent.once("sync", load);
        }
        else {
            load();
        }
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.CreateLayout
 * @alias SUGAR.App.view.layouts.CreateLayout
 * @extends View.Layout
 */
({
	// Create Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Sidebar:Toggle',
        'Create:Save',
        'Create:Cancel',
        'Dropdown:More'
    ]
}) },
"create-nodupecheck": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Create-nodupecheck Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Sidebar:Toggle',
        'Create:Save',
        'Create:Cancel'
    ]
}) },
"togglepanel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout for tabbing between filterable components.
 * Mostly to toggle between Activity Stream and list views
 *
 * @class View.Layouts.Base.TogglepanelLayout
 * @alias SUGAR.App.view.layouts.BaseTogglepanelLayout
 * @extends View.Layout
 */
({
	// Togglepanel Layout (base) 

    events: {
        'click .toggle-actions .btn': 'toggleView'
    },

    /**
     * @override
     * @param {Object} opts
     */
    initialize: function (opts) {
        this.componentsList = {}; //components that can be toggled
        this.toggles = []; //toggle buttons to display to user
        this.processToggles(opts);
        this._super('initialize', [opts]);
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var allComponents = this._components;
        this._components = this.getNonToggleComponents();
        this._super('loadData', [options]);
        this._components = allComponents;
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        // Only render components that cannot be toggled.
        var allComponents = this._components;
        this._components = this.getNonToggleComponents();
        this._super('_render');
        this._components = allComponents;

        // get the last viewed layout
        this.toggleViewLastStateKey = app.user.lastState.key('toggle-view', this);
        var lastViewed = app.user.lastState.get(this.toggleViewLastStateKey);

        // show the first toggle if the last viewed state isn't set in the metadata
        if (_.isUndefined(lastViewed) || this.isToggleButtonDisabled(lastViewed)) {
            var enabledToggles = _.filter(this.toggles, function(toggle) {
                return !toggle.disabled;
            });
            if (enabledToggles.length > 0) {
                lastViewed = _.first(enabledToggles).toggle;
            }
        }

        if (lastViewed) {
            this.showComponent(lastViewed, true);//SP-1766-don't double render!
            // Toggle the appropriate button and layout for initial render
            this.$('[data-view="' + lastViewed + '"]')
                .button('toggle')
                .attr('aria-pressed', true);
        }
    },

    /**
     * Get components that cannot be toggled.
     */
    getNonToggleComponents: function() {
        return _.filter(this._components, function(component) {
            return !_.contains(this.componentsList, component);
        }, this);
    },

    /**
     * Checks whether the toggle button is disabled
     * @param {string} name  The name of the button to check
     * @return {boolean}
     */
    isToggleButtonDisabled: function (name) {
        var disabled = false,
            toggleButton;

        toggleButton = _.find(this.toggles, function (toggle) {
            return toggle.toggle === name;
        });

        if (toggleButton) {
            disabled = toggleButton.disabled;
        }
        return disabled;
    },

    /**
     * Get components from the metadata and declare toggles.
     *
     * @param {Object} options The Backbone.View initialization options.
     */
    processToggles: function(options) {
        var temp = {};

        //Go through components and figure out which toggles we should add
        _.each(options.meta.components, function (component) {
            var toggle;
            if (component.view) {
                toggle = component.view;
            } else if (component.layout) {
                toggle = (_.isString(component.layout)) ? component.layout : component.layout.type;
            }

            var availableToggle = _.find(options.meta.availableToggles, function (curr) {
                return curr.name === toggle;
            }, this);
            if (toggle && availableToggle) {
                var disabled = !!availableToggle.disabled;
                temp[toggle] = {
                    toggle: toggle,
                    title: availableToggle.label,
                    class: availableToggle.icon,
                    css_class: availableToggle.css_class,
                    disabled: disabled,
                    route: availableToggle.route
                };
            }
        }, this);

        // Sort the toggles by the order in the availableToggles list
        _.each(options.meta.availableToggles, function(toggle) {
            if (temp[toggle.name]) {
                this.toggles.push(temp[toggle.name]);
            }
        }, this);
    },

    /**
     * @override
     * @private
     * @param {Component} component
     * @param {Object} def
     */
    _placeComponent: function (component, def) {
        var toggleAvailable = _.isObject(_.find(this.options.meta.availableToggles, function (curr) {
            return curr.name === component.name;
        }));

        if (toggleAvailable) {
            this.componentsList[component.name] = component;
        }

        this.$('.main-content').append(component.el);
    },

    /**
     * Show a toggle
     * @param {Event} e
     */
    toggleView: function (e) {
        var $el = this.$(e.currentTarget);
        // Only toggle if we click on an inactive button
        if (!$el.hasClass('active')) {
            var data = $el.data();
            if (data.route) {
                app.router.navigate(this.module + '/' + data.route, {trigger: true});
            } else {
                app.user.lastState.set(this.toggleViewLastStateKey, data.view);
            }
            this.showComponent(data.view);
            this._toggleAria($el);
        }
    },

    /**
     * Sets all button accessibility 'aria-pressed' attributes to false
     * then sets the active button 'aria-pressed' attribute to true.
     *
     * @private
     */
    _toggleAria: function(btn) {
        //If the buttons are present on the layout
        if (this.$el) {
            this.$('.btn').attr('aria-pressed', false);
        }
        btn.attr('aria-pressed', true);
    },

    /**
     * Show and render a given component. Hide all others.
     * @param {string} name
     * @param {boolean} silent
     */
    showComponent: function (name, silent) {
        if (!name) return;

        _.each(this.componentsList, function (comp) {
            if (comp.name === name) {
                comp.show();

                // Should only render if the component has never rendered before.
                if (!comp._skipRenderWhenToggled) {
                    comp.render();
                    comp._skipRenderWhenToggled = true;
                }
            } else {
                comp.hide();
            }
        }, this);

        //Need to respect silent param if true as it prevents double rendering:
        //SP-1766-Filter for sidecar modules causes two requests to list view
        this.trigger('filterpanel:change', name, silent);
    },

    /**
     * @override
     * @private
     */
    _dispose: function () {
        _.each(this.componentsList, function (component) {
            if (component) {
                component.dispose();
            }
        });
        this.componentsList = {};
        app.view.Layout.prototype._dispose.call(this);
    }
}) },
"preview-activitystream": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.PreviewActivityStreamLayout
 * @alias SUGAR.App.view.layouts.BasePreviewActivityStreamLayout
 * @extends View.Layouts.Base.ActivitystreamLayout
 */
({
	// Preview-activitystream Layout (base) 

    extendsFrom: 'ActivitystreamLayout',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * The instance of the {@link Core.Context preview layout context}.
         * @type {Core.Context}
         */
        this._previewContext = this.context.parent;

        app.events.on('preview:close', function() {
            this.disposeAllActivities();
        }, this);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this.fetchActivities(this._previewContext.get('model'), this._previewContext.get('collection'));
        this._super('_render');
    },

    /**
     * Fetch and render activities.
     *
     * @param {Data.Bean} model The {@link Data.Bean model} being previewed.
     * @param {Data.BeanCollection} collection The
     *   {@link Data.BeanCollection collection} of preview models.
     */
    fetchActivities: function(model, collection) {
        if (app.metadata.getModule(model.module).isBwcEnabled) {
            // don't fetch activities for BWC modules
            return;
        }
        this.disposeAllActivities();
        this.collection.dataFetched = false;
        this.$el.hide();

        this.collection.reset();
        this.collection.resetPagination();
        this.collection.setOption('endpoint', function(method, collection, options, callbacks) {
            var url = app.api.buildURL(model.module, null, {id: model.get('id'), link: 'activities'}, options.params);

            return app.api.call('read', url, null, callbacks);
        });
        this.collection.fetch({
            /*
             * Render activity stream
             */
            showAlerts: true,
            success: _.bind(this.renderActivities, this)
        });
    },

    /**
     * Render activity stream once the preview pane opens. Hide it when there are no activities.
     * @param collection
     */
    renderActivities: function(collection) {
        var self = this;
        if (this.disposed) {
            return;
        }

        if (collection.length) {
            collection.each(function(activity) {
                self.renderPost(activity, true);
            });
            this.$el.show();
        }
    },

    /**
     * No need to set collectionOptions.
     */
    setCollectionOptions: function() {},

    /**
     * No need to expose data transfer object since this activity stream is readonly.
     */
    exposeDataTransfer: function() {},

    /**
     * Don't load activity stream until 'preview:render' event has been fired.
     */
    loadData: function() {},

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.collection.on('add', function(activity) {
            if (!this.disposed) {
                this.renderPost(activity, true);
            }
        }, this);

        this._previewContext.on('change:model', this.render, this);
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this._previewContext.off('change:model', this.render, this);
        this._super('unbind');
    }
}) },
"footer-logos": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.FooterLayout
 * @alias SUGAR.App.view.layouts.BaseFooterLayout
 * @extends View.Layout
 */
({
	// Footer-logos Layout (base) 

    className: 'footer-item flex flex-row items-center',

    /**
     * Places all components within this layout inside `more-logos` div.
     *
     * @param {View.View|View.Layout} component View or layout component.
     * @override
     * @protected
     */
    _placeComponent: function(component) {
        this.$('.more-logos').append(component.el);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        // FiXME SC-5765 the logo should be a separate view, so we can update it based
        // on the re-render of this layout
        this.$('[data-metadata="logo"]').attr('src', app.metadata.getLogoUrl(app.utils.isDarkMode()));
        return this._super('_render');
    }
}) },
"side-drawer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SideDrawerLayout
 * @alias SUGAR.App.view.layouts.BaseSideDrawerLayout
 * @extends View.Layout
 */
({
	// Side-drawer Layout (base) 

    /**
     * @inheritdoc
     */
    className: 'side-drawer',

    /**
     * Function to be called once drawer is closed.
     * @property {Function}
     */
    onCloseCallback: null,

    /**
     * Current drawer state: 'opening', 'idle', 'closing', ''.
     * @property {string}
     */
    currentState: '',

    /**
     * Drawer configs.
     * @property {Object}
     */
    drawerConfigs: {
        // pixels between drawer's top and nav bar's bottom
        topPixels: 0,
        // pixels between drawer's bottom and footer's top
        bottomPixels: 0,
        // drawer's right in pixel or percentage
        right: 0,
        // drawer's left in pixel or percentage
        left: '25%',
    },

    /**
     * Main content of the App.
     * @property {Object}
     */
    $main: null,

    /**
     * Store breadcrumbs for the side-drawers being opened
     * @property {Array}
     */
    _breadcrumbs: [],

    /**
     * @inheritdoc
     */
    events: {
        'click [data-action=drawerClose]': 'close',
        'click [data-action=scroll]': 'switchRecord',
    },

    /**
     * Shortcuts.
     * @property {Array}
     */
    shortcuts: ['SideDrawer:Close'],

    /**
     * Flag indicating if close and edit actions may be performed or not at the moment.
     * @property {boolean}
     */
    areActionsEnabled: true,

    /**
     * Stores the context loaded in the drawer
     */
    currentContextDef: null,

    /**
     * Stores the context when the drawer was first opened
     */
    parentContextDef: null,

    /**
     * Flag indicating if the drawer is hidden or not
     * @property {boolean}
     */
    drawerHidden: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.$main = app.$contentEl.children().first();
        this.addDrawerHandler = _.bind(this.toggle, this);
        this.removeDrawerHandler = _.bind(this.toggle, this);
        this.resizeHandler = _.bind(this._resizeDrawer, this);
        this.$main.on('drawer:add.sidedrawer', this.addDrawerHandler);
        this.$main.on('drawer:remove.sidedrawer', this.removeDrawerHandler);
        $(window).on('resize.sidedrawer', this.resizeHandler);

        this.before('tabbed-dashboard:switch-tab', function(params) {
            var callback = _.bind(function() {
                this._close();
                if (params.callback && _.isFunction(params.callback)) {
                    params.callback.call(this);
                }
            }, this);

            if (this.hasUnsavedChanges(callback)) {
                return false;
            }
            this._close();
            return true;
        }, this);

        // Update the prev/next buttons when the list is paginated.
        this.on('sidedrawer:collection:change', function(newCollection) {
            let context = this.getParentContextDef('parentContext');
            if (!context) {
                return;
            }
            let collection = context.get('collection');
            if (!_.isEqual(collection, newCollection)) {
                return;
            }

            this.showPreviousNextBtnGroup();
            this.focusRow();
        }, this);

        if (!app.sideDrawer) {
            app.sideDrawer = this;
        }

        // Close the drawer when navigating to a new view
        app.before('app:view:load', function() {
            return this.close();
        }, this);

        // If the side drawer is on a tile view (not the global side drawer), make sure it is not visible
        if (this.layout && this.layout.name === 'filterpanel') {
            this.hide();
        }
    },

    /**
     * Config the drawer.
     * @param {Object} [configs={}] Drawer configs.
     */
    config: function(configs) {
        configs = configs || {};
        this.drawerConfigs = _.extend({}, this.drawerConfigs, configs);
        this.$el.css('top', $('#header .navbar').outerHeight() + this.drawerConfigs.topPixels);
        this.$el.css('height', this._determineDrawerHeight());
        this.$el.css('left', this.drawerConfigs.left);
        this.$el.css('right', this.drawerConfigs.right);
    },

    /**
     * Open the specified layout or view in this drawer.
     *
     * You can pass the current context if you want the context created to be a
     * child of that current context. If you don't pass a `scope`, it will
     * create a child of the main context (`app.controller.context`).
     *
     * @param {Object} def The component definition.
     * @param {Function} onClose Callback method when the drawer closes.
     * @param {boolean} sideDrawerClick True if the click originated from a side-drawer
     */
    open: function(def, onClose, sideDrawerClick) {
        // store the callback function to be called later
        this.onCloseCallback = onClose;

        if (sideDrawerClick) {
            this._breadcrumbs.push(def);
        } else {
            this._breadcrumbs = [def];
        }

        // open the drawer if not yet
        if (!this.isOpen()) {
            // Save the previous session to prevent overwriting it
            app.shortcuts.saveSession();
            app.shortcuts.createSession(this.shortcuts, this);
            this.registerShortcuts();

            this.currentState = 'opening';
            this.config();
            this.$el.show('slide', {direction: 'right'}, 300, _.bind(this.showComponent, this, def));
            this.currentState = 'idle';
        } else {
            this.showComponent(def);
        }

        let oldContext = this.getParentContextDef('parentContext');
        if (oldContext && !_.isEqual(oldContext, def.context.parentContext)) {
            oldContext.trigger('focusRow');
        }
        this.currentContextDef = def;
        if (!sideDrawerClick) {
            this.parentContextDef = def;
        }
        _.defer(function() {
            this.focusRow();
        }.bind(this));
        this.showPreviousNextBtnGroup();
    },

    /**
     * Focus (highlight) a list row
     * @param id (optional) the ID of the row to focus, or the current model ID if not specified
     */
    focusRow: function(id) {
        let parentContext = this.getParentContextDef('parentContext');
        if (parentContext) {
            id = id || this.getParentContextDef('baseModelId');
            if (id) {
                parentContext.trigger('focusRow', id);
            }
        }
    },

    /**
     * Unfocus (unhighlight) any highlighted list rows
     */
    unfocusRow: function() {
        let parentContext = this.getParentContextDef('parentContext');
        if (parentContext) {
            parentContext.trigger('unfocusRow');
        }
    },

    /**
     * Enable/disable the next/prev buttons
     */
    showPreviousNextBtnGroup: function() {
        let prevButton = this.$('[data-action-type="prev"]');
        let nextButton = this.$('[data-action-type="next"]');

        let context = this.getParentContextDef('parentContext');
        if (!context || app.utils.isTruthy(this.getParentContextDef('disableRecordSwitching'))) {
            this._setButtonState(prevButton, false);
            this._setButtonState(nextButton, false);
            return;
        }

        let listCollection = context.get('collection') || new app.data.createBeanCollection(this.module);
        if (listCollection.length !== 0) {
            let model = listCollection.get(this.getParentContextDef('baseModelId'));
            if (!model) {
                return;
            }

            this._findNextValidRow(listCollection, model, (hasNextModel, nextModel) => {
                this._setButtonState(nextButton, hasNextModel);
            });
            this._findPrevValidRow(listCollection, model, (hasPrevModel, prevModel) => {
                this._setButtonState(prevButton, hasPrevModel);
            });
        }
    },

    /**
     * Finds the previous valid row in the collection. A row is considered valid to switch to if:
     * 1. It exists at all
     * 2. The model ID for the linked record is set (catches empty relates)
     * 3. The module name for the linked record is set (catches empty flex relates)
     * 4. The user has access to the linked record
     * @param list
     * @param model
     * @param callback the callback is passed one parameter (false) if no valid previous row exists, and
     *                 two parameters (true, model) if one exists
     * @private
     */
    _findPrevValidRow: function(list, model, callback) {
        if (!list.hasPreviousModel(model)) {
            callback(false);
            return;
        }

        list.getPrev(model, prevModel => {
            if (!this._isValidModel(prevModel)) {
                this._findPrevValidRow(list, prevModel, callback);
            } else {
                callback(true, prevModel);
            }
        });
    },

    /**
     * Finds the next valid row in the collection. A row is considered valid to switch to if:
     * 1. It exists at all
     * 2. The current model is not the last in the currently loaded collection
     * 3. The model ID for the linked record is set (catches empty relates)
     * 4. The module name for the linked record is set (catches empty flex relates)
     * 5. The user has access to the linked record
     * @param list
     * @param model
     * @param callback the callback is passed one parameter (false) if no valid next row exists, and
     *                 two parameters (true, model) if one exists
     * @private
     */
    _findNextValidRow: function(list, model, callback) {
        if (!list.hasNextModel(model) || _.isEqual(list.at(-1), model)) {
            callback(false);
            return;
        }

        list.getNext(model, nextModel => {
            if (!this._isValidModel(nextModel)) {
                this._findNextValidRow(list, nextModel, callback);
            } else {
                callback(true, nextModel);
            }
        });
    },

    /**
     * Checks if the model can be shown in the side drawer
     * @param model
     * @return {boolean}
     * @private
     */
    _isValidModel: function(model) {
        let _isInvalidModel = this.context.get('_isInvalidModel');
        if (_.isFunction(_isInvalidModel) && _isInvalidModel(model)) {
            return false;
        }
        let modelId = this._getRelatedModelId(model);
        let moduleName = this._getRelatedModuleName(model);

        return !_.isEmpty(modelId) && !_.isEmpty(moduleName) && app.acl.hasAccessToModel('view', model);
    },

    /**
     * Sets the state of the prev or next buttons.
     * @param button
     * @param state true for enabled, false for disabled
     * @private
     */
    _setButtonState: function(button, state) {
        button.prop('disabled', !state);
        button.toggleClass('disabled', !state);
    },

    /**
     * Set up shortcuts for the side drawer
     */
    registerShortcuts: function() {
        // register shortcuts to close drawer
        app.shortcuts.register({
            id: 'SideDrawer:Close',
            keys: ['esc', 'mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $closeButton = this.$('button[data-action="close"]');
                if ($closeButton.is(':visible') && !$closeButton.hasClass('disabled')) {
                    $closeButton.click();
                }
            }
        });
    },

    /**
     * Show component in this drawer.
     *
     * @param {Object} def The component definition.
     */
    showComponent: function(def) {
        // remove old content
        if (this._components.length) {
            _.each(this._components, function(component) {
                component.dispose();
            }, this);
            this._components = [];
        }

        // initialize content definition components
        this._initializeComponentsFromDefinition(def);

        var component = _.last(this._components);
        if (component) {
            // load and render new content in drawer
            component.loadData();
            component.render();
        }
    },

    /**
     * Tell if the drawer is opened.
     * @return {boolean} True if open, false if not.
     */
    isOpen: function() {
        return this.currentState !== '';
    },

    /**
     * Show/hide the drawer.
     */
    toggle: function() {
        if (this.isOpen()) {
            this.$el.toggle();
        }
    },

    /**
     * Determines if there are any unsaved changes
     *
     * @param callback the callback
     * @return boolean true if has unsaved changes, false otherwise
     */
    hasUnsavedChanges: function(callback) {
        return !this.triggerBefore('side-drawer:close', {callback: callback});
    },

    /**
     * Check if it's okay to close the drawer before doing so.
     */
    close: function() {
        if (this.areActionsEnabled) {
            var _close = _.bind(this._close, this);
            if (this.hasUnsavedChanges(_close)) {
                return;
            }
            _close();

            this.currentContextDef = null;
            this.parentContextDef = null;
        }
    },

    /**
     * Close the drawer.
     *
     * @private
     */
    _close: function() {
        if (!this.$el) {
            return;
        }

        this.currentState = 'closing';
        this.$el.hide('slide', {direction: 'right'}, 300);
        this.currentState = '';
        this._breadcrumbs = [];
        this.drawerHidden = false;

        this.unfocusRow();

        // remove drawer content
        _.each(this._components, function(component) {
            component.dispose();
        }, this);
        this._components = [];

        // execute callback
        var callbackArgs = Array.prototype.slice.call(arguments, 0);
        if (this.onCloseCallback) {
            this.onCloseCallback.apply(window, callbackArgs);
        }
        app.shortcuts.restoreSession();
    },

    /**
     * Slide the drawer out of view without clearing the contents
     */
    slideOut: function() {
        if (this.disposed || this.isHidden()) {
            return;
        }
        this.drawerHidden = true;
        this.$el.hide('slide', {direction: 'right'}, 300);
    },

    /**
     * Slide the drawer into view without clearing the contents
     */
    slideIn: function() {
        if (this.disposed || !this.isHidden()) {
            return;
        }
        this.drawerHidden = false;
        this.$el.show('slide', {direction: 'right'}, 300);
    },

    /**
     * Returns if the drawer has been hidden
     * @return {boolean}
     */
    isHidden: function() {
        return app.utils.isTruthy(this.drawerHidden);
    },

    /**
     * Force to create a new context and create components from the layout/view
     * definition. If the parent context is defined, make the new context as a
     * child of the parent context.
     *
     * NOTE: this function is copied from drawer.js to have consistent behavior
     *
     * @param {Object} def The layout or view definition.
     * @private
     */
    _initializeComponentsFromDefinition: function(def) {
        var parentContext;
        def = def || {};

        if (_.isUndefined(def.context)) {
            def.context = {};
        }

        if (_.isUndefined(def.context.forceNew)) {
            def.context.forceNew = true;
        }

        if (!(def.context instanceof app.Context) && def.context.parent instanceof app.Context) {
            parentContext = def.context.parent;
            // remove the `parent` property to not mess up with the context attributes.
            delete def.context.parent;
        }

        this.initComponents([def], parentContext);
    },

    /**
     * Calculate the height of the drawer
     * @return {number}
     * @private
     */
    _determineDrawerHeight: function() {
        var windowHeight = $(window).height();
        var headerHeight = $('#header .navbar').outerHeight() + this.drawerConfigs.topPixels;
        var footerHeight = $('footer').outerHeight() + this.drawerConfigs.bottomPixels;

        return windowHeight - headerHeight - footerHeight;
    },

    /**
     * Resize the height of the drawer.
     * @private
     */
    _resizeDrawer: _.throttle(function() {
        if (this.disposed) {
            return;
        }
        // resize the drawer if it is opened.
        if (this.currentState === 'idle') {
            var drawerHeight = this._determineDrawerHeight();
            this.$el.css('height', drawerHeight);
        }
    }, 300),

    /**
     * @override
     */
    _placeComponent: function(component) {
        if (this.disposed) {
            return;
        }
        this.$el.find('.drawer-content').append(component.el);
    },

    /**
     * Handles click event on next/previous button of record.
     * @param {Event} evt
     */
    switchRecord: function(evt) {
        let context = this.getParentContextDef('parentContext');
        let list = context.get('collection');
        let baseModelId = this.getParentContextDef('baseModelId');
        let model = list.get(baseModelId);
        this._doSwitchRecord(model, evt.currentTarget.dataset.actionType);
    },

    /**
     * Switches the record displayed in the side drawer depending on direction and model
     * @param {Object} model
     * @param {string} actionType
     * @private
     */
    _doSwitchRecord: function(model, actionType) {
        let context = this.getParentContextDef('parentContext');
        let list = context.get('collection');

        if (actionType === 'next') {
            this._findNextValidRow(list, model, (hasNextModel, nextModel) => {
                if (hasNextModel) {
                    this.switchToAnotherModel(nextModel);
                }
            });
        } else if (actionType === 'prev') {
            this._findPrevValidRow(list, model, (hasPrevModel, prevModel) => {
                if (hasPrevModel) {
                    this.switchToAnotherModel(prevModel);
                }
            });
        }
    },

    /**
     * Changes the side drawer to a new model
     * @param model
     */
    switchToAnotherModel: function(model) {
        let def = this.getParentContextDef();
        def.context.baseModelId = model.get('id');

        // Get the correct module name and ID for the next record. The module name can vary, for
        // example with flex relate fields.
        def.context.module = this._getRelatedModuleName(model);
        def.context.modelId = this._getRelatedModelId(model);

        this.open(def);
    },

    /**
     * Gets the module name of the related record
     * @param model
     * @return {string}
     * @private
     */
    _getRelatedModuleName: function(model) {
        let fieldDefs = this.getParentContextDef('fieldDefs');
        switch (fieldDefs.type) {
            case 'name':
            case 'fullname':
                return model.get('_module');
            case 'relate':
                if (fieldDefs.module) {
                    return fieldDefs.module;
                }
                let link = fieldDefs.link && model.fields && model.fields[fieldDefs.link] || {};
                if (link.module) {
                    return link.module;
                }
                return app.data.getRelatedModule(model.module, fieldDefs.link);
            case 'parent':
                return model.get('parent_type');
            default:
                return '';
        }
    },

    /**
     * Gets the ID of the related record
     * @param model
     * @return {string}
     * @private
     */
    _getRelatedModelId: function(model) {
        let fieldDefs = this.getParentContextDef('fieldDefs');
        switch (fieldDefs.type) {
            case 'name':
            case 'fullname':
                return model.get('id');
            case 'relate':
                return model.get(fieldDefs.id_name);
            case 'parent':
                return model.get('parent_id');
            default:
                return '';
        }
    },

    /**
     * Getter for this.parentContextDef. Supports passing a key to return value from context
     * @param {string} key
     * @return {null|Object|*}
     */
    getParentContextDef: function(key) {
        if (key) {
            if (this.parentContextDef && this.parentContextDef.context) {
                return this.parentContextDef.context[key];
            }
        }
        return this.parentContextDef;
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.$main.off('drawer:add.sidedrawer', this.addDrawerHandler);
        this.$main.off('drawer:remove.sidedrawer', this.removeDrawerHandler);
        $(window).off('resize.sidedrawer', this.resizeHandler);
        this._super('_dispose');
    },
}) },
"base": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The Base Layout that all Layouts should extend from before extending
 * {@link #View.Layout}.
 *
 * Use this controller to specify your customizations for the Base platform.
 * This should contain any special override that only applies to Base platform
 * and not to Sidecar's library.
 *
 * Any Layout in a module can skip the default fallback and extend this one
 * directly. In your `BaseModuleMyLayout` component that lives in the file
 * `modules/<module>/clients/base/layouts/my-layout/my-layout.js`, you can
 * directly extend the `BaseLayout` skipping the normal extend flow which will
 * extend automatically from `BaseMyLayout` that might live in
 * `clients/base/layouts/my-layout/my-layout.js`. Simply define your controller
 * with:
 *
 * ```
 * ({
	// Base Layout (base) 

 *     extendsFrom: 'BaseLayout',
 *     // ...
 * })
 * ```
 *
 * This controller exists to force the component to be created and not fallback
 * to the default flow (which happens when the component isn't found).
 *
 * @class View.Layouts.Base.BaseLayout
 * @alias SUGAR.App.view.layouts.BaseBaseLayout
 * @extends View.Layout
 */
({
    /**
     * The Base Layout will always clear any tooltips after `render` or `dispose`.
     */
    initialize: function() {
        this._super('initialize', arguments);
        if (app.tooltip) {
            this.on('render', app.tooltip.clear);
        }
    }
}) },
"dashlet-row": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletRowLayout
 * @alias SUGAR.App.view.layouts.BaseDashletRowLayout
 * @extends View.Layout
 */
({
	// Dashlet-row Layout (base) 

    tagName: 'li',

    events: {
        'click .remove-row': 'removeClicked'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.index = options.meta.index;
        options.meta = this.setMetadata(options.meta);

        this._super('initialize', [options]);

        this.model.on("setMode", this.setMode, this);
        this.model.on("applyDragAndDrop", this.applyDragAndDrop, this);
        this.setMode(this.model.mode);
    },

    /**
     * Updates and sets metadata based on the meta param
     * @param {Object} meta
     * @return {Object} meta
     */
    setMetadata: function(meta) {
        meta.components = meta.components || [];
        _.each(meta.components, function(component, index){
            meta.components[index] = {
                layout: {
                    type : 'dashlet-cell',
                    index : this.index + '' + index,
                    components: component
                }
            };
        }, this);

        var addRowDashlet = {
            layout: {
                type: 'dashlet',
                index: this.index + '' + meta.components.length,
                empty: true,
                components: [
                    {
                        view: 'dashlet-row-empty',
                        context: {
                            module:'Home',
                            forceNew:true,
                            create:true
                        }
                    }
                ]
            }
        };
        meta.components.push(addRowDashlet);
        if(meta.css_class) meta.css_class += ' ';
        meta.css_class = 'span' + (meta.width || 12);
        return meta;
    },

    /**
     * @inheritdoc
     */
    _placeComponent: function(comp, def, prepend) {
        var nameId = 'dashlet_';
        var $body = this.$el.children(".dashlet-row");

        // If this is the last row of the dashlet list, mark it as such
        if (def.layout.empty) {
            nameId += 'last_';
        }

        // Now add the dashlet index
        nameId += comp.index;

        if($body.length === 0) {
            $body = $("<ul></ul>").addClass("dashlet-row");
            this.$el.append($body);
        }

        var headerTemplate = app.template.getLayout(this.name + '.header') || app.template.empty,
            $container = $("<div></div>", {'class': 'rows well well-invisible'})
                .append(headerTemplate())
                .append(comp.el),
            $el = $('<li></li>', {
                'class': 'row-fluid',
                'data-sortable': '1',
                'name': nameId
            }).data('index', function() {
                return comp.index + '';
            }).append($container);

        if(prepend) {
            $body.children("li:last").before($el);
        } else {
            $body.append($el);
        }
    },

    /**
     * @inheritdoc
     */
    addComponent: function(component, def) {
        if(this.prependComponent) {
            if (!component.layout) component.layout = this;
            this._components.splice(this._components.length - 1, 0, component);
            this._placeComponent(component, def, true);
            this.prependComponent = false;
        } else {
            this._super('addComponent', [component, def]);
        }
    },

    /**
     * Gets component from metadata.
     *
     * @param {Object} metadata for all dashboard components
     * @return {Object} dashboard component
     */
    getComponentsFromMetadata: function(metadata) {
        var component;
        // this is a tabbed dashboard
        if (metadata.tabs) {
            var tabIndex = this.context.get('activeTab') || 0;
            component = metadata.tabs[tabIndex].components;
        } else {
            component = metadata.components;
        }
        return component;
    },

    /**
     * Adds a row to the dashboard
     *
     * @param {Number} columns the number of columns in this row
     */
    addRow: function(columns) {
        var span = 12 / columns,
            components = [];
        _.times(columns, function() {
            components.push({
                width: span
            });
        });
        var metadata = this.model.get('metadata'),
            position = this.index.split(''),
            component = this.getComponentsFromMetadata(metadata);
        _.each(position, function(index){
            component = component.rows ? component.rows[index] : component[index];
        }, this);
        component.rows.push(app.utils.deepCopy(components));
        this.model.set("metadata", metadata, {silent: true});
        this.model.trigger("change:layout");

        this.prependComponent = true;
        _.each(this._components, function(component){
            component.index++;
        }, this);
        this._addComponentsFromDef([{
            layout: {
                type : 'dashlet-cell',
                index: this.index + '' + (this._components.length - 1),
                components: components
            }
        }]);
        _.each(this._components, function(component, index){
            component.index = this.index + '' + index;
        }, this);

        //init components of the most recently created row
        this._components[this._components.length-2].initComponents();

        this.setMode(this.model.mode);
    },

    /**
     * Displays a confirmation alert when removing a row.
     *
     * @param {Event} evt The `click` event.
     */
    removeClicked: function(evt) {
        var cell = $(evt.currentTarget).closest('.row-fluid'),
            index = (cell.data('index')()).split('').pop();
        if (!cell.find('[data-dashlet]').length) {
            this.removeRow(index);
            return;
        }
        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_REMOVE_DASHLET_ROW_CONFIRM', this.module),
            onConfirm: _.bind(function() {
                this.removeRow(index);
            }, this)
        });
    },

    /**
     * Removes a row.
     *
     * @param {Number} index The index of the row to remove.
     */
    removeRow: function(index) {
        var metadata = this.model.get("metadata"),
            position = this.index.split(''),
            component = this.getComponentsFromMetadata(metadata);
        _.each(position, function(index){
            component = component.rows ? component.rows[index] : component[index];
        }, this);
        component.rows.splice(index, 1);
        this._components[index].dispose();
        this._components.splice(index, 1);
        _.each(this._components, function(component, index) {
            // Update each row,
            component.index = this.index + '' + index;
            // And each cell of each row.
            _.each(component._components, function(cell, cellIndex) {
                cell.index = component.index + '' + cellIndex;
            });
        }, this);

        this.model.set("metadata", app.utils.deepCopy(metadata), {silent: true});
        this.model.trigger("change:layout");
        this.$el.children(".dashlet-row").children("li:eq(" + index + ")").remove();
    },

    /**
     * @inheritdoc
     */
    setMode: function(type) {
        if(type === 'edit' || (this.model._previousMode === 'edit' && type === 'drag')) {
            this.$el.children(".dashlet-row").sortable("enable");
            this.$el.children(".dashlet-row").children("li").not(":last").addClass("sortable").children(".rows").removeClass("well-invisible").children(".btn-link").toggleClass("hide", false);
        } else {
            this.$el.children(".dashlet-row").sortable("disable");
            this.$el.children(".dashlet-row").children("li").not(":last").addClass("sortable").children(".rows").addClass("well-invisible").children(".btn-link").toggleClass("hide", true);
        }
    },

    /**
     * Adds drag-and-drop functionality to the row
     */
    applyDragAndDrop: function() {
        var self = this;
        this.$el.children(".dashlet-row").sortable({
            axis: "y",
            items: "li.sortable",
            handle: ".move",
            forcePlaceholderSize: true,
            placeholder: "placeholder",
            update: function(event, ui) {
                var sourceIndex = ui.item.first().data('index')(),
                    targetIndex = ui.item.first().next().data('index')();

                self.switchComponent(targetIndex, sourceIndex);
            }
        });
        this.setMode(this.model.mode);
    },

    /**
     * Switch the places of two components
     *
     * @param {String} target key
     * @param {String} source key
     */
    switchComponent: function(target, source) {
        var metadata = this.model.get("metadata"),
            position = this.index.split(''),
            component = metadata.components,
            targetIndex = target.split('').pop(),
            sourceIndex = source.split('').pop();
        _.each(position, function(index){
            component = component.rows ? component.rows[index] : component[index];
        }, this);

        var sourceMetadata = component.rows[sourceIndex],
            sourceComponent = this._components[sourceIndex];

        if(sourceIndex > targetIndex) {
            //dragging up
            component.rows.splice(sourceIndex, 1);
            component.rows.splice(targetIndex, 0, sourceMetadata);

            this._components.splice(sourceIndex, 1);
            this._components.splice(targetIndex, 0, sourceComponent);
        } else {
            //dragging down
            component.rows.splice(targetIndex, 0, sourceMetadata);
            component.rows.splice(sourceIndex, 1);

            this._components.splice(targetIndex, 0, sourceComponent);
            this._components.splice(sourceIndex, 1);
        }

        _.each(this._components, function(component, index) {
            component.index = this.index + '' + index;
        }, this);

        this.model.set('metadata', app.utils.deepCopy(metadata), {silent: true});
        this.model.trigger('change:layout');
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        var $dashletRowChildren = this.$el.children('.dashlet-row');
        _.each($dashletRowChildren, function(child) {
            var $child = $(child);
            if (!_.isUndefined($child.sortable('instance'))) {
                $child.sortable('destroy');
            }
        });
        this.model.off('applyDragAndDrop', null, this);
        this.model.off('setMode', null, this);
        this._super('_dispose');
    }
}) },
"header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.HeaderLayout
 * @alias SUGAR.App.view.layouts.BaseHeaderLayout
 * @extends View.Layout
 */
({
	// Header Layout (base) 

    cache: null,

    /**
     * Listen to events to resize the header to fit the browser width
     * @param options
     */
    initialize: function(options) {
        this.cache = app[app.config.authStore || 'cache'];

        app.view.Layout.prototype.initialize.call(this, options);
        this.on('header:update:route', this.resize, this);
        app.events.on('app:view:change', this.resize, this);
        // Event listeners for showing and hiding the megamenu on auth expiration
        app.events.on('app:login', this.hide, this);
        app.events.on('app:login:success', this.show, this);

        var resize = _.bind(this.resize, this);
        $(window)
            .off('resize.header')
            .on('resize.header', resize);

        if (this.cache.has('ImpersonationFor')) {
            app.$rootEl.addClass('banner-shifted');
            $('#nprogress').addClass('banner-shifted');
        }
    },

    /**
     * Places all components within this layout inside nav-collapse div
     * @param component
     * @private
     */
    _placeComponent: function(component) {
        this.$el.find('.nav-collapse').append(component.$el);
    },

    /**
     * Calculates the width that the module list should resize to and triggers an event
     * that tells the module list to resize
     */
    resize: function() {
        var resizeWidth = this.getModuleListWidth();
        this.trigger('view:resize', resizeWidth);
    },

    /**
     * Returns the calculated module list width.
     * @return {number}
     */
    getModuleListWidth: function() {
        var maxMenuWidth = $(window).width();
        var totalWidth = 0;

        _.each(this._components, function(component) {
            if (component.name !== 'module-list') {
                // only calculate width for visible components
                if (component.$el.is(':visible')) {
                    totalWidth += component.$el.outerWidth(true);
                }
            }
        });
        return maxMenuWidth - totalWidth;
    },

    /**
     * Returns the minimum module list width.
     * @return {number}
     */
    getModuleListMinWidth: function() {
        var moduleListView = this.getComponent('module-list');
        if (moduleListView) {
            return moduleListView.computeMinWidth();
        }
    },

    /**
     * Sets whether or not the module-list should listen to the window resize.
     * @param {boolean} resize
     */
    setModuleListResize: function(resize) {
        this.getComponent('module-list').toggleResize(resize);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        // If we are authenticated show the megamenu
        if (app.api.isAuthenticated()) {
            this.show();
        } else {
            this.hide();
        }
    },

    /**
     * @inheritdoc
     */
    show: function() {
        this._super('show');
        this.resize();
    }
}) },
"audit": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Audit Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: ['AuditHeaderPanel:Close']
}) },
"default": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DefaultLayout
 * @alias SUGAR.App.view.layouts.BaseDefaultLayout
 * @extends View.Layout
 */
/**
 * Some events have been deprecated in 7.2 and removed.
 * List of changes:
 *
 * - `toggleSidebar` has been migrated to `sidebar:toggle`. It allows one param
 *    to indicate the state. {@link Layout.Default#toggleSidePane}
 *
 * - `openSidebar` has been removed. You can open the sidebar by triggering
 *    `sidebar:toggle` and passing `true`. Note that you can also close the
 *    sidebar by triggering `sidebar:toggle` and passing `false`.
 *
 * - `toggleSidebarArrows` has been removed. Trigger `sidebar:state:changed`
 *    with the value `open` or `close` instead.
 *
 * - `openSidebarArrows` has been removed. Trigger `sidebar:state:changed` with
 *    the value `open` instead.
 */
({
	// Default Layout (base) 

    className: 'row-fluid',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        /**
         * Name of the last state. This can be overridden in metadata, please
         * refer to the example.
         *
         * Example:
         *
         *     array(
         *          'default_hide' => '1',
         *          'hide_key' => 'hide-merge',
         *     ),
         *
         * @cfg {String}
         */
        this.HIDE_KEY = 'hide';

        /**
         * Default value for hiding the sidepane. `1` is hidden, `0` is show.
         * This is because the code which retrieves data from local storage
         * checks the value of the data and will return undefined if the result
         * resolves to a boolean false.
         *
         * Since an undefined hide value means "use the default" and int 0 means
         * show, but they both resolve to false, this causes complications. As a
         * result, we have to use a string.
         *
         * Using a string `0` or `1` is superior to something like "yes" and
         * "no" because we can use parseInt instead of an if/else setup.
         *
         * This setting can be overridden in metadata, please refer to the
         * example.
         *
         * Example:
         *
         *     array(
         *          'default_hide' => '1',
         *          'hide_key' => 'hide-merge',
         *     ),
         *
         * @property {String}
         * @protected
         */
        this._defaultHide = '0';

        /**
         * Key for storing the last state. This key is used in localstorage of the
         * browser. It is generated using `HIDE_KEY`
         *
         * Example:
         *
         *     state:Accounts:default:hide_last_state_key
         *
         *
         * @property {String}
         * @protected
         */
        this._hideLastStateKey = null;

        this._super('initialize', [options]);
        if (!_.isUndefined(this.meta.default_hide)) {
            this._defaultHide = this.meta.default_hide;
        }
        if (!_.isUndefined(this.meta.hide_key)) {
            this.HIDE_KEY = this.meta.hide_key;
        }

        this.on('sidebar:toggle', this.toggleSidePane, this);

        this.meta.last_state = this.meta.last_state || { id: 'default' };

        this._hideLastStateKey = app.user.lastState.key(this.HIDE_KEY, this);

        //Update the panel to be open or closed depending on how user left it last
        this._toggleVisibility(this.isSidePaneVisible());
    },

    /**
     * Check whether the side pane is currently visible.
     *
     * @return {Boolean} `true` if visible, `false` otherwise.
     */
    isSidePaneVisible: function() {
        var hideLastState = app.user.lastState.get(this._hideLastStateKey);
        var hidden = hideLastState || this._defaultHide;
        return !parseInt(hidden, 10);
    },

    /**
     * Toggle sidebar and save the current state.
     *
     * Both the hidden and show state is stored. In the default configuration,
     * the side pane is `visible`.
     * In the non-default case, the hidden state is represented by `0`, and the
     * show state is represented by `1`.
     *
     * @param {Boolean} [visible] Pass `true` to show the sidepane, `false` to
     *  hide it, otherwise will toggle the current state.
     */
    toggleSidePane: function(visible) {
        var isVisible = this.isSidePaneVisible();

        visible = _.isUndefined(visible) ? !isVisible : visible;

        if (isVisible === visible) {
            return;
        }

        app.user.lastState.set(
            this._hideLastStateKey,
            visible ? '0' : '1'
        );

        this._toggleVisibility(visible);
    },

    /**
     * Toggle visibility of the side pane.
     *
     * Toggling visibility can affect the content width in the same way as a
     * window resize. Thus we will trigger window `resize` so that any content
     * listening for a window `resize` can readjust themselves.
     *
     * @param {Boolean} visible `true` to show the side pane, `false` otherwise.
     * @private
     */
    _toggleVisibility: function(visible) {
        var state = visible ? 'open' : 'close';
        this.$('.main-pane').toggleClass('span12', !visible).toggleClass('span8', visible);

        this.$('.side').toggleClass('side-collapsed', !visible);

        $(window).trigger('resize');

        // let the rest of the app know if the sidebar changed state
        app.events.trigger('sidebar:state:changed', state);
        this.trigger('sidebar:state:changed', state);
    },

    /**
     * Get the width of either the main or side pane depending upon where the
     * component resides.
     *
     * @param {View.Component} component The component.
     * @return {Number} The component width.
     */
    getPaneWidth: function(component) {
        if (!this.$el) {
            return 0;
        }
        var paneSelectors = ['.main-pane', '.side'];
        var pane = _.find(paneSelectors, function(selector) {
                var $pane = this.$(selector).get(0);
                return $pane && $.contains($pane, component.el);
            }, this);

        return this.$(pane).width() || 0;
    }
}) },
"records": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Records Layout (base) 

    plugins: ['ShortcutSession', 'MappableList', 'ConfigDrivenList'],

    shortcuts: [
        'Sidebar:Toggle',
        'List:Headerpane:Create',
        'List:Select:Down',
        'List:Select:Up',
        'List:Scroll:Left',
        'List:Scroll:Right',
        'List:Select:Open',
        'List:Inline:Edit',
        'List:Delete',
        'List:Inline:Cancel',
        'List:Inline:Save',
        'List:Favorite',
        'List:Follow',
        'List:Preview',
        'List:Select',
        'SelectAll:Checkbox',
        'SelectAll:Dropdown',
        'Filter:Search',
        'Filter:Create',
        'Filter:Edit',
        'Filter:Show'
    ]
}) },
"panel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.PanelLayout
 * @alias SUGAR.App.view.layouts.BasePanelLayout
 * @extends View.Layout
 */
({
	// Panel Layout (base) 

    /**
     * @inheritdoc
     */
    className: 'filtered tabbable tabs-left',

    // "Hide/Show" state per panel
    HIDE_SHOW_KEY: 'hide-show',
    HIDE_SHOW: {
        HIDE: 'hide',
        SHOW: 'show'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initPanelState();
    },

    /**
     * Sets the `collapsed` state of the panel's context, depending on if
     * `app.config.collapseSubpanels` is configured or if the panel was
     * previously shown/hidden.
     *
     * @protected
     */
    _initPanelState: function() {
        var collapse;
        this.hideShowLastStateKey = app.user.lastState.key(this.HIDE_SHOW_KEY, this);

        if (app.config.collapseSubpanels) {
            collapse = true;
        } else {
            var hideShowLastState = app.user.lastState.get(this.hideShowLastStateKey);
            collapse = _.isUndefined(hideShowLastState) || hideShowLastState !== this.HIDE_SHOW.SHOW;
        }
        this.context.set('collapsed', collapse);
    },

    /**
     * @inheritdoc
     *
     * Decorate the subpanel based on if the collection is empty or not.
     *
     * When context is reloaded, we open the panel only if `skipFetch` is
     * `false`.
     *
     * When the context's collapse attribute changes, we confirm that the
     * panel's status is in sync with the flag (expanded/collapsed).
     */
    bindDataChange: function() {
        this.listenTo(this.collection, 'reset add remove', function() {
            this.$('.subpanel').toggleClass('empty', this.collection.length === 0);
        }, this);

        this.listenTo(this.context, 'refresh:count', function(hasAtLeast, properties) {
            if (!_.isEmpty(properties)) {
                this.$('.subpanel').toggleClass('empty', !properties.length);
            }
        }, this);

        this.listenTo(this.context.parent, 'panel-top:refresh', function(link) {
            app.logger.warn('`panel-top:refresh` is deprecated. Use `context.reloadData()` to reload and expand.');
            if (this.context.get('link') === link) {
                this.context.resetLoadFlag();
                this.toggle(true);
            }
        });

        this.listenTo(this.context, 'reload', function() {
            if (!this.context.get('skipFetch')) {
                this.toggle(true);
            }
        });

        this.listenTo(this.context, 'change:collapsed', function(context, collapsed) {
            this.toggle(!collapsed);
        });
    },

    /**
     * Places layout component in the DOM.
     * @override
     * @param {Component} component
     */
    _placeComponent: function(component) {
        this.$(".subpanel").append(component.el);
    },

    /**
     * Renders the `panel-top` component if the subpanel is in a collapsed
     * state, otherwise renders the subpanel.
     */
    _render: function() {
        var collapsed = this.context.get('collapsed');
        if (collapsed) {
            // FIXME: We're assuming that the first component is always the
            // panel-top. This should be fixed when panel-top-create is removed
            // from core in SC-4535.
            this._components[0].render();
        } else {
            /**
             * Internal flag used to determine if we are rendering the
             * component(s) in the panel layout for the first time.
             *
             * @protected
             * @property {boolean}
             */
            this._canToggle = true;
            this._super('_render');
        }

        this.$el.attr({
            'data-subpanel-link': this.options.context.get('link')
        });
        this.$('.subpanel').toggleClass('closed', collapsed);
    },

    /**
     * Saves the collapsed/expanded state of the subpanel in localStorage.
     *
     * @private
     * @param {boolean} [show] `true` to expand, `false` to collapse. Collapses
     *   by default.
     */
    _setCollapsedState: function(show) {
        var state = show ? this.HIDE_SHOW.SHOW : this.HIDE_SHOW.HIDE;
        app.user.lastState.set(this.hideShowLastStateKey, state);
    },

    /**
     * Toggles the panel.
     *
     * @private
     * @param {boolean} [show] `true` to show, `false` to hide, `undefined` to
     *   toggle.
     */
    toggle: function(show) {
        if (this.context.get('isCreateSubpanel')) {
            // no toggle available on create
            return;
        }

        show = _.isUndefined(show) ? this.context.get('collapsed') : show;

        this.$('.subpanel').toggleClass('closed', !show);
        this.context.set('collapsed', !show);
        this._toggleComponents(show);

        // no longer need to skip
        this.context.set('skipFetch', false);
        this.context.loadData();

        this._setCollapsedState(show);
    },

    /**
     * Show or hide component except `panel-top`(subpanel-header) component.
     *
     * @private
     * @param {boolean} [show] `true` to show, `false` to hide. Defaults to
     *   `false`.
     */
    _toggleComponents: function(show) {
        _.each(this._components, function(component) {
            // FIXME: The layout should not be responsible for this. Will be
            // addressed as part of SC-4533.
            if (this._stopComponentToggle(component)) {
                return;
            }
            if (!this._canToggle) {
                component.render();
            } else if (show) {
                component.show();
            } else {
                component.hide();
            }
        }, this);
        this._canToggle = true;
    },

    /**
     * Extensible check to see if this component should be allowed to be toggled.
     * If this returns true: _toggleComponent will return without further render/show/hide checks
     * If this returns false: _toggleComponent will continue through render/show/hide checks
     *
     * @param component
     * @return {boolean}
     * @private
     */
    _stopComponentToggle: function(component) {
        return component.$el.hasClass('subpanel-header');
    }
}) },
"dashboard-grid": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashboardGridLayout
 * @alias SUGAR.App.view.layouts.BaseDashboardGridLayout
 * @extends View.Layout
 */
({
	// Dashboard-grid Layout (base) 

    /**
     * Class applied to HTML element that holds the dashlet grid
     */
    className: 'dashboard-grid relative mx-2',

    /**
     * Event listeners
     */
    events: {
        'click .empty-create-button': 'addDashletClicked'
    },

    /**
     * Reference to the grid managed by this controller
     */
    grid: null,

    /**
     * Options passed to the grid during initialization.
     *
     * see https://github.com/gridstack/gridstack.js/tree/develop/doc#grid-options
     */
    defaultGridOptions: {
        handleClass: 'dashlet-header',
        animate: 'true',
        maxRow: 0, // 0 means no maximum
        minRow: 1,
        verticalMargin: 15,
        cellHeight: 34,
        disableOneColumnMode: true,
        draggable: {
            handle: '.dashlet-header',
            scroll: false,
            appendTo: 'body',
            containment: null,
            cancel: 'input,textarea,button,select,option,[role="button"]'
        },
        resizable: {
            handles: 'sw,se'
        }
    },

    /**
     * Flag to know if dashlets have been loaded into the grid
     */
    dashletsLoaded: false,

    /**
     * Flag to know if grid events have been bound
     *
     * This prevents duplicate grid event bindings if dashletsLoaded
     * was changed to force dashlet reload
     */
    gridEventsBound: false,

    /**
     * Default options passed to each dashlet container when initilizing the grid
     * item that holds it.
     *
     * see https://github.com/gridstack/gridstack.js/tree/develop/doc#item-options
     */
    defaultElementOptions: {
        autoPosition: false,
        x: 0,
        y: 0,
        width: 12,
        minWidth: 2,
        minHeight: 5,
        height: 6,
    },

    /**
     * Index to track which tab of a tabbed dashboard we're looking at.
     */
    tabIndex: -1,

    /**
     * Collection of dashlet metadata. For tabbed dashboards, this is initialized
     * to the dashlets for our current tab index. For non-tabbed dashboards, this
     * is the dashlets saved on the Dashboard's metadata
     */
    dashlets: [],

    /**
     * Get the current tab index, set this.dashlets to the initial dashlets,
     * and initialize our grid.
     *
     * @inheritdoc
     * @param {Object} options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._setDefaultGridOptions();
        this._setDefaultElementOptions();
        this.tabIndex = this._getTabIndex(options);
        this._setInitialDashlets();

        if (this.isSearchContext()) {
            this._setupSearchDashboard();
        }

        try {
            this.grid = GridStack.init(this._getGridOptions(), this.el);
        } catch (e) {
            console.warn('failed to load gridstack');
        }

        // This property is used by existing dashboards to apply legacy drag/drop
        // functionality that we no longer want.
        this.model.set('drag_and_drop', false);
    },

    /**
     * Get grid options.
     * @return {Object}
     * @private
     */
    _getGridOptions: function() {
        var gridOptions = _.extend({}, this.defaultGridOptions);
        if (this.context.parent && this.context.parent.get('readonly')) {
            gridOptions = _.extend(gridOptions, {disableDrag: true, disableResize: true});
        }
        return gridOptions;
    },

    /**
     * @inheritdoc
     * @private
     */
    _render: function() {
        this._super('render');
        // We load dashlets on render, because the DOM element holding the grid
        // needs to be in place before we add elements to it to properly size
        // and position the dashlets
        if (!this.dashletsLoaded) {
            this.loadDashlets();
            this.dashletsLoaded = true;

            // only bind grid events after the initial load
            if (!this.gridEventsBound) {
                this.bindGridEvents();
                this.gridEventsBound = true;
            }
        }
        this.grid.$el.toggleClass('grid-stack-empty', this.grid.isAreaEmpty());
    },

    /**
     * Indicates if we are in the search page or not.
     *
     * @return {boolean} `true` means we are in the search page.
     */
    isSearchContext: function() {
        return this.context.parent && this.context.parent.get('search');
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.isSearchContext()) {
            return;
        }

        this._super('bindDataChange');
        this.context.on('button:add_dashlet_button:click', this.addDashletClicked, this);
    },

    /**
     * Bind GridStack events
     */
    bindGridEvents: function() {
        /* The search's filter dashboard is a special dashboard:
           1. It's not saved in database by design.
           2. User can't add/remove dashlets.
           3. When dashlet is resized/moved, the dashboard shouldn't be saved since it doesn't exist in the database.
         */
        if (this.isSearchContext()) {
            return;
        }

        // to prevent a race condition, only save after the last save-able event has arrived
        var debouncedSave = _.debounce(_.bind(this.handleSave, this), 100);

        this.grid.on('removed', _.bind(function(event, items) {
            debouncedSave();
        }, this));

        // This event is fired on drag, drop, resize, or adding elements
        // from the grid
        this.grid.on('change', _.bind(function(event, items) {
            this._handleGridChange(event, items);
            debouncedSave();
        }, this));
    },

    /**
     * Load dashlets from the metadata into the grid. If our metadata changed
     * during load due to an element being auto-positioned, save.
     */
    loadDashlets: function() {
        var changed = false;
        var oldmeta;
        _.each(this.dashlets, function(dashletMeta, index) {
            oldmeta = this.dashlets[index];
            _.extend(this.dashlets[index], this.addDashlet(dashletMeta));
            if (!_.isEqual(oldmeta, this.dashlets[index])) {
                changed = true;
            }
        }, this);
        if (changed) {
            this.handleSave();
        }
    },

    /**
     * Create a dashboard-grid container from the dashlet metadata passed in, and
     * add it to the grid
     *
     * @param {Object} dashletDef dashlet metadata
     * @return {Object} dashlet metadata updated after being added to the grid
     */
    addDashlet: function(dashletDef) {
        // Components are indexed in the order they're added for reference later
        var dashletGridWrapper = this._initializeDashlet(dashletDef);

        // Obtain a copy of the default options so we can extend them without
        // changing object-level defaults
        var defaultOptions = app.utils.deepCopy(this.defaultElementOptions);
        var options = _.extendOwn(defaultOptions, dashletDef);

        // Generate a UUID for components to be stored with metadata so each
        // dashlet can be uniquely ID'd both on the frontend and in the DB
        options.id = options.id || app.utils.generateUUID();

        // Depending on the options set above for positioning, the dashlet
        // metadata may need to be updated after being added to the grid
        var widget = this.grid.addWidget(dashletGridWrapper.el, options);
        dashletDef = _.extend(dashletDef, this._getWidgetAttributes(widget));
        return dashletDef;
    },

    /**
     * Opens dashlet select drawer to allow users to add dashlets to the layout
     * @param {Event} evt
     */
    addDashletClicked: function(evt) {
        var self = this;
        app.drawer.open({
            layout: 'dashletselect',
            context: this.context
        }, function(model) {
            if (!model) {
                return;
            }
            var conf = model.toJSON();
            var ctx = {module: model.get('module')};
            if (model.get('link')) {
                ctx.link = model.get('link');
            }
            var dashletDef = {
                context: ctx
            };
            var type = conf.componentType;
            delete conf.config;
            delete conf.componentType;
            if (_.isEmpty(dashletDef.context.module) && _.isEmpty(dashletDef.context.link)) {
                delete dashletDef.context;
            }
            // use deepCopy to get rid of any undefined attributes that may
            // cause the Unsaved data warning.
            dashletDef[type] = app.utils.deepCopy(conf);
            self.addNewDashlet(dashletDef);
        });
    },

    /**
     * Called when adding a new dashlet to the layout. This sets new dashlets
     * to autoposition themselves, then unsets the autoposition property so
     * future page loads will respect the user's positioning.
     *
     * @param {Object} dashletDef dashlet metadata
     */
    addNewDashlet: function(dashletDef) {
        dashletDef.autoPosition = true;
        dashletDef = this.addDashlet(dashletDef);
        dashletDef.autoPosition = false;
        this.dashlets.push(dashletDef);
        this.handleSave();
    },

    /**
     * Removes a dashlet from the grid
     *
     * @param {View.Layout} dashlet Backbone layout holding our dashlet
     */
    removeDashlet: function(dashlet) {
        // We use the unique ID to get its index in our components list and
        // dashlet metadata collection so we can remove the correct dashlet
        // from each
        var id = dashlet.el.getAttribute('data-gs-id');
        var index = _.findIndex(this.dashlets, function(dashletDef) {
            return dashletDef.id === id;
        });
        this.dashlets.splice(index, 1);
        this._components.splice(index, 1);

        // this action should be performed after splicing the old dashlet
        // to prevent re-saving it on the grid
        this.grid.removeWidget(dashlet.el);

        dashlet.model.unset('updated');
    },

    collapseDashlet: function(dashlet) {
        var grid = this.grid;
        var el = dashlet.$el;
        var isCollapsed = el.hasClass('collapsed');
        var node = el.data('_gridstack_node');

        if (isCollapsed) {
            el
                .data('expand-min-height', node.minHeight)
                .data('expand-height', node.height);

            grid
                .resizable(el, false)
                .minHeight(el, null)
                .resize(el, null, 0);
        } else {
            grid
                .minHeight(el, el.data('expand-min-height'))
                .resize(el, null, el.data('expand-height'));
            if (!this.isSearchContext()) {
                grid.resizable(el, true);
            }
        }
    },

    /**
     * Called when clicking "Edit" in the gear menu on a dashlet. Updates the
     * dashlet metadata and saves most recent user preferences
     *
     * @param {View.Layout} dashlet Backbone layout holding our dashlet
     * @param {Object} newDashletDef Updated metadata
     */
    editDashlet: function(dashlet, newDashletDef) {
        var id = dashlet.el.getAttribute('data-gs-id');
        var index = _.findIndex(this.dashlets, function(dashletDef) {
            return dashletDef.id === id;
        });
        _.extend(this.dashlets[index], newDashletDef);
        this.handleSave();
    },

    /**
     * Saves current model metadata
     */
    handleSave: function() {
        if (!app.acl.hasAccessToModel('edit', this.model)) {
            this.model.unset('updated');
            return;
        }
        _.each(this.dashlets, function(dashletDef, i) {
            if (dashletDef.view && dashletDef.view.type === 'dashablerecord') {
                var newDef = app.utils.deepCopy(dashletDef);
                _.each(newDef.view.tabs, function(tab, i) {
                    delete newDef.view.tabs[i].meta;
                    delete newDef.view.tabs[i].model;
                    if (tab.type === 'list') {
                        delete newDef.view.tabs[i].collection;
                    }
                });
                this.dashlets[i] = newDef;
            }
        }, this);
        this.model.set('metadata', this._updateModelMeta(), {silent: true});
        this.model.save({}, {
            silent: true,
            showAlerts: false,
            success: _.bind(function() {
                if (!this.disposed) {
                    this.model.unset('updated');
                }
                this.grid.$el.toggleClass('grid-stack-empty', this.grid.isAreaEmpty());
            }, this),
            error: function() {
                app.alert.show('error_while_save', {
                    level: 'error',
                    title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                    messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                });
            }
        });
    },

    /**
     * Create a dashboard-grid container layout from the dashlet metadata passed
     * in
     *
     * @param {Object} dashletDef Dashlet metadata
     * @return {View.Layout} Dashlet Grid Item layout
     * @private
     */
    _initializeDashlet: function(dashletDef) {
        var dashletGridWrapper = app.view.createLayout({
            name: 'dashlet-grid-wrapper',
            layout: this,
            meta: {name: _.size(this._components)},
            context: this.context
        });
        this._components.push(dashletGridWrapper);
        dashletGridWrapper.addDashlet(dashletDef);
        // Legacy components need to have this class removed if they're being
        // loaded into a grid.
        dashletGridWrapper.$el.find('.dashlet').removeClass('ui-draggable');
        return dashletGridWrapper;
    },

    /**
     * Ensure our dashlet metadata has the current height/width/position for
     * each element
     * @param {Event} event ignored
     * @param {Array} items Dashlet grid containers
     * @private
     */
    _handleGridChange: function(event, items) {
        _.each(items, function(item) {
            var index = _.findIndex(this.dashlets, function(dashlet) {
                return dashlet.id === item.id;
            });
            if (index !== -1) {
                this.dashlets[index] = _.extend(this.dashlets[index], this._getItemAttributes(item));
            }
        }, this);
    },

    /**
     * Convert "widget" attributes to an object that matches our metadata
     * properties
     *
     * @param {jQuery} widget Gridstack Grid item
     * @return {Object} updated metadata
     * @private
     */
    _getWidgetAttributes: function(widget) {
        return {
            x: widget.getAttribute('data-gs-x'),
            y: widget.getAttribute('data-gs-y'),
            width: widget.getAttribute('data-gs-width'),
            height: widget.getAttribute('data-gs-height'),
            id: widget.getAttribute('data-gs-id') || ''
        };
    },

    /**
     * Convert "item" attributes to an object that matches our metadata
     *
     * @param {Object} item
     * @return {Object} updated widget metadata
     * @private
     */
    _getItemAttributes: function(item) {
        return {
            x: item.x,
            y: item.y,
            width: item.width,
            height: item.height,
            id: item.id,
        };
    },

    /**
     * Convert legacy component metadata to grid-style metadata
     * @param {Array} legacyComponents old-style dashboard metadata
     * @return {Array} Collection of dashlets
     * @private
     */
    _convertLegacyComponents: function(legacyComponents) {
        var dashlets = [];
        var x = 0;
        var y;
        var height = this.defaultElementOptions.height;
        var width;
        // "component" in legacy metadata is one column of dashlet-row elements
        _.each(legacyComponents, function(component) {
            // reset y index for each "component" to restart at the top of the grid
            y = 0;
            _.each(component.rows, function(row) {
                _.each(row, function(dashlet, dashletIndex) {
                    // do not convert component without view metadata
                    if (!_.has(dashlet, 'view')) {
                        return;
                    }

                    // Convert legacy dashboard width to grid-style width.
                    // Legacy dashboard "components" were sized in a 12-column
                    // grid, and each dashlet-row also contained 12 columns
                    var dashletWidth = dashlet.width || 12;
                    width = dashletWidth / 12 * component.width;
                    height = dashlet.height || height;

                    var dashletDef = _.extend(dashlet, {
                        x: x + width * dashletIndex,
                        y: y,
                        width: width,
                        height: height,
                    });
                    dashlets.push(dashletDef);
                    // increment y-value after every row
                    y += height;
                });
                // increment y-value after every dashlet-row
                y += height;
            });
            // increment x-value after every "component"
            x += component.width;
        });
        return dashlets;
    },

    /**
     * Get current tab index
     * @param {Object} options
     * @return {number}
     * @private
     */
    _getTabIndex: function(options) {
        return this.context.get('activeTab') || 0;
    },

    /**
     * Set this.dashlets when component is initialized.
     * @private
     */
    _setInitialDashlets: function() {
        var metadata = app.utils.deepCopy(this.model.get('metadata'));
        // If our model isn't populated, return here
        if (!metadata) {
            return;
        }
        // The dashlet-main component sets the legacyComponents metadata property
        // on already existing dashboards. If it's set, we need to convert legacy
        // metadata to current metadata
        if (!_.isEmpty(metadata.legacyComponents)) {
            this.dashlets = this._convertLegacyComponents(metadata.legacyComponents);
        } else if (metadata.tabs) {
            this.dashlets = metadata.tabs[this.tabIndex].dashlets || [];
        } else {
            this.dashlets = metadata.dashlets || [];
        }
    },

    /**
     * Prior to saving, we need to set this.dashlets on the model to the proper
     * attribute depending on whether this is a tabbed dashboard or not.
     * @return {Object} updated metadata
     * @private
     */
    _updateModelMeta: function() {
        var metadata = app.utils.deepCopy(this.model.get('metadata'));
        // If our model isn't populated, return here
        if (!metadata) {
            return;
        }
        if (metadata.tabs) {
            metadata.tabs[this.tabIndex].dashlets = this.dashlets;
            delete metadata.tabs[this.tabIndex].components;
        } else {
            metadata.dashlets = this.dashlets;
            delete metadata.components;
        }
        delete metadata.legacyComponents;
        return metadata;
    },

    /**
     * Disable dragging and resizing for dashlets if user lacks edit access to
     * the dashboard.
     *
     * @private
     */
    _setDefaultGridOptions: function() {
        var editable = !app.acl.hasAccessToModel('edit', this.model);
        var rtl = app.lang.direction === 'rtl';
        this.defaultGridOptions.disableDrag = editable;
        this.defaultGridOptions.disableResize = editable;
        this.defaultGridOptions.rtl = rtl;
    },

    /**
     * Setups dashboard settings for search dasahboard.
     *
     * @private
     */
    _setupSearchDashboard() {
        this.defaultGridOptions.cellHeight = 42;
        this.defaultGridOptions.disableResize = true;
        this.defaultGridOptions.disableDrag = true;
        this.defaultGridOptions.marginTop = 50;

        _.each(this.dashlets, function(dashletMeta, index) {
            this.dashlets[index].minHeight = 1;
            this.dashlets[index].height = 1;

            if (this.dashlets[index].view.ui_type === 'multi') {
                this.dashlets[index].minHeight = 4;
                this.dashlets[index].height = 4;
            }
        }, this);
    },

    /**
     * @inheritdoc
     * @private
     */
    _dispose: function() {
        if (this.context) {
            this.context.off('button:add_dashlet_button:click');
        }
        this.grid.off('change');
        this.grid.off('removed');
        this._super('_dispose');
    },

    /**
     * Set default values based on whether or not the dashboard is in a side drawer
     * @private
     */
    _setDefaultElementOptions: function() {
        if (!_.isUndefined(this.closestComponent('dashboard-pane')) && app.config.platform !== 'portal') {
            this.defaultElementOptions.minWidth = 6;
        } else {
            // When navigating from list/record views to home, the previous view's
            // value is still set when `initialize` is called
            this.defaultElementOptions.minWidth = 2;
        }
    },
}) },
"dashboard": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The outer layout of the dashboard.
 *
 * This layout contains the header view and wraps the daslet-main layout.
 * The layouts for each dashboard are stored in the server.
 *
 * @class View.Layouts.Base.DashboardLayout
 * @alias SUGAR.App.view.layouts.BaseDashboardLayout
 * @extends View.Layout
 * @deprecated 7.9 It will be removed in 7.11.
 *   Please use {@link View.Layouts.Dashboards.DashboardLayout} instead.
 */
({
	// Dashboard Layout (base) 

    className: 'row-fluid',
    //FIXME We need to remove this. TY-1132 will address it.
    dashboardLayouts: {
        'record': 'record-dashboard',
        'records': 'list-dashboard',
        'search': 'search-dashboard'
    },
    events: {
        'click [data-action=create]': 'createClicked'
    },
    error: {
        //Dashboard is a special case where a 404 here shouldn't break the page,
        //it should just send us back to the default homepage
        handleNotFoundError: function(error) {
            var currentRoute = Backbone.history.getFragment();
            if (currentRoute.substr(0, 5) === 'Home/') {
                app.router.redirect('#Home');
                //Prevent the default error handler
                return false;
            }
        },
        handleValidationError: function(error) {
            return false;
        }
    },

    /**
     * What is the current Visible State of the dashboard
     */
    dashboardVisibleState: 'open',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.logger.warn('The class `View.Layouts.Base.DashboardLayout`' +
            'has been deprecated since 7.9.0.0 and will be removed in 7.11.0.0. ' +
            'Please use `View.Layouts.Dashboards.DashboardLayout` instead.');

        var context = options.context;
        var module = context.parent && context.parent.get('module') || context.get('module');

        if (options.meta && options.meta.method && options.meta.method === 'record' && !context.get('modelId')) {
            context.set('create', true);
        }

        var hasDashboardModels;

        // The dashboard can be used to display facets on the search page.
        // This is a special use case for dashboards.
        // This checks to see if we're in the search context (i.e. the search page).
        if (context.parent && context.parent.get('search')) {
            // Note that dashboard.js is initialized twice because `navigateLayout` will call initComponents directly,
            // which creates a new context for each dashboard.
            // See `navigateLayout` for more details.
            // Also note that the module for the facets dashboard is set to `Home` in the search layout metadata.
            // Therefore, we have two brother contexts, both of which are in the `Home` module.
            // One is the initial dashboard that is created when the search layout is created.
            // The other is instantiated by the dashboard's `navigateLayout` method.
            var contextBro = context.parent.getChildContext({module: 'Home'});
            hasDashboardModels = contextBro.get('collection') && contextBro.get('collection').length;
            if (hasDashboardModels) {
                context.set({
                    // For the search page, we hardcode the facet dashboard index to 0.
                    // This is possible because in search, we only allow the
                    // facets dashboard.
                    // See `loadData` for more details.
                    model: contextBro.get('collection').at(0),
                    collection: this._getNewDashboardObject('collection', context),
                    skipFetch: true
                });
            }
        }

        if (!hasDashboardModels) {
            var model = this._getNewDashboardObject('model', context);
            if (context.get('modelId')) {
                model.set('id', context.get('modelId'), {silent: true});
            }
            context.set({
                model: model,
                collection: this._getNewDashboardObject('collection', context)
            });
        }

        this._super('initialize', [options]);

        this._bindButtonEvents();

        this.model.on('setMode', function(mode) {
            if (mode === 'edit' || mode === 'create') {
                this.$('.dashboard').addClass('edit');
            } else {
                this.$('.dashboard').removeClass('edit');
            }
        }, this);

        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            this.listenTo(defaultLayout, 'sidebar:state:changed', function(state) {
                this.dashboardVisibleState = state;
            }, this);

            try {
                this.dashboardVisibleState = defaultLayout.isSidePaneVisible() ? 'open' : 'close';
            } catch (error) {
                // this happens when the dashboard component is initially created because the defaultLayout doesn't
                // have _hideLastStateKey key set yet.  Just ignore this for now as with the way dashboards work
                // it this code will get run again once the logic below selects which dashboard to show.
            }
        }

        if (module === 'Home' && context.has('modelId')) {
            // save it as last visit
            var lastVisitedStateKey = this.getLastStateKey();
            app.user.lastState.set(lastVisitedStateKey, context.get('modelId'));
        }
    },

    /**
     * Binds the button events that are specific to the record pane.
     *
     * @protected
     */
    _bindButtonEvents: function() {
        this.context.on('button:save_button:click', this.handleSave, this);
    },

    /**
     * Overrides {@link View.Layout#initComponents} to trigger `change:metadata`
     * event if we are in the search results page.
     *
     * For other dashboards than the facet dashboard, `change:metadata` is
     * triggered by {@link View.Fields.Base.Home.LayoutbuttonField} but we don't
     * use this field in the facets dashboard so we need to trigger it here.
     *
     * @override
     */
    initComponents: function(components, context, module) {
        this._super('initComponents', [components, context, module]);
        if (this.isSearchContext()) {
            // For non-search dashboards, `change:metadata` is triggered by the
            // `layoutbutton.js`. We don't use this field in the facets
            // dashboard, so we need to trigger it here.
            this.model.trigger('change:metadata');
        }
    },

    /**
     * Indicates if we are in the search page or not.
     *
     * @return {boolean} `true` means we are in the search page.
     */
    isSearchContext: function() {
        return this.context.parent && this.context.parent.get('search');
    },

    /**
     * Gets the brother context.
     *
     * @param {string} module The module to get the brother context from.
     * @return {Core.Context} The brother context.
     */
    getContextBro: function(module) {
        return this.context.parent.getChildContext({module: module});
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        // Dashboards store their own metadata as part of their model.
        // For search facet dashboard, we do not want to load the dashboard
        // metadata from the database. Instead, we build the metadata below.
        if (this.isSearchContext()) {
            // The model does not have metadata the first time this function
            // is called. In subsequent calls, the model should have metadata
            // so we do not need to fetch it.
            if (this.model.has('metadata')) {
                return;
            }

            this._loadSearchDashboard();

            this.context.set('skipFetch', true);
            this.navigateLayout('search');
            return;
        }

        if (this.context.parent && !this.context.parent.isDataFetched()) {
            var parent = this.context.parent.get('modelId') ?
                this.context.parent.get('model') : this.context.parent.get('collection');

            if (parent) {
                parent.once('sync', function() {
                    this._super('loadData', [options]);
                }, this);
            }
        } else {
            this._super('loadData', [options]);
        }
    },

    /**
     * Loads the facet dashboard for the search page, and add it.
     *
     * @private
     */
    _loadSearchDashboard: function() {
        var dashboardMeta = this._getInitialDashboardMetadata();
        var model = this._getNewDashboardObject('model', this.context);
        // In `dashMeta`, we have a `metadata` property which contains all
        // the metadata needed for the dashboard.
        model.set(dashboardMeta);
        this.collection.add(model);
    },

    /**
     * Navigate to the create layout when create button is clicked.
     *
     * @param {Event} evt Mouse event.
     */
    createClicked: function(evt) {
        if (this.model.dashboardModule === 'Home') {
            var route = app.router.buildRoute(this.module, null, 'create');
            app.router.navigate(route, {trigger: true});
        } else {
            this.navigateLayout('create');
        }
    },

    /**
     * Places only components that include the Dashlet plugin and places them in the 'main-pane' div of
     * the dashlet layout.
     * @param {app.view.Component} component
     * @private
     */
    _placeComponent: function(component) {
        var dashboardEl = this.$('[data-dashboard]');
        var css = this.context.get('create') ? ' edit' : '';

        if (dashboardEl.length === 0) {
            dashboardEl = $('<div></div>').attr({
                'class': 'cols row-fluid'
            });
            this.$el.append(
                $('<div></div>')
                    .addClass('dashboard bg-content-background w-full absolute' + css)
                    .attr({'data-dashboard': 'true'})
                    .append(dashboardEl)
            );
        } else {
            dashboardEl = dashboardEl.children('.row-fluid');
        }
        dashboardEl.append(component.el);
    },

    /**
     * If current context doesn't contain dashboard model id,
     * it will trigger set default dashboard to create default metadata
     */
    bindDataChange: function() {
        if (this.isSearchContext()) {
            return;
        }
        var modelId = this.context.get('modelId');
        if (!(modelId && this.context.get('create')) && this.collection) {
            // On the search page, we don't want to save the facets dashboard
            // in the database, so we don't need to listen to changes on the
            // collection nor do we need to call `setDefaultDashboard`.
            this.collection.on('reset', this.setDefaultDashboard, this);
        }
    },

    /**
     * Build the default dashboard metadata only if dashboards are empty.
     *
     * Default dashboard metadata are stored in the following layout metadata
     * <pre>
     * listview - list-dashboard
     * recordview - record-dashboard
     * </pre>
     * If the default dashboard is not assigned,
     * the layout will render dashboard-empty template.
     */
    setDefaultDashboard: function() {
        if (this.disposed) {
            return;
        }
        var lastVisitedStateKey = this.getLastStateKey();
        var lastViewed = app.user.lastState.get(lastVisitedStateKey);
        var model;

        // FIXME: SC-4915 will change this to rely on the `hidden` context flag
        // instead.
        var hasParentContext = this.context && this.context.parent;
        var parentModule = hasParentContext && this.context.parent.get('module') || 'Home';

        if (this.collection.length > 0) {
            var currentModule = this.context.get('module');
            model = _.first(this.collection.models);

            if (lastViewed) {
                var lastVisitedModel = this.collection.get(lastViewed);
                //if last visited dashboard not in the fetching list,
                //it should navigate to the first searched dashboard.
                //And it should clean out the previous last visited dashboard,
                //since it is no longer existed.
                if (!_.isEmpty(lastVisitedModel)) {
                    app.user.lastState.set(lastVisitedStateKey, '');
                    model = lastVisitedModel;
                }
            }

            if (currentModule == 'Home' && _.isString(lastViewed) && lastViewed.indexOf('bwc_dashboard') !== -1) {
                app.router.navigate(lastViewed, {trigger: true});
            } else {
                // use the _navigate helper
                this._navigate(model);
            }
        } else {
            var _initDashboard = this._getInitialDashboardMetadata();

            // If there is no initial dashboard, render the empty template and bail
            if (!_initDashboard || _.isEmpty(_initDashboard.metadata)) {
                this._renderEmptyTemplate();
                return;
            }

            // Since we have an initial dashboard,
            // Drill-down to the dashlet level to check permissions for that module.
            _.each(_initDashboard.metadata.components, function(component, componentKey) {
                _.each(component.rows, function(row, rowKey) {
                    // Loop the cells checking access, rebuilding the cell array to only contain permitted dashlets.
                    _initDashboard.metadata.components[componentKey].rows[rowKey] =
                        _.filter(row, function(cell) {
                            var module = (cell.context && cell.context.module) ? cell.context.module : this.module;
                            return (app.acl.hasAccess('access', module));
                        });
                }, this);

                // Now that we've processed all the rows in this component,
                // rebuild the array to only have rows with dashlets.
                _initDashboard.metadata.components[componentKey].rows =
                    _.filter(_initDashboard.metadata.components[componentKey].rows, function(row) {
                        return (row.length > 0);
                    });
            }, this);

            model = this._getNewDashboardObject('model', this.context);
            model.set(_initDashboard);
            if (this.context.get('modelId')) {
                model.set('id', this.context.get('modelId'), {silent: true});
            }
            // make sure that the model actually has some metadata
            if (!_.isUndefined(model.get('metadata'))) {
                model.save({}, this._getDashboardModelSaveParams());
                this.collection.add(model);
            }
        }
    },

    /**
     * Gets initial dashboard metadata
     *
     * @return {Object} dashboard metadata
     * @private
     */
    _getInitialDashboardMetadata: function() {
        var layoutName = this.dashboardLayouts[this.context.parent && this.context.parent.get('layout') || 'record'];
        var initDash = app.metadata.getLayout(this.model.dashboardModule, layoutName) || {};
        return initDash;
    },

    /**
     * Build the cache key for last visited dashboard
     * Combine parent module and view name to build the unique id
     *
     * @return {string} hash key.
     */
    getLastStateKey: function() {
        if (this._lastStateKey) {
            return this._lastStateKey;
        }

        var model = this.context.get('model');
        var view = model.get('view_name');
        var module = model.dashboardModule;
        var key = module + '.' + view;

        this._lastStateKey = app.user.lastState.key(key, this);
        return this._lastStateKey;
    },

    /**
     * Utility method to use when trying to figure out how we need to navigate when switching dashboards
     *
     * @param {Backbone.Model} (dashboard) The dashboard we are trying to navigate to
     * @private
     */
    _navigate: function(dashboard) {
        if (this.disposed) {
            return;
        }

        var hasParentContext = (this.context && this.context.parent);
        var hasModelId = (dashboard && dashboard.has('id'));
        var actualModule = (hasParentContext) ? this.context.parent.get('module') : this.module;
        var isHomeModule = (actualModule === 'Home');

        if (hasParentContext && hasModelId) {
            // we are on a module and we have an dashboard id
            this._navigateLayout(dashboard.get('id'));
        } else if (hasParentContext && !hasModelId) {
            // we are on a module but we don't have a dashboard id
            this._navigateLayout('list');
        } else if (!hasParentContext && hasModelId && isHomeModule) {
            // we on the Home module and we have a dashboard id
            app.navigate(this.context, dashboard);
        } else if (isHomeModule) {
            // we on the Home module and we don't have a dashboard
            var route = app.router.buildRoute(this.module);
            app.router.navigate(route, {trigger: true});
        }
    },

    /**
     * Intercept the navigateLayout calls to make sure that the dashboard we are currently on didn't change.
     * If it did, we need to prompt and make sure they want to continue or cancel.
     *
     * @param {string} dashboard What dashboard do we want to display
     * @return {boolean}
     * @private
     */
    _navigateLayout: function(dashboard) {
        var onConfirm = _.bind(function() {
            this.navigateLayout(dashboard);
        }, this);
        var headerpane = this.getComponent('dashboard-headerpane');

        // if we have a headerpane and it was changed then run the warnUnsavedChanges method
        if (headerpane && headerpane.changed) {
            return headerpane.warnUnsavedChanges(
                onConfirm,
                undefined,
                _.bind(function() {
                    // when the cancel button is presses, we need to clear out the collection
                    // because it messes with the add dashlet screen.
                    this.collection.reset([], {silent: true});
                }, this)
            );
        }

        // if we didn't have a headerpane or we did have one, but nothing changed, just run the normal method
        onConfirm();
    },

    /**
     * For the RHS dashboard, this method loads entire dashboard component
     *
     * @param {string} id dashboard id. This id can be the dashboard id, or
     * the following strings: create, list, search.
     * @param {string} type (Deprecated) the dashboard type.
     */
    navigateLayout: function(id, type) {
        if (!_.isUndefined(type)) {
            // TODO: Remove the `type` parameter. This is to be done in TY-654
            app.logger.warn('The `type` parameter to `View.Layouts.Base.DashboardLayout.navigateLayout`' +
                'has been deprecated since 7.9.0.0. Please update your code to stop using it.');
        }
        var layout = this.layout;
        var lastVisitedStateKey = this.getLastStateKey();

        // For search dashboards, use the search-dashboard-headerpane
        var headerPaneView = (id === 'search') ? 'search-dashboard-headerpane' : 'dashboard-headerpane';

        this.dispose();

        //if dashboard layout navigates to the different dashboard,
        //it should store last visited dashboard id.
        if (!_.contains(['create', 'list'], id)) {
            app.user.lastState.set(lastVisitedStateKey, id);
        }

        var ctxVars = {};
        if (id === 'create') {
            ctxVars.create = true;
        } else if (id !== 'list') {
            ctxVars.modelId = id;
        }

        layout.initComponents([
            {
                // Note that we reinitialize the dashboard layout itself, creating a new context (forceNew: true)
                layout: {
                    type: 'dashboard',
                    components: (id === 'list') ? [] : [
                        {
                            view: headerPaneView
                        },
                        {
                            layout: 'dashlet-main'
                        }
                    ],
                    last_state: {
                        id: 'last-visit'
                    }
                },
                context: _.extend({
                    module: 'Home',
                    forceNew: true
                }, ctxVars)
            }
        ]);

        layout.removeComponent(0);
        layout.loadData();
        layout.render();
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        if (this.collection) {
            this.collection.off('reset', this.setDefaultDashboard, this);
        }

        if (this.context.parent) {
            var model = this.context.parent.get('model');
            var collection = this.context.parent.get('collection');

            if (model) {
                model.off('sync', null, this);
            }
            if (collection) {
                collection.off('sync', null, this);
            }
        }

        this._super('unbindData');
    },

    /**
     * Returns a Dashboard Model or Dashboard Collection based on modelOrCollection
     *
     * @param {string} modelOrCollection The return type, 'model' or 'collection'
     * @param {Object} context
     * @return {Bean|BeanCollection}
     * @private
     */
    _getNewDashboardObject: function(modelOrCollection, context) {
        var obj;
        var ctx = context && context.parent || context;
        var module = ctx.get('module') || context.get('module');
        var layoutName = ctx.get('layout') || '';
        var sync = function(method, model, options) {
            options = app.data.parseOptionsForSync(method, model, options);
            // there is no max limit for number of dashboards permodule view
            if (options && options.params) {
                options.params.max_num = -1;
            }

            var callbacks = app.data.getSyncCallbacks(method, model, options);
            var path = (this.dashboardModule === 'Home' || model.id) ?
                this.apiModule : this.apiModule + '/' + this.dashboardModule;

            if (method === 'read') {
                options.params.view_name = layoutName;
            }

            app.data.trigger('data:sync:start', method, model, options);
            model.trigger('data:sync:start', method, options);

            app.api.records(method, path, model.attributes, options.params, callbacks);
        };

        if (module === 'Home') {
            layoutName = '';
        }
        switch (modelOrCollection) {
            case 'model':
                obj = this._getNewDashboardModel(module, layoutName, sync);
                break;

            case 'collection':
                obj = this._getNewDashboardCollection(module, layoutName, sync);
                break;
        }

        return obj;
    },

    /**
     * Returns a new Dashboard Bean with proper view_name and sync function set
     *
     * @param {string} module The name of the module we're in
     * @param {string} layoutName The name of the layout
     * @param {Function} syncFn The sync function to use
     * @param {boolean} [getNew=true] If you want a new instance or just the
     *   Dashboard definition.
     * @return {Dashboard} a new Dashboard Bean
     * @private
     */
    _getNewDashboardModel: function(module, layoutName, syncFn, getNew) {
        getNew = (_.isUndefined(getNew)) ? true : getNew;
        var Dashboard = app.Bean.extend({
            sync: syncFn,
            apiModule: 'Dashboards',
            module: 'Home',
            dashboardModule: module,
            maxColumns: (module === 'Home') ? 3 : 1,
            minColumnSpanSize: (module === 'Home') ? 4 : 12,
            defaults: {
                view_name: layoutName
            }
        });
        return (getNew) ? new Dashboard() : Dashboard;
    },

    /**
     * Returns a new DashboardCollection with proper view_name and sync function set
     *
     * @param {string} module The name of the module we're in
     * @param {string} layoutName The name of the layout
     * @param {Function} syncFn The sync function to use
     * @param {boolean} [getNew=true] If you want a new instance or just the
     *   DashboardCollection definition.
     * @return {DashboardCollection} A new Dashboard BeanCollection
     * @private
     */
    _getNewDashboardCollection: function(module, layoutName, syncFn, getNew) {
        getNew = (_.isUndefined(getNew)) ? true : getNew;

        var Dashboard = this._getNewDashboardModel(module, layoutName, syncFn, false);
        var DashboardCollection = app.BeanCollection.extend({
            sync: syncFn,
            apiModule: 'Dashboards',
            module: 'Home',
            dashboardModule: module,
            model: Dashboard
        });

        return (getNew) ? new DashboardCollection() : DashboardCollection;
    },

    /**
     * Collects params for Dashboard model save
     *
     * @return {Object} The dashboard model params to pass to its save function
     * @private
     */
    _getDashboardModelSaveParams: function() {
        var params = {
            silent: true,
            //Don't show alerts for this request
            showAlerts: false
        };

        params.error = _.bind(this._renderEmptyTemplate, this);

        params.success = _.bind(function(model) {
            if (!this.disposed) {
                this._navigate(model);
            }
        }, this);

        return params;
    },

    /**
     * Gets the empty dashboard layout template
     * and renders it to <pre><code>this.$el</code></pre>
     *
     * @private
     */
    _renderEmptyTemplate: function() {
        var tplName = this.type || this.name;
        var template = app.template.getLayout(tplName + '.dashboard-empty');

        this.$el.html(template(this));
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            this.stopListening(defaultLayout);
        }

        this.dashboardLayouts = null;
        this._super('_dispose');
    },

    /**
     * Saves the dashboard to the server.
     */
    handleSave: function() {
        this.model.save({}, {
            //Show alerts for this request
            showAlerts: true,
            fieldsToValidate: {
                'name': {
                    required: true
                },
                'metadata': {
                    required: true
                }
            },
            success: _.bind(function() {
                this.model.unset('updated');
                if (this.context.get('create')) {
                    // We have a parent context only for dashboards in the RHS.
                    if (this.context.parent) {
                        this.getContextBro('Home').get('collection').add(this.model);
                        this.navigateLayout(this.model.id);
                    } else {
                        app.navigate(this.context, this.model);
                    }
                } else {
                    this.context.trigger('record:set:state', 'view');
                }
            }, this),
            error: function() {
                app.alert.show('error_while_save', {
                    level: 'error',
                    title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                    messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                });
            }
        });
    }
}) },
"omnichannel-console-config": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The layout for the Omnichannel console.
 *
 * @class View.Layouts.Base.OmnichannelConsoleConfigLayout
 * @alias SUGAR.App.view.layouts.BaseOmnichannelConsoleConfigLayout
 * @extends View.Layouts.Base.OmnichannelConsoleLayout
 */
({
	// Omnichannel-console-config Layout (base) 

    /**
     * Layout to extend
     */
    extendsFrom: 'OmnichannelConsoleLayout',

    /**
     * CSS classes added to layout
     */
    className: 'omni-console omni-console-config',

    /**
     * Indicates that its syncing metadata after config is modified
     * @property {boolean}
     */
    isSyncing: false,

    /**
     * @override
     *
     * Set 'config-layout' on context so child components can change behavior
     * accordingly
     *
     * @param options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        // extend the events object to contain another click event for the same function. This gives us the open and
        // close of the omniconsole for free
        this.events = _.extend({}, this.events, {
            'click [name="add_dashlet_button"]': '_handleDashletToolbarActions',
        });
        this.context.set('config-layout', true);
        // This will override the current data-action=close event to trigger the closeAndDispose function
        this.events = _.extend({}, this.events, {
            'click [data-action=close]': 'closeAndDispose',
        });
        app.events.on('app:sync:complete', _.bind(function() {
            this.inSync(false);
        }, this), this);
    },

    /**
     * @inheritdoc
     *
     * @override
     */
    bindRouterEvents: function() {
        app.router.on('route', this.disposeOnRoute, this);
    },

    /**
     * @override
     *
     * Opens config layout, so the full console is visible. setMode is called
     * before sliding drawer up so the user only sees the full drawer appear
     * from the bottom.
     */
    open: function() {
        if (!this.isOpen()) {
            if (app.omniConsole && app.omniConsole.isOpen()) {
                app.omniConsole.close();
            }
            this.currentState = 'opening';
            this.isConfig = true;
            this.setKebabState('open');
            this.setMode('full');
            var animationEndHandler = _.bind(this.resizeCCP, this);
            this.$el.show('slide', {direction: 'down'}, this.animationLength, animationEndHandler);
            var $main = app.$contentEl.children().first();
            $main.on('drawer:add.omniConsole', this.boundCloseImmediately);
            this.currentState = 'idle';
            this.removeToolbarActionListener();
        }
    },

    /**
     * It will trigger a resize on the contact control panel.
     */
    resizeCCP: function() {
        var ccp = this.getComponent('omnichannel-ccp');
        ccp.resize();
    },

    /**
     * Close and dispose the console.
     */
    closeAndDispose: function() {
        this.isConfig = false;
        this.isConfigPaneExpanded = false;
        this.setKebabState('init');
        this.close(_.bind(this.dispose, this));
    },

    /**
     * Called when a route event happens while on the omnichannel-console-config
     */
    disposeOnRoute: function() {
        // Sometimes a routing event occurs when the screen is reloaded (such as when we update the summary panel view
        // metadata. This check is to ensure that if the routing event is a simple refresh of the drawer we will not
        // dispose of the the drawer, but wait till metadata is refreshed for a proper open to happen.
        this.closeImmediately();
        if (app.router._currentFragment !== app.router._previousFragment || !this.inSync()) {
            this.dispose();
        } else {
            this.trigger('omniconfig:reopen');
            this.open();
            this.setKebabState('open');
        }
    },

    /**
     * Sets/Gets isSyncing flag
     *
     * @param {boolean} newState
     * @return {boolean}
     */
    inSync(newState) {
        if (!_.isUndefined(newState)) {
            this.isSyncing = newState;
        }
        return this.isSyncing;
    },

    /**
     * Sets the kebab button on the footer for SugarLive to either open or init
     * @param state
     */
    setKebabState: function(state) {
        // defensive check to ensure everything is defined in the chain as it should be
        var footer = this.$el.siblings('#footer');
        if (footer.length !== 0) {
            var configButton = footer.find('.config-menu');
            if (configButton.length !== 0) {
                configButton.attr('data-mode', state);
            }
        }
    },

    /**
     * @override
     *
     * Return an empty object as the config view has dummy data
     */
    getModelPrepopulateData: function() {
        return {};
    },

    /**
     * @override
     *
     * Override to simply re-open the config view
     */
    _handleClosedQuickcreateDrawer: function() {
        // if there are other drawers, follow regular drawer close behavior
        if (!app.drawer.count()) {
            this.open();
        }
    },

    /**
     * @override
     *
     * Override to prevent cache updates from the config view
     */
    _updateModeCache: function() {
    },

    /**
     * Unset context value on dispose
     * @private
     */
    _dispose: function() {
        // Grab the '.config-menu' item on the footer element. Change this back to 'init' data-mode so the
        // kebab is restored
        this.setKebabState('init');
        this.context.unset('config-layout');
        delete app.omniConsoleConfig;
        app.router.off('route', this.disposeOnRoute, this);
        app.events.off('app:sync:complete', null, this);
        this._super('_dispose');
    },
}) },
"merge-duplicates-preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.MergeDuplicatesPreviewLayout
 * @alias SUGAR.App.view.layouts.BaseMergeDuplicatesPreviewLayout
 * @extends View.Layout
 */
({
	// Merge-duplicates-preview Layout (base) 

    extendsFrom: 'PreviewLayout',

    initialize: function(options) {
        this._super('initialize', [options]);
    }
}) },
"omnichannel-dashboard-switch": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The container of Omnichannel console dashboards.
 *
 * @class View.Layouts.Base.OmnichannelDashboardSwitchLayout
 * @alias SUGAR.App.view.layouts.BaseOmnichannelDashboardSwitchLayout
 * @extends View.Layout
 */
({
	// Omnichannel-dashboard-switch Layout (base) 

    className: 'omni-dashboard-switch',

    /**
     * Contact Ids.
     * @property {Array}
     */
    contactIds: [],

    /**
     * z-index for next top dashboard.
     * @property {number}
     */
    zIndex: 1,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        if (this.layout) {
            this.layout.on('ccp:terminated', this.removeAllDashboards, this);
            this.layout.on('contact:view', this.showDashboard, this);
            this.layout.on('contact:destroyed', this.removeDashboard, this);
            this.layout.on('contact:records:matched', this._handleContactRecordsMatched, this);
        }
    },

    /**
     * Handles when a search of Sugar records matched to a contact is completed
     *
     * @param {Object} contact connect-streams Contact object
     * @param {Array} models the list of beans found by the record match search
     * @private
     */
    _handleContactRecordsMatched: function(contact, models, context) {
        var contactId = contact && contact.getContactId();
        if (contactId) {
            this.setModels(contactId, models, 0);
            if (context && !_.isEmpty(context.phoneSearchParams)) {
                this.setSearch(contactId, context.phoneSearchParams, true);
            }
        }
    },

    /**
     * Show a contact's dashboard. Create a new dashbord if it doesn't exist.
     * @param {Object} contact AWS contact
     */
    showDashboard: function(contact) {
        var contactId = contact.getContactId();
        var index = _.indexOf(this.contactIds, contactId);

        if (index === -1) {
            this._createDashboard();
            this.contactIds.push(contactId);
        } else {
            var dashboard = this._components[index];
            // move to top
            dashboard.$el.css('z-index', this.zIndex++);
        }
    },

    /**
     * Create a new dashboard.
     * @private
     */
    _createDashboard: function() {
        var context = this.context.getChildContext({forceNew: true, module: 'Dashboards'});
        var dashboard = app.view.createLayout({
            type: 'omnichannel-dashboard',
            context: context
        });
        this._components.push(dashboard);
        this.$el.append(dashboard.$el);
        dashboard.$el.css('z-index', this.zIndex++);
        dashboard.initComponents();
        dashboard.loadData();
        dashboard.render();
    },

    /**
     * Remove a contact's dashboard.
     * @param {string} contactId
     */
    removeDashboard: function(contactId) {
        var self = this;
        var index = _.indexOf(this.contactIds, contactId);
        if (index !== -1) {
            var dashboard = this._components[index];
            var _remove = function() {
                self._removeDashboard(index);
            };
            if (!dashboard.triggerBefore('omni-dashboard:close', {callback: _remove})) {
                self._showClearButton(index, contactId);
                return;
            }
            _remove();
        }
    },

    /**
     * Show 'Clear' button on a dashboard.
     * @param {number} index - Current index of dashboard
     * @param {string} contactId - Id of connect Contact associated with dashboard
     */
    _showClearButton: function(index, contactId) {
        var self = this;
        var _remove = function() {
            self._clearButtonClicked(contactId);
        };
        var dashboard = this._components[index];
        var tabbedDashboard = dashboard._getTabbedDashboard();
        this._markClearButtonAsVisible(tabbedDashboard);
        var $button = tabbedDashboard.$el.find('a[name=clear]');
        if ($button) {
            $button.removeClass('hidden');
            tabbedDashboard.context.on('button:clear_button:click', function() {
                // check if there are any unsaved changes before removing
                if (!dashboard.triggerBefore('omni-dashboard:close', {callback: _remove})) {
                    return;
                }

                _remove();
            });
        }
    },

    /**
     * Marks the clear button from the metadata as visible. This way when the header is re-rendered
     * the buttons will stay visible. This mark will be reset OOTB once the dashboard is closed.
     *
     * @param {Object} tabbedDashboard It is the tabbed dashboard component.
     */
    _markClearButtonAsVisible: function(tabbedDashboard) {
        // We have only 1 button which is the clear button.
        var metaData = tabbedDashboard.model.get('metadata');
        var buttonMeta = metaData.buttons[0];
        // Remove the default 'hidden' class.
        buttonMeta.css_class = buttonMeta.css_class.replace(' hidden', '');
        // Set it on the dashboards's meta so on render it would be displayed.
        metaData.buttons[0] = buttonMeta;
        tabbedDashboard.model.set('metadata', metaData);
    },

    /**
     * Remove a contact's dashboard by index.
     * @param {number} index
     */
    _removeDashboard: function(index) {
        var dashboard = this._components[index];
        if (dashboard) {
            dashboard.dispose();
            this._components.splice(index, 1);
            this.contactIds.splice(index, 1);
        }
    },

    /**
     * Close appropriate dashboard for contactId when user click's Clear button
     * @param {string} contactId
     * @private
     */
    _clearButtonClicked: function(contactId) {
        var index = _.indexOf(this.contactIds, contactId);
        if (index > -1) {
            this._removeDashboard(index);
        }
    },

    /**
     * Remove all dashboards.
     */
    removeAllDashboards: function() {
        var self = this;
        if (this._components.length < 1) {
            this.layout.close();
            return;
        }
        _.each(this._components, function(dashboard, index) {
            var _remove = function() {
                self._removeDashboard(index);
                if (self.contactIds.length < 1) {
                    self.layout.close();
                    self.zIndex = 1;
                }
            };
            if (!dashboard.triggerBefore('omni-dashboard:close', {callback: _remove})) {
                self._showClearButton(index);
                return;
            }
            _remove();
        });
    },

    /**
     *
     * @param contactId
     * @return {View.Layout|null}
     */
    getDashboard: function(contactId) {
        var index = _.indexOf(this.contactIds, contactId);
        if (index !== -1) {
            return this._components[index];
        }
        return null;
    },

    /**
     * Sets contact model for dashboard in a particular tab.
     *
     * @param {string} contactId - connect-streams Contact Id
     * @param {Bean} contactModel contact model
     * @param {boolean} silent if true, do not switch dashboard tab
     * @deprecated Since 11.1, use setModel() instead
     */
    setContactModel: function(contactId, contactModel, silent) {
        this.setModel(contactId, contactModel, silent);
    },

    /**
     * Sets case model for dashboard in a particular tab.
     *
     * @param {string} contactId - connect-streams Contact Id
     * @param {Bean} caseModel case model
     * @deprecated Since 11.1, use setModel() instead
     */
    setCaseModel: function(contactId, caseModel) {
        this.setModel(contactId, caseModel, false);
    },

    /**
     * Sets the pre-filled search parameters for the search tab of the given
     * contact's dashboard
     *
     * @param {string} contactId connect-streams ID of the contact
     * @param {Object} params the search parameters to set
     * @param {string} params.term the search term to set
     * @param {string} params.module_list the list of modules to search
     * @param {Object} params.filters the search filters
     * @param {boolean} silent if true, do not switch dashboard tab
     */
    setSearch: function(contactId, params, silent) {
        var contactDashboard = this.getDashboard(contactId);
        if (!_.isEmpty(contactDashboard)) {
            var tabIndex = contactDashboard.getSearchTabIndex();
            if (_.isNumber(tabIndex)) {
                contactDashboard.setSearch(params);
                if (!silent) {
                    contactDashboard.switchTab(tabIndex);
                }
            }
        }
    },

    /**
     * Sets a list of models into their appropriate tabs of the given contact's
     * dashboard
     *
     * @param {string} contactId connect-streams ID of the contact
     * @param {Array} models the list of models to set
     * @param {number} focusIndex f provided, will switch tab focus to the model
     *                 at the given index in models
     */
    setModels: function(contactId, models, focusIndex) {
        if (!_.isEmpty(models) && !_.isEmpty(contactId)) {
            _.each(models, function(model, index) {
                var focus = _.isNumber(focusIndex) && index === focusIndex;
                this.setModel(contactId, model, !focus);
            }, this);
        }
    },

    /**
     * Sets the model for the appropriate tab of the given contact's dashboard
     *
     * @param {string} contactId connect-streams ID of the contact
     * @param {Bean} model the model to set
     * @param {boolean} silent if true, do not switch dashboard tab
     */
    setModel: function(contactId, model, silent) {
        var contactDashboard = this.getDashboard(contactId);
        if (!_.isEmpty(contactDashboard) && !_.isEmpty(model)) {
            var tabIndex = contactDashboard.getTabIndexForModel(model);
            if (_.isNumber(tabIndex)) {
                contactDashboard.setModel(tabIndex, model);
                if (!silent) {
                    contactDashboard.switchTab(tabIndex);
                }
            }
        }
    },

    /**
     * Gets the data to pre-populate a model with from the given contact's
     * dashboard
     *
     * @param {string} targetModule the module to get prepopulate data for
     * @return {Object} The attributes to pre-populate a model with
     */
    getModelPrepopulateData: function(contactId, targetModule) {
        var contactDashboard = this.getDashboard(contactId);
        return !_.isEmpty(contactDashboard) ? contactDashboard.getModelPrepopulateData(targetModule) : {};
    },

    /**
     * Handles any special functionality that should be run for the given
     * contact's dashboard after a model is quick-created from the Omnichannel
     * console
     *
     * @param {string} contactId the ID of the contact to set a model for
     * @param {Bean} model the model to set on the contact's dashboard
     */
    postQuickCreate: function(contactId, model) {
        var contactDashboard = this.getDashboard(contactId);
        if (!_.isEmpty(contactDashboard) && !_.isEmpty(model)) {
            contactDashboard.postQuickCreate(model);
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.layout.off('ccp:terminated', this.removeAllDashboards, this);
        this.layout.off('contact:view', this.showDashboard, this);
        this.layout.off('contact:destroyed', this.removeDashboard, this);
    }
}) },
"preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.PreviewLayout
 * @alias SUGAR.App.view.layouts.BasePreviewLayout
 * @extends View.Layout
 */
({
	// Preview Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._bindPreviewEvents();

        /**
         * Creates a child context, which will carry the previewed model.
         *
         * @type {Core.Context}
         */
        this.context = this.context.getChildContext({});
    },

    /**
     * Binds the events that this preview layout uses.
     *
     * @private
     */
    _bindPreviewEvents: function() {
        app.events.on('preview:render', this._toggle, this);
        app.events.on('preview:open', this.showPreviewPanel, this);
        app.events.on('preview:close', this.hidePreviewPanel, this);
        app.events.on('preview:pagination:hide', this.hidePagination, this);
    },

    /**
     * Checks if {@link #$el this layout element} is in the active drawer, if
     * there is an instance of
     * {@link View.Layouts.Base.DrawerLayout app.drawer}. In case no drawers are
     * defined, this function returns `true`.
     *
     * @return {boolean} `true` if
     *   {@link View.Layouts.Base.DrawerLayout app.drawer} is not defined, or if
     *   this layout is in the active drawer, `false` otherwise.
     */
    _isActive: function() {
        if (_.isEmpty(app.drawer)) {
            return true;
        }

        return app.drawer.isActive(this.$el);
    },

    /**
     * Initializes the preview panel if the given model is different from the
     * model on the {@link #context}. Shows the preview panel if this
     * layout is {@link #_hidden hidden}, hides it otherwise.
     *
     * @private
     * @param {Data.Bean} model The {@link Data.Bean model} being previewed.
     * @param {Data.BeanCollection} collection The
     *   {@link Data.BeanCollection collection} of preview models.
     */
    _toggle: function(model, collection) {
        if (!this._isActive()) {
            return;
        }

        var isSameModel = model === this.context.get('model');

        if (isSameModel) {
            if (this._hidden) {
                this.showPreviewPanel();
                app.events.trigger('list:preview:decorate', model, this);
            } else {
                this.hidePreviewPanel();
            }
        } else {
            this._initPreviewPanel(model, collection);
        }
    },

    /**
     * Initializes the preview layout components using the correct module.
     *
     * @private
     * @param {Data.Bean} model The {@link Data.Bean model} being previewed.
     * @param {Data.BeanCollection} collection The
     *   {@link Data.BeanCollection collection} of preview models.
     */
    _initPreviewPanel: function(model, collection) {
        if (!this._isActive()) {
            return;
        }

        var attrs = {
            model: model,
            collection: collection,
            module: model.module,
            modelId: model.id
        };

        // If `this._components` is empty, its the first time we are
        // initializing the preview panel. Otherwise, if the modules are
        // different, we need to reinitialize the preview panel with the new
        // metadata from that module.
        var hasComponents = !_.isEmpty(this._components);
        var modelChanged = this.context.get('module') !== model.module;

        if (!hasComponents || modelChanged) {
            this._disposeComponents();
            this.context.set(attrs);
            this.initComponents(this._componentsMeta, this.context, model.module);
            if (hasComponents) {
                // In case we already have components, reload the
                // data to remove previous load data (e.g. fetchCalled, etc)
                this.context.reloadData({resetCollection: false});
            } else {
                this.context.loadData();
            }
            this.render();
        } else {
            this.context.set(attrs);
            this.context.reloadData({resetCollection: false, hideDbvWarning: true});
        }

        this.showPreviewPanel();
        app.events.trigger('list:preview:decorate', model, this);
    },

    /**
     * Shows the preview panel, if it is part of the active drawer or if there
     * is no drawer open.
     */
    showPreviewPanel: function() {
        if (!this._isActive()) {
            return;
        }

        // trigger that preview is visible
        this.layout.context.trigger('tabbed-layout:tab:change', this.name, true);

        var layout = this.$el.parents('.sidebar-content');
        layout.find('.side-pane').removeClass('active');
        layout.find('.dashboard-pane').hide();
        layout.find('.preview-pane').addClass('active');

        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            defaultLayout.trigger('sidebar:toggle', true);
        }
        this._hidden = false;
    },

    /**
     * Hides the preview panel, if it is part of the active drawer or if there
     * is no drawer open.
     */
    hidePreviewPanel: function() {
        if (!this._isActive()) {
            return;
        }

        // trigger that preview is not visible
        this.layout.context.trigger('tabbed-layout:tab:change', this.name, false);

        var layout = this.$el.parents('.sidebar-content');
        layout.find('.side-pane').addClass('active');
        layout.find('.dashboard-pane').show();
        layout.find('.preview-pane').removeClass('active');
        app.events.trigger('list:preview:decorate', false);
        this._hidden = true;
    },

    hidePagination: function() {
        if (!this._isActive()) {
            return;
        }

        this.hideNextPrevious = true;
        this.trigger('preview:pagination:update');
    }
}) },
"omnichannel-search": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The container of Omnichannel search tab.
 *
 * @class View.Layouts.Base.OmnichannelSearchLayout
 * @alias SUGAR.App.view.layouts.BaseOmnichannelSearchLayout
 * @extends View.Views.Base.QuicksearchLayout
 */

({
	// Omnichannel-search Layout (base) 

    extendsFrom: 'QuicksearchLayout',
    className: 'omnichannel-search',

    componentsToAdd: [
        'omnichannel-search-modulelist',
        'omnichannel-search-button',
        'omnichannel-search-bar',
    ],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // Remove unneeded event from the parent quicksearch layout
        this.off('quicksearch:close');

        var dashboard = this.closestComponent('omnichannel-dashboard');
        if (dashboard && dashboard.searchCollection) {
            this.collection.off();
            this.collection = dashboard.searchCollection;
        }
    },
    /**
     * @inheritdoc
     */
    _placeComponent: function(component) {
        if (_.contains(this.componentsToAdd, component.name)) {
            this.$('[data-component=searchbar]').append(component.el);
        } else {
            this._super('_placeComponent', [component]);
        }
    },

    /**
     * Save the search collection so it can be used if we ever recreate this component
     * @private
     */
    _dispose: function() {
        // While this is a little dangerous, we need to save the data whenever the search tab gets disposed
        // searchCollection should get disposed later when omnichannel-dashboard is disposed
        var dashboard = this.closestComponent('omnichannel-dashboard');
        if (dashboard) {
            dashboard.searchCollection = this.collection;
        }
        this._super('_dispose');
    }
}) },
"merge-duplicates": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Merge-duplicates Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Headerpane:Cancel',
        'Headerpane:Save',
        'Sidebar:Toggle'
    ]
}) },
"resolve-conflicts": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Resolve-conflicts Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Headerpane:Cancel',
        'Sidebar:Toggle'
    ]
}) },
"drawer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DrawerLayout
 * @alias SUGAR.App.view.layouts.BaseDrawerLayout
 * @extends View.Layout
 */
({
	// Drawer Layout (base) 

    backdropHtml: '<div class="drawer-backdrop"></div>',

    onCloseCallback: null, //callbacks to be called once drawers are closed

    scrollTopPositions: [], //stores scroll positions for main and side pane

    // Do not show focus drawer icons in the top drawer
    disableFocusDrawer: true,

    initialize: function(options) {
        var self = this;

        /**
         * The fragments queue of the open drawers.
         *
         * @property {Array}
         * @private
         */
        this._fragments = [];

        if (!this.$el.is('#drawers')) {
            app.logger.error('Drawer layout can only be included as an Additional Component.');
            return;
        }

        app.drawer = this;
        this.onCloseCallback = [];

        // define the states the drawer can be in
        this.STATES = {
            IDLE: 'idle',
            OPENING: 'opening',
            CLOSING: 'closing'
        };
        // start in the IDLE state; the drawer will be IDLE most of the time
        this._enterState(this.STATES.IDLE);

        //clear out drawers before routing to another page
        this.name = 'drawer';

        app.view.Layout.prototype.initialize.call(this, options);

        // Browser find functionality auto-scrolls even when overflow is set to hidden.
        // Prevent scrolling only when there are active drawers.
        $(window).on('scroll.prevent', function() {
            self._preventScroll($(this));
        });
        app.$contentEl.on('scroll.prevent', function() {
            self._preventScroll($(this));
        });

        app.before('app:view:load', function() {
            return this.reset();
        }, this);
    },

    /**
     * Open the specified layout or view in a drawer.
     *
     * You can pass the current context if you want the context created to be a
     * child of that current context. If you don't pass a `scope`, it will
     * create a child of the main context (`app.controller.context`).
     *
     * @param {Object} def The component definition.
     * @param {Core.Context/Object} [def.context] The context to pass to
     *  the drawer.
     * @param {Core.Context} [def.context.parent] The parent context of
     *  the context to pass to the drawer.
     * @param {Function} [onClose] Callback method when the drawer closes.
     */
    open: function(def, onClose) {
        var component;

        app.shortcuts.saveSession();
        if (!app.triggerBefore('app:view:change')) {
            return;
        }

        this._enterState(this.STATES.OPENING);

        //store the callback function to be called later
        if (_.isUndefined(onClose)) {
            this.onCloseCallback.push(function(){});
        } else {
            this.onCloseCallback.push(onClose);
        }

        //initialize layout definition components
        this._initializeComponentsFromDefinition(def);

        component = _.last(this._components);

        this._updateFragments();

        //scroll both main and sidebar to the top
        this._scrollToTop();

        // Close omnichannel-console when opening drawer if it is open and not in compact mode
        if (app.omniConsole && app.omniConsole.isOpen() && app.omniConsole.getMode() !== 'compact') {
            app.omniConsole.close();
        }

        // Close the side drawer when the top drawer is open
        if (app.sideDrawer && app.sideDrawer.isOpen()) {
            app.sideDrawer.slideOut();
        }

        //open the drawer
        this._animateOpenDrawer(_.bind(function() {
            this._afterOpenActions();
        }, this));

        //load and render new layout in drawer
        component.loadData();
        component.render();
    },

    /**
     * Closes the top-most drawer.
     *
     * @param any parameters passed into the close method will be passed to the
     * callback.
     */
    close: function() {
        var self = this,
            args = Array.prototype.slice.call(arguments, 0);

        this._updateFragments(true);

        if (!Modernizr.csstransitions) {
            this.closeImmediately.apply(this, args);
            return;
        }

        if (this._components.length > 0) {
            if (!app.triggerBefore('app:view:change')) {
                return;
            }

            this._enterState(this.STATES.CLOSING);

            //close the drawer
            this._animateCloseDrawer(function() {
                self._afterCloseActions(args);
            });
        }
    },

    /**
     * Updates the fragments array according to the passed parameter.
     *   - Adds the current fragment to the fragments queue if no
     *   argument or `false` is passed.
     *   - Navigates back to the previous fragment if `true` is passed.
     *
     * @param {boolean} goBack `true` to navigate back to the previous fragment.
     *   No argument or `false` to add the current fragment to the queue.
     * @private
     */
    _updateFragments: function(goBack) {
        var component = _.last(this._components);
        if (!component.context.get('fromRouter')) {
            return;
        }

        if (goBack) {
            this._fragments.pop();
            app.router.navigate(_.last(this._fragments));
            if (this.count() === 1) {
                this._fragments = [];
            }
        } else {
            if (this.count() === 1) {
                this._fragments = [app.router.getPreviousFragment(), app.router.getFragment()];
            } else {
                this._fragments.push(app.router.getFragment());
            }
        }
    },

    /**
     * Close the top-most drawer immediately without transitions.
     *
     * @param any parameters passed into the close method will be passed to the
     * callback
     */
    closeImmediately: function() {
        if (this._components.length > 0) {
            var args = Array.prototype.slice.call(arguments, 0),
                drawers = this._getDrawers(false),
                drawerHeight = this._determineDrawerHeight();

            if (!app.triggerBefore('app:view:change')) {
                return;
            }

            this._enterState(this.STATES.CLOSING);

            //move the bottom drawer to the top and the next drawer to be viewed on the bottom.
            drawers.$bottom.css('top','');
            if (drawers.$next) {
                drawers.$next.css('top', this._isMainAppContent(drawers.$next) ? drawerHeight : drawers.$next.offset().top - drawerHeight);
            }

            this._removeBackdrop(drawers.$bottom);
            this._cleanUpAfterClose(drawers);
            this._afterCloseActions(args);

            // If the side drawer was open before this drawer was open, restore the side drawer
            if (app.sideDrawer && app.sideDrawer.isHidden()) {
                app.sideDrawer.slideIn();
            }
        }
    },

    /**
     * Reload the current drawer with a new layout or view.
     *
     * @param def The layout or view definition.
     */
    load: function(def) {
        var comp = this._components.pop(),
            top = comp.$el.css('top'),
            height = comp.$el.css('height'),
            drawers;

        comp.dispose();

        if (!app.triggerBefore('app:view:change')) {
            return;
        }

        this._enterState(this.STATES.OPENING);

        this._initializeComponentsFromDefinition(def);

        drawers = this._getDrawers(true);
        drawers.$next
            .addClass('drawer active')
            .css({
                top: top,
                height: height
            });

        //refresh backdrop
        this._removeBackdrop(drawers.$top);
        this._createBackdrop(drawers.$next, drawers.$top);

        comp = _.last(this._components);
        comp.loadData();
        comp.render();

        if (app.omniConsole && app.omniConsole.isOpen()) {
            app.omniConsole._setSize(app.omniConsole.isExpanded());
        }
        this._enterState(this.STATES.IDLE);
    },

    /**
     * Retrieves the number of drawers in the stack.
     *
     * @return {Number}
     */
    count: function() {
        return this._components.length;
    },

    /**
     * Test if element is part of active drawer.  Always returns true if there's no inactive components on page.
     * @param el DOM element to test if it is in the active drawer
     * @return boolean
     */
    isActive: function(el) {
        return ((this.count() === 0) || ($(el).parents('.drawer.active').length > 0));
    },

    /**
     * Gets the active drawer.
     *
     * @return {View.Component} The active drawer's component. `undefined` if
     *   no drawer is open.
     */
    getActive: function() {
        return _.last(this._components);
    },

    /**
     * Get currently active drawer layout.
     *
     * @return {View.Layout}
     * @deprecated Since 7.7. Will be removed in 7.9.
     */
    getActiveDrawerLayout: function() {
        app.logger.warn('Drawer\'s `getActiveDrawerLayout` is deprecated and will be removed in 7.9,' +
            'please use `getActive` instead.');
        return this.count() ? this.getActive() : app.controller.layout;
    },

    /**
     * Remove all drawers and reset
     * @param trigger Indicates whether to triggerBefore (defaults to true if anything other than `false`)
     */
    reset: function(triggerBefore) {
        triggerBefore = triggerBefore === false ? false : true;
        if (triggerBefore && !this.triggerBefore("reset", {drawer: this})) {
            return false;
        }

        var $main = app.$contentEl.children().first();

        this._enterState(this.STATES.CLOSING);

        _.each(this._components, function(component) {
            component.dispose();
        }, this);

        this._components = [];
        this.onCloseCallback = [];

        if ($main.hasClass('drawer')) {
            $main
                .removeClass('drawer inactive')
                .removeAttr('aria-hidden')
                .css('top','');
            this._removeBackdrop($main);
        }

        $('body').removeClass('noscroll');
        app.$contentEl.removeClass('noscroll');

        this._enterState(this.STATES.IDLE);
    },

    /**
     * Force to create a new context and create components from the layout/view
     * definition. If the parent context is defined, make the new context as a
     * child of the parent context.
     *
     * NOTE: same function is also used in side-drawer.js to have consistent behavior
     *
     * @param {Object} def The layout or view definition.
     * @private
     */
    _initializeComponentsFromDefinition: function(def) {
        var parentContext;
        def = def || {};

        if (_.isUndefined(def.context)) {
            def.context = {};
        }

        if (_.isUndefined(def.context.forceNew)) {
            def.context.forceNew = true;
        }

        if (!(def.context instanceof app.Context) && def.context.parent instanceof app.Context) {
            parentContext = def.context.parent;
            // Remove the `parent` property to not mess up with the context
            // attributes.
            delete def.context.parent;
        }

        this.initComponents([def], parentContext);
    },

    /**
     * Animate opening of a new drawer.
     *
     * @private
     * @param {Function} callback Called when open animation is finished.
     */
    _animateOpenDrawer: function(callback) {
        if (this._components.length === 0) {
            this._enterState(this.STATES.IDLE);
            return;
        }

        var drawers = this._getDrawers(true),
            drawerHeight = this._determineDrawerHeight(),
            topDrawerCurrentTopPos = drawers.$top.offset().top,
            aboveWindowTopPos = topDrawerCurrentTopPos - drawerHeight, //top position above the browser window
            bottomDrawerTopPos = this._isMainAppContent(drawers.$top) ? drawerHeight : topDrawerCurrentTopPos + drawerHeight,
            belowWindowTopPos; //top position below the browser window

        if (drawers.$bottom) {
            belowWindowTopPos = drawers.$bottom.offset().top + drawerHeight;
        }

        if (this._isMainAppContent(drawers.$top)) {
            //make sure that the main application content is set as a drawer
            drawers.$top.addClass('drawer').trigger('drawer:add');
            $('body').addClass('noscroll');
            app.$contentEl.addClass('noscroll');
        }

        //add the backdrop to the top drawer
        this._createBackdrop(drawers.$next, drawers.$top);

        //indicate that it's an active drawer
        drawers.$next.addClass('drawer active');
        //set the height of the new drawer
        drawers.$next.css('height', drawerHeight);
        //set the animation starting point for the new drawer
        drawers.$next.css('top', aboveWindowTopPos);
        //mark the top drawer as inactive
        drawers.$top
            .addClass('inactive')
            .removeClass('active')
            .attr('aria-hidden', true); //accessibility
        //prevent scrolling on drawer
        drawers.$top.on('scroll.prevent', _.bind(function() {
            this._preventScroll(drawers.$top);
        }, this));

        // Need to do a defer so that transition can be applied when the drawer is coming down
        // but not when it's being setup above browser window.
        _.defer(_.bind(function() {
            this._setTransition(drawers);
            this._onTransitionEnd(drawers.$next, function() {
                this._removeTransition(drawers);
                if (_.isFunction(callback)) {
                    callback();
                }
                this.trigger('drawer:resize', drawerHeight);
            });

            //start animation to open the drawer
            drawers.$next.css('top','');
            drawers.$top.css('top', bottomDrawerTopPos);
            if (drawers.$bottom) {
                drawers.$bottom.css('top', belowWindowTopPos);
            }

            //resize the visible drawer when the browser resizes
            if (this._components.length === 1) {
                $(window).on('resize.drawer', _.bind(this._resizeDrawer, this));
            }
        }, this));
    },

    /**
     * Animate closing of the top-most drawer.
     *
     * @param {Function} callback Function to be called after drawer has been
     * closed.
     * @private
     */
    _animateCloseDrawer: function(callback) {
        if (this._components.length === 0) {
            this._enterState(this.STATES.IDLE);
            return;
        }

        var drawers = this._getDrawers(false),
            drawerHeight = this._determineDrawerHeight(),
            aboveWindowTopPos = drawers.$top.offset().top - drawerHeight, //top position above the browser window
            bottomDrawerTopPos; //top position of the bottom drawer

        if (drawers.$next) {
            bottomDrawerTopPos = this._isMainAppContent(drawers.$next) ? drawerHeight : drawers.$next.offset().top - drawerHeight;
        }

        this._setTransition(drawers);
        this._onTransitionEnd(drawers.$bottom, function() {
            this._removeTransition(drawers);
            this._cleanUpAfterClose(drawers);
            if (_.isFunction(callback)) {
                callback();
            }
        });

        //start the animation to close the drawer
        drawers.$top.css('top', aboveWindowTopPos);
        drawers.$bottom.css('top','');
        if (drawers.$next) {
            drawers.$next.css('top', bottomDrawerTopPos);
        }

        this._removeBackdrop(drawers.$bottom);
    },

    /**
     * Get all (top, bottom, next) drawers layouts depending upon whether or not
     * a drawer is being opened or closed.
     *
     * @param {boolean} open `true` if the drawer is being opened.
     * @return {Object}
     * @private
     */
    _getDrawers: function(open) {
        var $main = app.$contentEl.children().first(),
            $nextDrawer, $topDrawer, $bottomDrawer,
            open = _.isUndefined(open) ? true : open,
            drawerCount = this._components.length;

        switch (drawerCount) {
            case 0: //no drawers
                break;
            case 1: //only one drawer
                $nextDrawer = open ? this._components[drawerCount-1].$el : undefined;
                $topDrawer = open ? $main : this._components[drawerCount-1].$el;
                $bottomDrawer = open? undefined : $main;
                break;
            case 2: //two drawers
                $nextDrawer = open ? this._components[drawerCount-1].$el : $main;
                $topDrawer = open ? this._components[drawerCount-2].$el : this._components[drawerCount-1].$el;
                $bottomDrawer = open? $main : this._components[drawerCount-2].$el;
                break;
            default: //more than two drawers
                $nextDrawer = open ? this._components[drawerCount-1].$el : this._components[drawerCount-3].$el;
                $topDrawer = open ? this._components[drawerCount-2].$el : this._components[drawerCount-1].$el;
                $bottomDrawer = open? this._components[drawerCount-3].$el : this._components[drawerCount-2].$el;
        }

        return {
            $next: $nextDrawer,
            $top: $topDrawer,
            $bottom: $bottomDrawer
        };
    },

    /**
     * Is this drawer the main application content area?
     * @param $layout
     * @return {Boolean}
     * @private
     */
    _isMainAppContent: function($layout) {
        return !$layout.parent().is(this.$el);
    },

    /**
     * Calculate how far down the drawer should drop down, i.e. the height of the drawer
     * @param $mainContent
     * @return {Number}
     * @private
     */
    _determineDrawerHeight: function() {
        var windowHeight = $(window).height(),
            headerHeight = $('#header .navbar').outerHeight(),
            footerHeight = $('footer').outerHeight();

        return windowHeight - headerHeight - footerHeight;
    },

    /**
     * Calculate how much to collapse the drawer
     * @return {Number}
     * @private
     */
    _determineCollapsedHeight: function() {
        return $(window).height()/2; //middle of the window
    },

    /**
     * Create tab and the backdrop. Add the ability to expand and collapse the drawer when the tab is clicked
     * @param $top
     * @param $bottom
     * @deprecated Since 10.3.0
     * @private
     */
    _createTabAndBackdrop: function($top, $bottom) {
        app.logger.warn(
            '_createTabAndBackdrop($top, $bottom) is deprecated in 10.3.0. ' +
            'The ability to expand the drawer view has been removed. ' +
            'Please use _createBackdrop($top, $bottom) instead.'
        );

        var $drawerTab;

        //add the expand tab and the backdrop to the top drawer
        this.expandTpl = app.template.getLayout(this.name + '.expand');
        this.expandTabHtml = this.expandTpl();

        $bottom
            .append(this.expandTabHtml)
            .append(this.backdropHtml);

        //add tooltip
        $drawerTab = $bottom.find('.drawer-tab');

        //add expand/collapse tab behavior
        $drawerTab.on('click', _.bind(function(event) {
            if ($('i', event.currentTarget).hasClass('sicon-chevron-up')) {
                this._collapseDrawer($top, $bottom);
            } else {
                this._expandDrawer($top, $bottom);
            }
            return false;
        }, this));
        app.accessibility.run($drawerTab, 'click');
    },

    /**
     * Create backdrop for the drawer.
     * @param $top
     * @param $bottom
     * @private
     */
    _createBackdrop: function($top, $bottom) {
        $bottom
            .append(this.backdropHtml);
    },

    /**
     * Remove the tab and the backdrop and the event listener that handles the ability to expand and collapse the drawer.
     * @param $drawer
     * @deprecated Since 10.3.0.
     * @private
     */
    _removeTabAndBackdrop: function($drawer) {
        app.logger.warn(
            '_removeTabAndBackdrop($drawer) is deprecated in 10.3.0. ' +
            'The ability to expand the drawer view has been removed. ' +
            'Please use _removeBackdrop($drawer) instead.'
        );

        //remove drawer tab
        var $drawerTab = $drawer.find('.drawer-tab')
            .off('click')
            .remove();

        //remove backdrop
        $drawer.find('.drawer-backdrop')
            .remove();
    },

    /**
     * Remove the drawer backdrop.
     * @param $drawer
     * @private
     */
    _removeBackdrop: function($drawer) {
        $drawer.find('.drawer-backdrop')
            .remove();
    },

    /**
     * Process clean up after the drawer has been closed.
     * @param {Object} drawers Object of drawers ({@link #_getDrawers})
     * @private
     */
    _cleanUpAfterClose: function(drawers) {
        drawers.$top.removeClass('active');

        drawers.$bottom
            .removeClass('inactive')
            .addClass('active')
            .removeAttr('aria-hidden') //accessibility
            .off('scroll.prevent'); //remove event handler that prevents scrolling

        if (this._isMainAppContent(drawers.$bottom)) {
            drawers.$bottom.removeClass('drawer active').trigger('drawer:remove');
            $('body').removeClass('noscroll');
            app.$contentEl.removeClass('noscroll');
        } else {
            //refresh drawer position and height for collapsed or resized drawers
            this._expandDrawer(drawers.$bottom, drawers.$next);
        }

        //set scrollable elements back its original position
        this._scrollBackToOriginal(drawers.$bottom);

        //remove resize handler
        if (this._components.length === 1) {
            $(window).off('resize.drawer');
        }
    },

    /**
     * Trigger view change event and return to idle state.
     *
     * @private
     */
    _afterOpenActions: function() {
        var layout = _.last(this._components);

        // Forecasts config route uses the drawer but if user
        // does not have access, initialize is never called so the
        // context on the layout never gets set. Adding check to make
        // sure there actually is a context to use on the layout
        if (layout.context) {
            app.trigger('app:view:change', layout.options.type, _.extend(layout.context.attributes, {drawer: true}));
        }

        this._enterState(this.STATES.IDLE);
    },

    /**
     * Trigger view change event and restore shortcuts session.
     * @param {array} callbackArgs Arguments that will be passed to the callback
     * @private
     */
    _afterCloseActions: function(callbackArgs) {
        var layout;
        var topDrawer;
        var closeCallback;

        topDrawer = this._components.pop();
        if (topDrawer) {
            topDrawer.dispose(); //dispose top-most drawer
        }

        layout = _.last(this._components);
        if (layout) { // still have layouts in the drawer
            app.trigger('app:view:change', layout.options.type, layout.context.attributes);
        } else { //we've returned to base layout
            app.trigger('app:view:change', app.controller.context.get('layout'),
                _.extend(app.controller.context.attributes, {drawer: true}));

            // If the side drawer was open before this drawer was open, restore the side drawer
            if (app.sideDrawer && app.sideDrawer.isHidden()) {
                app.sideDrawer.slideIn();
            }

            // Reopen the omnichannel after all drawers are closed, as long as the omnichannel was closed automatically
            // and omnichannel config is not open either
            if (app.omniConsole && app.omniConsole.canBeAutomaticallyReopened() &&
                !(app.omniConsoleConfig && (app.omniConsoleConfig.isMinimized || app.omniConsoleConfig.isOpen()))
            ) {
                app.omniConsole.open();
            }
        }

        this._enterState(this.STATES.IDLE);

        app.shortcuts.restoreSession();

        closeCallback = this.onCloseCallback.pop();
        if (closeCallback) {
            closeCallback.apply(window, callbackArgs); //execute callback
        }
    },

    /**
     * Expand the drawer.
     * @param {jQuery} $top The top drawer
     * @param {jQuery} $bottom The bottom drawer
     * @private
     */
    _expandDrawer: function($top, $bottom) {
        var expandHeight = this._determineDrawerHeight();
        $top.css('height', expandHeight);

        if (this._isMainAppContent($bottom)) {
            $bottom.css('top', expandHeight);
        } else {
            $bottom.css('top', expandHeight + $top.offset().top);
        }

        $bottom
            .find('.drawer-tab i')
            .removeClass('sicon-chevron-down')
            .addClass('sicon-chevron-up');

        this.trigger('drawer:resize', expandHeight);
    },

    /**
     * Collapse the drawer.
     * @param {jQuery} $top The top drawer
     * @param {jQuery} $bottom The bottom drawer
     * @private
     */
    _collapseDrawer: function($top, $bottom) {
        var collapseHeight = this._determineCollapsedHeight();
        $top.css('height', collapseHeight);

        if (this._isMainAppContent($bottom)) {
            $bottom.css('top', collapseHeight);
        } else {
            $bottom.css('top', collapseHeight + $top.offset().top);
        }

        $bottom
            .find('.drawer-tab i')
            .removeClass('sicon-chevron-up')
            .addClass('sicon-chevron-down');

        this.trigger('drawer:resize', collapseHeight);
    },

    /**
     * Add transition to the drawers.
     * @param {Object} drawers Object of drawers ({@link #_getDrawers})
     * @private
     */
    _setTransition: function(drawers) {
        drawers.$top.addClass('transition');

        if (drawers.$next) {
            drawers.$next.addClass('transition');
        }

        if (drawers.$bottom) {
            drawers.$bottom.addClass('transition');
        }
    },

    /**
     * Remove transition from the drawers.
     * @param {Object} drawers Object of drawers ({@link #_getDrawers})
     * @private
     */
    _removeTransition: function(drawers) {
        drawers.$top.removeClass('transition');

        if (drawers.$next) {
            drawers.$next.removeClass('transition');
        }

        if (drawers.$bottom) {
            drawers.$bottom.removeClass('transition');
        }
    },

    /**
     * Is the drawer in a middle of a transition?
     * @param {jQuery} drawer top, bottom, or next drawer layout
     * @return {boolean}
     * @private
     */
    _isInTransition: function(drawer) {
        return drawer.hasClass('transition');
    },

    /**
     * Attach transition end event handler for a given drawer.
     * @param {jQuery} $drawer Drawer to attach the event
     * @param {Function} callback Event handler
     * @private
     */
    _onTransitionEnd: function($drawer, callback) {
        var self = this,
            transitionEndEvents = 'webkitTransitionEnd oTransitionEnd otransitionend transitionend msTransitionEnd';

        //once the animation is done, reset to original state and execute callback parameter
        $drawer.one(transitionEndEvents, function() {
            $drawer.off(transitionEndEvents); //some browsers fire multiple transitionend events
            callback.call(self);
        });

        //this is a failsafe to ensure that drawer will always close
        //in Chrome the css change to 'top' sometimes (randomly) doesn't actually change the css value
        _.delay(function() {
            $drawer.trigger('transitionend');
        }, 400);
    },

    /**
     * Scroll the scrollable divs to the top and save its position.
     * Content needs to be scrolled as well because in small width screens,
     * the responsive layout changes the #content div to be a scrollable container
     * @private
     */
    _scrollToTop: function() {
        var drawers = this._getDrawers(true),
            $mainpane = drawers.$top.find('.main-pane'),
            $sidepane = drawers.$top.find('.sidebar-content'),
            $content = app.$contentEl;

        this.scrollTopPositions.push({
            main: $mainpane.scrollTop(),
            side: $sidepane.scrollTop(),
            drawer: drawers.$top.scrollTop(),
            content: $content.scrollTop()
        });

        drawers.$top.scrollTop(0);
        $mainpane.scrollTop(0);
        $sidepane.scrollTop(0);
        $content.scrollTop(0);
    },

    /**
     * Scroll the scrollable elements back to its original position.
     * @param {jQuery} [$drawer] Drawer to scroll back
     * @private
     */
    _scrollBackToOriginal: function($drawer) {
        var scrollPositions = this.scrollTopPositions.pop();

        if (!scrollPositions || _.isEmpty(scrollPositions)) {
            return;
        }

        if ($drawer) {
            $drawer.scrollTop(scrollPositions.drawer);
        } else {
            $drawer = app.$contentEl;
        }

        $drawer.find('.main-pane').scrollTop(scrollPositions.main);
        $drawer.find('.sidebar-content').scrollTop(scrollPositions.side);
        app.$contentEl.scrollTop(scrollPositions.content);
    },

    /**
     * Get the current height of the active drawer
     * @return {Number}
     */
    getHeight: function(){
        if (_.isEmpty(this._components)) {
            return 0; // No drawers on page
        }
        var $top = this._getDrawers(false).$top;
        return $top.height();
    },

    /**
     * Prevent scrolling when drawer is open.  This feature is needed because browsers
     * automatically scroll when the Find feature is used (Ctrl+F) even when the scrollable
     * elements have been set with hidden overflow.
     * @param {jQuery} $scrollable Scrollable element that needs to be prevented from scrolling
     * @private
     */
    _preventScroll: function($scrollable) {
        // Preventing scrolls in iOS 7 causes AJAX calls to be paused (MAR-2768). No problems in iOS 8.
        if (!Modernizr.touch && (app.drawer.count() > 0)) {
            $scrollable.scrollTop(0);
        }
    },

    _dispose: function() {
        this.reset();
        app.offBefore(null, null, this);
        $(window).off('resize.drawer');
        $(window).off('scroll.prevent');
        app.$contentEl.on('scroll.prevent');
        this._super('_dispose');
    },

    /**
     * Resize the height of the drawer by expanding.
     */
    _resizeDrawer: _.throttle(function() {
        var drawers = this._getDrawers(false);
        // Do not resize the drawer when the drawer is opening or closing.
        if (drawers.$top && !this.isOpening() && !this.isClosing()) {
            this._expandDrawer(drawers.$top, drawers.$bottom);
        }
    }, 300),

    /**
     * Enter the drawer into one of the allowed states.
     *
     * @param {string} state
     * @return {string} If the returned state is the same as the previous
     * state, then the parameter was not a valid state.
     * @private
     */
    _enterState: function(state) {
        if (_.contains(this.STATES, state)) {
            this.state = state;
        }

        return this.state;
    },

    /**
     * Confirms or denies that the current state of the drawer is the expected
     * state.
     *
     * @param state
     * @return {boolean}
     */
    isInState: function(state) {
        return state === this.state;
    },

    /**
     * Is the drawer currently in the idle state?
     *
     * The drawer will be in the IDLE state unless a drawer is currently
     * opening or closing.
     *
     * @return {boolean}
     */
    isIdle: function() {
        return this.isInState(this.STATES.IDLE);
    },

    /**
     * Is the drawer currently opening?
     *
     * The drawer will be in the OPENING state while a drawer is opening. Once
     * the open animation has completed, the drawer state is returned to IDLE.
     *
     * @return {boolean}
     */
    isOpening: function() {
        return this.isInState(this.STATES.OPENING);
    },

    /**
     * Is the drawer currently closing?
     *
     * The drawer will be in the CLOSING state while a drawer is closing. Once
     * the close animation has completed, the drawer state is returned to IDLE.
     *
     * @return {boolean}
     */
    isClosing: function() {
        return this.isInState(this.STATES.CLOSING);
    }
}) },
"subpanel-with-massupdate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SubpanelWithMassupdateLayout
 * @alias SUGAR.App.view.layouts.BaseSubpanelWithMassupdateLayout
 * @extends View.Layouts.Base.SubpanelLayout
 */
({
	// Subpanel-with-massupdate Layout (base) 

    extendsFrom:"SubpanelLayout",

    /**
     * Overriding to just check the items in a subpanel-with-massupdate
     * @inheritdoc
     * @override
     */
    _stopComponentToggle: function(component) {
        // subpanel header top should always render
        return component.name === "panel-top" || component.name === 'massupdate'
        || (!_.isUndefined(component.$el)
        && component.$el.hasClass('subpanel-header'));
    }
}) },
"create-no-cancel-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.CreateNoCancelButtonLayout
 * @alias SUGAR.App.view.layouts.CreateNoCancelButtonLayout
 * @extends View.Layouts.Base.CreateLayout
 */
({
	// Create-no-cancel-button Layout (base) 

    extendsFrom: 'CreateLayout',
}) },
"row-model-data": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.RowModelDataLayout
 * @alias SUGAR.App.view.layouts.RowModelDataLayout
 * @extends View.Layout
 */
({
	// Row-model-data Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.context.set('layout', options.context.get('layout') || 'multi-line');
        this.context.set('rowModel', options.context.get('model'));
        this.context = this.context.getChildContext({layout: this.context.get('layout')});
    },

    /**
     * Extends the base loadData to make sure that we have a fully fetched bean
     * for the rowModel
     * @param options
     */
    loadData: function(options) {
        if (this.options && this.options.context && this.options.context.get('modelId')) {
            var rowModelBean = app.data.createBean(this.options.context.get('module'), {
                id: this.options.context.get('modelId')
            });

            app.alert.show('load_row_data_model', {
                level: 'process',
                title: app.lang.get('LBL_LOADING'),
                autoClose: false
            });

            rowModelBean.fetch({
                success: _.bind(function() {
                    if (this.disposed) {
                        return;
                    }
                    this.context.parent.set('rowModel', rowModelBean);
                    _.each(app.sideDrawer._breadcrumbs, function(bread) {
                        if (bread.context.modelId === rowModelBean.get('id')) {
                            bread.context.model = rowModelBean;
                        }
                    });
                    this._super('loadData', [options]);
                }, this),
                complete: function() {
                    app.alert.dismiss('load_row_data_model');
                }
            });
        } else {
            this._super('loadData', [options]);
        }
    },

    /**
     * Change row model.
     * @param {Object} model The new row model
     * @return {boolean} true if model changed, otherwise false
     */
    setRowModel: function(model) {
        var dashboard = this.getComponent('row-model-data').getComponent('dashboard');
        if (dashboard && dashboard.model.mode !== 'edit') {
            this.context.parent.set('rowModel', model);
            dashboard.getComponent('dashlet-main').setMetadata();
            return true;
        }
        return false;
    },

    /**
     * Retrieves the current row model
     *
     * @return {Bean|null} the current row model if it exists; null otherwise
     */
    getRowModel: function() {
        var focusedRecord = this.context && this.context.parent && this.context.parent.get('rowModel');
        return focusedRecord || null;
    }
}) },
"consent-wizard": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ConsentWizardLayout
 * @alias SUGAR.App.view.layouts.BaseConsentWizardLayout
 * @extends View.Layouts.Base.WizardLayout
 */
({
	// Consent-wizard Layout (base) 

    extendsFrom: 'WizardLayout',

    /**
     * Skip to the Layout addComponent to ignore logic around adding buttons to meta
     * inside wizard.js
     *
     * @override
     */
    addComponent: function(component, def) {
        if (_.result(component, 'showPage')) {
            app.view.Layout.prototype.addComponent.call(this, component, def);
        }
    }
}) },
"multi-selection-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.MultiSelectionListLayout
 * @alias SUGAR.App.view.layouts.BaseMultiSelectionListLayout
 * @extends View.Layout.Base.SelectionListLayout
 */
({
	// Multi-selection-list Layout (base) 

    extendsFrom: 'SelectionListLayout'
}) },
"hint-news-panel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
* @class View.Layouts.Base.HintNewsPanelLayout
* @alias SUGAR.App.view.layouts.BaseHintNewsPanelLayout
* @extends View.Layout
*/
({
	// Hint-news-panel Layout (base) 

    plugins: ['Stage2CssLoader'],
}) },
"modal": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ModalLayout
 * @alias SUGAR.App.view.layouts.BaseModalLayout
 * @extends View.Layout
 */
/**
 *
 * Create a modal popup that renders popup layout container
 * array(
 *      'layout' => 'modal',
 *      'showEvent' => [event name] //corresponding trigger name (a single string or array of strings)
 *      ),
 * @fires [event name] Create popup modal window and draws specified type of layout
 *      @params Parameters - [Object] {
 *              span - [int] size of modal[1-12]
 *              options - (Optional) 3rd party options goes here
 *
 *              components - [Array] list of either views or layouts (optional for single layout)
 *                           i.e. [ {view: ... } , {layout: ..., context: ... }, ...]
 *
 *                  context should be within the each component metadata.
 *                  context - [Object] configured context attributes
 *                        i.e. { module:..., link:..., modelId:... }
 *                        {
 *                            module - [String] Module name (i.e. Accounts, Contacts, etc) (optional),
 *                            link - [String] related module name (optional),
 *                            modelId - [String] model ID (optional)
 *                        }
 *      }
 *
 *      @params callback - [function(model)] - called by trigger "modal:callback" with correponded model
 *
 * @fires "modal:callback" Executes binded callback function with the updated model as parameter
 *      @params model - object Backbone model that relates to the current job
 *
 * @fires "modal:close" Close popup modal and release layout for popup
 *
 * How to Use:
 * in the view dashlet
 *     this.layout.trigger([event name], ...)
 * in the field dashlet
 *     this.view.layout.trigger([event name], ...)
 */
({
	// Modal Layout (base) 

    baseComponents: [
        { 'view' : 'modal-header' }
    ],
    initialize: function(options, skipModalJsCheck) {
        var self = this,
            showEvent = options.meta.showEvent;

        if (!skipModalJsCheck) {
            if(!_.isFunction(this.$el.modal)) {
                app.logger.error("Unable to load modal.js: Needs bootstrap modal plugin.");
            }
        }

        this.metaComponents = options.meta.components;
        options.meta.components = this.baseComponents;
        if (options.meta.before){
            _.each(options.meta.before, function(callback, event){
                self.before(event, callback);
            });
        }
        app.view.Layout.prototype.initialize.call(this, options);
        options.meta.components = this.metaComponents; //revert components metadata back to original
        if (showEvent) {
            if(_.isArray(showEvent)) {
                //Bind the multiple event handler names
                _.each(showEvent, function(evt, index) {
                    self._bindShowEvent(evt);
                });
            } else {
                self._bindShowEvent(showEvent);
            }
        }
    },
    _bindShowEvent : function(event, delegate){
        var self = this;
        if (_.isObject(event))
        {
            delegate = event.delegate;
            event = event.event;
        }
        if (delegate){
            self.layout.events = self.layout.events || {};
            self.layout.events[event] = function(params, callback){self.show(params, callback)};
            self.layout.delegateEvents();
        } else {
            self.layout.on(event, function(params, callback){self.show(params, callback);}, self);
        }
    },
    getBodyComponents: function() {
        return _.rest(this._components, this._initComponentSize);
    },
    _placeComponent: function(comp, def) {
        if(this.$('.modal:first').length == 0) {
            this.$el.append(
                $('<div>', {'class' : 'modal hide'}).append(
                    this.$body
                )
            );
        }

        if(def.bodyComponent) {
            if(_.isUndefined(this.$body)) {
                this.$body = $('<div>', {'class' : 'modal-body'});
                this.$('.modal:first').append(this.$body);
            }
            this.$body.append(comp.el);
        } else {
            this.$('.modal:first').append(comp.el);
        }
    },

    /**
     *
     * @param params
     * @param callback
     * @private
     */
    _buildComponentsBeforeShow : function(params, callback) {
        var self = this,
            params = params || {},
            buttons = params.buttons || [],
            message = params.message || '',
            components = (params.components || this.metaComponents || []),
            title = (params.title || this.meta.title) + '';
        if(message && components.length == 0) {
            this.confirmMessage = message;
            components.push({view: 'modal-confirm'});
        }
        //stops for empty component elements
        if(components.length == 0) {
            app.logger.error("Unable to display modal dialog: no components or message");
            return false;
        }

        //set title and buttons for modal-header
        var header_view = self.getComponent('modal-header');
        if(header_view) {
            header_view.setTitle(title);
            header_view.setButton(buttons);
        }

        //if previous modal-body exists, remove it.
        if(self._initComponentSize) {
            for(var i = 0; i < self._components.length; i++) {
                self._components[self._components.length - 1].$el.remove();
                self.removeComponent(self._components.length - 1);
            }
        } else {
            self._initComponentSize = self._components.length;
        }

        this.initComponents(components);

        self.context.off("modal:callback");
        self.context.on("modal:callback", function(model) {
            callback(model);
            self.hide();
        },self);
        self.context.off("modal:close");
        self.context.on("modal:close", self.hide, self);


    },

    show: function(params, callback) {
        if (!this.triggerBefore("show") || this.disposed) return false;
        var self = this;
        if (params.before){
            _.each(params.before, function(callback, event){
                self.offBefore(event);
                self.before(event, callback);
            });
        }

        if (this._buildComponentsBeforeShow(params, callback) === false)
            return false;
        this.loadData();
        this.render();
        var width = params ? params.width : null,
            options = params ? params.options || {} : {},
            modal_container = this.$(".modal:first");

        //Clean out previous span css class
        modal_container.attr("style", "");
        if(_.isNumber(width)) {
            modal_container.width(width);
            modal_container.css('marginLeft', -(width/2) + 'px');
        }
        if(!_.isFunction(modal_container.modal)) {
            app.logger.error("Unable to load modal.js: Needs bootstrap modal plugin.");
            return false;
        }

        modal_container.modal(_.extend({keyboard:false, backdrop:'static'}, options.modal));
        modal_container.modal('show');

        this.trigger("show");
        return true;
    },
    hide: function(event) {
        if (!this.triggerBefore("hide")) return false;
        //restore back to the scroll position at the top
        var modal_container = this.$(".modal:first");
        modal_container.scrollTop(0);

        if(!_.isFunction(modal_container.modal)) {
            app.logger.error("Unable to load modal.js: Needs bootstrap modal plugin.");
            return false;
        }
        modal_container.modal('hide');
        this.trigger("hide");
        return true;
    }
}) },
"shortcuts": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ShortcutsLayout
 * @alias SUGAR.App.view.layouts.BaseShortcutsLayout
 * @extends View.Layout
 */
({
	// Shortcuts Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: ['Headerpane:Cancel'],

    /**
     * @inheritdoc
     */
    _placeComponent: function(component) {
        this.$('[data-action=render]').append(component.el);
    },

    /**
     * Do not fetch data.
     */
    loadData: $.noop
}) },
"selection-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SelectionListLayout
 * @alias SUGAR.App.view.layouts.BaseSelectionListLayout
 * @extends View.Layout
 */
({
	// Selection-list Layout (base) 

    plugins: ['ShortcutSession', 'ConfigDrivenList'],

    shortcuts: [
        'Headerpane:Cancel',
        'Sidebar:Toggle'
    ],

    loadData: function(options) {
        var fields = _.union(this.getFieldNames(), (this.context.get('fields') || []));
        this.context.set('fields', fields);
        this._super('loadData', [options]);
    }
}) },
"filterpanel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.FilterpanelLayout
 * @alias SUGAR.App.view.layouts.BaseFilterpanelLayout
 * @extends View.Layouts.Base.TogglepanelLayout
 */
({
	// Filterpanel Layout (base) 

    extendsFrom: 'TogglepanelLayout',

    /**
     * @inheritdoc
     *
     * Certain options can be set in the filterpanel metadata:
     *     - `auto_apply`: this will determine whether or not to apply the
     *       filter while completing filter rows. This is used mainly because
     *       getRelevantContextList may return the global context and will
     *       filter its collection automatically, and sometimes this is not
     *       desired (e.g. a drawer layout with a filterpanel embedded).
     *
     *     - `stickiness`: this will determine whether or not to save
     *       properties pertaining to filters in localstorage. This is needed
     *       for certain views that have filterpanels, do not require
     *       stickiness and do not want to affect already-stored values in
     *       localstorage (e.g. the filterpanel layout in dashboardconfiguration
     *       shouldn't affect the stickiness of filters on record/list views,
     *       so it should be set to false).
     *
     *     - `show_actions`: this will determine whether or not the
     *       `delete`, `reset`, and `cancel` action buttons will be rendered on
     *       the `filter-actions` view.
     *
     *     @example
     *     <pre><code>
     *         'layout' => array(
     *              'type' =>'filterpanel',
     *              'filter_options' => array(
     *                  'auto_apply' => false,
     *                  'stickiness' => false,
     *                  'show_actions' => false,
     *              ),
     *          ),
     *     </code></pre>
     */
    initialize: function(opts) {
        // The filter options default to true.
        var defaultOptions = {
            'auto_apply': true,
            'stickiness': true,
            'show_actions': true
        };

        this.events = _.extend({}, this.events, {
            'click [data-action=refreshList]': '_refreshList'
        });

        var moduleMeta = app.metadata.getModule(opts.module) || {};
        this.disableActivityStreamToggle(opts.module, moduleMeta, opts.meta || {});

        this.disablePipelineToggle(opts.module, moduleMeta, opts.meta || {});

        this.on("filterpanel:change:module", function(module, link) {
            this.currentModule = module;
            this.currentLink = link;
        }, this);

        this.on('filter:create:open', function() {
            this.$('.filter-options').removeClass('hide');

            // "filter:create:open" is triggered even when the edit drawer is
            // being closed, so protect against saving the shortcuts when that
            // happens
            var activeShortcutSession = app.shortcuts.getCurrentSession();
            if (_.isNull(activeShortcutSession)
                || (activeShortcutSession && activeShortcutSession.layout !== this)) {
                app.shortcuts.saveSession();
                app.shortcuts.createSession([
                    'Filter:Add',
                    'Filter:Remove',
                    'Filter:Close',
                    'Filter:Save',
                    'Filter:Delete',
                    'Filter:Reset'
                ], this);
            }
        }, this);

        this.on('filter:collapse', function() {
            this.togglePanelHide();
            this.collapseAndUpdateDisplay(true);
        }, this);

        this.on('filter:create:close', function() {
            this.togglePanelHide();
            this.collapseAndUpdateDisplay(false);

            // "filter:create:close" is triggered even when filter:create:open has not been called
            var activeShortcutSession = app.shortcuts.getCurrentSession();
            if (activeShortcutSession && (activeShortcutSession.layout === this)) {
                app.shortcuts.restoreSession();
            }
        }, this);

        // This is required, for example, if we've disabled the subapanels panel so that app doesn't attempt to render later
        this.on('filterpanel:lastviewed:set', function(viewed) {
            this.toggleViewLastStateKey = this.toggleViewLastStateKey || app.user.lastState.key('toggle-view', this);
            var lastViewed = app.user.lastState.get(this.toggleViewLastStateKey);
            if (lastViewed !== viewed) {
                app.user.lastState.set(this.toggleViewLastStateKey, viewed);
            }
        }, this);

        this._super("initialize", [opts]);

        // Set the filter that's currently being edited.
        this.context.editingFilter = null;

        // Obtain any options set in the metadata and override the defaultOptions with them
        // to set on the context.
        var filterOptions = _.extend(defaultOptions, this.meta.filter_options, this.context.get('filterOptions'));
        this.context.set('filterOptions', filterOptions);

        // The `defaultModule` will either evaluate to the model's module (more
        // specific, and used on dashablelist filters), or the module on the
        // current context.
        var lastViewed = app.user.lastState.get(this.toggleViewLastStateKey),
            defaultModule = this.module || this.model.get('module') || this.context.get('module');

        this.trigger('filterpanel:change:module', (moduleMeta.activityStreamEnabled && lastViewed === 'activitystream') ? 'Activities' : defaultModule);
    },

    /**
     * Toggles hiding the filter panel
     */
    togglePanelHide: function() {
        this.$('.filter-options').addClass('hide');
    },

    /**
     * Called when collapsing the filter panel. Controls updating the the displayed filter name
     * @param {boolean} collapse
     */
    collapseAndUpdateDisplay: function(collapse) {
        const filter = this.context.editingFilter;
        if (!filter) {
            return;
        }
        const filterId = filter.get('id');

        if (!filterId) {
            if (collapse) {
                this.context.trigger('filter:collapse', {
                    id: 'create',
                    text: app.lang.get('LBL_FILTER_CREATE_NEW_UNSAVED')
                });
            }
        } else {
            const filterName = filter.get('name');
            if (collapse) {
                this.context.trigger('filter:collapse', {id: `${filterId}`,
                    text: `${filterName} ${app.lang.get('LBL_FILTER_EDIT_UNSAVED_SUFFIX')}`});
            }
        }
    },

    /**
     * Applies last filter
     * @param {Collection} collection the collection to retrieve the filter definition
     * @param {String} condition(optional) You can specify a condition in order to prevent applying filtering
     */
    applyLastFilter: function(collection, condition) {
        var triggerFilter = true;
        if (_.size(collection.origFilterDef)) {
            if (condition === 'favorite') {
                //Here we are verifying the filter applied contains $favorite otherwise we don't really care about
                //refreshing the listview
                triggerFilter = !_.isUndefined(_.find(collection.origFilterDef, function(value, key) {
                    return key === '$favorite' || (value && !_.isUndefined(value.$favorite));
                }));
            }
            if (triggerFilter) {
                var query = this.$('.search input.search-name').val();
                this.trigger('filter:apply', query, collection.origFilterDef);
            }
        }
    },

    /**
     * Refreshes the list view by applying filters.
     *
     * @private
     */
    _refreshList: function() {
        this.trigger('filter:apply');
    },
    
    /**
     * Disables the activity stream toggle if activity stream is not enabled for a module
     * @param {String} moduleName The name of the module
     * @param {Object} moduleMeta The metadata for the module
     * @param {Object} viewMeta The metadata for the component
     */
    disableActivityStreamToggle: function(moduleName, moduleMeta, viewMeta) {
        if (moduleName !== 'Activities' && !moduleMeta.activityStreamEnabled) {
            _.each(viewMeta.availableToggles, function(toggle) {
                if (toggle.name === 'activitystream') {
                    toggle.disabled = true;
                    toggle.label = 'LBL_ACTIVITY_STREAM_DISABLED';
                }
            });
        }
    },

    /**
     * Disables the pipeline toggle if not enabled for a module
     * @param {string} moduleName The name of the module
     * @param {Object} moduleMeta The metadata for the module
     * @param {Object} viewMeta The metadata for the component
     */
    disablePipelineToggle: function(moduleName, moduleMeta, viewMeta) {
        var pipelineConfig = app.metadata.getModule('VisualPipeline', 'config') || {};
        var enableModules = pipelineConfig.enabled_modules || [];
        if (enableModules.length === 0 || enableModules.indexOf(moduleName) < 0) {
            _.each(viewMeta.availableToggles, function(toggle) {
                if (toggle.name === 'pipeline') {
                    toggle.disabled = true;
                    toggle.label = 'LBL_VISUAL_PIPELINE_DISABLED';
                }
            });
        }
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        this._super('_render');
        // `filter-rows` view is outside of `filter` layout and is rendered after `filter` layout is rendered.
        // Now that we are able to preserve last search, we need to initialize filter only once all the filter
        // components rendered.
        this.trigger('filter:reinitialize');
    }
}) },
"quicksearch": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchLayout
 * @alias SUGAR.App.view.views.BaseQuicksearchLayout
 * @extends View.Layout
 */
({
	// Quicksearch Layout (base) 

    className: 'search',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * The collection for executing searches and passing results.
         * This is to be shared and used by components.
         */
        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of this.collection.
        this.collection = app.data.createMixedBeanCollection();

        this.selectedTags = [];

        /**
         * Key to indicate version 2 search (new global search). This is used by the component views to determine
         * what version of the API to use. Default is false.
         * @type {boolean}
         */
        // FIXME SC-4254 Remove this.v2
        this.v2 = this.meta.v2 || false;

        /**
         * Index of the focused component. Only the focused component should have keyboard listeners.
         * @type {number}
         */
        this.compOnFocusIndex = 0;

        /**
         * Maximum viewport width of responsive mode. Under this width we should
         * be in responsive mode, and above in desktop mode.
         * @type {number}
         */
        this.maxResponsiveWidth = 540;

        /**
         * Tells if we're in responsive mode or not.
         *
         * In responsive mode, the search bar is hidden when collapsed and only
         * the magnifying glass is shown. When it's expanded, it takes the full
         * width of the screen.
         *
         * @type {boolean}
         */
        this.isResponsiveMode = false;

        /**
         * Indicates if the search bar is expanded
         * @type {boolean}
         */
        this.expanded = false;

        // shortcut keys
        // Focus the search bar
        app.shortcuts.registerGlobal({
            id: 'Search:Focus',
            keys: ['s', 'mod+alt+0'],
            component: this,
            description: 'LBL_SHORTCUT_SEARCH',
            handler: function() {
                this.trigger('navigate:to:component', 'quicksearch-bar');
                this.triggerExpand();
            }
        });

        // When a component is trying to navigate from its last element to the next component,
        // Check to make sure there is a next navigable component. If it exists, set it to the component to focus
        this.before('navigate:next:component', function() {
            var i = this.compOnFocusIndex, comp;
            while (comp = this._components[++i]) {
                if (_.result(comp, 'isFocusable')) {
                    this.compOnFocusIndex = i;
                    return true;
                }
            }
            return false;
        }, this);

        // When a component is trying to navigate from its first element to the previous component,
        // Check to make sure there is a previous navigable component. If it exists, set it to the component to focus
        this.before('navigate:previous:component', function() {
            var i = this.compOnFocusIndex, comp;
            while (comp = this._components[--i]) {
                if (_.result(comp, 'isFocusable')) {
                    this.compOnFocusIndex = i;
                    return true;
                }
            }
            return false;
        }, this);

        // Navigate to the next component. We have already set this.compOnFocusIndex in the before function.
        this.on('navigate:next:component', function() {
            this._components[this.compOnFocusIndex].trigger('navigate:focus:receive', true);
        }, this);

        // Navigate to the previous component. We have already set this.compOnFocusIndex in the previous function.
        this.on('navigate:previous:component', function() {
            this._components[this.compOnFocusIndex].trigger('navigate:focus:receive', false);
        }, this);

        // Navigate to a specific component. This bypasses the previous/next logic.
        this.on('navigate:to:component', function(componentName) {
            var newIndex = this.compOnFocusIndex;
            // Find the index of the component that is requesting focus.
            // We cannot use `layout.getComponent()` because that only returns the component, not the index.
            _.each(this._components, function(component, index) {
                if (componentName === component.name) {
                    newIndex = index;
                    return;
                }
            });
            // Unfocus the old component and focus on the new component.
            this._components[this.compOnFocusIndex].trigger('navigate:focus:lost');
            this.compOnFocusIndex = newIndex;
            this._components[this.compOnFocusIndex].trigger('navigate:focus:receive');
        }, this);

        // Reset navigation
        this.on('quicksearch:close', function(keepExpanded) {
            this.removeFocus();
            if (!this.expanded) {
                return;
            }
            this.collection.abortFetchRequest();
            if (keepExpanded) {
                return;
            }
            this.collapse();
        }, this);

        this.on('quicksearch:expand', this.expand);

        // Listener for app:view:change to expand or collapse the search bar
        app.events.on('app:view:change', function() {
            if (this.context.get('search')) {
                this.triggerExpand();
            } else {
                _.bind(this.collapse, this);
            }
        }, this);

        this.$el.focusin(_.bind(function() {
            this.$el.off('focusout');
            this.$el.focusout(_.bind(function() {
                this.$el.off('focusout');
                _.defer(_.bind(function() {
                    // We use `has(':focus')` instead of `is(':focus')` to check
                    // if the focused element is or is inside `this.$el`.
                    if (this.$el && this.$el.has(':focus').length === 0) {
                        this.trigger('quicksearch:close', this.context.get('search'));
                    }
                }, this));
            }, this));
        }, this));

        // Listener for display of tags ribbon menu
        this.on('quicksearch:tag:open', function() {
            this.$el.addClass('quicksearch-tags-open');
        }, this);

        // Listener for hiding of tags ribbon menu
        this.on('quicksearch:tag:close', function() {
            this.$el.removeClass('quicksearch-tags-open');
        }, this);

        // On window resize, if expanded, recalculate expansion
        $(window)
            .off('resize.quicksearch')
            .on('resize.quicksearch', _.debounce(_.bind(this.resizeHandler, this), 10));
    },

    /**
     * @inheritdoc
     */
    _placeComponent: function(component) {
        if (component.name === 'quicksearch-modulelist' ||
            component.name === 'quicksearch-taglist' ||
            component.name === 'quicksearch-bar'
        ) {
            this.$('[data-component=searchbar]').append(component.el);
        } else {
            this._super('_placeComponent', [component]);
        }
    },

    /**
     * Removes the current focus and resets the focused index
     */
    removeFocus: function() {
        this._components[this.compOnFocusIndex].trigger('navigate:focus:lost');
        this.compOnFocusIndex = 0;
    },

    /**
     * Expand quicksearch bar asynchronously.
     * @param {boolean} update `true` means the expansion is to update the width.
     *                  `false` means the expansion is new and needs animation.
     */
    triggerExpand: function(update) {
        _.defer(_.bind(this.expand, this, update));
    },

    /**
     * Expands the quicksearch.
     *
     * @param {boolean} update `true` means the expansion is to update the width.
     *                  `false` means the expansion is new and needs animation.
     */
    expand: function(update) {
        // if the search bar is already expanded and it is not an update,
        // do nothing.
        if (this.expanded && !update) {
            return;
        }

        this.expanded = true;
        this.$el.addClass('expanded');

        // On route, call the router handler.
        app.router
            .off('route', this.routerHandler)
            .on('route', this.routerHandler, this);

        this.trigger('quicksearch:expanded');
        this.trigger('quicksearch:button:toggle', false);

        if (this.isResponsiveMode) {
            this.trigger('navigate:to:component', 'quicksearch-bar');
            return;
        }

        // Calculate the target searchbox width
        var newWidth = this._calculateExpansion();

        // if the newWidth is not defined, then the menu hasn't completely
        // loaded, and we should do nothing.
        if (_.isUndefined(newWidth)) {
            return;
        }

        // For new expansions, we need to clear out the modules.
        var headerLayout = this.closestComponent('header');
        if (_.isUndefined(headerLayout)) {
            return;
        }
        headerLayout.trigger('view:resize', headerLayout.getModuleListMinWidth());

        // Now that there is space for the search bar to expand, animate the
        // expansion.
        if (update) {
            this.$('[data-component=searchbar]').width(newWidth);
        } else {
            this.$('[data-component=searchbar]').animate({width: newWidth}, {duration: 100});
        }

        // Turn off the default header resize listener
        headerLayout.setModuleListResize(false);
    },

    /**
     * Resizes the expanded search bar when the window is resized.
     * @private
     */
    resizeHandler: function() {
        this._toggleResponsiveMode();
        if (this.expanded && !this.isResponsiveMode) {
            this.triggerExpand(true);
        }
    },

    /**
     * Renders the layout and toggles the responsive class.
     *
     * @private
     */
    _render: function() {
        this._super('_render');
        this._toggleResponsiveMode();
    },

    /**
     * Toggles the responsive mode according to the viewport width.
     *
     * @private
     */
    _toggleResponsiveMode: function() {
        this.isResponsiveMode = $(window).width() < this.maxResponsiveWidth;
    },

    /**
     * Handles the route event on the router.
     *
     * This simple function allows us to reuse a function pointer to the router
     * handler. The router does not allow namespaced events such as
     * `route.quicksearch`. So, this function pointer is necessary to
     * properly dispose the event handler.
     */
    routerHandler: function() {
        this.trigger('quicksearch:close', this.context.get('search'));
    },

    /**
     * Calculates the target width for the search bar expansion based off the current state of the megamenu.
     *
     * @return {number} The target width for expansion.
     * @private
     */
    _calculateExpansion: function() {
        var headerLayout = this.closestComponent('header');
        if (_.isUndefined(headerLayout)) {
            return;
        }

        // The starting width of the input box
        var searchbarStartingWidth = this.$('[data-component=searchbar]').outerWidth();

        // The total width of the module list header
        var totalModuleWidth = headerLayout.getModuleListWidth();

        // The minimum width necessary for module list header
        var minimumModuleWidth = headerLayout.getModuleListMinWidth();

        // The target width is most of the module list, saving room for the
        // minimum module list width.
        return searchbarStartingWidth +
            totalModuleWidth -
            minimumModuleWidth;
    },

    /**
     * Collapses the quicksearch.
     */
    collapse: function() {
        this.expanded = false;
        this.$el.removeClass('expanded');

        this.trigger('quicksearch:collapse');
        app.router.off('route', this.routerHandler);
        this.trigger('quicksearch:button:toggle', true);

        if (this.isResponsiveMode) {
            return;
        }
        var headerLayout = this.closestComponent('header');
        if (_.isUndefined(headerLayout)) {
            return;
        }

        // Turn on the default header resize listener
        headerLayout.setModuleListResize(true);

        // jQuery `width` function with no arguments (or null arguments) only
        // returns the current width. Calling `width('')` with the empty string
        // sets the width to an empty value, which the browser ignores and
        // uses the css width.
        this.$('[data-component=searchbar]').width('');
        headerLayout.resize();
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        app.router.off('route', null, this);
        this.$el.off();
        $(window).off('resize.quicksearch');
        this._super('unbind');
    }
}) },
"filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout for filtering a collection.
 *
 * Composed of a module dropdown(optional), a filter dropdown and an input.
 *
 * @class View.Layouts.Base.FilterLayout
 * @alias SUGAR.App.view.layouts.BaseFilterLayout
 * @extends View.Layout
 */
({
	// Filter Layout (base) 

    className: 'filter-view search',

    events: {
        'click .add-on.fa-times': function() { this.trigger('filter:clear:quicksearch'); },
        'click .add-on.sicon-close': function() { this.trigger('filter:clear:quicksearch'); }
    },

    /**
     * The collection of filters.
     *
     * @property {Data.BeanCollection}
     */
    filters: null,

    /**
     * @override
     * @param {Object} opts
     */
    initialize: function(opts) {
        var filterLayout = app.view._getController({type:'layout',name:'filter'});
        filterLayout.loadedModules = filterLayout.loadedModules || {};
        app.view.Layout.prototype.initialize.call(this, opts);

        this.layoutType = app.utils.deepCopy(this.options.meta.layoutType) || this.context.get('layout') || this.context.get('layoutName') || app.controller.context.get('layout');

        this.aclToCheck = (this.layoutType === 'record')? 'view' : 'list';

        // Can't use getRelevantContextList here, because the context may not
        // have all the children we need.
        if (this.layoutType === 'records' || this.layoutType === 'activities') {
            // filters will handle data fetching so we skip the standard data fetch
            this.context.set('skipFetch', true);
        } else {
            if(this.context.parent) {
                this.context.parent.set('skipFetch', true);
            }
            this.context.on('context:child:add', function(childCtx) {
                if (childCtx.get('link')) {
                    // We're in a subpanel.
                    childCtx.set('skipFetch', true);
                }
            }, this);
        }

        /**
         * bind events
         */
        this.on('filter:apply', this.applyFilter, this);

        this.on('filter:create:close', function() {
            if (!this.createPanelIsOpen()) {
                return;
            }
            this.layout.trigger('filter:create:close');
            // When canceling creating a new filter, we want to go back to the `all_records` filter
            if (this.getLastFilter(this.layout.currentModule, this.layoutType) === 'create') {
                // For that we need to remove the last state key and trigger reinitialize
                this.clearLastFilter(this.layout.currentModule, this.layoutType);
                this.layout.trigger("filter:reinitialize");
            }
            this.context.editingFilter = null;
        }, this);

        this.on('filter:create:open', function(filterModel) {
            this.context.editingFilter = filterModel;
            this.layout.trigger('filter:create:open', filterModel);
        }, this);

        this.on('subpanel:change', function(linkName) {
            this.layout.trigger('subpanel:change', linkName);
        }, this);

        this.on('filter:get', this.initializeFilterState, this);

        this.on('filter:change:filter', this.handleFilterChange, this);

        this.layout.on('filter:apply', function(query, def) {
            this.trigger('filter:apply', query, def);
        }, this);

        this.layout.on('filterpanel:change', this.handleFilterPanelChange, this);
        this.layout.on('filterpanel:toggle:button', this.toggleFilterButton, this);

        //When a filter is saved, update the cache and set the filter to be the currently used filter
        this.context.on('filter:add', this.addFilter, this);

        // When a filter is deleted, update the cache and set the default filter
        // to be the currently used filter.
        this.layout.on('filter:remove', this.removeFilter, this);

        this.layout.on('filter:reinitialize', function() {
            this.initializeFilterState(this.layout.currentModule, this.layout.currentLink);
        }, this);

        this.listenTo(app.events, 'dashlet:filter:save', this.refreshDropdown);
        this.context.on('filter:clear', this.clearFilters, this);
    },

    /**
     * Clears out any filters and states for the layout
     */
    clearFilters: function() {
        this.context.set('currentFilterId', null);
        this.clearLastFilter(this.layout.currentModule, this.layoutType);
        this.layout.trigger('filter:reinitialize');
    },

    /**
     * This function refreshes the list of filters in the filter dropdown, and
     * is invoked when a filter is saved on a dashlet (`dashlet:filter:save`).
     * It triggers a `filter:reinitialize` event and resets the cached
     * module in `loadedModules` on the filter layout if the dashlet module
     * matches the `currentModule` on the filter layout.
     *
     * @param {String} module
     */
    refreshDropdown: function(module) {
        if (module === this.layout.currentModule) {
            var filterLayout = app.view._getController({type:'layout', name:'filter'});
            filterLayout.loadedModules[module] = false;
            this.layout.trigger('filter:reinitialize');
        }
    },

    /**
     * handles filter removal
     * @param model
     */
    removeFilter: function(model) {
        this.filters.collection.remove(model);
        this.context.set('currentFilterId', null);
        this.clearLastFilter(this.layout.currentModule, this.layoutType);
        this.layout.trigger('filter:reinitialize');
    },

    /**
     * Creates the key used to set/get the filter id last used.
     * Tile view and list view filters should be sticky.
     *
     * @param {string} filterModule The name of the filtered module.
     * @param {string} layoutName The name of the current layout.
     */
    getLastFilterKey: function(filterModule, layoutName) {
        if (layoutName === 'pipeline-records') {
            layoutName = 'records';
        }
        var keyString = 'last-' + filterModule + '-' + layoutName;
        return app.user.lastState.key(keyString, this);
    },

    /**
     * Saves last filter id to app cache.
     *
     * @param {String} filterModule The name of the filtered module.
     * @param {String} layoutName The name of the current layout.
     * @param {String} filterId The filter id.
     */
    setLastFilter: function(filterModule, layoutName, filterId) {
        var filterOptions = this.context.get('filterOptions') || {};
        this.context.set('currentFilterId', filterId);
        if (filterOptions.stickiness !== false) {
            var key = this.getLastFilterKey(filterModule, layoutName);
            app.user.lastState.set(key, filterId);
        }
    },

    /**
     * Gets last filter id from cache.
     *
     * @param {String} filterModule The name of the filtered module.
     * @param {String} layoutName The name of the current layout.
     * @return {String} The filter id.
     */
    getLastFilter: function(filterModule, layoutName) {
        // Check if we've already loaded it.
        var filter = this.context.get('currentFilterId');
        if (!_.isEmpty(filter)) {
            return filter;
        }

        var filterOptions = this.context.get('filterOptions') || {};
        // Load from cache.
        if (filterOptions.stickiness !== false) {
            var key = this.getLastFilterKey(filterModule, layoutName);
            filter = app.user.lastState.get(key);
        }

        // Check if there is an initial filter defined that we should use instead.
        if (_.isEmpty(filter) && filterOptions.initial_filter) {
            filter = filterOptions.initial_filter;
        }

        this.context.set('currentFilterId', filter);
        return filter;
    },

    /**
     * Clears last filter id from cache.
     *
     * @param {String} filterModule The name of the filtered module.
     * @param {String} layoutName The name of the current layout.
     */
    clearLastFilter: function(filterModule, layoutName) {
        var filterOptions = this.context.get('filterOptions') || {};
        if (filterOptions.stickiness !== false) {
            var key = this.getLastFilterKey(filterModule, layoutName);
            app.user.lastState.remove(key);
        }
        this.clearFilterEditState();
    },

    /**
     * Gets key for storing filter being editted.
     *
     * @return {string}
     */
    getFilterEditStateKey: function() {
        return app.user.lastState.key('edit-' + this.layout.currentModule + '-' + this.layoutType, this);
    },

    /**
     * Retrieves the current edit state from cache.
     *
     * @return {Object} The filter attributes if found.
     */
    retrieveFilterEditState: function() {
        var filterOptions = this.context.get('filterOptions') || {};
        if (filterOptions.stickiness !== false) {
            var key = this.getFilterEditStateKey();
            return app.user.lastState.get(key);
        }
    },

    /**
     * Saves the current edit state into the cache
     *
     * @param {Object} filter
     */
    saveFilterEditState: function(filter) {
        var filterOptions = this.context.get('filterOptions') || {};
        if (filterOptions.stickiness !== false) {
            var key = this.getFilterEditStateKey();
            app.user.lastState.set(key, filter);
        }
    },

    /**
     * Removes the edit state from the cache
     */
    clearFilterEditState: function() {
        var filterOptions = this.context.get('filterOptions') || {};
        if (filterOptions.stickiness !== false) {
            var key = this.getFilterEditStateKey();
            app.user.lastState.remove(key);
        }
    },

    /**
     * Removes deprecated cache entries of one module.
     *
     * The {@link Data.Base.FiltersBeanCollection} is now responsible for
     * storing the list of filters in memory. This list is no longer saved to
     * the local storage.
     *
     * First version, the list was stored with a key looking like this:
     *
     *     this.module + ':filter:saved-' + this.layout.currentModule
     *
     * Second version, the list was stored with a key looking like this:
     *
     *     module + ':filter:saved-filters
     *
     * Examples of keys we need to remove:
     *
     *     Home:filter:saved-Accounts
     *     Accounts:filter:saved-Accounts
     *     Contacts:filter:saved-Accounts
     *     Accounts:filter:saved-filters
     *     Contacts:filter:saved-filters
     *
     * @param {String} module The module name.
     */
    removeDeprecatedCache: function(module) {
        app.user.lastState.remove(app.user.lastState.key('saved-' + module, this));

        var layoutModule = this.module;
        this.module = module;
        // The filter collection used to be cached. It's now only saved in
        // memory so we need to remove the potential existing cache entry.
        app.user.lastState.remove(app.user.lastState.key('saved-filters', this));
        this.module = layoutModule;
    },

    /**
     * Handles filter addition or update.
     *
     * @param {Data.Base.FiltersBean} model The filter model that is created or
     *   updated.
     */
    addFilter: function(model) {
        var id = model.get('id');
        this.filters.collection.add(model, {merge: true});
        this.filters.collection.trigger('cache:update', model);
        this.setLastFilter(this.layout.currentModule, this.layoutType, id);
        this.context.set('currentFilterId', id);
        this.clearFilterEditState();
        this.layout.trigger('filter:reinitialize');
    },

    /**
     * Enables or disables a filter toggle button (e.g. activity or subpanel toggle buttons)
     * @param {String} toggleDataView the string used in `data-view` attribute for that toggle element (e.g. 'subpanels', 'activitystream')
     * @param {Boolean} on pass true to enable, false to disable
     */
    toggleFilterButton: function (toggleDataView, on) {
        var toggleButtons = this.layout.$('.toggle-actions a.btn');

        // Loops toggle buttons for 'data-view' that corresponds to `toggleDataView` and enables/disables per `on`
        _.each(toggleButtons, function(btn) {
            if($(btn).data('view') === toggleDataView) {
                if(on) {
                    $(btn).removeAttr('disabled').removeClass('disabled');
                } else {
                    $(btn).attr('disabled', 'disabled').addClass('disabled');
                    $(btn).attr('title', app.lang.get('LBL_NO_DATA_AVAILABLE'));
                }
            }
        });
    },

    /**
     * Handles filter panel changes between activity and subpanels
     * @param {String} name Name of panel
     * @param {Boolean} silent Whether to trigger filter events
     * @param {Boolean} setLastViewed Whether to set last viewed to `name` panel
     */
    handleFilterPanelChange: function(name, silent, setLastViewed) {
        this.showingActivities = name === 'activitystream';
        var module = this.showingActivities ? "Activities" : this.module;
        var link;

        this.$el.css('visibility', app.acl.hasAccess(this.aclToCheck, module) ? 'visible' : 'hidden');
        if(this.layoutType === 'record' && !this.showingActivities) {
            // FIXME: TY-499 will address removing the dependancy on this.layout
            module = link = app.user.lastState.get(app.user.lastState.key('subpanels-last', this.layout)) || 'all_modules';
            if (link !== 'all_modules') {
                module = app.data.getRelatedModule(this.module, link);
            }
        } else {
            link = null;
        }
        if (!silent) {
            this.trigger("filter:render:module");
            this.trigger("filter:change:module", module, link);
        }
        if (setLastViewed) {
            // Asks filterpanel to update user.lastState with new panel name as last viewed
            this.layout.trigger('filterpanel:lastviewed:set', name);
        }
    },

    /**
     * Handles filter change.
     *
     * @param {String} id The filter id.
     */
    handleFilterChange: function(id) {
        this.setLastFilter(this.layout.currentModule, this.layoutType, id);

        var filter, editState = this.retrieveFilterEditState();
        // Figure out if we have an edit state. This would mean user was editing the filter so we want him to retrieve
        // the filter form in the state he left it.
        filter = this.filters.collection.get(id) || app.data.createBean('Filters', {module_name: this.moduleName});
        if (editState && (editState.id === id || (id==='create' && !editState.id))) {
            filter.set(editState);
        } else {
            editState = false;
        }

        this.context.set('currentFilterId', filter.get('id'));

        var editable = filter.get('editable') !== false;

        // If the user selects a filter that has an incomplete filter
        // definition (i.e. filter definition != filter_template), open the
        // filterpanel to indicate it is ready for further editing.
        var isIncompleteFilter = filter.get('filter_template') &&
            JSON.stringify(filter.get('filter_definition')) !== JSON.stringify(filter.get('filter_template'));

        // If the user selects a filter template that gets populated by values
        // passed in the context/metadata, open the filterpanel to show the
        // actual search.
        var isTemplateFilter = filter.get('is_template');

        var modelHasChanged = !_.isEmpty(filter.changedAttributes(filter.getSynced()));

        if (editable &&
            (isIncompleteFilter || isTemplateFilter || editState || id === 'create' || modelHasChanged)
        ) {
            this.layout.trigger('filter:set:name', '');
            this.trigger('filter:create:open', filter);
            this.layout.trigger('filter:toggle:savestate', true);
        } else {
            // FIXME: TY-1457 should improve this
            this.context.editingFilter = null;
            this.layout.trigger('filter:create:close');
        }

        var ctxList = this.getRelevantContextList();
        var clear = false;
        //Determine if we need to clear the collections
        _.each(ctxList, function(ctx) {
            var filterDef = filter.get('filter_definition');
            var orig = ctx.get('collection').origFilterDef;
            ctx.get('collection').origFilterDef = filterDef;  //Set new filter def on each collection
            if (_.isUndefined(orig) || !_.isEqual(orig, filterDef)) {
                clear = true;
            }
        });
        //If so, reset collections and trigger quicksearch to repopulate
        if (clear) {
            _.each(ctxList, function(ctx) {
                ctx.get('collection').resetPagination();
                // Silently reset the collection otherwise the view is re-rendered.
                // It will be re-rendered on request response.
                ctx.get('collection').reset(null, { silent: true });
            });
            this.trigger('filter:apply');
        }
    },
    /**
     * Applies filter on current contexts
     * @param {String} query search string
     * @param {Object} dynamicFilterDef(optional)
     */
    applyFilter: function(query, dynamicFilterDef) {
        // TODO: getRelevantContextList needs to be refactored to handle filterpanels in drawer layouts,
        // as it will return the global context instead of filtering a list view within the drawer context.
        // As a result, this flag is needed to prevent filtering on the global context.
        var filterOptions = this.context.get('filterOptions') || {};
        if (filterOptions.auto_apply === false) {
            return;
        }

        // to make sure quick filter is handled properly
        if (_.isEmpty(query)) {
            var filterQuicksearchView = this.getComponent('filter-quicksearch');
            query = filterQuicksearchView && filterQuicksearchView.$el.val() || '';
        }

        //If the quicksearch field is not empty, append a remove icon so the user can clear the search easily
        this._toggleClearQuickSearchIcon(!_.isEmpty(query));
        var self = this;
        var ctxList = this.getRelevantContextList();

        // Here we split the relevant contexts into two groups, 'count', and
        // 'fetch'. For the 'count' contexts, we do a 'fetchOnlyIds' on their
        // collection so we can update the count and highlight the subpanel
        // icon, even though they are collapsed. For the 'fetch' group, we do a
        // full collection fetch so the subpanel can render its list view.
        var relevantCtx = _.groupBy(ctxList, function(ctx) {
            return ctx.get('collapsed') ? 'count' : 'fetch';
        });

        var batchId = relevantCtx.count && relevantCtx.count.length > 1 ? _.uniqueId() : false;
        _.each(relevantCtx.count, function(ctx) {
            var ctxCollection = ctx.get('collection');
            var origFilterDef = dynamicFilterDef || ctxCollection.origFilterDef || [];
            var filterDef = self.buildFilterDef(origFilterDef, query, ctx);
            var options = {
                //Show alerts for this request
                showAlerts: true,
                apiOptions: {
                    bulk: batchId
                }
            };

            ctxCollection.filterDef = filterDef;
            ctxCollection.origFilterDef = origFilterDef;
            ctxCollection.resetPagination();

            options = _.extend(options, ctx.get('collectionOptions'));
            ctx.resetLoadFlag({recursive: false});
            ctx.set('skipFetch', true);
            ctx.loadData(options);

            // We need to reset twice so we can trigger the other bulk call.
            ctx.resetLoadFlag({recursive: false});
            options.success = _.bind(function(hasAmount, properties) {
                if (!this.disposed) {
                    ctx.trigger('refresh:count', hasAmount, properties);
                }
            }, this);
            ctxCollection.hasAtLeast(ctx.get('limit'), options);
        });

        // FIXME: Filters should not be triggering the bulk request and should
        // be moved to subpanels instead. Will be fixed as part of SC-4533.
        if (batchId) {
            app.api.triggerBulkCall(batchId);
        }

        batchId = relevantCtx.fetch && relevantCtx.fetch.length > 1 ? _.uniqueId() : false;
        _.each(relevantCtx.fetch, function(ctx) {
            ctx.trigger('filter:fetch:start');

            var ctxCollection = ctx.get('collection');
            var origFilterDef = dynamicFilterDef || ctxCollection.origFilterDef || [];

            // origFilterDef needs to be an array for the concat() operation below
            origFilterDef = _.isArray(origFilterDef) ? origFilterDef : [origFilterDef];

            // add any default filter to the original filter
            var updatedFilterDef = ctxCollection.defaultFilterDef ?
                origFilterDef.concat(ctxCollection.defaultFilterDef) : origFilterDef;

            var filterDef = self.buildFilterDef(updatedFilterDef, query, ctx);
            var options = {
                //Show alerts for this request
                showAlerts: true,
                apiOptions: {
                    bulk: batchId
                },
                success: function(collection, response, options) {
                    // Close the preview pane to ensure that the preview
                    // collection is in sync with the list collection.
                    app.events.trigger('preview:close');

                    ctx.trigger('filter:fetch:success');
                }
            };

            ctxCollection.filterDef = filterDef;
            ctxCollection.origFilterDef = origFilterDef;

            ctx.resetLoadFlag({recursive: false});
            ctx.set('skipFetch', false);
            ctx.loadData(options);
        });
        if (batchId) {
            app.api.triggerBulkCall(batchId);
        }
    },

    /**
     * Look for the relevant contexts. It can be
     * - the activity stream context
     * - the list view context on records layout
     * - the selection list view context on records layout
     * - the contexts of the subpanels on record layout
     * @return {Array} array of contexts
     */
    getRelevantContextList: function() {
        var contextList = [];
        if (this.showingActivities) {
            _.each(this.layout._components, function(component) {
                var ctx = component.context;
                if (component.name == 'activitystream' && !ctx.get('modelId') && ctx.get('collection')) {
                    //FIXME: filter layout's _components array has multiple references to same activitystreams layout object
                    contextList.push(ctx);

                }
            });
        } else {
            if (this.layoutType === 'records') {
                var ctx = this.context;
                if (!ctx.get('modelId') && ctx.get('collection')) {
                    contextList.push(ctx);
                }
            } else {
                //Locate and add subpanel contexts
                _.each(this.context.children, function(ctx) {
                    if (ctx.get('isSubpanel') && !ctx.get('hidden') && !ctx.get('modelId') && ctx.get('collection')) {
                        contextList.push(ctx);
                    }
                });
            }
        }
        return _.uniq(contextList);
    },

    /**
     * Builds the filter definition based on preselected filter and module quick search fields
     * @param {Object} oSelectedFilter
     * @param {String} searchTerm
     * @param {Context} context
     * @return {Array} array containing filter def
     */
    buildFilterDef: function(oSelectedFilter, searchTerm, context) {
        var selectedFilter = app.utils.deepCopy(oSelectedFilter),
            isSelectedFilter = _.size(selectedFilter) > 0,
            module = context.get('module'),
            filtersBeanPrototype = app.data.getBeanClass('Filters').prototype,
            searchFilter = filtersBeanPrototype.buildSearchTermFilter(module, searchTerm),
            isSearchFilter = _.size(searchFilter) > 0;

        selectedFilter = _.isArray(selectedFilter) ? selectedFilter : [selectedFilter];
        /**
         * Filter fields that don't exist either on vardefs or search definition.
         *
         * Special fields (fields that start with `$`) like `$favorite` aren't
         * cleared.
         *
         * TODO move this to a plugin method when refactoring the code (see SC-2555)
         * TODO we should support cleanup on all levels (currently made on 1st
         * level only).
         */
        var specialField = /^\$/,
            meta = app.metadata.getModule(module);
        selectedFilter = _.filter(selectedFilter, function(def) {
            var fieldName = _.keys(def).pop();
            return specialField.test(fieldName) || meta.fields[fieldName];
        }, this);

        if (isSelectedFilter && isSearchFilter) {
            selectedFilter.push(searchFilter[0]);
            return [{'$and': selectedFilter }];
        } else if (isSelectedFilter) {
            return selectedFilter;
        } else if (isSearchFilter) {
            return searchFilter;
        }

        return [];
    },

    /**
     * Loads the full filter panel for a module.
     *
     * @param {String} moduleName The module name.
     * @param {String} [linkName] The related module link name, by default it
     *   will load the last selected filter,
     * @param {String} [filterId] The filter ID to initialize with. By default
     *   it will load the last selected filter or the default filter from
     *   metadata.
     */
    initializeFilterState: function(moduleName, linkName, filterId) {

        if (this.showingActivities) {
            moduleName = 'Activities';
            linkName = null;
        } else {
            moduleName = moduleName || this.module;

            if (this.layoutType === 'record') {
                // FIXME: TY-499 will address removing the dependancy on this.layout
                linkName = app.user.lastState.get(app.user.lastState.key('subpanels-last', this.layout)) ||
                    linkName ||
                    'all_modules';

                // if the incoming module is the same as the layoutModule then we need to find the other side.
                if (linkName !== 'all_modules' && this.layout.module === moduleName) {
                    moduleName = app.data.getRelatedModule(moduleName, linkName) || moduleName;
                }

                // For subpanels where layoutType is record and linkName is all_modules,
                // only the all_records filter should be used.
                if (linkName === 'all_modules') {
                    filterId = 'all_records';
                }
            }
        }

        filterId = filterId || this.getLastFilter(moduleName, this.layoutType);

        this.layout.trigger('filterpanel:change:module', moduleName, linkName);
        this.trigger('filter:change:module', moduleName, linkName, true);
        this.getFilters(moduleName, filterId);
    },

    /**
     * Retrieves the appropriate list of filters from cache if found, otherwise
     * from the server.
     *
     * @param {String} moduleName The module name.
     * @param {String} [defaultId] The filter `id` to select once loaded.
     */
    getFilters: function(moduleName, defaultId) {
        if (moduleName === 'all_modules') {
            this.selectFilter('all_records');
            return;
        }
        var filterOptions = this.context.get('filterOptions') || {};

        if (this.filters) {
            this.filters.dispose();
        }

        // Remove deprecated cache entries.
        this.removeDeprecatedCache(moduleName);

        this.filters = app.data.createBeanCollection('Filters');
        this.filters.setModuleName(moduleName);
        this.filters.setFilterOptions(filterOptions);

        this.filters.load({
            success: _.bind(function() {
                if (this.disposed) {
                    return;
                }
                defaultId = defaultId || this.filters.collection.defaultFilterFromMeta;
                this.selectFilter(defaultId);

            }, this)
        });
    },

    /**
     * Selects a filter.
     *
     * @triggers filter:select:filter to select the filter in the dropdown.
     *
     * @param {String} filterId The filter id to select.
     * @return {String} The selected filter id.
     */
    selectFilter: function(filterId) {
        var possibleFilters,
            selectedFilterId = filterId;

        if (selectedFilterId !== 'create') {
            possibleFilters = [selectedFilterId, this.filters.collection.defaultFilterFromMeta, 'all_records'];
            possibleFilters = _.filter(possibleFilters, this.filters.collection.get, this.filters.collection);
            selectedFilterId = _.first(possibleFilters);
        }
        this.trigger('filter:render:filter');
        this.trigger('filter:select:filter', selectedFilterId);
        return selectedFilterId;
    },

    /**
     * Utility function to know if the create filter panel is opened.
     * @return {boolean} `true` if opened, `false` otherwise
     */
    createPanelIsOpen: function() {
        return !this.layout.$(".filter-options").is(":hidden");
    },

    /**
     * Determines whether a user can create a filter for the current module.
     * @return {boolean} `true` if creatable, `false` otherwise
     */
    canCreateFilter: function() {
        // Check for create in meta and make sure that we're only showing one
        // module, then return false if any is false.
        var contexts = this.getRelevantContextList(),
            creatable = app.acl.hasAccess("create", "Filters"),
            meta;
        // Short circuit if we don't have the ACLs to create Filter beans.

        if (creatable && contexts.length === 1) {
            meta = app.metadata.getModule(contexts[0].get("module"));
            if (meta && _.isObject(meta.filters)) {
                _.each(meta.filters, function(value) {
                    if (_.isObject(value)) {
                        creatable = creatable && value.meta.create !== false;
                    }
                });
            }
        }

        return creatable;
    },

    /**
     * Append or remove an icon to the quicksearch input so the user can clear the search easily
     * @param {Boolean} addIt TRUE if you want to add it, FALSO to remove
     */
    _toggleClearQuickSearchIcon: function(addIt) {
        if (addIt && !this.$('.sicon-close.add-on')[0]) {
            this.$el.append('<i class="sicon sicon-close add-on"></i>');
        } else if (!addIt) {
            this.$('.sicon-close.add-on').remove();
        }
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        if (app.acl.hasAccess(this.aclToCheck, this.module)) {
            app.view.Layout.prototype._render.call(this);
        }
    },

    /**
     * @override
     */
    unbind: function() {
        if (this.filters) {
            this.filters.dispose();
        }
        this.filters = null;
        app.view.Layout.prototype.unbind.call(this);
    }

}) },
"toggle": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout that provides basic functionality for toggling visibility of
 * sub-layouts & views.
 *
 * @class View.Layouts.Base.ToggleLayout
 * @alias SUGAR.App.view.layouts.BaseToggleLayout
 * @extends View.Layout
 */
({
	// Toggle Layout (base) 

    /**
     * Components to be toggled
     * Key is the name of the layout or view
     * Value is an object with icon/label if toggle buttons are to be displayed, empty object otherwise
     */
    availableToggles: {},

    /**
     * Default component to show when this layout is initialized
     */
    defaultToggle: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.toggleComponents = [];
        this.componentsList = {};
        this.availableToggles = options.meta.available_toggles || this.availableToggles;
        this.defaultToggle = options.meta.default_toggle || this.defaultToggle;

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    initComponents: function(components, context, module) {
        this._super('initComponents', [components, context, module]);

        _.each(this.componentsList, function(comp) {
            if (_.isFunction(comp.initComponents)) {
                comp.initComponents();
            }
        });

        if (this.defaultToggle) {
            this.showComponent(this.defaultToggle);
        }

        this.on('toggle:showcomponent', this.showComponent, this);
    },

    /**
     * Defer rendering/appending of toggle-able components and render/append the rest
     * @param component
     */
    _placeComponent: function(component) {
        if (!_.isUndefined(this.availableToggles[component.name])) {
            this.toggleComponents.push(component);
            this.componentsList[component.name] = component;
            this._components.splice(this._components.indexOf(component), 1);
        } else {
            component.render();
            this.getContainer(component).append(component.el);
        }
    },

    /**
     * Container where the content should be placed (topmost layout element by default)
     * Override for a different container
     * @param component useful if the container is dependent on the component - not used in base implementation
     */
    getContainer: function(component) {
        return this.$el;
    },

    /**
     * Show the given component and hide the other toggle-able components.
     * Render the named component if it is in our list of components that have
     * not yet been rendered and append it to the appropriate container.
     *
     * The firing of the 'append' event is done after showing the component to
     * ensure that its DOM surroundings (ie. element width) are completely set
     * up - allowing anything listening to adjust accordingly.
     *
     * @param {string} name Name of the component to show
     */
    showComponent: function(name) {
        var oldToggle = this.currentToggle;

        _.each(this.toggleComponents, function(component) {
            if (component.name === name) {
                component.show();
            } else {
                component.hide();
            }
        }, this);

        if (this.componentsList[name]) {
            this._components.push(this.componentsList[name]);
            this.getContainer(this.componentsList[name]).append(this.componentsList[name].el);
            // notify the component it's been appended to the container.
            // it may want to adapt to its new neighborhood
            this.componentsList[name].trigger("append");
            this.componentsList[name].render();
            this.componentsList[name] = null;
        }

        this.currentToggle = name;
        this.trigger('toggle:change', name, oldToggle);
    },

    /**
     * Clean up any components that were never rendered and added to _components
     * @private
     */
    _dispose: function() {
        _.each(this.componentsList, function(component) {
            if (component) {
                component.dispose();
            }
        });
        this.componentsList = {};
        this.toggleComponents = null;
        app.view.Layout.prototype._dispose.call(this);
    }

}) },
"subpanel-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SubpanelCreateLayout
 * @alias SUGAR.App.view.layouts.BaseSubpanelCreateLayout
 * @extends View.Layouts.Base.SubpanelLayout
 */
({
	// Subpanel-create Layout (base) 

    extendsFrom: 'SubpanelLayout',

    initialize: function(options) {
        app.logger.warn('`BaseSubpanelCreateLayout` controller ' +
            'has been deprecated since 7.8.0 and will be removed in 7.9.0. To use `BaseSubpanelLayout` controller, ' +
            'specify the `type` property in your `subpanel-create` metadata file instead.');

        this._super('initialize', [options]);
    }
}) },
"subpanel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SubpanelLayout
 * @alias SUGAR.App.view.layouts.BaseSubpanelLayout
 * @extends View.Layouts.Base.PanelLayout
 */
({
	// Subpanel Layout (base) 

    extendsFrom: 'PanelLayout',

    /**
     * What is our current dataview
     */
    dataView: 'subpanel-list',

    /**
     * @override
     */
    initialize: function(options) {
        //Check for the override_subpanel_list_view from the parent layout metadata and replace the list view if found.
        if (options.meta && options.def && options.def.override_subpanel_list_view) {
            _.each(options.meta.components, function(def) {
                if (def.view && def.view.indexOf('subpanel-list') !== -1) {
                    def.view = options.def.override_subpanel_list_view;
                }
            });
            // set the dataview if we override it
            this.dataView = options.def.override_subpanel_list_view;
            // override last_state.id with "override_subpanel_list_view" for unique state name.
            if (options.meta.last_state.id) {
                options.meta.last_state.id = options.def.override_subpanel_list_view;
            }
        }

        if (options.meta && options.def && options.def.override_paneltop_view) {
            _.each(options.meta.components, function(def) {
                if (def.view && def.view == 'panel-top') {
                    def.view = options.def.override_paneltop_view;
                }
            });
        }

        this._super('initialize', [options]);

        // if the dataView variable does not equal 'subpanel-list', it means it was changed
        // and we need to set the correct dataView on the context so when the data is fetched via
        // the api, it pulls the correct fields.
        if (this.dataView !== 'subpanel-list') {
            this.context.set('dataView', this.dataView);
        }

        // FIXME in SC-3360 - this is a hacky flag to be able to fetch a collection of
        // links. We will be able to remove this code once we introduce the CollectionsAPI.
        var ignoreRole = this.context.get('ignore_role');
        if (ignoreRole) {
            var collection = this.collection;
            var options = collection.getOption() || {};
            var params = options.params || {};
            params.ignore_role = ignoreRole;
            collection.setOption('params', params);
        }

        // binding so subpanels can trigger other subpanels to reload by link name
        // example: ctx.trigger('subpanel:reload', {links: ['opportunities','revenuelineitems']});
        if (this.context.parent) {
            this.context.parent.on('subpanel:reload', function(args) {
                app.logger.warn('`subpanel:reload` is deprecated. Use `context.reloadData()` to reload and expand.');
                if (!_.isUndefined(args) && _.isArray(args.links) && _.contains(args.links, this.context.get('link'))) {
                    this.context.reloadData({recursive: false});
                }
            }, this);
        }

        // If any settings have been specified for the subpanel, set them on the context
        if (options.def.settings) {
            this.context.set('settings', options.def.settings);
        }
    },

    /**
     * @inheritdoc
     */
    show: function() {
        this.context.set('hidden', false);
        this._super('show');
    },

    /**
     * @inheritdoc
     */
    hide: function() {
        this.context.set('hidden', true);
        this._super('hide');
    }
}) },
"search": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout for the global search results page.
 *
 * @class View.Layouts.Base.SearchLayout
 * @alias SUGAR.App.view.layouts.BaseSearchLayout
 * @extends View.Layout
 */
({
	// Search Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._beforeInit(options);
        this._super('initialize', [options]);

        this.context.set('search', true);
        this.collection.query = this.context.get('searchTerm') || '';

        /**
         * Flag to indicate if the search has been filtered using facets or not.
         *
         * @property {boolean} `true` if the search has been filtered.
         */
        this.filteredSearch = false;
        /**
         * Object containing the selected facets in the current search.
         *
         * @property {Object} selectedFacets
         */
        this.selectedFacets = {};

        this.context.on('search:fire:new', function() {
            this.search();
        }, this);

        this.context.on('facet:apply', this.filter, this);

        this.collection.on('sync', function(collection) {
            var isCollection = (collection instanceof App.BeanCollection);
            if (!isCollection) {
                return;
            }
            app.utils.GlobalSearch.formatRecords(collection, true);

            if (!_.isEmpty(collection.xmod_aggs)) {
                if (!this.filteredSearch) {
                    this._initializeSelectedFacets(collection.xmod_aggs);
                }

                this.context.set('selectedFacets', this.selectedFacets);
                this.context.set('facets', collection.xmod_aggs, {silent: true});
                this.context.trigger('facets:change', collection.xmod_aggs);
            }

        }, this);

        this.context.on('facets:reset', this.search, this);

        this.collection.setOption('params', {xmod_aggs: true});
    },

    /**
     * Initialization of properties needed before calling the sidecar/backbone initialize method
     *
     * @param {Object} options
     *
     */
    _beforeInit: function(options) {
        var previewPane = {
            layout: 'preview',
            label: 'Hint-Tab'
        };

        if (app.hint && app.user.hasLicense('HINT')) {
            _.each(options.meta.components, function(def) {
                _.each(def.layout.components, function(comp) {
                    if (comp.layout.name === 'preview-pane') {
                        comp.layout.components.push(previewPane);
                    }
                });
            });
        }
    },

    /**
     * Builds the selected facets object to be sent to the server.
     *
     * @param {Object} facets The facets object that comes from the server.
     * @private
     */
    _initializeSelectedFacets: function(facets) {
        _.each(facets, function(facet, key) {
            if (key === 'modules') {
                this.selectedFacets[key] = [];
            } else {
                this.selectedFacets[key] = false;
            }
        }, this);
    },

    /**
     * Updates {@link #selectedFacets} with the facet change.
     *
     * @param {String} facetId The facet type.
     * @param {String} facetCriteriaId The id of the facet criteria.
     * @param {boolean} isSingleItem `true` if it's a single item facet.
     * @private
     */
    _updateSelectedFacets: function(facetId, facetCriteriaId, isSingleItem) {
        if (isSingleItem) {
            this.selectedFacets[facetId] = !this.selectedFacets[facetId];
            return;
        }
        var index;
        if (this.selectedFacets[facetId]) {
            index = this.selectedFacets[facetId].indexOf(facetCriteriaId);
        } else {
            this.selectedFacets[facetId] = [];
        }
        if (_.isUndefined(index) || index === -1) {
            this.selectedFacets[facetId].splice(0, 0, facetCriteriaId);
        } else {
            this.selectedFacets[facetId].splice(index, 1);
            if (this.selectedFacets[facetId].length === 0) {
                delete this.selectedFacets[facetId];
            }
        }
    },

    /**
     * Searches on a term and a module list.
     *
     * @param {boolean} reset `true` if we reset the filters.
     */
    search: function(reset) {
        // Prevents to trigger a new fetch if the user clicks on
        if (reset && !this.filteredSearch) {
            return;
        }
        var searchTerm = this.context.get('searchTerm');
        var moduleList = this.context.get('module_list') || [];
        this.filteredSearch = false;

        var tagFilters = _.pluck(this.context.get('tags'), 'id');

        this.collection.fetch({query: searchTerm, module_list: moduleList,
            apiOptions:
            {
                data: {
                    tag_filters: tagFilters
                },
                fetchWithPost: true,
                useNewApi: true
            }
        });
    },

    /**
     * Refines the search applying a facet change.
     *
     * @param facetId The facet id.
     * @param facetCriteriaId The facet criteria id.
     * @param isSingleItem `true` if it's a single criteria facet.
     */
    filter: function(facetId, facetCriteriaId, isSingleItem) {
        this._updateSelectedFacets(facetId, facetCriteriaId, isSingleItem);

        var searchTerm = this.context.get('searchTerm');
        var moduleList = this.context.get('module_list') || [];
        this.filteredSearch = true;
        var tagFilters = _.pluck(this.context.get('tags'), 'id');
        this.collection.fetch({query: searchTerm, module_list: moduleList,
            apiOptions:
            {
                data: {
                    agg_filters: this.selectedFacets,
                    tag_filters: tagFilters
                },
                fetchWithPost: true,
                useNewApi: true
            }
        });
    },

    /**
     * We override `loadData` to not send the `fields` param in the
     * request, so it's consistent with the request sent by
     * {@link View.Views.Base.QuicksearchBarView#fireSearchRequest fireSearchRequest}
     * method in the quicksearch bar.
     * Note that the `fields` param is not used anymore by the globalsearch API.
     *
     * @inheritdoc
     */
    loadData: function(options) {
        options = options || {};

        options.module_list = this.context.get('module_list') || [];

        // pull tag ids out of context and pass them into our options to filter
        var tagFilters = _.pluck(this.context.get('tags'), 'id');
        if (tagFilters) {
            options.apiOptions = options.apiOptions || {};
            options.apiOptions.data = {tag_filters: tagFilters};
            options.apiOptions.fetchWithPost = true;
            options.apiOptions.useNewApi = true;
        }

        this._super('loadData', [options]);
    }
}) },
"sweetspot": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SweetspotLayout
 * @alias SUGAR.App.view.layouts.BaseSweetspotLayout
 * @extends View.Layout
 */
({
	// Sweetspot Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of layout.collection.
        this.collection = app.data.createMixedBeanCollection();

        app.shortcuts.registerGlobal({
            id: 'Sweetspot:Toggle',
            keys: 'mod+shift+space',
            component: this,
            description: 'LBL_SHORTCUT_SWEETSPOT',
            callOnFocus: true,
            handler: this.toggle
        });
        app.events.on('app:logout app:login', this.hide, this);
        app.events.on('app:sync:complete sweetspot:reset', this._setTheme, this);

        this.on('sweetspot:config', this.openConfigPanel, this);
        this.on('sweetspot:calc:resultsHeight', this.calculateResultsHeight, this);

        /**
         * Flag to indicate the visible state of the sweet spot.
         *
         * @type {boolean}
         * @private
         */
        this._isVisible = false;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (!this.isReady()) {
            return;
        }
        this._super('_render');
        this._setTheme();
    },

    /**
     * Sets the theme for sweetspot.
     *
     * @protected
     */
    _setTheme: function() {
        var prefs = app.user.getPreference('sweetspot');
        var theme = prefs && prefs.theme;

        this.$el.removeAttr('data-theme');
        if (theme) {
            this.$el.attr('data-theme', theme);
        }
    },

    /**
     * Binds events that this layout uses.
     *
     * @protected
     */
    _bindEvents: function() {
        this.createShortcuts();
        this.bindOutsideClick();
        this.bindResize();
    },

    /**
     * Unbinds events that this layout uses.
     *
     * @protected
     */
    _unbindEvents: function() {
        this.removeShortcuts();
        this.unbindOutsideClick();
        this.unbindResize();
    },

    /**
     * Binds the outside `click` event.
     */
    bindOutsideClick: function() {
        $('body').bind('click.' + this.cid, _.bind(function(e) {
            if ($(e.target).closest('#sweetspot').length === 0) {
                this.hide();
            }
        }, this));
    },

    /**
     * Unbinds the outside `click` event.
     */
    unbindOutsideClick: function() {
        $('body').unbind('click.' + this.cid);
    },

    /**
     * Create new shortcut session and add shortcut to hide SweetSpot
     */
    createShortcuts: function() {
        app.shortcuts.saveSession();
        app.shortcuts.createSession(['SweetSpot:Toggle:Off'], this);
        app.shortcuts.registerGlobal({
            id: 'Sweetspot:Toggle:Off',
            keys: 'esc',
            component: this,
            description: 'LBL_SHORTCUT_SWEETSPOT_HIDE',
            callOnFocus: true,
            handler: this.hide
        });
    },

    /**
     * Remove shortcuts for SweetSpot and restore previous session.
     */
    removeShortcuts: function() {
        app.shortcuts.restoreSession();
    },

    /**
     * Binds the `resize` event.
     */
    bindResize: function() {
        $(window).on('resize.sweetspot-' + this.cid, _.bind(this.calculateResultsHeight, this));
    },

    /**
     * Unbinds the `resize` event.
     */
    unbindResize: function() {
        $(window).off('resize.sweetspot-' + this.cid);
    },

    /**
     * Checks if this layout is ready to be {@link #show displayed}, or
     * {@link #_render rendered}.
     *
     * FIXME SC-2761: Checking `isVisible` on the header component is necessary
     * for disabling this layout on full-page modal views like the first login
     * wizard. However, hiding additionalComponents should be event driven,
     * see https://github.com/sugarcrm/Mango/pull/18722#discussion_r11782561.
     *
     * @return {boolean} `true` if this layout is OK to render/show, `false`
     *   otherwise.
     */
    isReady: function() {
        return app.api.isAuthenticated() && app.isSynced && app.additionalComponents.header.isVisible();
    },

    /**
     * @override
     */
    isVisible: function() {
        return this._isVisible;
    },

    /**
     * @override
     */
    show: function() {
        if (this.isVisible()) {
            return;
        }
        if (!this.triggerBefore('show')) {
            return false;
        }
        if (!this.isReady()) {
            return;
        }

        this._isVisible = true;
        this.$('input').val('');
        this.$el.fadeToggle(50, 'linear', _.bind(this.focusInput, this));
        this.trigger('show');
        this.calculateResultsHeight();
        this._bindEvents();
    },

    /**
     * @override
     */
    hide: function() {
        if (!this.isVisible()) {
            return;
        }
        if (!this.triggerBefore('hide')) {
            return false;
        }

        this._isVisible = false;
        this._unbindEvents();
        this.$el.fadeToggle(50, 'linear');
        this.$el.removeClass('has-results');
        this.trigger('hide');
    },

    /**
     * Toggles the Sweet Spot.
     */
    toggle: function() {
        if (this.isVisible()) {
            this.hide();
        } else {
            this.show();
        }
    },

    /**
     * Focuses on the Sweet Spot input.
     */
    focusInput: function() {
        this.$('input').focus();
    },

    /**
     * Opens a drawer with the {@link View.Layouts.Base.SweetspotConfigLayout}
     * to configure the Sweet Spot.
     */
    openConfigPanel: function() {
        // TODO: This is bad and there should be an option in drawer.js to
        // prevent opening an already-open drawer of the same type.
        var activeDrawerLayout = app.drawer.getActive();
        if (activeDrawerLayout && activeDrawerLayout.type === 'sweetspot-config') {
            return;
        }

        app.drawer.open({
            layout: 'sweetspot-config',
            context: {
                skipFetch: true,
                forceNew: true
            }
        });
    },

    /**
     * Trigger a system action.
     *
     * @param {string} method Name of the method in {@link #_systemActions}.
     */
    triggerSystemAction: function(method) {
        if (!_.isFunction(this._systemActions[method])) {
            return;
        }
        this._systemActions[method].call(this);
    },

    /**
     * List of system action callbacks.
     *
     * Use {@link #triggerSystemAction} to trigger them.
     */
    _systemActions: {
        openConfig: function() {
            this.openConfigPanel();
        }
    },

    /**
     * Calculates the results dropdown height based on the window height and
     * triggers 'sweetspot:results:adjustMaxHeight' passing the value.
     */
    calculateResultsHeight: function() {
        var distanceToFooter = 80;
        var resultsMaxHeight = $(window).height() - this.$el.offset().top - $('footer').height() - distanceToFooter;
        if (resultsMaxHeight > 460) {
            resultsMaxHeight = 460;
        }

        this.trigger('sweetspot:results:adjustMaxHeight', resultsMaxHeight);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this._unbindEvents();
        this._super('_dispose');
    }
}) },
"actionbutton-setup": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ActionbuttonSetup
 * @alias SUGAR.App.view.layouts.BaseActionbuttonSetupLayout
 * @extends View.Layouts.Base.BaseLayout
 */
({
	// Actionbutton-setup Layout (base) 

    /**
     * Options that should be available only on SELL and SERVE
     *
     * @var array
     */
    sellServeOptions: [
        'document-merge',
    ],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        let ctxModel = this.context.get('model');
        let actions = options.meta.actions;

        /**
         * If the license is not SELL or SERVE,
         * we need to remove some of the actions
         */
        actions = this._filterSellServeOptions(actions);

        ctxModel.set({
            actions: actions
        });
    },

    /**
     * Remove SELL/SERVE options from the actions
     *
     * @param {Object} actions
     */
    _filterSellServeOptions: function(actions) {
        if (!app.user.hasSellServeLicense()) {
            for (const option of this.sellServeOptions) {
                if (_.has(actions, option)) {
                    delete actions[option];
                }
            }
        }

        return actions;
    },
}) },
"omnichannel-dashboard": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The dashboard container of the Omnichannel console.
 *
 * @class View.Layouts.Base.OmnichannelDashboardLayout
 * @alias SUGAR.App.view.layouts.BaseOmnichannelDashboardLayout
 * @extends View.Layout
 */
({
	// Omnichannel-dashboard Layout (base) 

    className: 'omni-dashboard dashboard-pane',

    /**
     * Stores the index of the search tab
     */
    searchTabIndex: 0,

    /**
     * Maps the module to the appropriate tab index
     */
    moduleTabIndex: {
        Contacts: 1,
        Accounts: 2,
        Leads: 3,
        Cases: 4,
    },

    /**
     * Context models for tabs.
     * @property {Array}
     */
    tabModels: [],

    /**
     * Defines properties that are passed in to the quick-create drawer as
     * pre-populated data when the quick-create drawer is opened within the
     * context of an open Omnichannel console. The format is as follows:
     *
     * ```
     * populateLists: {
     *     *module name to pre-populate*: {
     *         *source module from dashboard*: {
     *             ...
     *             *target prepopulate data property*: *property name from source module's model*
     *             ...
     *         }
     *     }
     * }
     * ```
     */
    populateLists: {
        Cases: {
            Contacts: {
                primary_contact_id: 'id',
                primary_contact_name: 'name',
                account_id: 'account_id',
                account_name: 'account_name'
            }
        }
    },

    /**
     * Defines functions that should run after certain new models are created
     * from a quick-create drawer
     */
    postQuickCreateFunctions: {
        Cases: [
            '_setContactModelFromCaseModel'
        ]
    },

    /**
     * The current search parameters of the search tab
     */
    searchParams: {},

    /**
     * Holds the last searched collection on the search tab
     * We do this so that when you switch tabs, we can restore the previous collection when
     * returning to the search tab.
     * @property {Data.MixedBeanCollection}
     */
    searchCollection: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.tabModels = [];
        // this tells dashboard controller which dashboard to load
        this.context.set({
            layout: 'omnichannel',
            module: 'Dashboards'
        });
        this.context = this._getContext();

        this.before('tabbed-dashboard:switch-tab', function(params) {
            return this.triggerBefore('omni-dashboard:content-changed', {callback: params.callback});
        }, this);
    },

    /**
     * Util method to get context for layout
     *
     * @return {Object} context for layout
     * @private
     */
    _getContext: function() {
        return this.context.getChildContext({
            forceNew: true,
            layout: 'omnichannel',
            module: 'Dashboards',
            readonly: true
        });
    },

    /**
     * Override dashboard.js to remove dashboard header.
     * @inheritdoc
     */
    initComponents: function(components, context, module) {
        if (_.isArray(components) && components[0] && components[0].layout && components[0].layout.type &&
            components[0].layout.type === 'dashboard') {
            components[0].layout.components = this._getDashboardComponents();
        }
        return this._super('initComponents', [components, context, module]);
    },

    /**
     * Util to get dashboard components
     * @return {Array} Array of components representing dashboard metadata
     * @private
     */
    _getDashboardComponents: function() {
        return [
            {
                view: {
                    name: 'omnichannel-dashboard',
                    type: 'omnichannel-dashboard',
                    sticky: false
                }
            },
            {
                layout: 'dashlet-main'
            }
        ];
    },

    /**
     * Returns the tab index of the search tab
     *
     * @return {int|null} the tab index of the search tab, or null if it doesn't
     *                    exist
     */
    getSearchTabIndex: function() {
        return _.isNumber(this.searchTabIndex) ? this.searchTabIndex : null;
    },

    /**
     * Set parameters to pre-fill the search query in the search tab
     *
     * @param {Object} params the search parameters to set
     * @param {string} params.term the search term to set
     * @param {string} params.module_list the list of modules to search
     * @param {Object} params.filters the search filters
     */
    setSearch: function(params) {
        this.searchParams = {
            term: params.term || null,
            module_list: params.module_list || null,
            filter: params.filters || null
        };
    },

    /**
     * Set context model for a tab.
     * @param {number} tabIndex
     * @param {Object} model The new model
     */
    setModel: function(tabIndex, model) {
        this.tabModels[tabIndex] = model;
        // enable tab
        var tabbedDashboard = this._getTabbedDashboard();
        if (tabbedDashboard) {
            tabbedDashboard.setTabMode(tabIndex, true);
        }
    },

    /**
     * Change context model.
     * @param {number} tabIndex
     */
    switchModel: function(tabIndex) {
        if (this.tabModels[tabIndex]) {
            if (this.context.parent) {
                this.context.parent.set('rowModel', this.tabModels[tabIndex]);
            }
            if (this.context.children[tabIndex]) {
                this.context.set('module', this.context.children[tabIndex].get('module'));
            }
            // for interaction dashlets
            this.context.set('rowModel', this.tabModels[tabIndex]);
        }
    },

    /**
     * Change active tab.
     * @param {number} tabIndex
     */
    switchTab: function(tabIndex) {
        this.switchModel(tabIndex);
        var tabbedDashboard = this._getTabbedDashboard();

        if (tabbedDashboard && !_.isEmpty(tabbedDashboard.tabs)) {
            // The tabbed dashboard exists and its tabs have already been set
            tabbedDashboard.switchTab(tabIndex);
        } else {
            // The tabbed dashboard either does not exist or its tabs have not
            // yet been set. Keep track of the active tab here so that when the
            // tabs are set, we can switch to the correct tab when it is initialized
            this.initActiveTab = tabIndex;
        }
    },

    /**
     * Enable/disable tabs.
     */
    setTabModes: function() {
        var tabbedDashboard = this._getTabbedDashboard();
        if (tabbedDashboard && _.isArray(tabbedDashboard.tabs)) {
            var len = tabbedDashboard.tabs.length;
            if (this.configLayout) {
                tabbedDashboard.setTabMode(0, false);
            }
            for (let i = 1; i < len; i++) {
                if (app.acl.hasAccess('view',tabbedDashboard.tabs[i].module)) {
                    // enable tab if tabModel is set, otherwise disable it
                    tabbedDashboard.setTabMode(i, !_.isUndefined(this.tabModels[i]));
                } else {
                    // Hide the tab is the module has no view access instead of disabling it
                    this.setTabMode(i, false);
                }
            }
        }
    },

    /**
     *
     * Show/hide a tab.
     * @param {number} index The tab index
     * @param {boolean} mode True to enable, false to disbale
     */
    setTabMode: function(index, mode) {
        if (this.tabs && this.tabs[index]) {
            this.tabs[index].enabled = mode;
        }
        var $tab = this.$('a[data-index="' + index + '"]').closest('.tab');
        if ($tab) {
            mode ? $tab.removeClass('hidden') : $tab.addClass('hidden');
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        var tabbedDashboard = this._getTabbedDashboard();
        if (tabbedDashboard && !this._onTabEvent) {
            if (tabbedDashboard.context) {
                tabbedDashboard.context.on('change:activeTab', function(ctx) {
                    this.switchModel(ctx.get('activeTab'));
                }, this);
            }
            tabbedDashboard.on('render', this.setTabModes, this);
            this._onTabEvent = true;
        }
    },

    /**
     * Get 'omnichannel-dashboard' component.
     * @return {View.View|null}
     * @private
     */
    _getTabbedDashboard: function() {
        var tabbedDashboard = null;
        var dashboard = this.getComponent('dashboard');
        if (dashboard) {
            tabbedDashboard = dashboard.getComponent('omnichannel-dashboard');
        }
        return tabbedDashboard;
    },

    /**
     * Gets the index of the correct tab of the dashboard for the given model
     *
     * @param {Bean} model the model to get the tab index for
     * @return {int|null} the integer index of the tab if it exists, null otherwise
     */
    getTabIndexForModel: function(model) {
        var module = model.module || model.get('_module');
        return this.moduleTabIndex[module] || null;
    },

    /**
     * Gets the model stored in the given tab index of the dashboard
     *
     * @param {int} tabIndex The index of the tab to get the model from
     * @return {Bean|null} The model of the tab index if it exists; null otherwise
     */
    getModelForTabIndex: function(tabIndex) {
        return this.tabModels[tabIndex] || null;
    },

    /**
     * Builds and returns an object containing attribute data gathered from this
     * dashboard's various tab models as defined in populateLists
     *
     * @param {string} targetModule the module to get prepopulate data for
     * @return {Object} The set of prepopulate data attributes
     */
    getModelPrepopulateData: function(targetModule) {
        var data = {};

        // Get the source modules defined for the given module
        var sources = this.populateLists[targetModule];

        // For each of the source modules, pull the defined data from that module's tab
        _.each(sources, function(populateList, sourceModule) {
            var model = this.getModelForTabIndex(this.moduleTabIndex[sourceModule]);
            if (!_.isEmpty(model)) {
                data = _.extend(data, this._getPopulateListFromModel(populateList, model));
            }
        }, this);

        return data;
    },

    /**
     * Returns a set of source fields mapped to the values of target fields in
     * a model's attributes
     *
     * @param {Object} populateList a mapping of {target attribute => source attribute}
     * @param {Bean} model the model to get source attributes from
     * @return {Object} a mapping of {target attribute => source attribute value from model}
     * @private
     */
    _getPopulateListFromModel: function(populateList, model) {
        return _.mapObject(populateList, function(sourceField) {
            return model.get(sourceField);
        });
    },

    /**
     * Handles any special functionality that should be run after a model is
     * quick-created from the Omnichannel console, as defined in the
     * postQuickCreateFunctions variable
     *
     * @param {Bean} createdModel the model that came from the quick-create drawer
     */
    postQuickCreate: function(createdModel) {
        // Get the list of functions to run based on the module of the created model
        var module = createdModel.module || createdModel.get('_module');
        var functionsList = this.postQuickCreateFunctions[module];

        // Run the functions in the list, passing the created model in
        _.each(functionsList, function(functionName) {
            if (_.isFunction(this[functionName])) {
                this[functionName](createdModel);
            }
        }, this);
    },

    /**
     * Given a Case model, sets the Contact model of this dashboard to the
     * record linked by the primary_contact_id field of the case
     *
     * @param model The case model
     */
    _setContactModelFromCaseModel: function(model) {
        var module = model.module || model.get('_module');
        if (module !== 'Cases') {
            return;
        }

        // Get the ID of the primary Contact record for the created Case
        var newContactId = model.get('primary_contact_id');

        // Get the ID of the Contact currently stored in the Contacts tab
        var oldContact = this.getModelForTabIndex(this.moduleTabIndex.Contacts);
        var oldContactId = !_.isEmpty(oldContact) ? oldContact.get('id') : null;

        // If the new Contact ID is a different record, fetch it and replace the
        // one that is currently stored in the Contacts tab
        if (newContactId && newContactId !== oldContactId) {
            var contactBean = app.data.createBean('Contacts', {id: newContactId});
            contactBean.fetch({
                success: _.bind(function() {
                    this.setModel(this.getTabIndexForModel(contactBean), contactBean);
                }, this)
            });
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.searchCollection) {
            this.searchCollection.off();
            this.searchCollection = null;
        }
        this._super('_dispose');
    }
}) },
"find-duplicates": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Find-duplicates Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Headerpane:Cancel',
        'Sidebar:Toggle'
    ]
}) },
"bwc": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.BwcLayout
 * @alias SUGAR.App.view.layouts.BaseBwcLayout
 * @extends View.Layout
 */
({
	// Bwc Layout (base) 

    className: 'bwc layout',

    loadData: function() {
        // don't load record list for bwc modules
    }
}) },
"omnichannel-search-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout for the global search results page.
 *
 * @class View.Layouts.Base.OmnichannelSearchListLayout
 * @alias SUGAR.App.view.layouts.BaseOmnichannelSearchListLayout
 * @extends View.Layouts.Base.SearchLayout
 */
({
	// Omnichannel-search-list Layout (base) 

    extendsFrom: 'SearchLayout',
    className: 'omnichannel-search-list',

    componentsToAdd: [
        'omnichannel-search-headerpane',
        'omnichannel-search-list',
        'omnichannel-search-list-bottom',
    ],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initSearchCollection();
    },

    /**
     * Initializes the collection to use within the layout and its views
     *
     * @private
     */
    _initSearchCollection: function() {
        this.collection = this.layout.collection;

        // Store a reference to the collection on the omnichannel dashboard
        var omnichannelDashboard = this.closestComponent('omnichannel-dashboard');
        if (!_.isEmpty(omnichannelDashboard)) {
            omnichannelDashboard.searchCollection = this.collection;
        }
    },

    /**
     * @inheritdoc
     */
    _placeComponent: function(component) {
        if (_.contains(this.componentsToAdd, component.name)) {
            this.$('[data-component=searchlist]').append(component.el);
        } else {
            this._super('_placeComponent', [component]);
        }
    }
}) },
"searchbar-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SearchbarDropdownLayout
 * @alias SUGAR.App.view.views.BaseSearchbarDropdownLayout
 * @extends View.Views.Base.ContentsearchDropdownLayout
 */
({
	// Searchbar-dropdown Layout (base) 

    /**
     * @inheritdoc
     */
    className: 'searchbar-dropdown shadow-xl border-dropdown-widget rounded-t-none rounded-b-md',

    /**
     * @inheritdoc
     */
    extendsFrom: 'ContentsearchDropdownLayout'
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Record Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Sidebar:Toggle',
        'Record:Edit',
        'Record:Delete',
        'Record:Save',
        'Record:Cancel',
        'Record:Previous',
        'Record:Next',
        'Record:Favorite',
        'Record:Follow',
        'Record:Copy',
        'Record:Action:More'
    ]
}) },
"content-container": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This component is a non-dashlet dashlet type. It may look, behave, etc.
 * as a dashlet without being coupled with a dashboard
 *
 * @class View.Layouts.Base.ContentContainerLayout
 * @alias SUGAR.App.view.layouts.BaseContentContainerLayout
 * @extends View.Layout
 */
({
	// Content-container Layout (base) 

    className: 'content-container rounded-md shadow hover:shadow-lg transition-shadow ' +
        'bg-dashlet-background hover:bg-content-container-background-hover',

    /**
     * @inheritdoc
     */
    _placeComponent: function(component) {
        this.$el.find('.content-container-items').append(component.el);
    },
}) },
"dupecheck": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout displays a list of duplicate records found along with a count
 *
 * Note: Next step will be to add ability to switch to a filter list (and back).
 *       This is why this is in a layout.
 *
 * @class View.Layouts.Base.DupecheckLayout
 * @alias SUGAR.App.view.layouts.BaseDupecheckLayout
 * @extends View.Layout
 */
({
	// Dupecheck Layout (base) 

    initialize: function(options) {
        if(options.context.has('dupelisttype')) {
            options.meta = this.switchListView(options.meta, options.context.get('dupelisttype'));
        }
        app.view.Layout.prototype.initialize.call(this, options);
    },

    switchListView: function(meta, dupelisttype) {
        var listView = _.find(meta.components, function(component) {
            return (component.name === 'dupecheck-list');
        });
        listView.view = dupelisttype;
        return meta;
    }
}) },
"help": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The base layout for the help component.
 *
 * @class View.Layouts.Base.HelpLayout
 * @alias SUGAR.App.view.layouts.BaseHelpLayout
 * @extends View.Layout
 */
({
	// Help Layout (base) 

    events: {
        'click [data-action=close]': 'close'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * The internal state of this layout.
         * By default this layout is closed ({@link #toggle} will call render).
         *
         * FIXME TY-1798/TY-1800 This is needed due to the bad popover plugin.
         *
         * @type {boolean}
         * @private
         */
        this._isOpen = false;

        /**
         * This is the Help button in the footer.
         * Needed to render the modal by calling `popover` on the button.
         *
         * @type {jQuery}
         */
        this.button = options.button;

        /**
         * `True` if the helpObject has been created for the current view,
         * `false` otherwise.
         *
         * @type {boolean}
         * @private
         */
        this._helpObjectCreated = false;

        /**
         * Each view requires its own help object.
         * On view change, the helpObject needs to be recreated.
         */
        app.events.on('app:view:change', _.bind(function() {
            this._helpObjectCreated = false;
            if (this.button) {
                this.button.popover('destroy');
            }
        }, this));
    },

    /**
     * Initializes the popover plugin for the button given.
     *
     * @param {jQuery} button The jQuery button.
     * @private
     */
    _initPopover: function(button) {
        button.popover({
            title: this._getTitle('LBL_HELP_' + app.controller.context.get('layout').toUpperCase() + '_TITLE'),
            content: _.bind(function() {
                return this.$el;
            }, this),
            html: true,
            placement: 'top',
            trigger: 'manual',
            template: '<div class="popover footer-modal feedback helpmodal" data-modal="help">' +
                '<div class="arrow"></div><h3 class="popover-title"></h3>' +
                '<div class="popover-content"></div></div>'
        });

        // Reposition the modal so all of its contents are within the window.
        button.on('shown.bs.popover', _.bind(this._positionPopover, this));
    },

    /**
     * Fetches the title of the help modal.
     * If none exists, returns a default help title.
     *
     * @param {string} titleKey The modal title label.
     * @return {string} The converted title.
     * @private
     */
    _getTitle: function(titleKey) {
        var title = app.lang.get(titleKey, app.controller.context.get('module'), app.controller.context);
        return title === titleKey ? app.lang.get('LBL_HELP') : title;
    },

    /**
     * Toggles the help on the side pane.
     *
     * @param {boolean} show `true` to show the help, `false` to hide it.
     * @param {View.Component} [comp] Component that triggered
     * \'app:help:toggle\' event.
     * @deprecated Since 7.9. Will be removed in 7.11.
     *   Please use the `toggle` method instead.
     */
    toggleHelp: function(show, comp) {
        app.logger.warn('The function `View.Layouts.Base.HelpLayout.toggleHelp` is deprecated in 7.9.0.0' +
            ' and will be removed in 7.11.0.0. Please use `View.Layouts.Base.HelpLayout.toggle` instead.');

        if (!app.drawer.isActive(this.$el)) {
            return;
        }
        if (show || this.module === 'Home') {
            var defaultLayout = this.closestComponent('sidebar');
            if (defaultLayout) {
                defaultLayout.toggleSidePane(show);
            }
        }

        this._toggleHelpPane(show);

        var event = show ? 'app:help:shown' : 'app:help:hidden';
        app.events.trigger(event);
    },

    /**
     * Shows the help pane and hides the other panes in the RHS.
     *
     * FIXME: SC-4915 will remove this method.
     *
     * @param {boolean} show `true` to show the help pane, `false` to hide it.
     * @private
     */
    _toggleHelpPane: function(show) {
        var toggle = show ? 'hide' : 'show';
        var $layout = this.$el.closest('[data-component=sidebar]');
        $layout.find('[data-component=dashboard-pane]')[toggle]();
        $layout.find('[data-component=side-pane]').toggleClass('active', !show);
        $layout.find('[data-component=preview-pane]').removeClass('active');
    },

    /**
     * Toggle this view (by re-rendering).
     *
     * @param {boolean} [show] `true` to show, `false` to hide, `undefined`
     *   to toggle the current state.
     */
    toggle: function(show) {
        if (!this.button) {
            return;
        }

        if (_.isUndefined(show)) {
            this._isOpen = !this._isOpen;
        } else {
            this._isOpen = show;
        }

        this.button.popover('destroy');

        if (this._isOpen) {
            this._initHelpObject();
            this.render();
            this._initPopover(this.button);
            this.button.popover('show');
            this.bindOutsideClick();
        } else {
            this.unbindOutsideClick();
        }

        this.trigger(this._isOpen ? 'show' : 'hide', this, this._isOpen);
    },

    /**
     * Creates the helpObject if it has not yet been created for this.
     *
     * @private
     */
    _initHelpObject: function() {
        if (!this._helpObjectCreated) {
            this.getComponent('base').getComponent('helplet').createHelpObject();
            this._helpObjectCreated = true;
        }
    },

    /**
     * Sets the horizontal position of the modal.
     *
     * @private
     */
    _positionPopover: function() {
        var $popoverContainer = this.button.data()['bs.popover'].tip();
        var left;
        if (app.lang.direction === 'rtl') {
            // Leave 16px of space between lhs edge of popover and the screen.
            left = 16;
        } else {
            // Leave 16px of space between rhs edge of popover and the screen.
            left = $(window).width() - $popoverContainer.width() - 16;
        }
        $popoverContainer.css('left', left);
    },

    /**
     * Closes the Help modal if event target is outside of the Help modal.
     *
     * param {Object} evt jQuery event.
     */
    closeOnOutsideClick: function(evt) {
        if ($(evt.target).closest('[data-modal=help]').length === 0) {
            this.toggle(false);
        }
    },

    /**
     * Binds the outside `click` event.
     */
    bindOutsideClick: function() {
        $('body').bind('click.' + this.cid, _.bind(this.closeOnOutsideClick, this));
    },

    /**
     * Unbinds the outside `click` event.
     */
    unbindOutsideClick: function() {
        $('body').unbind('click.' + this.cid);
    },

    /**
     * Triggered when the close button on the help-header view is pressed.
     */
    close: function() {
        this.toggle(false);
    },

    /**
     * @inheritdoc
     *
     * During dispose destroy the popover.
     */
    _dispose: function() {
        this.unbindOutsideClick();
        if (this.button) {
            this.button.popover('destroy');
        }
        this._super('_dispose');
    }
}) },
"dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletLayout
 * @alias SUGAR.App.view.layouts.BaseDashletLayout
 * @extends View.Layout
 */
({
	// Dashlet Layout (base) 

    /**
     * A reference to the main dashboard
     */
    dashboard: undefined,

    /**
     * Reference to the component to be reloaded when the refresh button is clicked.
     * If not set, the first component will be used.
     */
    reloadableComponent: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.index = options.meta.index;
        this._super('initialize', [options]);

        if (!(this.meta.preview || this.meta.empty)) {
            // grab a reference to the dashboard to pass down
            this.dashboard = this.findLayout('dashboard', options.layout);
        }

        //set current model draggable
        this.on('render', function() {
            // If the user does not have write access, don't display drag/drop cursor
            if (!app.acl.hasAccessToModel('edit', this.model)) {
                this.$('[data-toggle=dashlet]').css('cursor', 'default');
            }
        }, this);
        this.context.on('dashboard:collapse:fire', this.collapse, this);
    },

    /**
     * Search recursively through the <pre><code>layout.layout</code></pre> list
     * until the <pre><code>layout.name == name</code></pre>
     *
     * @param {String} name the name of the layout you're looking for
     * @param {Object} layout the layout object to look through
     * @return {Mixed}
     */
    findLayout: function(name, layout) {
        return (layout.name === name || layout.type === name) ?
            layout :
            layout.layout ?
                this.findLayout(name, layout.layout) :
                null;
    },

    /**
     * @inheritdoc
     * Append dashlet toolbar view based on custom_toolbar definition
     *
     * @param {Array} list of component metadata
     */
    _addComponentsFromDef: function(components) {
        if (!(this.meta.preview || this.meta.empty)) {
            var dashletDef = _.first(components),
                dashletMeta,
                dashletModule,
                toolbar = {},
                pattern = /^(LBL|TPL|NTC|MSG)_(_|[a-zA-Z0-9])*$/,
                label = this.meta.label;
            //try to get the dashlet dashlet metadata
            if(dashletDef.view) {
                toolbar = dashletDef.view['custom_toolbar'] || {};
                dashletMeta = app.metadata.getView(dashletDef.view.module, dashletDef.view.name || dashletDef.view.type);
                dashletModule = dashletDef.view.module ? dashletDef.view.module : null;
            } else if (dashletDef.layout) {
                toolbar = dashletDef.layout.custom_toolbar || {};
                dashletMeta = app.metadata.getLayout(dashletDef.layout.module, dashletDef.layout.name || dashletDef.layout.type);
                dashletModule = dashletDef.layout.module ? dashletDef.layout.module : null;
            }
            if (!dashletMeta) {
                var dashletViews = app.utils.getMfeDashletViews(this.context);
                var customComp = _.find(dashletViews, function(dashlet) {
                    return dashlet.metadata.dashletType === dashletDef.view.type;
                });
                if (customComp) {
                    dashletDef.view.type = 'external-app-dashlet';
                    dashletDef.view.src = customComp.metadata.config.src;
                    dashletDef.view.customConfig = true;
                }
            }
            if (!dashletModule && dashletDef.context && dashletDef.context.module) {
                dashletModule = dashletDef.context.module;
            }
            if (pattern.test(this.meta.label)) {
                label = app.lang.get(label, dashletModule, dashletDef.view || dashletDef.layout);
            }
            //determine whether it contains custom_toolbar or not
            if (_.isEmpty(toolbar) && dashletMeta && dashletMeta['custom_toolbar']) {
                toolbar = dashletMeta['custom_toolbar'];
            }
            if(toolbar !== "no") {
                components.push({
                    view: {
                        name: 'dashlet-toolbar',
                        label: label,
                        toolbar: toolbar
                    },
                    context: {
                        module: 'Home',
                        skipFetch: true
                    }
                });
            } else {
                this.hasToolbar = false;
            }
        }

        this._setDashletContents();

        var context = this.context.parent || this.context;
        this._super('_addComponentsFromDef', [components, context, context.get("module")]);
    },

    /**
     * Set contents of `.dashlet-container` element. If we're initializing an
     * empty dashlet, set the innerHTML of `this.$el`. If we're updating an
     * existing dashlet, update with `replaceWith` to not overwrite neighbors or
     * their event listeners
     * @private
     */
    _setDashletContents: function() {
        var htmlContent = this.meta.empty ? app.template.empty(this) : this.template(this);
        var currentContent = this.$el.children('.dashlet-container').first();
        if (!_.isEmpty(currentContent)) {
            currentContent.replaceWith(htmlContent);
        } else {
            this.$el.html(htmlContent);
        }
    },

    /**
     * @inheritdoc
     * Set default skipFetch as false.
     * Able to get the custom title label from the dashlet component.
     */
    createComponentFromDef: function(def, context, module) {
        //pass the parent context only to the main dashlet component
        if (def.view && !_.isUndefined(def.view.toolbar)) {
            var dashlet = _.first(this._components);
            if (dashlet) {
                if (_.isFunction(dashlet.getLabel)) {
                    def.view.label = dashlet.getLabel();
                }
                context = dashlet.context;
            }
        }
        //set default skipFetch as false
        var skipFetch = def.view ? def.view.skipFetch : def.layout.skipFetch;
        if (def.context && skipFetch !== false) {
            def.context.skipFetch = true;
        }
        return this._super('createComponentFromDef', [def, context, module]);
    },

    /**
     * Set current dashlet as invisible
     */
    setInvisible: function() {
        if (this._invisible === true) {
            return;
        }
        var comp = _.first(this._components);
        this.model.on("setMode", this.setMode, this);
        this._invisible = true;
        this.$el.addClass('hide');
        this.listenTo(comp, "render", this.unsetInvisible, this);
    },

    /**
     * Set current dashlet back as visible
     */
    unsetInvisible: function() {
        if (this._invisible !== true) {
            return;
        }
        var comp = _.first(this._components);
        comp.trigger("show");
        this._invisible = false;
        this.model.off("setMode", null, this);
        this.$el.removeClass('hide');
        this.stopListening(comp, "render");
    },

    /**
     * @inheritdoc
     * Place the each component to the right location
     *
     * @param comp
     * @param def
     */
    _placeComponent: function(comp, def) {
        if(this.meta.empty) {
            //add-a-dashlet component
            this.$el.append(comp.el);
        } else if(this.meta.preview) {
            //preview mode
            this.$el.addClass('dashlet-preview pt-4 px-2');
            this.$('[data-dashlet=dashlet]').append(comp.el);
        } else if (_.isUndefined(def)) {
            this.$('[data-dashlet=dashlet]').after(comp.el);
        } else if(def.view && !_.isUndefined(def.view.toolbar)) {
            //toolbar view
            this.$('[data-dashlet=toolbar]').append(comp.el);
        } else if (def.prepend) {
            this.$('[data-dashlet=dashlet]').before(comp.el);
        } else {
            //main dashlet component
            this.$('[data-dashlet=dashlet]').append(comp.el);
        }
    },

    /**
     * Convert the dashlet setting metadata into the dashboard model data
     *
     * @param {Object} setting metadata
     * @return {Object} component metadata
     */
    setDashletMetadata: function(meta) {
        var metadata = this.model.get("metadata"),
            component = this.getCurrentComponent(metadata, this.index);

        _.each(meta, function(value, key){
            this[key] = value;
        }, component);

        this.model.set("metadata", app.utils.deepCopy(metadata), {silent: true});
        this.model.trigger("change:layout");
        //auto save
        if(this.model.mode === 'view') {
            this.model.save(null, {
                silent: true,
                //Show alerts for this request
                showAlerts: true,
                success: _.bind(function() {
                    this.model.unset('updated');
                }, this)
            });
        }
        return component;
    },

    /**
     * Gets component from metadata.
     *
     * @param {Object} metadata for all dashboard components
     * @return {Object} dashboard component
     */
    getComponentsFromMetadata: function(metadata) {
        var component;
        // this is a tabbed dashboard
        if (metadata.tabs) {
            var tabIndex = this.context.get('activeTab') || 0;
            component = metadata.tabs[tabIndex].components;
        } else {
            component = metadata.components;
        }
        return component;
    },

    /**
     * Retrives the seperate component metadata from the whole dashboard components
     *
     * @param {Object} metadata for all dashboard componenets
     * @param {String} tree based trace key (each digit represents the index number of the each level)
     * @return {Object} component metadata
     */
    getCurrentComponent: function(metadata, tracekey) {
        var position = tracekey.split('');
        var component = this.getComponentsFromMetadata(metadata);

        _.each(position, function(index){
            component = component.rows ? component.rows[index] : component[index];
        }, this);

        return component;
    },

    /**
     * Append the dashlet component from the setting metadata
     *
     * @param {Object} setting metadata
     */
    addDashlet: function(meta) {
        var component = this.setDashletMetadata(meta),
            def = component.view || component.layout || component;

        this.meta.empty = false;
        this.meta.label = def.label || def.name || "";
        this.meta.type = def.type;
        this.meta.moduleName = def.module;
        //clear previous dashlet
        _.each(this._components, function(component) {
            component.layout = null;
            component.dispose();
        }, this);
        this._components = [];

        if(component.context) {
            _.extend(component.context, {
                forceNew: true
            })
        }
        this.meta.components = [component];
        this.initComponents(this.meta.components);
        this.model.set('updated', true);
        this.loadData();
        this.render();
    },

    /**
     * Remove the current attached dashlet component
     */
    removeDashlet: function() {
        var cellLayout = this.layout,
            rowLayout = cellLayout.layout;
        if (this.model.mode === 'view' && cellLayout._components.length === 1) {
            var dashletRow = this.closestComponent('dashlet-row');
            // this.layout needs to have method to return all the components
            dashletRow.removeRow(this.layout.index.split('').pop());
            dashletRow.model.save(null, {showAlerts: true});
            return;
        }
        var metadata = this.model.get("metadata"),
            component = this.getCurrentComponent(metadata, this.index);
        _.each(component, function(value, key){
            if(key!=='width') {
                delete component[key];
            }
        }, this);
        this.model.set("metadata", app.utils.deepCopy(metadata), {silent: true});
        this.model.trigger("change:layout");
        //auto save
        if(this.model.mode === 'view') {
            this.model.save(null, {
                //Show alerts for this request
                showAlerts: true
            });
        } else {
            this.model.set('updated', true);
        }
        this.meta.empty = true;
        //clear previous dashlet
        _.each(this._components, function(component) {
            component.layout = null;
            component.dispose();
        }, this);
        this._components = [];
        this.initComponents([
            {
                view: 'dashlet-cell-empty',
                context: {
                    module: 'Home',
                    skipFetch: true
                }
            }
        ]);
        this.render();
    },

    /**
     * Calls the layout's addRow function to add another row
     *
     * @param {Number} columns the number of columns to add
     */
    addRow: function(columns) {
        this.layout.addRow(columns);
    },

    /**
     * Refresh the dashlet
     *
     * Call dashlet's loadData to refetch the remote data
     *
     * @param {Object} options
     */
    reloadDashlet: function(options) {
        var component = this.reloadableComponent ||  _.first(this._components);
        var context = component.context;
        context.resetLoadFlag();
        component.loadData(options);
    },

    /**
     * Edit current dashlet's settings
     *
     * Convert the current componenet's metadata into setting metadata
     * and then it loads its dashlet's configuration view
     *
     * @param {Window.Event}
     */
    editDashlet: function(evt) {
        var self = this,
            meta = app.utils.deepCopy(_.first(this.meta.components)),
            type = meta.layout ? "layout" : "view";
        if(_.isString(meta[type])) {
            meta[type] = {name:meta[type], config:true};
        } else {
            meta[type].config = true;
        }
        meta[type] = _.extend({}, meta[type], meta.context);

        if(meta.context) {
            meta.context.skipFetch = true;
            delete meta.context.link;
        }

        app.drawer.open({
            layout: {
                name: 'dashletconfiguration',
                components: [meta]
            },
            context: {
                model: new app.Bean(),
                forceNew: true
            }
        }, function(model) {
            if(!model) return;

            var conf = model.toJSON(),
                dash = {
                    context: {
                        module: model.get("module") || (meta.context ? meta.context.module : null),
                        link: model.get("link") || null
                    }
                };
            delete conf.config;
            if(_.isEmpty(dash.context.module) && _.isEmpty(dash.context.link)) {
                delete dash.context;
            }
            dash[type] = conf;
            self.addDashlet(dash);
        });
    },

    /**
     * Open Report detail view on a new tab
     */
    viewReport: function() {
        var meta = app.utils.deepCopy(_.first(this.meta.components));

        if (meta.view && meta.view.saved_report_id) {
            var link = app.bwc.buildRoute('Reports', meta.view.saved_report_id);
            window.open('index.php#' + link, '_blank');
        }
    },

    /**
     * Fold/Unfold the dashlet
     *
     * @param {Boolean} true if it needs to be collapsed
     */
    collapse: function(collapsed) {
        if (this.hasToolbar === false) {
            return;
        }

        // If user attempts to collapse a dashlet that is already collapsed via the "collapse all" fab button,
        // dont execute any logic
        if (!_.isUndefined(this.isCollapsed) && this.isCollapsed === collapsed) {
            return;
        }
        this.isCollapsed = collapsed;

        this.$('.dashlet-toggle > i').toggleClass('sicon-chevron-down', collapsed);
        this.$('.dashlet-toggle > i').toggleClass('sicon-chevron-up', !collapsed);
        this.$(".thumbnail").toggleClass("collapsed", collapsed);
        this.$("[data-dashlet=dashlet]").toggleClass("hide", collapsed);

        this.$el.toggleClass('collapsed', collapsed);
        this.layout.collapseDashlet(this);
    },

    /**
     * Displays current invisible dashlet when current mode is on edit/drag
     *
     * @param {String} (edit|drag|view)
     */
    setMode: function(type) {
        if (!this._invisible) {
            return;
        }
        if (type === 'edit' || type === 'drag') {
            this.show();
        } else {
            this.hide();
        }
    },

    /**
     * Sets the Dashlet layout Title
     * @param title
     */
    setTitle: function(title) {
        // make sure we've got an $el before using it
        if (this.$el) {
            var $titleEl = this.$('h4.dashlet-title');
            if($titleEl.length) {
                $titleEl.text(title);
            }
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.off("setMode", null, this);
        this.off("render");
        this.context.off("dashboard:collapse:fire", null, this);
        this._super('_dispose');
    }
}) },
"tabbed-layout": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.TabbedLayoutLayout
 * @alias SUGAR.App.view.layouts.BaseTabbedLayoutLayout
 * @extends View.Layout
 */
({
	// Tabbed-layout Layout (base) 

    maxTabs: undefined,
    $moreTabs: undefined,
    $overflowTabs: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.firstIsActive = false;

        if (options.meta) {
            // default to no tabs
            options.meta.notabs = true;
            if (options.meta.components) {
                // update metadata notabs setting before parent view initialize
                options.meta.notabs = options.meta.components.length <= 1;
            }
        }

        this.updateLayoutConfig();

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.context.on('tabbed-layout:tab:change', this.toggleTabVisibility, this);
    },

    /**
     * @inheritdoc
     */
    render: function() {
        var isPreview = this.name === 'preview-pane';

        if (isPreview) {
            this.$('a[data-toggle="tab"]').off('shown.bs.tab');
        }

        this._super('render');

        if (isPreview) {
            this.$('a[data-toggle="tab"]').on('shown.bs.tab', function(e) {
                var tabName = $(e.target.parentElement).data('tab-name');
                var $navTabs = $(e.target).parents('.nav-tabs');
                var $tabbable = $(e.target).parents('.tabbable');

                $navTabs.toggleClass('preview-pane-tabs', tabName === 'preview');
                $tabbable.toggleClass('preview-active', tabName === 'preview');
            });
        }
    },

    /**
     * Toggles the visibility of multiple tabbed-layout layouts
     *
     * @param {string} tabName The name of the tab being toggled
     * @param {boolean} isVisible True if the tab is visible now or not
     */
    toggleTabVisibility: function(tabName, isVisible) {
        var method = isVisible ? 'hide' : 'show';

        if (this.name.indexOf(tabName) === -1) {
            this[method]();
        }
    },

    /**
     * Extensible function that updates any local config vars that need to be set.
     */
    updateLayoutConfig: function() {
        this.maxTabs = 3;
    },

    /**
     * Triggers that a sugar app needs to be loaded
     * @private
     */
    _triggerSugarAppLoad: function(compDef) {
        this.context.trigger('sugarApp:' + this.cid + ':load:' + compDef.srn);
    },

    /**
     * @inheritdoc
     */
    _placeComponent: function(comp, def) {
        var id = _.uniqueId('record-bottom');
        var compDef = def.layout || def.view || {};
        var lblKey = compDef.label || compDef.name || compDef.type;
        var lblName = compDef.name || compDef.title || compDef;

        if (!lblKey) {
            // handles the 'preview' case returning the label
            // 'LBL_PREVIEW' for translations
            lblKey = 'LBL_' + compDef.toUpperCase();
        }

        var label = app.lang.get(lblKey, this.module) || lblKey;
        var $nav = $('<li/>')
            .html('<a href="#' + id + '" onclick="return false;" data-toggle="tab">' + label + '</a>');

        // we have a sugar app and want to lazy load it
        if (compDef.type === 'external-app') {
            $nav = $nav.on('click', this._triggerSugarAppLoad.bind(this, compDef));
        }

        var $content = $('<div/>')
            .addClass('tab-pane')
            .attr('id', id)
            .html(comp.el);

        this.$mainTabs = this.$('.nav');
        var tabIndex = this.$mainTabs.children().length;

        this.$mainTabs.addClass(this.name + '-tabs');
        $nav.addClass('nav-item')
            .attr('data-tab-name', label)
            .attr('data-tab-index', tabIndex);
        $nav.data('tab-name', lblName);

        if (!this.firstIsActive) {
            $nav.addClass('active');
            $content.addClass('active');

            if (lblName === 'preview') {
                this.$('.tabbable').addClass('preview-active');
            }
        }

        // use existing or get new reference
        this.$moreTabs = this.$moreTabs || this.$('.more-tabs');

        this.firstIsActive = true;
        this.$('.tab-content').append($content);
        // append new nav tab to the tab list
        this.$mainTabs.append($nav);
        this.$mainTabs.append(this.$moreTabs);

        if (this._components.length > this.maxTabs) {
            // get a reference to the bound event for removal
            if (!this.onMoreTabItemClickedHandler) {
                this.onMoreTabItemClickedHandler = _.bind(this.onMoreTabItemClicked, this);
            }
            // more than maxTabs so hide the new tab on the tab list
            $nav.addClass('hidden');

            // use existing or get new reference
            this.$overflowTabs = this.$overflowTabs || this.$('[data-container="overflow"]');
            // show moreTabs
            this.$moreTabs.removeClass('hidden');
            // make sure moreTabs is the last item in the list
            this.$mainTabs.append(this.$moreTabs);
            // append the new tab to the overflow tabs dropdown
            this.$overflowTabs.append($nav);
            // -1 because the $moreTabs button counts as a child
            tabIndex = this.$mainTabs.children().length - 1 + this.$overflowTabs.children().length;
            $nav.removeClass('hidden')
                .attr('data-tab-index', tabIndex)
                .on('click', this.onMoreTabItemClickedHandler);
        }

        var $navItems = this.$mainTabs.find('.nav-item');
        $navItems.removeClass('border-right')
            .last()
            .addClass('border-right');
    },

    /**
     * When a component is removed, the tab layout needs to remove the tabs as well,
     * including possibly setting a new active tab
     *
     * @param {Object} component The component to remove from the layout
     */
    removeComponent: function(component) {
        var i = _.isNumber(component) ? component : this._components.indexOf(component);

        this._super('removeComponent', [i]);

        var $tabNavEl = $(this.$('.nav-tabs li')[i]);
        var $tabContentEl = $(this.$('.tab-pane')[i]);
        var resetActive = $tabNavEl.hasClass('active');

        $tabNavEl.remove();
        $tabContentEl.remove();

        if (resetActive) {
            this.$(this.$('li')[0]).addClass('active');
            this.$(this.$('.tab-pane')[0]).addClass('active');
        }
    },

    /**
     * When there are more than `maxTabs` and one of those overflow tabs gets clicked,
     * this function switches the tabs from the overflow dropdown to the main tab area
     *
     * @param {Event} evt The Click Event
     */
    onMoreTabItemClicked: function(evt) {
        var $overflowTabToMove = $(evt.currentTarget);
        var $lastMainTab = $(this.$mainTabs.children()[2]);

        // add the main tab to the overflow tabs
        this.$overflowTabs.prepend($lastMainTab);
        // remove the active class from the tab moved back to overflow
        $lastMainTab.removeClass('active');
        // add the dropdown tab to the main tabs list
        this.$mainTabs.append($overflowTabToMove);
        // remove the extra click handler from the new overflow tab thats now on the main list
        $overflowTabToMove.off('click', 'click', this.onMoreTabItemClickedHandler);
        // add the new click handler to the main tab moved to overflow tabs
        $lastMainTab.on('click', this.onMoreTabItemClickedHandler);

        // make sure moreTabs is the last item in the list
        this.$mainTabs.append(this.$moreTabs);
        // update the moved tab index to this.maxTabs
        $overflowTabToMove.attr('data-tab-index', this.maxTabs);
        // update the overflow tabs tab-index values
        var $navItems = this.$overflowTabs.find('.nav-item');
        _.each($navItems, function(navItem, index) {
            $(navItem).attr('data-tab-index', this.maxTabs + 1 + index);
        }, this);

    },

    /**
     * @inheritdoc
     */
    dispose: function() {
        if (this.name === 'preview-pane') {
            this.$('a[data-toggle="tab"]').off('shown.bs.tab');
        }

        this._super('dispose');
    }
}) },
"pipeline-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Pipeline-filter Layout (base) 

    extendsFrom: 'FilterLayout',

    /**
     * @inheritdoc
     *
     * Change layout type to 'records' for pipeline view.
     */
    getFilterEditStateKey: function() {
        if (this.layoutType === 'pipeline-records') {
            return app.user.lastState.key('edit-' + this.layout.currentModule + '-records', this);
        } else {
            return this._super('getFilterEditStateKey');
        }
    },

    /**
     * @inheritdoc
     *
     * Applies pipeline filters if layout type is pipeline-records
     */
    applyFilter: function(query, dynamicFilterDef) {
        if (this.layoutType === 'pipeline-records') {
            this.filterPipeline(query, dynamicFilterDef);
        } else {
            this._super('applyFilter', [query, dynamicFilterDef]);
        }
    },

    /**
     * Gets called when the filters are added/removed, and triggers filterChanged listener
     * @param {string} query search string
     * @param {Object} dynamicFilterDef(optional)
     */
    filterPipeline: function(query, dynamicFilterDef) {
        if (_.isEmpty(query)) {
            var filterQuicksearchView = this.getComponent('filter-quicksearch');
            query = filterQuicksearchView && filterQuicksearchView.$el.val() || '';
        }

        var ctxCollection = this.context.get('collection');
        var origFilterDef = dynamicFilterDef || ctxCollection.origFilterDef || [];
        var filterDef = this.buildFilterDef(origFilterDef, query, this.context);

        ctxCollection.filterDef = filterDef;
        ctxCollection.origFilterDef = origFilterDef;
        this.context.trigger('pipeline:recordlist:filter:changed', filterDef);
    },

    /**
     * @inheritdoc
     *
     * Adds the pipeline-records context to relevant context list if on layout
     */
    getRelevantContextList: function() {
        var contextList = [];
        if (this.layoutType === 'pipeline-records') {
            var context = this.context;
            if (!context.get('modelId') && context.has('collection')) {
                contextList.push(context);
            }
        } else {
            contextList = this._super('getRelevantContextList');
        }
        return _.uniq(contextList);
    }
}) },
"asdashlet-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ASDashletFilterLayout
 * @alias SUGAR.App.view.layouts.BaseASDashletFilterLayout
 * @extends View.Layout
 */
({
	// Asdashlet-filter Layout (base) 

    className: 'dashablelist-filter',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //Set up a listener for the configuration save
        this.listenTo(this.layout, 'asdashlet:config:save', this.saveFilterToDashlet);
    },

    /**
     * Set the current filter ID and def to be seen on the dashlet
     *
     * @private
     */
    saveFilterToDashlet: function() {
        var filterPanelLayout = this.getComponent('filterpanel');
        if (!filterPanelLayout) {
            return;
        }

        this.model.set('currentFilterId', filterPanelLayout.context.get('currentFilterId'));
    }
}) },
"shortcuts-config": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ShortcutsConfigLayout
 * @alias SUGAR.App.view.layouts.BaseShortcutsConfigLayout
 * @extends View.Layout
 */
({
	// Shortcuts-config Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Headerpane:Cancel',
        'Headerpane:Save'
    ],

    /**
     * @inheritdoc
     */
    _placeComponent: function(component) {
        this.$('[data-action=render]').append(component.el);
    },

    /**
     * Do not fetch data.
     */
    loadData: $.noop
}) },
"history-default": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This is the extension of {@link View.Layouts.Base.DefaultLayout} that is used
 * for the history summary drawer.
 *
 * The aim of this extension is to make the right pane collapsed by default, and
 * to remove stickiness so the pane is always collapsed when you initialize the
 * layout.
 *
 * @class View.Layouts.Base.HistoryDefaultLayout
 * @alias SUGAR.App.view.layouts.BaseHistoryDefaultLayout
 * @extends View.Layouts.Base.DefaultLayout
 */
({
	// History-default Layout (base) 

    extendsFrom: 'DefaultLayout',

    /**
     * Extend to return `false` the first time this method is called, so the
     * pane is always collapsed on first load.
     *
     * @inheritdoc
     */
    isSidePaneVisible: function() {
        if (this._isSidePaneVisibleCalledOnce !== true) {
            this._isSidePaneVisibleCalledOnce = true;
            app.user.lastState.set(this._hideLastStateKey, 1);
            return false;
        }
        return this._super('isSidePaneVisible');
    },

    /**
     * Removes the cache entry because it is unnecessary to keep it since we
     * reset it on first load.
     *
     * @inheritdoc
     */
    _dispose: function() {
        app.user.lastState.remove(this._hideLastStateKey);

        this._super('_dispose');
    }
}) },
"sweetspot-config": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SweetspotConfigLayout
 * @alias SUGAR.App.view.layouts.BaseSweetspotConfigLayout
 * @extends View.Layout
 */
({
	// Sweetspot-config Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'SweetSpot:Config:Save',
        'SweetSpot:Config:Cancel'
    ],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._bindEvents();
    },

    /**
     * @override
     */
    _placeComponent: function(component) {
        this.$('.main-pane').append(component.el);
    },

    /**
     * Binds the events that this layout uses.
     *
     * @protected
     */
    _bindEvents: function() {
        this.context.on('sweetspot:cancel:config', this.cancelConfig, this);

        // Button events
        this.context.on('button:save_button:click', this.saveConfig, this);
        this.context.on('button:cancel_button:click', this.cancelConfig, this);
    },


    /**
     * This method prepares the attributes payload for the call to
     * {@link Core.User#updatePreferences}.
     *
     * @protected
     * @param {Object} data The unprepared configuration data.
     * @return {Object} The prepared configuration data.
     */
    _formatForUserPrefs: function(data) {
        return {sweetspot: data};
    },

    /**
     * Receives all the configuration models from the subcomponents, to be
     * saved in user preferences.
     *
     * @protected
     */
    _getAllConfigs: function() {
        var config = {};
        this.context.off('sweetspot:receive:configs');
        this.context.on('sweetspot:receive:configs', function(data) {
            _.extend(config, data);
        });
        this.context.trigger('sweetspot:ask:configs');
        return config;
    },

    /**
     * Saves the sanitized Sweet Spot settings in user preferences and closes
     * the drawer.
     */
    saveConfig: function() {
        var data = this._getAllConfigs();
        data = this._formatForUserPrefs(data);

        this.context.trigger('sweetspot:config:enableButtons', false);
        app.alert.show('sweetspot', {
            level: 'process',
            title: app.lang.get('LBL_SAVING'),
            autoClose: false
        });

        app.user.updatePreferences(data, _.bind(this._saveConfigCallback, this));
    },

    /**
     * Callback for the call to {@link Core.User#updatePreferences}.
     *
     * @param {string} err Error message returned by the server.
     */
    _saveConfigCallback: function(err) {
        app.alert.dismiss('sweetspot');
        if (err) {
            var errorMsg = app.lang.get('LBL_SWEETSPOT_CONFIG_ERR', this.module, {errorMsg: err});
            this.context.trigger('sweetspot:config:enableButtons', true);
            app.alert.show('config-failed', {
                level: 'error',
                title: 'LBL_SWEETSPOT',
                messages: errorMsg
            });
            return;
        }
        app.drawer.close(this.collection);
        app.events.trigger('sweetspot:reset');
    },

    /**
     * Closes the config drawer without saving changes.
     */
    cancelConfig: function() {
        app.drawer.close();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.context.off('sweetspot:receive:configs');
        this._super('_dispose');
    }
}) },
"content-grid": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This component is an abstracted type of dashboard-grid. De-couples
 * dashboard-grid and dashlets
 *
 * @class View.Views.Base.ContentGridLayout
 * @alias SUGAR.App.view.views.BaseContentGridLayout
 * @extends View.Layout
 */
({
	// Content-grid Layout (base) 

    className: 'content-grid grid-stack',

    /**
     * Class name for grid item
     */
    gridItemClassName: 'content-grid-item',

    /**
     * Should this component use Gridstack?
     */
    useGridstack: true,

    /**
     * The grid
     */
    grid: null,

    /**
     * How many pixels per row on a Gridstack grid?
     *
     * Although there is no documentation on how this is calculated,
     * it's consistently opts.cellHeight + opts.verticalMargin
     */
    pixelsPerGridstackRow: 0,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        if (this.useGridstack) {
            this.initGridstack();
        }
    },

    /**
     * Gridstack options on initialization
     */
    getGridstackOptions: function() {
    },

    /**
     * Gridstack widget options
     */
    getGridstackWidgetOptions: function() {
    },

    /**
     * Initialize the Gridstack library
     */
    initGridstack: function() {
        try {
            this.grid = GridStack.init(this.getGridstackOptions(), this.el);

            this.pixelsPerGridstackRow = this.grid.opts.cellHeight + this.grid.opts.verticalMargin;
        } catch (e) {
            console.warn('failed to load gridstack');
        }
    },

    /**
     * Add a component to the Gridstack grid
     *
     * @param component
     * @param options
     */
    addGridstackWidget(component, options = {}) {
        if (this.grid) {
            this.grid.addWidget(component.el, options);
        }
    },

    /**
     * Add and render components onto the grid
     */
    initGrid: function() {
        let defs = this.getDefsForComponents();

        _.each(defs, def => {
            let wrappedDefs = this.getWrappedDefsForGridItem(def);
            let comp = this.createComponentFromDef(wrappedDefs, null, this.module);
            this.addComponent(comp);

            comp.initComponents();
            comp.render();

            this.addGridstackWidget(comp, this.getGridstackWidgetOptions(comp));
        }, this);
    },

    /**
     * Get definitions for components to be added to the grid
     *
     * To be overridden by child components as definitions may
     * be retrieved from different places
     */
    getDefsForComponents: function() {
    },

    /**
     * Wrap the def in the grid item class name
     *
     * @param def
     * @return {Object}
     */
    getWrappedDefsForGridItem: function(def) {
        return {
            layout: {
                css_class: this.gridItemClassName,
                components: [
                    def
                ]
            }
        };
    }
}) },
"contentsearch-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ContentsearchDropdownLayout
 * @alias SUGAR.App.view.views.BaseContentsearchDropdownLayout
 * @extends View.Layout
 */
({
	// Contentsearch-dropdown Layout (base) 

    /**
     * @inheritdoc
     */
    className: 'contentsearch-dropdown',

    events: {
        'click [data-action="clicklink"]': 'linkClicked'
    },

    /**
     * Shows the dropdown
     */
    show: function() {
        $('body').on('click.contentsearch', _.bind(function(event) {
            if (!$.contains(this.el, event.target)) {
                this.$el.hide();
                $('body').off('click.contentsearch');
            }
        }, this));
        this.$el.show();
    },

    /**
     * Hides the dropdown
     */
    hide: function() {
        this.$el.hide();
    },

    /**
     * Opens a link in a new tab and hides the dropdown.
     *
     * @param {Event} evt The click event
     */
    linkClicked: function(evt) {
        var $target = this.$(evt.currentTarget);
        var url = $target.data('url');
        window.open(url, '_blank');
        this.hide();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        $('body').off('click.contentsearch');
    }
}) },
"omnichannel-dashboard-config": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The dashboard container of the Omnichannel console config.
 *
 * @class View.Layouts.Base.OmnichannelDashboardConfigLayout
 * @alias SUGAR.App.view.layouts.BaseOmnichannelDashboardConfigLayout
 * @extends View.Layouts.Base.OmnichannelDashboardLayout
 */
({
	// Omnichannel-dashboard-config Layout (base) 

    extendsFrom: 'OmnichannelDashboardLayout',

    /**
     * Flag to indicate if the open layout is a Configure Layout
     */
    configLayout: true,

    /**
     * Stores the default tab index to switch to when the config dashboard loads
     */
    initActiveTab: 1,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.context.set('config-layout', true);
        this.bindEvents();
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        this._super('_render');
        this._setDummyModels();
    },

    /**
     * Bind events
     */
    bindEvents: function() {
        this.context.on('dashboard:restore-tab:clicked', _.bind(this.restoreTabToDefault, this));
    },

    /**
     * Set empty models on the dashboard so all tabs are visible. We set
     * `dataFetched` on the models to True so that the dashlets render
     * their contents instead of "Loading" while trying to fetch data from
     * backend
     *
     * @private
     */
    _setDummyModels: function() {
        var dashboardModules = _.keys(this.moduleTabIndex);
        _.each(dashboardModules, function(module) {
            var model = app.data.createBean(module);
            model.dataFetched = true;
            var tabIndex = this.moduleTabIndex[module];
            this.setModel(tabIndex, model);
        }, this);
    },

    /**
     * @override
     *
     * Override so the dashboard isn't readonly in the config drawer.
     *
     * @return {Object} Context to set on layout
     * @private
     */
    _getContext: function() {
        return this.context.getChildContext({
            forceNew: true,
            layout: 'omnichannel',
            module: 'Dashboards'
        });
    },

    /**
     * @override
     *
     * Override to add the dashboard-fab from the Dashboards module to the
     * components list.
     *
     * @return {Array} List of components to render
     * @private
     */
    _getDashboardComponents: function() {
        var components = this._super('_getDashboardComponents');
        components.push({
            view: 'dashboard-fab',
            loadModule: 'Dashboards'
        });
        return components;
    },

    /**
     * Restore the specified tab to default metadata
     *
     * @param tabIndex the tab index to restore
     */
    restoreTabToDefault: function(tabIndex) {
        app.alert.show('restore_default_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_RESTORE_DEFAULT_TAB_CONFIRM', 'Dashboards'),
            onConfirm: _.bind(function() {
                var attributes = {
                    id: this._getOmniDashboardBeanId()
                };
                var params = {
                    dashboard: 'omnichannel',
                    tab_index: tabIndex
                };

                var url = app.api.buildURL('Dashboards', 'restore-tab-metadata', attributes, params);
                app.api.call('update', url, null, {
                    success: _.bind(function() {
                        this._getTabbedDashboard().fetchModel();
                    }, this)
                });
            }, this)
        });
    },

    /**
     * Get the bean ID for the omnichannel dashboard component
     *
     * @return string
     * @private
     */
    _getOmniDashboardBeanId: function() {
        var component = _.find(this._components, function(comp) {
            return comp.type && comp.type === 'dashboard' &&
                comp.model && comp.model.get('view_name') === 'omnichannel';
        });
        var model = component ? component.model : null;
        return model ? model.get('id') : '';
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.context.off('dashboard:restore-tab:clicked');
        this._super('_dispose');
    }
}) },
"dashablelist-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashablelistFilterLayout
 * @alias SUGAR.App.view.layouts.BaseDashablelistFilterLayout
 * @extends View.Layout
 */
({
	// Dashablelist-filter Layout (base) 

    className: 'dashablelist-filter',

    /**
     * @inheritdoc
     */
    initComponents: function(components, context, module) {
        this._super('initComponents', [components, context, module]);

        // We need to initialize the filterpanel with the filter and module
        // saved on the dashlet.
        var filterPanelLayout = this.getComponent('filterpanel');
        if (filterPanelLayout) {
            filterPanelLayout.before('render', this._reinitializeFilterPanel, this);
            this.listenTo(this.layout, 'dashlet:filter:reinitialize', filterPanelLayout.render);
        }
    },

    /**
     * This function sets the `currentModule` on the filterpanel layout, and
     * the `currentFilterId` on its context. It is invoked before
     * `filter:reinitialize` is triggered from `_render` on the filterpanel
     * layout.
     *
     * @private
     */
    _reinitializeFilterPanel: function() {
        var filterPanelLayout = this.getComponent('filterpanel');
        if (!filterPanelLayout) {
            return;
        }

        var moduleName = this.model.get('module'),
            id = this.model.get('filter_id');

        filterPanelLayout.currentModule = moduleName;
        this.context.set('currentFilterId', id);
    }
}) },
"stage2-news-preferences": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Stage2NewsPreferencesLayout
 * @alias SUGAR.App.view.layouts.BaseStage2NewsPreferencesLayout
 * @extends View.Layout
 */
({
	// Stage2-news-preferences Layout (base) 

    plugins: ['Stage2CssLoader', 'PushNotifications'],

    pushNotificationFilePath: './include/javascript/hint-push-worker.js',

    events: {
        'click [data-action=addNewPreference]': 'addNewPreference'
    },

    minNrofPreferences: 1,

    maxNrofPreferences: 20,

    targetFields: ['sugar', 'browser', 'email-immediate', 'email-daily', 'email-weekly'],

    /**
     * Event name indicating dashlet configuration phase.
     * This flag is used exclusively by the dashlet configuration headerpane.
     * It allows us to detect if the drawer will be close by the configuration view
     * or needs to be closed from this layout.
     */
    configurationEvent: '',

    /**
     * Used for adding empty records to the layout.
     */
    newPreferenceTemplate: {
        'type': '',
        'category': '',
        'tag': [],
        'sugar': false,
        'browser': false,
        'email-immediate': false,
        'email-daily': false,
        'email-weekly': false
    },

    /**
     * @inheritdoc
     */
    initialize: function(opts) {
        this._super('initialize', [opts]);
        this.loadPreferences();
        this.bindEventHandlers();
    },

    /**
     * Bind event handlers
     */
    bindEventHandlers: function() {
        app.events.on('news-preference:remove', _.bind(this.removePreference, this));
        app.events.on('news-preferences:cancel', _.bind(this.handleDrawerCancel, this));
        app.events.on('news-preferences:save', _.bind(this.initPreferencesSync, this));
        app.events.on('news-preference:enable-notifications', _.bind(this.handleBrowserTargetSelect, this));
    },

    /**
     * Creates a new collection of preferences, sets the
     * collection's initial state and loads the preferences.
     */
    loadPreferences: function() {
        this.collection = app.data.createBeanCollection('HintAccountsets');
        this.collection.pref_delete = [];
        this.collection.nrOfChanges = 0;
        this.collection.orderBy = {
            field: 'date_entered',
            direction: 'asc'
        };
        this.collection.fetch({
            myItems: true,
            success: _.bind(this.processPreferences, this)
        });
    },

    /**
     * Sets up the initial state of the preferences and the preferences UI.
     */
    processPreferences: function() {
        this.extendModels();
        this.checkNotificationSetup();
        _.each(this.collection.models, this.renderPreference, this);
        this.toggleButtons();
    },

    /**
     * Creates a preference row dynamically and renders it on the page.
     *
     * @param {Backbone.Model} model Representation of a user preference.
     */
    renderPreference: function(model) {
        // Set this for when the user cancels enabling browser notifications.
        // Want to easily be able to set browser notification icon back to its original state.
        model.set('browserInitialState', model.get('browser'));
        var view = app.view.createView({
            layout: this,
            model: model,
            module: this.module,
            context: this.context,
            type: 'stage2-news-preference',
            pushMessages: this.pushMessageSupport
        });
        this.addComponent(view);
        view.render();
    },

    /**
     * @inheritdoc
     *
     * @override Place a preference row into the DOM, right before the add button.
     *
     * @param {Object} component
     */
    _placeComponent: function(component) {
        if (this.disposed) {
            return;
        }
        this.$el.find('.stage2-notifications-emptyline').before(component.el);
    },

    /**
     * Updates the layout control buttons (Add button and Remove button).
     * While there are at least 20 preferences, the add button has to be disabled.
     * While there is only 1 preference, the remove button has to be disabled.
     * In any other cases all buttons should be enabled.
     */
    toggleButtons: function() {
        var nrOfRecords = this.collection.models.length;

        if (nrOfRecords === 1) {
            this.$('.stage2-notification-pref-removebtn.real').addClass('hide');
            this.$('.stage2-notification-pref-removebtn.fake').removeClass('hide');
        } else if (nrOfRecords > 19) {
            this.$('.stage2-notification-pref-addbtn.real').addClass('hide');
            this.$('.stage2-notification-pref-addbtn.fake').removeClass('hide');
        } else {
            this.$('.stage2-notification-pref-addbtn.fake').addClass('hide');
            this.$('.stage2-notification-pref-addbtn.real').removeClass('hide');
            this.$('.stage2-notification-pref-removebtn.fake').addClass('hide');
            this.$('.stage2-notification-pref-removebtn.real').removeClass('hide');
        }
    },

    /**
     * Adds a new preference dynamically to the layout and collection.
     * The layout control buttons have to be updated to reflect the correct status after the addition.
     */
    addNewPreference: function() {
        if (this.collection.models.length < this.maxNrofPreferences) {
            var newPreference = app.data.createBean('HintAccountsets', this.newPreferenceTemplate);
            newPreference.setDefault({
                'assigned_user_id': app.user.id,
                'assigned_user_name': app.user.get('full_name')
            });
            this.collection.add(newPreference);
            this.renderPreference(newPreference);
            this.toggleButtons();
        }
    },

    /**
     * Remove a preference from the layout and collection.
     * The layout control buttons have to be updated to reflect the correct status after the removal.
     *
     * @param {view} view A view representing a preference setting.
     * @param {string} cid The component Id of the view.
     */
    removePreference: function(view, cid) {
        if (this.collection.models.length > this.minNrofPreferences) {
            var preferenceRecord = _.findWhere(this.collection.models, {cid: cid});
            if (preferenceRecord.id) {
                this.collection.pref_delete.push(preferenceRecord);
            }
            this.collection.remove(preferenceRecord);
            this.removeComponent(view);
            this.toggleButtons();
            view.dispose();
        }
    },

    /**
     * Checks each model for changes and makes a summary of the different changes that have been made.
     * If a model has no id yet, it means that it was just created. Else if it is changed, an update is necessary.
     */
    setCollectionDelta: function() {
        this.collection.pref_update = _.filter(this.collection.models, function(model) {
            return model.hasChanged();
        });

        this.collection.nrOfChanges = this.collection.pref_update.length + this.collection.pref_delete.length;
    },

    /**
     * Increments the counter that shows the number of changes that have been saved.
     * If all saves have been run, the drawer will be closed.
     * Note: result may not have a status if a bean is returned.
     *
     * @param {Bean} model The preference that has been saved/deleted.
     * @param {Object} result Response results (model attributes OR error info).
     */
    updateSyncProgress: function(model, result) {
        this.completedRequests++;
        this.hasErrorsInSync |= result.message && result.status !== 200;
        this.runFinalSyncSteps();
    },

    hasFinishedSync: function() {
        return !this.disposed && this.completedRequests === this.collection.nrOfChanges;
    },

    /**
     * After all preferences have been saved successfully close the drawer.
     * In case of errors show an error message but do not close the drawer.
     */
    runFinalSyncSteps: function() {
        if (this.hasFinishedSync()) {
            if (this.hasErrorsInSync) {
                this.showSyncError();
            } else {
                this.closeView();
            }
        }
    },

    /**
     * Show sync error alert
     */
    showSyncError: function() {
        app.alert.show('notification_sync_error', {
            level: 'error',
            messages: app.lang.get('LBL_NOTIFICATIONS_ERROR_MESSAGE_FAILEDSYNC')
        });
    },

    /**
     * Shows an error regarding the fact that some user preferences
     * have not been set correctly.
     */
    showRequiredError: function() {
        app.alert.show('notification_required_error', {
            level: 'error',
            messages: app.lang.get('LBL_NOTIFICATIONS_ERROR_MESSAGE_MISSING_REQUIRED')
        });
    },

    /**
     * Checks if a model has its required values completed.
     * Note: this method will not trigger any other functionalities/events
     * related to standard validation.
     *
     * @param {model} model A news preference model.
     * @return {boolean} True if requirements are met.
     */
    validateModel: function(model) {
        var type = model.get('type');
        var tags = model.get('tag');
        var category = model.get('category');
        var hasTags = (type === 'tags') ? (tags && !_.isEmpty(tags)) : true;
        return type && category && hasTags;
    },

    /**
     * Checks new and extisting preferences that are subject of an update.
     * If any of the preferences lack a required value, they are considered invalid.
     *
     * @return {boolean} True if preferences have been completed properly.
     */
    arePreferencesValid: function() {
        return _.every(this.collection.pref_update, function(model) {
            return this.validateModel(model);
        }, this);
    },

    /**
     * Saves new preferences, updates existing ones and removes those which have been deleted.
     * If there are no changes the drawer needs to be closed. If at least one of the preferences
     * is not set correctly, an error will be shown, valid preferences will not ne saved until
     * all error have not been corrected.
     *
     * @param {string} configurationEvent Event name indicating dashlet configuration phase.
     */
    initPreferencesSync: function(configurationEvent) {
        this.setCollectionDelta();
        this.completedRequests = 0;
        this.hasErrorsInSync = false;
        this.configurationEvent = configurationEvent;

        if (this.collection.nrOfChanges > 0) {
            if (this.arePreferencesValid()) {
                _.each(this.collection.pref_update, this.savePreference, this);
                _.each(this.collection.pref_delete, this.deletePreference, this);
            } else {
                this.showRequiredError();
            }
        } else {
            this.closeView();
        }
    },

    /**
     * Creates and/or updates a preference.
     *
     * @param {Bean} model A notification preference.
     */
    savePreference: function(model) {
        this.compressTargets(model);
        model.save(model.attributes, {
            error: _.bind(this.updateSyncProgress, this),
            success: _.bind(this.updateSyncProgress, this)
        });
    },

    /**
     * Deletes a notification preference.
     *
     * @param {Bean} model The preference to be deleted.
     */
    deletePreference: function(model) {
        model.destroy({
            error: _.bind(this.updateSyncProgress, this),
            success: _.bind(this.updateSyncProgress, this)
        });
    },

    /*****************/
    /* GENERAL LOGIC */
    /*****************/

    /**
    * Actions to be performed in case the user does not give permission
    * for push notificaitons. Revert all browser target to false.
    */
    handleDeniedPermission: function() {
        _.each(this.collection.models, function(model) {
            if (model.get('browser') === true) {
                model.set('browser', false);
            }
        });
    },

    /**
     * If we have at least one browser target, set up the push notifications.
     */
    checkNotificationSetup: function() {
        var hasBrowserTarget = _.find(this.collection.models, function(model) {
            return model.get('browser') === true;
        });
        if (hasBrowserTarget) {
            this.setupPushNotifications();
        }
    },

    /**
     * If the user activates a browser target we need to set up push notifications.
     * A warning will be triggered during the process; in case the user denies permission
     * the browser target will need to stay inactive.
     */
    handleBrowserTargetSelect: function(model) {
        var denyPermissionCallback = _.bind(function(model) {
            model.revertAttributes();
            model.set('browser', model.get('browserInitialState'));
        }, this, model);
        this.setupPushNotifications(denyPermissionCallback);
    },

    /**
     * Save the subscription for push notifications on the server.
     *
     * @param {string} subscription A JSON string.
     */
    saveSubscription: function(subscription) {
        app.data.createBean('HintNotificationTargets', {
            type: 'browser',
            assigned_user_id: app.user.id,
            credentials: JSON.stringify(subscription)
        }).save();
    },

    /**
     * Checks if there are any unsaved changes, if yes pops up a warning, if not, initiates closing.
     *
     * @param {string} configurationEvent Event name indicating dashlet configuration phase.
     */
    handleDrawerCancel: function(configurationEvent) {
        this.setCollectionDelta();
        this.configurationEvent = configurationEvent;
        if (this.collection.nrOfChanges === 0) {
            this.closeView();
        } else {
            this.warnAboutUnsavedChanges();
        }
    },

    /**
     * A warning message about unsaved changes. If the intention of leaving is confirmed,
     * the changes will not be saved but the drawer will be closed.
     */
    warnAboutUnsavedChanges: function() {
        app.alert.show('leave_confirmation', {
            level: 'confirmation',
            onConfirm: _.bind(this.closeView, this),
            messages: app.lang.get('LBL_WARN_UNSAVED_CHANGES', this.module)
        });
    },

    /**
     * Leaving the view may happen in three distinct ways.
     * Through dashlet configuration save, closing will be handled
     * by dashlet configuration header view.
     * If the preferences were opened through a drawer, we close the drawer.
     * If the preferences were opened through a link, we navigate to the home page.
     */
    closeView: function() {
        if (this.configurationEvent) {
            app.events.trigger('dashletconfig:news-preferences:' + this.configurationEvent);
        } else if (app.drawer.count()) {
            app.drawer.close();
        } else {
            app.router.redirect('#Home');
        }
    },

    /**
     * @inheritdoc
     * Have to detach events.
     */
    _dispose: function() {
        app.events.off('news-preferences:save');
        app.events.off('news-preference:remove');
        app.events.off('news-preferences:cancel');
        app.events.off('news-preference:enable-notifications');
        this._super('_dispose');
    },

    /***************************/
    /* HACKS FOR TARGET FIELDS */
    /***************************/
    extendModels: function() {
        _.each(this.collection.models, this.extendTargets, this);
    },

    /**
     * Targets should be represented by standalone fields.
     * Extends an accountset with the individual target values.
     * NOTE: the syntax used in the each cycle can not be shortened
     * further due to limitations under IE.
     *
     * @param {Bean} model A preference record.
     */
    extendTargets: function(model) {
        var targets = model.get('targets');
        _.each(this.targetFields, function(field) {
            var IEattribute = {};
            IEattribute[field] = targets.indexOf(field) > -1;
            model.setDefault(IEattribute);
        }, this);
    },

    /**
     * Targets should be represented by standalone fields, but saved as a list.
     * Compresses the individual target values into a list and sets them on the model.
     *
     * @param {Bean} model A preference record.
     */
    compressTargets: function(model) {
        var targetList = _.filter(this.targetFields, function(field) {
            return model.get(field);
        });
        model.set('targets', targetList);
    }
}) },
"sweetspot-config-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SweetspotConfigListLayout
 * @alias SUGAR.App.view.layouts.BaseSweetspotConfigListLayout
 * @extends View.Layout
 */
({
	// Sweetspot-config-list Layout (base) 

    className: 'columns',

    // FIXME: Change this to 'UnsavedChanges' when SC-4167 gets merged. It won't
    // work until then, because 'Editable' can only be attached to a view.
    plugins: ['Editable'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initRows();
        this._bindEvents();
    },

    /**
     * Initializes this layout by adding
     * {@link View.Views.Base.SweetspotConfigListRowView rows} of configured
     * hotkeys if they exist in user preferences.
     *
     * @protected
     * @return {undefined} Returns `undefined` if there are no configured
     *   hotkeys.
     */
    _initRows: function() {
        var data = app.user.getPreference('sweetspot');
        data = data && data.hotkeys;
        if (_.isEmpty(data)) {
            // Always add an empty row if we don't have anything configured.
            this.addRow();
            return;
        }

        _.each(data, function(row) {
            _.each(row.keyword, function(word) {
                this._initRow(row, word);
            }, this);
        }, this);
    },

    /**
     * Adds a {@link View.Views.Base.SweetspotConfigListRowView row view} to the
     * layout, and sets the `keyword` and `action` attributes on the model of
     * the added row component.
     *
     * @param {Object} row The object containing row attributes.
     * @param {string} keyword The `keyword` attribute of the row.
     * @param {string} action The `action` attribute of the row.
     */
    _initRow: function(row, keyword, action) {
        action = action || row.action;
        keyword = keyword || row.keyword;

        var rowComponent = this.addRow();
        rowComponent.model.set('action', action);
        rowComponent.model.set('keyword', keyword);
    },

    /**
     * Binds the events that this layout uses.
     *
     * @protected
     */
    _bindEvents: function() {
        // Config data events
        this.context.on('sweetspot:ask:configs', this.generateConfig, this);

        // Config list row events
        this.context.on('sweetspot:config:addRow', this.addRow, this);
        this.context.on('sweetspot:config:removeRow', this.removeRow, this);
    },

    /**
     * @override
     */
    _placeComponent: function(component) {
        this.$('[data-sweetspot=actions]').append(component.el);
    },

    /**
     * Adds a {@link View.Views.Base.SweetspotConfigListRowView row view} to the
     * layout.
     *
     * @param {View.View} component The component that triggered this event.
     */
    addRow: function(component) {
        var def = _.extend(
                {view: 'sweetspot-config-list-row'},
                app.metadata.getView(null, 'sweetspot-config-list-row')
            );
        var rowComponent = this.createComponentFromDef(def, this.context, this.module);

        if (component) {
            // Add the row after the row where the user clicked the '+' sign.
            component.$el.after(rowComponent.el);
        } else {
            this.addComponent(rowComponent, def);
        }
        rowComponent.render();
        return rowComponent;
    },

    /**
     * Removes and disposes this row view from the
     * {@link View.Views.Base.SweetspotConfigListLayout list layout}
     *
     * @param {View.View} component The component that triggered this event.
     */
    removeRow: function(component) {
        this.collection.remove(component.model);
        component.dispose();
        this.removeComponent(component);

        if (this.$('[data-sweetspot=actions]').children().length === 0) {
            this.addRow();
        }
    },

    /**
     * Generates an object that the
     * {@link View.Layouts.Base.SweetspotConfigLayout config layout} uses to
     * save configurations to the user preferences.
     */
    generateConfig: function() {
        var data = this.collection.toJSON();
        data = this._formatData(data);

        this.context.trigger('sweetspot:receive:configs', data);
    },

    /**
     * Formatter method that sanitizes and prepares the data to be used by
     * {@link View.Layouts.Base.SweetspotConfigLayout#saveConfig}. Also allows
     * for multiple hotkeys to be associated with a single action.
     *
     * @protected
     * @param {Array} data The unsanitized configuration data.
     * @return {Array} The formatted data.
     */
    _formatData: function(data) {
        var result = this._sanitizeConfig(data);
        result = this._joinKeywordConfigs(result);
        result = this._formatForUserPrefs(result);

        return result;
    },

    /**
     * This is a helper function that takes in the sanitized configuration data
     * and analyzes if there are actions being assigned to multiple keywords.
     *
     * If there are actions with more than one keyword, the corresponding
     * keywords are joined together in an array. For example:
     *
     *     [{action: '#Bugs', keyword: 'b1'}, {action: '#Bugs', keyword: 'b2'}]
     *
     * would be transformed to:
     *
     *     [{action: '#Bugs', keyword: ['b1', 'b2']}]
     *
     * By default, this function transforms the keyword attribute to an array.
     * For example:
     *
     *    [{action: '#Bugs', keyword: 'b1'}]
     *
     * would be transformed to:
     *
     *    [{action: '#Bugs', keyword: ['b1']}]
     *
     * @private
     * @param {Array} data The sanitized configuration data.
     * @return {Array} The configuration data, with single/multiple keywords per
     *   action stored in an array.
     */
    _joinKeywordConfigs: function(data) {
        var result = {};

        _.each(data, function(obj) {
            result[obj.action] = result[obj.action] || obj;
            var keyword = _.isArray(obj.keyword) ? obj.keyword : [obj.keyword];
            result[obj.action].keyword = _.union(result[obj.action].keyword, keyword);
        });
        return _.toArray(result);
    },

    /**
     * Sanitizes the configuration data by removing empty/falsy values.
     *
     * @protected
     * @param {Array} data The unsanitized configuration data.
     * @return {Array} The sanitized configuration data.
     */
    _sanitizeConfig: function(data) {
        data = _.reject(data, function(row) {
            return !row.keyword || !row.action;
        });

        return data;
    },

    /**
     * This method prepares the attributes payload for the call to
     * {@link Core.User#updatePreferences}.
     *
     * @protected
     * @param {Array} data The unprepared configuration data.
     * @return {Object} The prepared configuration data.
     */
    _formatForUserPrefs: function(data) {
        return {hotkeys: data};
    },

    /**
     * Compare with the user preferences and return true if the collection
     * contains changes.
     *
     * This method is called by {@link app.plugins.Editable}.
     *
     * @return {boolean} `true` if current collection contains unsaved changes,
     *   `false` otherwise.
     */
    hasUnsavedChanges: function() {
        var prefs = app.user.getPreference('sweetspot');
        var oldConfig = prefs && prefs.hotkeys;
        var newConfig = this.collection.toJSON();
        var isChanged = !_.isEqual(oldConfig, newConfig);

        return isChanged;
    }
}) },
"dashletconfiguration": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletconfigurationLayout
 * @alias SUGAR.App.view.layouts.BaseDashletconfigurationLayout
 * @extends View.Layout
 */
({
	// Dashletconfiguration Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Dashlet:Config:Cancel',
        'Dashlet:Config:Save'
    ],

    initialize: function(options) {
        var meta = app.metadata.getLayout(options.module, options.name),
            main_panel;

        _.each(meta.components, function(component) {
            main_panel = _.find(component.layout.components, function(childComponent) {
                return childComponent.layout && childComponent.layout.name === 'main-pane';
            }, this);
        }, this);
        if(main_panel){
            main_panel.layout.components = _.union(main_panel.layout.components, options.meta.components);
        }
        options.meta = meta;
        this._super('initialize', [options]);
    }
}) },
"stage2-news-preferences-drawer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Stage2NewsPreferencesDrawerLayout
 * @alias SUGAR.App.view.layouts.BaseStage2NewsPreferencesDrawerLayout
 * @extends View.Layout
 */
({
	// Stage2-news-preferences-drawer Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Stage2:News:Preferences:Cancel',
        'Stage2:News:Preferences:Save'
    ]
}) },
"dashlet-main": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletMainLayout
 * @alias SUGAR.App.view.layouts.BaseDashletMainLayout
 * @extends View.Layout
 */
({
	// Dashlet-main Layout (base) 

    tagName: "ul",
    className: "dashlets row-fluid",

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on("change:metadata", this.setMetadata, this);
            this.model.on("change:layout", this.setWidth, this);
            this.model.on("applyDragAndDrop", this.applyDragAndDrop, this);
            this.model.on("setMode", function(mode) {
                this.model._previousMode = this.model.mode;
                this.model.mode = mode;
            }, this);
            this.model.trigger('setMode', this.context.get("create") ? 'edit' : 'view');
        }
        if (this.context) {
            this.context.on('tabbed-dashboard:switch-tab', function(index) {
                this.setMetadata({tabIndex: index});
            }, this);
        }
    },

    /**
     * Remove all components from the dashboard.
     * @private
     */
    _cleanComponents: function() {
        // Clean all components
        _.each(this._components, function(component) {
            component.dispose();
        }, this);
        this._components = [];
        this.$el.children().remove();
    },

    /**
     * Replace all components based on the dashboard metadata value
     * @param {Object} [options] Options.
     * @param {number} [options.tabIndex=0] Index of the currently active tab.
     */
    setMetadata: function(options) {
        if (!this.model.has('metadata')) {
            return;
        }

        this._cleanComponents();

        var omniConfig = this.closestComponent('omnichannel-dashboard-config');
        // if the omnichannel-dashboard-config exists and config-layout is set, use tab 1
        var tabIndex = omniConfig && omniConfig.context.get('config-layout') ? 1 : 0;
        var metadata = app.utils.deepCopy(this.model.get('metadata'));
        if (options && !_.isUndefined(options.tabIndex)) {
            tabIndex = options.tabIndex;
        } else {
            var tabComp = this.layout.getComponent('tabbed-dashboard');
            if (tabComp) {
                tabIndex = tabComp.activeTab;
            }
        }

        var components = metadata.components;
        var grid = [{layout: {name: 'dashboard-grid', css_class: 'grid-stack'}}];

        // if this is a tabbed dashboard, inject the metadata from the currently active tab and mark the active tab
        if (metadata.tabs) {
            components = metadata.tabs[tabIndex].components;
            var tabs = app.utils.deepCopy(metadata.tabs);
            var tabOptions = {activeTab: tabIndex, tabs: tabs};
            if (!_.isUndefined(metadata.buttons)) {
                tabOptions.buttons = app.utils.deepCopy(metadata.buttons);
            }
            this.context.trigger('tabbed-dashboard:update', tabOptions);
        }

        if (_.every(components, function(component) {
            return _.has(component, 'rows');
        })) {
            if (components) {
                this.model.set('metadata', _.extend(metadata, {legacyComponents: components}), {silent: true});
            }
            components = grid;
        }

        _.each(components, function(component, index) {
            if (component.rows) {
                var row = {
                    type: 'dashlet-row',
                    width: component.width,
                    components: component.rows,
                    index: index + '',
                };
                this.initComponents([{
                    layout: row,
                }]);
            } else {
                // if 'rows' not defined, we assume its a non-dashlet component and display it as is
                this.initComponents([component]);
            }
        }, this);

        this.loadData();
        this.render();
    },

    /**
     * Set current main layout's width proportion
     */
    setWidth: function() {
        var metadata = this.model.get("metadata"),
            $el = this.$el.children();

        _.each(metadata.components, function(component, index) {
            $el.get(index).className = $el.get(index).className.replace(/span\d+\s*/, '');
            $($el.get(index)).addClass("span" + component.width);
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Resets the original css classes, and adds the dashboard classes if
     * defined.
     */
    _render: function() {
        this.$el.removeClass();
        this.$el.addClass(this.className);
        this._super('_render');
        if (this.model.has('css_class')) {
            this.$el.addClass(this.model.get('css_class'));
        } else {
            /** For predefined dashlets/dashboard, in case
            storing css class on model is not possible. */
            var metadata = this.model.get('metadata');
            if (metadata && metadata.css_class) {
                this.$el.addClass(metadata.css_class);
            }
        }
    },

    /**
     * Set all appended dashlets drag-and-droppable
     */
    applyDragAndDrop: function() {
        if (this.model.get('drag_and_drop') === false) {
            return;
        }
        var self = this;
        this.$('.dashlet:not(.empty)').draggable({
            revert: 'invalid',
            handle: 'h4',
            scroll: true,
            scrollSensitivity: 100, //pixel
            appendTo: this.$el,
            start: function(event, ui) {
                $(this).css({visibility: 'hidden'});
                self.model.trigger("setMode", "drag");
                self.context.trigger('dashlet:draggable:start');
            },
            stop: function() {
                self.model.trigger("setMode", self.model._previousMode);
                self.$(".dashlet.ui-draggable").attr("style", "");
                self.context.trigger('dashlet:draggable:stop');
            },
            helper: function() {
                var $clone = $(this).clone();
                $clone
                    .addClass('helper')
                    .css({opacity: 0.8})
                    .width($(this).width());
                $clone.find('.btn-toolbar').remove();
                return $clone;
            }
        });

        this.$('.dashlet-container').droppable({
            activeClass: 'ui-droppable-active',
            hoverClass: 'active',
            tolerance: 'pointer',
            accept: function($el) {
                return $el.data('type') === 'dashlet' && self.$(this).find('[data-action=droppable]').length === 1;
            },
            drop: function(event, ui) {
                var sourceIndex = ui.draggable.parents(".dashlet-container:first").data('index')(),
                    targetIndex = self.$(this).data('index')();
                self.switchComponent(targetIndex, sourceIndex);
            }
        });
    },

    /**
     * Gets component from metadata.
     *
     * @param {Object} metadata for all dashboard components
     * @return {Object} dashboard component
     */
    getComponentsFromMetadata: function(metadata) {
        var component;
        // this is a tabbed dashboard
        if (metadata.tabs) {
            var tabIndex = this.context.get('activeTab') || 0;
            component = metadata.tabs[tabIndex].components;
        } else {
            component = metadata.components;
        }
        return component;
    },

    /**
     * Retrives the seperate component metadata from the whole dashboard components
     *
     * @param {Object} metadata for all dashboard componenets
     * @param {String} tree based trace key (each digit represents the index number of the each level)
     * @return {Object} component metadata and its dashlet frame layout
     */
    getCurrentComponent: function(metadata, tracekey) {
        var position = tracekey.split('');
        var component = this.getComponentsFromMetadata(metadata);

        _.each(position, function(index) {
            component = component.rows ? component.rows[index] : component[index];
        }, this);

        var layout = this;
        _.each(position, function(index) {
            layout = layout._components[index];
        }, this);
        return {
            metadata: component,
            layout: layout
        };
    },

    /**
     * Switch the places of two components
     *
     * @param {String} target key
     * @param {String} source key
     */
    switchComponent: function(target, source) {
        if (target === source) {
            return;
        }
        var metadata = this.model.get('metadata'),
            targetComponent = this.getCurrentComponent(metadata, target),
            sourceComponent = this.getCurrentComponent(metadata, source);

        //Swap the metadata except 'width' property since it's previous size
        var cloneMeta = app.utils.deepCopy(targetComponent.metadata);
        _.each(targetComponent.metadata, function(value, key) {
            if (key !== 'width') {
                delete targetComponent.metadata[key];
            }
        }, this);
        _.each(sourceComponent.metadata, function(value, key) {
            if (key !== 'width') {
                targetComponent.metadata[key] = value;
                delete sourceComponent.metadata[key];
            }
        }, this);
        _.each(cloneMeta, function(value, key) {
            if (key !== 'width') {
                sourceComponent.metadata[key] = value;
            }
        }, this);

        this.model.set('metadata', app.utils.deepCopy(metadata), {silent: true});
        this.model.trigger('change:layout');
        if (this.model._previousMode === 'view') {
            //Autosave for view mode
            this.model.save(null, {
                //Show alerts for this request
                showAlerts: true
            });
        }
        //Swap the view components
        var targetDashlet = targetComponent.layout._components.splice(0);
        var sourceDashlet = sourceComponent.layout._components.splice(0);

        //switch the metadata
        var targetMeta = app.utils.deepCopy(targetComponent.layout.meta);
        var sourceMeta = app.utils.deepCopy(sourceComponent.layout.meta);
        targetComponent.layout.meta = sourceMeta;
        sourceComponent.layout.meta = targetMeta;

        _.each(targetDashlet, function(comp) {
            sourceComponent.layout._components.push(comp);
            comp.layout = sourceComponent.layout;
        }, this);
        _.each(sourceDashlet, function(comp) {
            targetComponent.layout._components.push(comp);
            comp.layout = targetComponent.layout;
        }, this);
        //switch invisibility
        var targetInvisible = targetComponent.layout._invisible;
        var sourceInvisible = sourceComponent.layout._invisible;
        if (targetInvisible) {
            sourceComponent.layout.setInvisible();
        } else {
            sourceComponent.layout.unsetInvisible();
        }
        if (sourceInvisible) {
            targetComponent.layout.setInvisible();
        } else {
            targetComponent.layout.unsetInvisible();
        }

        //Swap the DOM
        var cloneEl = targetComponent.layout.$el.children(':first').get(0);
        targetComponent.layout.$el.append(sourceComponent.layout.$el.children(':not(.helper)').get(0));
        sourceComponent.layout.$el.append(cloneEl);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        var $dashlets = this.$('.dashlet');
        var $dashletContainers = this.$('.dashlet-container');

        // Make sure the element is initialized to be draggable before destroying.
        _.each($dashlets, function(dashlet) {
            var $dashlet = $(dashlet);
            if (!_.isUndefined($dashlet.draggable('instance'))) {
                $dashlet.draggable('destroy');
            }
        });

        // Make sure the element is initialized to be droppable before destroying.
        _.each($dashletContainers, function(dashletContainer) {
            var $dashletContainer = $(dashletContainer);
            if (!_.isUndefined($dashletContainer.droppable('instance'))) {
                $dashletContainer.droppable('destroy');
            }
        });

        this._super('_dispose');
    }
}) },
"activity-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ActivityFilterlLayout
 * @alias SUGAR.App.view.layouts.BaseActivityFilterLayout
 * @extends View.Layouts.Base.FilterLayout
 */
({
	// Activity-filter Layout (base) 

    extendsFrom: 'FilterLayout',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.context.set('filterList', this.getFilterList());

        this.on('filter:change:module', function(moduleName, linkName, silent) {
            this.context.trigger('filter:change:module', linkName, silent);
        }, this);
    },

    /**
     * Get list of filter menu points
     *
     * @return {Array}
     */
    getFilterList: function() {
        var modulesMeta = app.metadata.getView(this.module, 'activity-timeline');
        var activityModules = (modulesMeta && modulesMeta.activity_modules) ? modulesMeta.activity_modules : [];
        var moduleSingular = app.lang.get('LBL_MODULE_NAME_SINGULAR', this.module) || this.module;
        var filters = [
            {id: 'all_modules', text: app.lang.get('LBL_LINK_ALL')},
            {id: 'audit', text: moduleSingular + ' ' + app.lang.get('LBL_UPDATES')},
        ];

        _.each(activityModules, function(item) {
            var name = item.module;
            if (name === 'Audit' || !app.metadata.getModule(name)) {
                return;
            }
            filters.push({
                id: name.toLowerCase(),
                text: app.lang.get('LBL_' + name.toUpperCase()),
            });
        }, this);

        return filters;
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        this._super('_render');

        var filterId = this.getLastFilter(this.module, this.layoutType);
        var linkName = app.user.lastState.get(app.user.lastState.key(this.name, this)) || 'all_modules';

        this.initializeFilterState(this.name, linkName, filterId);
    },
}) },
"pipeline-records": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Layouts.Base.PipelineRecordsLayout
 * @alias SUGAR.App.view.layouts.BasePipelineRecordsLayout
 */
({
	// Pipeline-records Layout (base) 

    className: 'pipeline-records',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.pipelineModules = app.metadata.getModule('VisualPipeline', 'config').enabled_modules || [];
    },

    /**
     * Loads data for a particular user and renders the pipelineType on callback success
     * @param options
     */
    loadData: function(options) {
        var filter = {
            '$or': [
                {'assigned_user_id': {'$equals': app.user.get('id')}}
            ]
        };

        this.collection.setOption('filter', filter);
        this.collection.setOption('params', {order_by: 'date_modified:DESC'});
        this.collection.setOption('limit', 2); // At most 2 rows - default config and user config (if any).
        this.collection.fetch();
    },

    /**
     * @inheritdoc
     */
    render: function() {
        this._super('render');

        if (this.$('.btn-group.pipeline-refresh-btn')[0] &&
            this.$('.btn-group.pipeline-refresh-btn')[0].firstElementChild) {
            // Change the label of refresh button to say 'Refresh Tiles' instead on 'Refresh list'
            this.$('.btn-group.pipeline-refresh-btn')[0].firstElementChild.title = app.lang.get('LBL_TILE_REFRESH');
        }
    }
}) },
"subpanels-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SubpanelsCreateLayout
 * @alias SUGAR.App.view.layouts.BaseSubpanelsCreateLayout
 * @extends View.Layouts.Base.SubpanelsLayout
 */
({
	// Subpanels-create Layout (base) 

    extendsFrom: 'SubpanelsLayout',

    initialize: function(options) {
        app.logger.warn('`BaseSubpanelsCreateLayout` controller ' +
            'has been deprecated since 7.8.0 and will be removed in 7.9.0. To use `BaseSubpanelsLayout` controller, ' +
            'specify the `type` property in your `subpanels-create` metadata file instead.');

        this._super('initialize', [options]);
    }
}) },
"omnichannel-console": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The layout for the Omnichannel console.
 *
 * @class View.Layouts.Base.OmnichannelConsoleLayout
 * @alias SUGAR.App.view.layouts.BaseOmnichannelConsoleLayout
 * @extends View.Layout
 */
({
	// Omnichannel-console Layout (base) 

    /**
     * Css class for this component.
     * @property {string}
     */
    className: 'omni-console',

    /**
     * The current state of the console: 'opening', 'idle', 'closing', ''.
     * @property {string}
     */
    currentState: '',

    /**
     * Control omnichannel-console state when drawer closes.
     */
    isMinimized: null,

    /**
     * Stores settings for the omnichannel-console
     */
    settings: {
        inbound: {
            modeCacheKey: 'inbound-mode',
            defaultMode: 'full'
        },
        outbound: {
            modeCacheKey: 'outbound-mode',
            defaultMode: 'compact'
        }
    },

    /**
     * Stores the available modes that the console can be in
     */
    modes: {
        FULL: 'full',
        COMPACT: 'compact'
    },

    /**
     * The current mode of the console
     * @property {string}
     */
    currentMode: 'compact',

    /**
     * Size of console with ccp only.
     * The ccp itself can be 200px to a maximum of 320px wide and 400px to 465px tall according to:
     * https://github.com/amazon-connect/amazon-connect-streams
     *
     * @property {Object}
     */
    ccpSize: {
        width: 320,
        height: 540
    },

    /**
     * Height of the console header.
     * @property {number}
     */
    headerHeight: 28,

    /**
     * Event handlers.
     * @property {Object}
     */
    events: {
        // Closing the Omnichannel console
        'click [data-action=omnichannelClose]': 'closeClicked',
        // Toggling between compact and full modes
        'click [data-action=toggleMode]': '_toggleModeClicked',
        // Editing dashlet
        'click [data-dashletaction="editClicked"]': '_handleDashletToolbarActions',
        // Adding Interactions
        'click [data-dashletaction="composeEmail"], [data-dashletaction="createRecord"]': '_handleDashletToolbarActions'
    },

    /**
     * The omnichannel-dashboard-switch component
     */
    omniDashboardSwitch: null,

    /**
     * The omnichannel-ccp component
     */
    ccpComponent: null,

    /**
     * Fields from the AWS contact info to NOT pre-fill in when pre-populating models
     */
    prepopulateAwsContactDenyList: [
        'last_name',
        'name'
    ],

    /**
     * Attributes that should always be set in a model that is pre-filled from
     * the Omnichannel console
     */
    prepopulateAttributes: {
        no_success_label_link: true
    },

    /**
     * Length of drawer open/close animation
     */
    animationLength: 300,

    /**
     * Is there currently a Call or Message active?
     */
    isCallActive: false,

    /**
     * Is this the config mode or not
     */
    isConfig: false,

    /**
     * Did the user manually click the Close button to hide the console?
     * Or if false, Live was closed by some other means (drawer opened, etc.)
     */
    userManuallyClosedConsole: false,

    /**
     * Flag to store if the console is closed as the result of the user changing views.
     *
     * @property {boolean}
     */
    closedAfterRouteChange: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        $(window).on('resize.omniConsole', _.bind(this._resize, this));
        this.boundOpen = _.bind(this.open, this);
        this.boundCloseImmediately = _.bind(this.closeImmediately, this);

        // Re-initialize the console's mode when AWS contacts change
        this.on('contact:view', this._initMode, this);
        this.on('contact:destroyed', this._initMode, this);
        app.events.once('app:login', this.closeOnLoginRedirect, this);

        this.bindRouterEvents();
    },

    /**
     * Bind specific router events for this layout
     */
    bindRouterEvents: function() {
        app.router.on('route', this.closeOnRouteChange, this);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        // Handle when the quickcreate drawer is closed
        this._getTopLevelContext().on('quickcreate-drawer:closed', this._handleClosedQuickcreateDrawer, this);
    },

    /**
     * Handler for dashlet toolbar action like edit or create record.
     * This listens for drawer:remove event to reopen the omniconsole
     *
     * @private
     */
    _handleDashletToolbarActions: function() {
        var drawers = app.drawer._getDrawers(true);
        // if a new drawer is about to open
        if (!_.isUndefined(drawers) && drawers.$next.length > 0) {
            var $main = app.$contentEl.children().first();
            // open console once the toolbar action drawer is closed
            $main.on('drawer:remove.omniConsole', this.boundOpen);
        }
    },

    /**
     * Gets the data to pre-populate a model with from the active dashboard
     *
     * @param {string} targetModule the module to get prepopulate data for
     * @return {Object} The attributes to pre-populate a model with
     */
    getModelPrepopulateData: function(targetModule) {
        var data = {};
        var ccp = this._getCCPComponent();
        var dashboardSwitch = this._getOmnichannelDashboardSwitch();
        if (ccp.activeContact && dashboardSwitch) {
            var activeContactInfo = ccp.getContactInfo(ccp.activeContact);
            data = _.extendOwn(
                data,
                _.omit(activeContactInfo, this.prepopulateAwsContactDenyList),
                dashboardSwitch.getModelPrepopulateData(ccp.getActiveContactId(), targetModule),
                this.prepopulateAttributes
            );
        }

        return data;
    },

    /**
     * Handles when the quick create drawer is closed, regardless of whether or
     * not a new record was created
     *
     * @param {Bean|undefined} createdModel the model created in the quick
     *                      create drawer if it was saved; undefined if the
     *                      quick create drawer was canceled
     * @private
     */
    _handleClosedQuickcreateDrawer: function(createdModel) {
        // Pass the created model to the omnichannel-dashboard-switch layout
        if (!_.isEmpty(createdModel)) {
            var ccp = this._getCCPComponent();
            var activeContactId = ccp.getActiveContactId();
            var dashboardSwitch = this._getOmnichannelDashboardSwitch();
            dashboardSwitch.setModel(activeContactId, createdModel, false);
            dashboardSwitch.postQuickCreate(activeContactId, createdModel);
        }

        // Re-open the Omnichannel console
        this.open();
    },

    /**
     * Get and return the omnichannel dashboard switch component
     *
     * @return {View.Layout}
     * @private
     */
    _getOmnichannelDashboardSwitch: function() {
        if (!this.omniDashboardSwitch) {
            this.omniDashboardSwitch = this.getComponent('omnichannel-dashboard-switch');
        }

        return this.omniDashboardSwitch;
    },

    /**
     * Get and return the omnichannel dashboard for the active contact
     *
     * @return {View.Layout}
     * @private
     */
    _getOmnichannelDashboard: function() {
        var ccp = this._getCCPComponent();
        var contactId = ccp.getActiveContactId();

        return this._getOmnichannelDashboardSwitch().getDashboard(contactId);
    },

    /**
     * Get and return the CCP component
     *
     * @return {View.View}
     * @private
     */
    _getCCPComponent: function() {
        if (!this.ccpComponent) {
            this.ccpComponent = this.getComponent('omnichannel-ccp');
        }

        return this.ccpComponent;
    },

    /**
     * Get relevant model data from the selected Contact, if there is one selected
     *
     * @return {Object}
     * @deprecated Since 11.1, the omnichannel-dashboard layout will handle
     *              gathering prepopulate data from the active dashboard
     */
    getContactModelDataForQuickcreate: function() {
        var dashboard = this._getOmnichannelDashboard();
        var tabModels = dashboard.tabModels;

        var data = {};

        // if there is no selected Contact, return empty
        if (!tabModels[dashboard.moduleTabIndex.Contacts]) {
            return data;
        }

        // these attributes will be deleted from data after retrieving them as the
        // model requires a different attribute name
        var modelAttributes = [
            'id',
            'name',
        ];

        var attributes = modelAttributes.concat([
            'account_id',
            'account_name',
        ]);

        var model = tabModels[dashboard.moduleTabIndex.Contacts];

        _.each(attributes, function(attr) {
            data[attr] = model.get(attr);
        });

        // update the attribute names so they're friendly for the new model
        data.primary_contact_id = data.id;
        data.primary_contact_name = data.name;

        // remove the attributes that were updated
        _.each(modelAttributes, function(attr) {
            delete data[attr];
        });

        return data;
    },

    /**
     * Open the console.
     */
    open: function() {
        // open the console if not yet
        if (!this.isOpen()) {
            app.events.on('app:view:change', this._setSize, this);
            app.events.on('sidebar:state:changed', this._setSize, this);

            $('#content').addClass('omniconsole-visible');
            this.userManuallyClosedConsole = false;
            this.closedAfterRouteChange = false;
            this.currentState = 'opening';
            this._initMode();
            this.$el.css({
                left: 0,
                display: ''
            });
            this.currentState = 'idle';
            this.isMinimized = false;
            var $main = app.$contentEl.children().first();
            $main.on('drawer:add.omniConsole', this.boundCloseImmediately);
            this.trigger('omniconsole:open');
            this.removeToolbarActionListener();
        }
    },

    /**
     * Unsubscribe to dashlet toolbar events that open a new drawer.
     */
    removeToolbarActionListener: function() {
        var $main = app.$contentEl.children().first();
        $main.off('drawer:remove.omniConsole', this.boundOpen);
    },

    /**
     * Tell if the console is opened.
     * @return {boolean} True if open, false if not.
     */
    isOpen: function() {
        return this.currentState !== '';
    },

    /**
     * Checks if the console can be automatically reopened - used by the top drawer to check if it's correct
     * to reopen the console after the top drawer closes
     * @return {boolean}
     */
    canBeAutomaticallyReopened: function() {
        return !this.isOpen() && this.isMinimized && !this.userManuallyClosedConsole && !this.closedAfterRouteChange;
    },

    /**
     * Tell if console is expanded with dashboard and/or detail panel.
     *
     * @return {boolean} True if it's expanded, false otherwise
     * @deprecated Since 11.1, use getMode instead
     */
    isExpanded: function() {
        return this.getMode() !== this.modes.COMPACT;
    },

    /**
     * Close the console immediately.
     */
    closeImmediately: function() {
        // don't close in compact mode
        if (!this.$el || this.getMode() === 'compact') {
            return;
        }
        this.handleResetOnClose();
    },

    /**
     * Utility function to perform required clean up after the console is closed
     */
    handleResetOnClose: function() {
        this._resetPageElementsCssOnClose();
        this._offEvents();
    },

    /**
     * Handles closing the console when redirected to the login page
     */
    closeOnLoginRedirect: function() {
        this.closedAfterRouteChange = true;
        this.handleResetOnClose();
    },

    /**
     * On route change, close the console only if we're in full mode
     */
    closeOnRouteChange: function() {
        if (this.getMode() === this.modes.FULL) {
            // Opening and closing the top drawer changes the route, but we handle that separately
            if (!app.drawer.isOpening() && !app.drawer.isClosing()) {
                this.closedAfterRouteChange = true;
            }
            this.closeImmediately();
        }
    },

    /**
     * Expand/shrink console.
     *
     * @deprecated Since 11.1, use _initMode or setMode instead
     */
    toggle: function() {
        this._initMode();
    },

    /**
     * Handles the event of clicking either the minimize button or close button associated with omnichannel
     * Having this function allows the close() function to accept a callback
     */
    closeClicked: function() {
        this.isMinimized = true;
        this.userManuallyClosedConsole = true;
        this.closedAfterRouteChange = false;
        this.close();
    },

    /**
     * Resets page elements that console has touched while open
     * @private
     */
    _resetPageElementsCssOnClose: function() {
        var leftOffset = this.currentMode === this.modes.COMPACT ?
            `-${this.ccpSize.width}px` : `-${$(window).width()}px`;
        $('#content')
            .removeClass('omniconsole-visible')
            .css({
                marginLeft: '',
                width: ''
            });
        $('.main-pane').css({
            marginLeft: '',
            width: ''
        });
        $('.main-pane .headerpane').css({
            marginLeft: '',
            width: ''
        });
        this.$el.css('left', leftOffset);

        this.currentState = '';
        this.isMinimized = true;
    },

    /**
     * Close the console.
     * @param onClose callback function to be executed after animation completes
     */
    close: function(onClose) {
        if (!_.isFunction(onClose)) {
            onClose = null;
        }

        if (this.isOpen()) {
            this.currentState = 'closing';

            app.events.off('app:view:change', null, this);
            app.events.off('sidebar:state:changed', null, this);

            this.handleResetOnClose();
        }
    },

    /**
     * Unsubscribe to events.
     * @private
     */
    _offEvents: function() {
        var $main = app.$contentEl.children().first();
        $main.off('drawer:add.omniConsole', this.boundCloseImmediately);
    },

    /**
     * Initializes the mode of the console based on its current state
     *
     * @private
     */
    _initMode: function() {
        // If there is an active contact, get the correct mode for the direction
        // of the contact. Otherwise, default to 'compact'
        var activeContactDirection = this._getActiveContactDirection();
        var mode = activeContactDirection ? this._getModeForDirection(activeContactDirection) : this.modes.COMPACT;

        this.isCallActive = !!this.getActiveContact();

        // let omnichannel-header know to toggle Compact/Full mode button on/off
        this.trigger('omniconsole:activeCall', this.isCallActive);
        // Apply the mode to the console
        this.setMode(mode);
    },

    /**
     * Returns the direction of the current/active contact session if there is
     * one
     *
     * @return {string|null} 'inbound' if the active contact session is an inbound call or a chat;
     *                       'outbound' if the active contact session is an outbound call;
     *                       null if there is no active contact session
     * @private
     */
    _getActiveContactDirection: function() {
        // Default direction is null
        var direction = null;

        // If we have an active contact session, update direction to reflect it
        var activeContact = this.getActiveContact();

        if (activeContact) {
            direction = activeContact.isInbound() ? 'inbound' : 'outbound';
        }

        return direction;
    },

    /**
     * Returns the Active Contact from the CCP Component
     *
     * @return {*} False or the active Contact
     */
    getActiveContact: function() {
        var ccp = this._getCCPComponent();
        return ccp && ccp.getActiveContact();
    },

    /**
     * Given a direction of a conversation, returns the correct mode for the
     * console based on the cached or default mode for that direction
     *
     * @param {string} direction, either 'inbound' or 'outbound'
     * @return {string|null} The correct mode of the console for the direction
     *                       or null if no mode exists for the directiom
     * @private
     */
    _getModeForDirection: function(direction) {
        var mode = null;

        // Get the settings for the given direction
        var directionSettings = this.settings && this.settings[direction];

        // Try to load the cached mode first
        if (directionSettings && directionSettings.modeCacheKey) {
            var modeCacheKey = app.user.lastState.key(directionSettings.modeCacheKey, this);
            mode = app.user.lastState.get(modeCacheKey);
        }

        // If no mode was cached, use the default mode
        if (_.isEmpty(mode) && (directionSettings && directionSettings.defaultMode)) {
            mode = directionSettings.defaultMode;
        }

        return mode;
    },

    /**
     * Handles when the toggleMode button is clicked to update the mode of the
     * console
     */
    _toggleModeClicked: function() {
        // Calculate what the new mode should be
        var newMode = this.getMode() === this.modes.FULL ? this.modes.COMPACT : this.modes.FULL;

        // Set the new mode of the console
        this.setMode(newMode);
    },

    /**
     * Set the current mode of the console
     *
     * @param {string} mode the mode of the console to set
     */
    setMode: function(mode) {
        // Set the new mode
        this.currentMode = mode;

        // Update the size of the console
        this._setSize(this.isOpen());

        // Update the cached mode value
        this._updateModeCache();

        // Notify the layout so other components can register the change
        this.trigger('omniconsole:mode:set', mode);
    },

    /**
     * Returns the current mode of the console
     *
     * @return {string} the current mode of the console
     */
    getMode: function() {
        return this.currentMode;
    },

    /**
     * Caches the current mode of the console for the direction of the active
     * contact session (inbound or outbound) if one exists
     *
     * @private
     */
    _updateModeCache: function() {
        var direction = this._getActiveContactDirection();
        if (direction) {
            var cacheKey = this.settings && this.settings[direction] && this.settings[direction].modeCacheKey;
            if (cacheKey) {
                app.user.lastState.set(app.user.lastState.key(cacheKey, this), this.currentMode);
            }
        }
    },

    /**
     * Set the size of the console.
     *
     * @param {boolean} animate if true, will animate the size change
     * @private
     */
    _setSize: function(animate) {
        if (_.isObject(animate) && animate.name === 'bwc') {
            return;
        }

        if (this.closedAfterRouteChange) {
            return;
        }

        var leftContentOffset = this.ccpSize.width;
        var $sidebar = $('.side.sidebar-content');
        var hasSidebar = !!$sidebar.length;
        var isSidebarCollapsed = $sidebar.hasClass('side-collapsed');
        var noSidebarOrSidebarIsCollapsed = !hasSidebar || (hasSidebar && isSidebarCollapsed);
        var areDrawersActive = !!app.drawer.count();
        var contentProps;
        var mainPaneProps;
        var headerpaneProps;
        var drawerMainPaneProps;
        var drawerHeaderpaneProps;
        var inactiveDrawerHeaderpaneProps;
        var mainPaneWidth;
        var $drawerSidebar;
        var hasDrawerSidebar;
        var $mainPane;
        var $activeDrawerMainPane;
        var $activeDrawerHeaderpane;
        var cssCalc100MinusLeftOffset = `calc(100% - ${leftContentOffset}px)`;
        var cssCalc100MinusLeftOffsetMinus34vw = `calc(100% - ${leftContentOffset}px - 34vw)`;

        contentProps = {
            marginLeft: leftContentOffset,
            width: isSidebarCollapsed ? '100%' : cssCalc100MinusLeftOffset
        };
        $('#content').css(contentProps);

        if (hasSidebar && isSidebarCollapsed) {
            mainPaneWidth = cssCalc100MinusLeftOffset;
        } else if (noSidebarOrSidebarIsCollapsed) {
            mainPaneWidth = '100%';
        } else {
            mainPaneWidth = `calc(100% - 34vw)`;
        }
        mainPaneProps = {
            marginLeft: '',
            width: mainPaneWidth
        };
        $mainPane = $('#content .main-pane');
        $mainPane.css(mainPaneProps);

        headerpaneProps = {
            marginLeft: noSidebarOrSidebarIsCollapsed || areDrawersActive ? 0 : leftContentOffset,
            width: noSidebarOrSidebarIsCollapsed ? cssCalc100MinusLeftOffset : cssCalc100MinusLeftOffsetMinus34vw
        };
        if (areDrawersActive) {
            headerpaneProps.width = '100%';
        }
        $mainPane.find('.headerpane').css(headerpaneProps);

        // Set props for drawer elements if active
        if (areDrawersActive) {
            $drawerSidebar = $('.drawer.active .side.sidebar-content');
            hasDrawerSidebar = $drawerSidebar.length && !$drawerSidebar.hasClass('side-collapsed');

            drawerMainPaneProps = {
                marginLeft: leftContentOffset,
                width: hasDrawerSidebar ? cssCalc100MinusLeftOffsetMinus34vw : cssCalc100MinusLeftOffset
            };

            drawerHeaderpaneProps = {
                marginLeft: hasDrawerSidebar ? leftContentOffset : 0,
                width: hasDrawerSidebar ? cssCalc100MinusLeftOffsetMinus34vw : cssCalc100MinusLeftOffset
            };

            $activeDrawerMainPane = $('#drawers .drawer.active .main-pane');
            $activeDrawerMainPane.css(drawerMainPaneProps);

            $activeDrawerHeaderpane = $activeDrawerMainPane.find('.headerpane');
            $activeDrawerHeaderpane.css(drawerHeaderpaneProps);

            // reset the inactive drawer headerpane
            inactiveDrawerHeaderpaneProps = {
                marginLeft: this.currentState === 'opening' ? '320px' : '',
                width: this.currentState === 'opening' ? cssCalc100MinusLeftOffset : ''
            };
            $('#drawers .drawer.inactive .main-pane .headerpane').css(inactiveDrawerHeaderpaneProps);
        }

        if (animate || this.isConfig) {
            this.$el.css({
                left: 0,
                width: this.currentMode === this.modes.COMPACT ? `${this.ccpSize.width}px` : '100%'
            });
        } else {
            this.$el.css('left', '0px');
        }
    },

    /**
     * Resize the console.
     * @private
     */
    _resize: _.throttle(function() {
        if (this.disposed) {
            return;
        }
        // resize the console if it is opened
        if (this.currentState === 'idle') {
            this._setSize(false);
        }
    }, 30),

    /**
     * Get top-level context for setting Quick Create models
     *
     * @return {Object} context
     * @private
     */
    _getTopLevelContext: function() {
        var context = this.context;
        while (context.parent) {
            context = context.parent;
        }
        return context;
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        $(window).off('resize.omniConsole');
        app.events.off('app:login', this.closeOnLoginRedirect, this);
        app.router.off('route', null, this);
        this._getTopLevelContext().off('quickcreate-drawer:closed', this._handleClosedQuickcreateDrawer, this);
        this._super('_dispose');
    },
}) },
"pii": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.PiiLayout
 * @alias SUGAR.App.view.layouts.BasePiiLayout
 * @extends View.Layouts.Base.DefaultLayout
 */
({
	// Pii Layout (base) 

    extendsFrom: 'DefaultLayout',

    plugins: ['ShortcutSession'],

    shortcuts: ['PiiHeaderPanel:Close']
}) },
"activities": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ActivitiesLayout
 * @alias SUGAR.App.view.layouts.BaseActivitiesLayout
 * @extends View.Layout
 */
({
	// Activities Layout (base) 

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        if (!app.config.activityStreamsEnabled) {
            this.$('.search-filter').addClass('hide');
        }

        return this;
    }
}) },
"list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout that places components using bootstrap fluid layout divs.
 *
 * @class View.Layouts.Base.ListLayout
 * @alias SUGAR.App.view.layouts.BaseListLayout
 * @extends View.Layout
 */
({
	// List Layout (base) 

    /**
     * Places a view's element on the page. This shoudl be overriden by any custom layout types.
     * @param {View.View} comp
     * @protected
     * @method
     */
    _placeComponent: function(comp, def) {
        // Helper to create boiler plate layout containers
        function createLayoutContainers(self) {
            // Only creates the containers once
            if (!self.$el.children()[0]) {
                comp.$el.addClass('list');
            }
        }

        createLayoutContainers(this);

        // All components of this layout will be placed within the
        // innermost container div.
        this.$el.append(comp.el);
    }

}) },
"fluid": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout that places components using bootstrap fluid layout divs.
 *
 * @class View.Layouts.Base.FluidLayout
 * @alias SUGAR.App.view.layouts.BaseFluidLayout
 * @extends View.Layout
 */
({
	// Fluid Layout (base) 

    /**
     * Places a view's element on the page. This should be overriden by any custom layout types.
     * In layout defs, the child component should have a `span` definition corresponding to the bootstrap scaffold.
     * @param {View.View} comp
     * @protected
     */
    _placeComponent: function(comp, def) {
        var compdef = def.layout || def.view,
            size = compdef.span || 4;

        if (!this.$el.children()[0]) {
            this.$el.addClass("container-fluid").append('<div class="row-fluid"></div>');
        }

        //Create a new td and add the layout to it
        $().add("<div></div>").addClass("span" + size).append(comp.el).appendTo(this.$el.find("div.row-fluid")[0]);
    }
}) },
"config-drawer-content": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ConfigDrawerContentLayout
 * @alias SUGAR.App.view.layouts.BaseConfigDrawerContentLayout
 * @extends View.Layout
 *
 * Triggered Events:
 *  config:howtoData:change - When a different accordion panel is clicked, a howtoData:change event will be triggered
 *      with the current how-to data for View.Views.Base.ConfigHowToView to listen for and update
 */
({
	// Config-drawer-content Layout (base) 

    events: {
        'click .accordion-toggle': 'onAccordionToggleClicked'
    },

    /**
     * The HTML ID of the Accordion divs
     */
    collapseDivId: 'config-accordion',

    /**
     * The currently-selected config panel
     */
    selectedPanel: undefined,

    /**
     * The current HowTo data Object
     */
    currentHowToData: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.currentHowToData = {};
        this._initHowTo();
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var $toggles;

        this._super('_render');

        //This is because backbone injects a wrapper element.
        this.$el.addClass(`accordion ${this.module}-config`);
        this.$el.attr('id', this.collapseDivId);
        $toggles = this.$('.accordion-toggle');
        // ignore the first accordion toggle
        $toggles.splice(0, 1);
        $toggles.addClass('collapsed');

        //apply the accordion to this layout
        this.$('.collapse').collapse({
            toggle: false,
            parent: '#' + this.collapseDivId
        });

        // select the first panel in metadata
        this.selectPanel(_.first(this.meta.components).view);
    },

    /**
     * Used to select a specific panel by name
     * Correct names can be found in the specific view's hbs
     * Specifically found in the id attribute of '.accordion-heading a'
     *
     * @param {String} panelName The ID name of the panel to select
     */
    selectPanel: function(panelName) {
        this.selectedPanel = panelName;
        this.$('#' + panelName + 'Collapse').collapse('show');
    },

    /**
     * Event handler for 'click .accordion-toggle' event
     *
     * @param {jQuery.Event|undefined} evt
     */
    onAccordionToggleClicked: function(evt) {
        var panelName = (evt) ? $(evt.currentTarget).data('help-id') : this.selectedPanel;
        var oldPanel;
        var newPanel;
        var currentEventViewColumns;
        var tmpIndex;

        if (evt && panelName === this.selectedPanel) {
            // dont allow closing the same tab
            return false;
        }

        this._switchHowToData(panelName);

        this.context.trigger('config:howtoData:change', this.currentHowToData);

        if (this.selectedPanel) {
            oldPanel = _.find(this._components, function(component) {
                return component.name === this.selectedPanel;
            }, this);

            if (oldPanel) {
                oldPanel.$('.accordion-toggle').addClass('collapsed');
                oldPanel.trigger('config:panel:hide');
            }
        }

        this.selectedPanel = panelName;

        newPanel = _.find(this._components, function(component) {
            return component.name === panelName;
        }, this);

        // This makes sure that the panel fields are correctly updated when not saved
        _.each(newPanel.panelFields, function(panelField) {
            panelField.currentState = 'unchecked';
        }, this);

        // Get current columns visible on the config accordion
        currentEventViewColumns = newPanel.model.get(newPanel.eventViewName);

        // For each visible column mark the corresponding panel field as checked
        _.each(currentEventViewColumns, function(headerField) {
            tmpIndex = _.findIndex(newPanel.panelFields, function(field) {
                return field.name === headerField.name;
            }, this);
            if (tmpIndex >= 0) {
                newPanel.panelFields[tmpIndex].currentState = 'checked';

                _.each(newPanel.panelFields[tmpIndex].relatedFields, function(relField) {
                    var tmpRelIndex = _.findIndex(newPanel.panelFields, function(field) {
                        return field.name === relField;
                    });

                    // Make sure that the related fields, if unchecked, are filled
                    if (tmpRelIndex >= 0 && (_.isUndefined(newPanel.panelFields[tmpRelIndex].currentState) ||
                        newPanel.panelFields[tmpRelIndex].currentState === 'unchecked')) {
                        newPanel.panelFields[tmpRelIndex].currentState = 'filled';
                    }
                }, this);
            }
        }, this);

        newPanel.trigger('config:panel:show');
    },

    /**
     * Function for child modules to initialize their own HowTo data
     *
     * @private
     */
    _initHowTo: function() {
    },

    /**
     * Handles switching the HowTo text and info by a specific accordion view being toggled
     *
     * @param {string} helpId The panel component name
     * @private
     */
    _switchHowToData: function(helpId) {
    },

    /**
     * Allows child config views with specific needs to be able to 'manually' update the HowTo text
     *
     * @param title
     * @param text
     */
    changeHowToData: function(title, text) {
        this.currentHowToData.title = title;
        this.currentHowToData.text = text;
        this.context.trigger('config:howtoData:change', this.currentHowToData);
    }
}) },
"dashlet-grid-wrapper": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletGridWrapperLayout
 * @alias SUGAR.App.view.layouts.BaseDashletGridWrapperLayout
 * @extends View.Layout
 */
({
	// Dashlet-grid-wrapper Layout (base) 

    extendsFrom: 'DashletLayout',

    /**
     * Remove the current attached dashlet component
     */
    removeDashlet: function() {
        this.layout.removeDashlet(this);
    },

    /**
     * @override
     *
     * The dashboard-grid component maintains dashlet state to track the
     * position/size of its children, so dashlets no longer need to find their
     * metadata within the dashboard component list.
     *
     * @param {Object} meta
     * @return {Object} unmodified metadata
     */
    setDashletMetadata: function(meta) {
        return meta;
    },

    /**
     * @override
     *
     * If we get here by updating an existing dashlet, we need to update the
     * metadata on the layout. Then we unset model.updated to avoid unsaved
     * changes warnings from updating metadata.
     *
     * @param {Object} dashletDef
     */
    addDashlet: function(dashletDef) {
        if (this._components.length > 0) {
            // save the change
            this.layout.editDashlet(this, dashletDef);
        }
        this._super('addDashlet', [dashletDef]);
        this.model.unset('updated');
    },
}) },
"selection-list-module-switch": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SelectionListModuleSwitchLayout
 * @alias SUGAR.App.view.layouts.BaseSelectionListModuleSwitchLayout
 * @extends View.Layouts.Base.SelectionListLayout
 */
({
	// Selection-list-module-switch Layout (base) 

    extendsFrom: 'SelectionListLayout',

    /**
     * Build the module list for the dropdown from filterList attribute that is set
     * on the context.
     * @inheritdoc
     * @param {Object} options
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this._filterList = this.context.get('filterList');
        this.context.set('filterList', this._buildModuleSwitchList(this._filterList));

        this.context.on('selection-list:reload', this.reload, this);
    },

    /**
     * Given a list of modules, it checks to see if the user has access to those modules
     * and returns a list in a form that Select2 dropdown accepts.
     * @param {Array} modules - List of modules to be displayed in the dropdown.
     * @return {Array}
     * @private
     */
    _buildModuleSwitchList: function(modules) {
        var filter = [];

        _.each(modules, function(module) {
            if (app.acl.hasAccess('list', module)) {
                filter.push({id: module, text: app.lang.get('LBL_MODULE_NAME', module)});
            }
        }, this);

        return filter;
    },

    /**
     * Reload this drawer layout.
     * @param {string} module
     */
    reload: function(module) {
        var self = this;
        // Need to defer so that we do not reload and dispose the drawer before all event
        // callbacks have completely finished.
        _.defer(function() {
            app.drawer.load({
                layout: 'selection-list-module-switch',
                context: {
                    module: module,
                    fields: self.context.get('fields'),
                    filterOptions: self.context.get('filterOptions'),
                    filterList: self._filterList
                }
            });
        });
    }
}) },
"dashlet-cell": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletCellLayout
 * @alias SUGAR.App.view.layouts.BaseDashletCellLayout
 * @extends View.Layouts.Base.DashletRowLayout
 */
({
	// Dashlet-cell Layout (base) 

    extendsFrom: 'DashletRowLayout',
    tagName: 'ul',
    className: 'dashlet-cell rows row-fluid',

    /**
     * @inheritdoc
     */
    _placeComponent: function(comp, def) {
        var span = 'dashlet-container span' + (def.width || 12),
            self = this;
        this.$el.append($('<li>', {'class': span, name: 'dashlet_' + comp.index}).data('index', function() {
            var index = def.layout.index.split('').pop();
            return self.index + '' + index;
        }).append(comp.el));
    },

    /**
     * Updates and sets metadata based on the meta param
     * @param {Object} meta
     * @return {Object} meta
     */
    setMetadata: function(meta) {
        meta.components = meta.components || [];
        _.each(meta.components, function(component, index){
            if(!(component.view || component.layout)) {
                meta.components[index] = _.extend({}, {
                    layout: {
                        type: 'dashlet',
                        index: this.index + '' + index,
                        empty: true,
                        components: [
                            {
                                view: 'dashlet-cell-empty',
                                context:{
                                    module:'Home',
                                    create:true
                                }
                            }
                        ]
                    }
                }, component);
            } else {
                var def = component.view || component.layout;
                if (!_.isObject(def)) {
                    def = component;
                }
                if(component.context) {
                    _.extend(component.context, {
                        forceNew: true
                    })
                }
                meta.components[index] = {
                    layout: {
                        type: 'dashlet',
                        index: this.index + '' + index,
                        label: def.label || def.name || "",
                        components: [
                            component
                        ]
                    },
                    width: component.width
                };
            }
        }, this);

        return meta;
    }
}) },
"wizard": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout used for Wizards (like the first time login wizard).
 * Extend this layout and provide metadata for your wizard page components.
 *
 * Default implementation allows you to register a callback on the context
 * to get notified when Wizard is finished.
 *
 * For example,
 *
 *     context.set("callbacks", {
 *         complete: function(){...}
 *     }
 *
 * @class View.Layouts.Base.WizardLayout
 * @alias SUGAR.App.view.layouts.BaseWizardLayout
 * @extends View.Layout
 */
({
	// Wizard Layout (base) 


    /**
     * Current page index shown in Wizard
     * @private
     */
    _currentIndex: 0,

    /**
     * @param {Object} options
     * @override
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        $(window).on('keypress.' + this.cid, _.bind(this.handleKeypress, this));
    },

    /**
     * Place only initial wizard page at first
     * @param component Wizard page component
     * @override
     * @private
     */
    _placeComponent: function(component){
        if (component == this._components[this._currentIndex]) {
            this.$el.append(component.el);
        }
    },

    /**
     * Add only wizard pages that the current user needs to see.
     *
     * @param {View.Layout/View.View} component Component (view or layout) to add
     * @param {Object} def Metadata definition
     * @override
     */
    addComponent: function(component, def) {
        component = this._addButtonsForComponent(component);
        if (_.result(component, 'showPage')) {
            this._super('addComponent', [component, def]);
        }
    },
    /**
     * Helper to add appropriate buttons based on which page of wizard we're on.
     * Assumes that button 0 is previous, 1 is next, 2 is finish (Start Sugar).
     * Should only be called internal by `addComponent`.
     * @param {Object} component component from `addComponent`
     * @private
     */
    _addButtonsForComponent: function(component) {
        var buttons = [];
        component.meta = component.meta || {};
        //Adds appropriate button for component based on position in wizard
        _.each(this.meta.components, function(comp, i) {
            //found a match, add appropriate buttons based on wizard position
            if (comp.view === component.name) {
                if (i===0) {
                    //next button only
                    buttons.push(this.meta.buttons[1]);
                } else if (i === this.meta.components.length-1) {
                    // previous/start sugar buttons
                    buttons.push(this.meta.buttons[0]);
                    buttons.push(this.meta.buttons[2]);
                } else {
                    // previous/next buttons
                    buttons.push(this.meta.buttons[0]);
                    buttons.push(this.meta.buttons[1]);
                }
            }
        }, this);
        component.meta.buttons = buttons;
        return component;
    },

    /**
     * Renders a different page from the wizard
     * @param {number} newIndex New page index to select
     * @return {Object} How far the user has progressed through the wizard
     * @return {number} return.page The current page number
     * @return {number} return.lastPage The last page number
     */
    setPage: function(newIndex){
        if (newIndex !== this._currentIndex &&
                (newIndex >= 0 && newIndex < this._components.length)) {
            //detach preserves jQuery event listeners, etc.
            this._components[this._currentIndex].$el.detach();
            this._currentIndex = newIndex;
            this.$el.append(this._components[this._currentIndex].el);

            // Wait for the wizard-page to tell us it's ready for interactions from keypresses.
            this.on('wizard-page:render:complete', function() {
                $(window).on('keypress.' + this.cid, _.bind(this.handleKeypress, this));
            });

            this._components[this._currentIndex].render();
        }
        return this.getProgress();
    },

    /**
     * Only render the current component (WizardPageView) instead of each component in layout
     * @override
     * @private
     */
    _renderHtml: function() {
        if (Modernizr.touch) {
            app.$contentEl.addClass('content-overflow-visible');
        }
        if (this._components) {
            this._components[this._currentIndex].render();
        }
    },

    /**
     * Returns current progress through wizard
     * @return {Object} How far the user has progressed through the wizard
     * @return {number} return.page The current page number
     * @return {number} return.lastPage The last page number
     */
    getProgress: function(){
        return {
            page: this._currentIndex + 1,
            lastPage: this._components.length
        };
    },

    /**
     * Moves to previous page, if possible.
     * @return {Object} How far the user has progressed through the wizard
     * @return {number} return.page The current page number
     * @return {number} return.lastPage The last page number
     */
    previousPage: function(){
        // We're navigating, don't get any more keypresses.
        $(window).off('keypress.' + this.cid);
        return this.setPage(this._currentIndex - 1);
    },

    /**
     * Moves to next page, if possible.
     * @return {Object} How far the user has progressed through the wizard
     * @return {number} return.page The current page number
     * @return {number} return.lastPage The last page number
     */
    nextPage: function(){
        // We're navigating, don't get any more keypresses.
        $(window).off('keypress.' + this.cid);
        return this.setPage(this._currentIndex + 1);
    },

    /**
     * Disposes of layout then calls finished callback if registered
     */
    finished: function(){
        if (Modernizr.touch) {
            app.$contentEl.removeClass('content-overflow-visible');
        }
        var callbacks = this.context.get("callbacks"); //save callbacks first
        this.dispose();
        if (callbacks && callbacks.complete) {
            callbacks.complete();
        }
    },

    /**
     * Process next on key 'Enter'
     * @param e
     */
    handleKeypress: function(e) {
        var wizardPage = this._components[this._currentIndex];
        // Check wizardPage no matter which key we're trapping (for future expansion).
        if (wizardPage) {
            // Check if we're catching enter.
            if (e.keyCode === 13) {
                document.activeElement.blur();
                if (wizardPage.isPageComplete()) {
                    // Once we're navigating, don't get any more keypresses.
                    $(window).off('keypress.' + this.cid);
                    wizardPage.next();
                }
            }
        }
    },

    /**
     * @private
     * @override
     */
    _dispose: function() {
        // We're done with this view, remove the keypress bind.
        $(window).off('keypress.' + this.cid);
        this._super('_dispose');
    }
}) },
"footer-buttons": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.FooterButtons
 * @alias SUGAR.App.view.layouts.BaseFooterButtonsLayout
 */
({
	// Footer-buttons Layout (base) 

    className: 'footer-buttons flex',
}) },
"activity-card": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ActivityCardLayout
 * @alias SUGAR.App.view.layouts.BaseActivityCardLayout
 * @extends View.Layout
 */
({
	// Activity-card Layout (base) 

    // Do not show focus drawer icons on links to records within the activity card itself,
    // only in the actions menu
    disableFocusDrawer: true,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.setTimelineType(options);

        if (options.module == 'Audit') {
            // this is a change card, use parent module to add class so correct module icon will be displayed
            this.$el.addClass('activity-card-' + options.context.parent.get('module').toLowerCase());
        }
        this.$el.addClass('activity-card-' + options.module.toLowerCase());
    },

    /**
     * Sets activity timeline type
     *
     * @param options Initialize options
     */
    setTimelineType: function(options) {
        this.timelineType = options.timelineType || 'activity-timeline-base';
    },

    /**
     * Returns activity timeline type
     */
    getTimelineType: function() {
        return this.timelineType;
    },

    /**
     * Override this method to set activity card menu icon visibility
     */
    setCardMenuVisibilities: function() {
    }
}) },
"focus-drawer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.FocusDrawerLayout
 * @alias SUGAR.App.view.layouts.BaseFocusDrawerLayout
 * @extends View.Layouts.Base.SideDrawerLayout
 * @deprecated FocusDrawerLayout controller is deprecated as of 11.2.0. Use SideDrawerLayout instead.
 */
({
	// Focus-drawer Layout (base) 

    extendsFrom: 'SideDrawerLayout',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.logger.warn('FocusDrawerLayout controller is deprecated as of 11.2.0. Use SideDrawerLayout instead.');
        this._super('initialize', [options]);
    }
}) },
"impersonation-banner": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ImpersonationBanner
 * @alias SUGAR.App.view.layouts.BaseImpersonationBanner
 * @extends View.Layout
 */
({
	// Impersonation-banner Layout (base) 

    cache: null,

    /**
     * @param options
     */
    initialize: function(options) {
        this.cache = app[app.config.authStore || 'cache'];
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        if (this.cache.has('ImpersonationFor') && app.api.isAuthenticated()) {
            this.show();
        } else {
            this.hide();
        }
    },

}) }
}}

,
	"modules":{
		"Login":{
}
	}}})(SUGAR.App);
